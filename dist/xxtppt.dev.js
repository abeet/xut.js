// Device.js
// (c) 2014 Matthew Hudson
// Device.js is freely distributable under the MIT license.
// For all details and documentation:
// http://matthewhudson.me/projects/device.js/

(function() {

  var device,
    previousDevice,
    addClass,
    documentElement,
    find,
    handleOrientation,
    hasClass,
    orientationEvent,
    removeClass,
    userAgent;

  // Save the previous value of the device variable.
  previousDevice = window.device;

  device = {};

  // Add device as a global object.
  window.device = device;

  // The <html> element.
  documentElement = window.document.documentElement;

  // The client user agent string.
  // Lowercase, so we can use the more efficient indexOf(), instead of Regex
  userAgent = window.navigator.userAgent.toLowerCase();

  // Main functions
  // --------------

  device.ios = function() {
    return device.iphone() || device.ipod() || device.ipad();
  };

  device.iphone = function() {
    return !device.windows() && find('iphone');
  };

  device.ipod = function() {
    return find('ipod');
  };

  device.ipad = function() {
    return find('ipad');
  };

  device.android = function() {
    return !device.windows() && find('android');
  };

  device.androidPhone = function() {
    return device.android() && find('mobile');
  };

  device.androidTablet = function() {
    return device.android() && !find('mobile');
  };

  device.blackberry = function() {
    return find('blackberry') || find('bb10') || find('rim');
  };

  device.blackberryPhone = function() {
    return device.blackberry() && !find('tablet');
  };

  device.blackberryTablet = function() {
    return device.blackberry() && find('tablet');
  };

  device.windows = function() {
    return find('windows');
  };

  device.windowsPhone = function() {
    return device.windows() && find('phone');
  };

  device.windowsTablet = function() {
    return device.windows() && (find('touch') && !device.windowsPhone());
  };

  device.fxos = function() {
    return(find('(mobile;') || find('(tablet;')) && find('; rv:');
  };

  device.fxosPhone = function() {
    return device.fxos() && find('mobile');
  };

  device.fxosTablet = function() {
    return device.fxos() && find('tablet');
  };

  device.meego = function() {
    return find('meego');
  };

  device.cordova = function() {
    return window.cordova && location.protocol === 'file:';
  };

  device.nodeWebkit = function() {
    return typeof window.process === 'object';
  };

  device.mobile = function() {
    return device.androidPhone() || device.iphone() || device.ipod() || device.windowsPhone() || device.blackberryPhone() || device.fxosPhone() || device.meego();
  };

  device.tablet = function() {
    return device.ipad() || device.androidTablet() || device.blackberryTablet() || device.windowsTablet() || device.fxosTablet();
  };

  device.desktop = function() {
    return !device.tablet() && !device.mobile();
  };

  device.television = function() {
    var i, tvString;

    television = [
      "googletv",
      "viera",
      "smarttv",
      "internet.tv",
      "netcast",
      "nettv",
      "appletv",
      "boxee",
      "kylo",
      "roku",
      "dlnadoc",
      "roku",
      "pov_tv",
      "hbbtv",
      "ce-html"
    ];

    i = 0;
    while(i < television.length) {
      if(find(television[i])) {
        return true;
      }
      i++;
    }
    return false;
  };

  device.portrait = function() {
    return(window.innerHeight / window.innerWidth) > 1;
  };

  device.landscape = function() {
    return(window.innerHeight / window.innerWidth) < 1;
  };

  // Public Utility Functions
  // ------------------------

  // Run device.js in noConflict mode,
  // returning the device variable to its previous owner.
  device.noConflict = function() {
    window.device = previousDevice;
    return this;
  };

  // Private Utility Functions
  // -------------------------

  // Simple UA string search
  find = function(needle) {
    return userAgent.indexOf(needle) !== -1;
  };

  // Check if documentElement already has a given class.
  hasClass = function(className) {
    var regex;
    regex = new RegExp(className, 'i');
    return documentElement.className.match(regex);
  };

  // Add one or more CSS classes to the <html> element.
  addClass = function(className) {
    var currentClassNames = null;
    if(!hasClass(className)) {
      currentClassNames = documentElement.className.replace(/^\s+|\s+$/g, '');
      documentElement.className = currentClassNames + " " + className;
    }
  };

  // Remove single CSS class from the <html> element.
  removeClass = function(className) {
    if(hasClass(className)) {
      documentElement.className = documentElement.className.replace(" " + className, "");
    }
  };

  // HTML Element Handling
  // ---------------------

  // Insert the appropriate CSS class based on the _user_agent.

  if(device.ios()) {
    if(device.ipad()) {
      addClass("ios ipad tablet");
    } else if(device.iphone()) {
      addClass("ios iphone mobile");
    } else if(device.ipod()) {
      addClass("ios ipod mobile");
    }
  } else if(device.android()) {
    if(device.androidTablet()) {
      addClass("android tablet");
    } else {
      addClass("android mobile");
    }
  } else if(device.blackberry()) {
    if(device.blackberryTablet()) {
      addClass("blackberry tablet");
    } else {
      addClass("blackberry mobile");
    }
  } else if(device.windows()) {
    if(device.windowsTablet()) {
      addClass("windows tablet");
    } else if(device.windowsPhone()) {
      addClass("windows mobile");
    } else {
      addClass("desktop");
    }
  } else if(device.fxos()) {
    if(device.fxosTablet()) {
      addClass("fxos tablet");
    } else {
      addClass("fxos mobile");
    }
  } else if(device.meego()) {
    addClass("meego mobile");
  } else if(device.nodeWebkit()) {
    addClass("node-webkit");
  } else if(device.television()) {
    addClass("television");
  } else if(device.desktop()) {
    addClass("desktop");
  }

  if(device.cordova()) {
    addClass("cordova");
  }

  // Orientation Handling
  // --------------------

  // Handle device orientation changes.
  handleOrientation = function() {
    if(device.landscape()) {
      removeClass("portrait");
      addClass("landscape");
    } else {
      removeClass("landscape");
      addClass("portrait");
    }
    return;
  };

  // Detect whether device supports orientationchange event,
  // otherwise fall back to the resize event.
  if(Object.prototype.hasOwnProperty.call(window, "onorientationchange")) {
    orientationEvent = "orientationchange";
  } else {
    orientationEvent = "resize";
  }

  // Listen for changes in orientation.
  if(window.addEventListener) {
    window.addEventListener(orientationEvent, handleOrientation, false);
  } else if(window.attachEvent) {
    window.attachEvent(orientationEvent, handleOrientation);
  } else {
    window[orientationEvent] = handleOrientation;
  }

  handleOrientation();

  device.find = find

  if(typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
    define(function() {
      return device;
    });
  } else if(typeof module !== 'undefined' && module.exports) {
    module.exports = device;
  } else {
    window.device = device;
  }

}).call(this);
/**
 * 判断加载环境 是否嵌套iframe
 * 1 单独杂志
 * 2 读库客户端
 * 3 妙妙学客户端
 * 4 新阅读客户端
 * 5 子文档模式
 * ........
 *
 * GLOBALCONTEXT 插件全局调用接口
 * GLOBALIFRAME  是否iframe加载
 *
 *
 *提供给iframe内的配置文件
 *
 *  window.XXTIFRAME = {
 *       path: "sdcard/" + config.data.appId + "/content/gallery/",
 *       iframeDrop: function () {
 *            //iframe退出的处理方法
 *       }
 *   }
 *
 */
;
(function(CONFIG) {

  //上文环境
  //1 新阅读
  //2 子文档
  //3 本身
  //插件的上下文永远是GLOBALCONTEXT调用
  window.GLOBALCONTEXT = CONFIG.context; //全局上下文(兼容iframe父容器与本身执行环境)
  window.GLOBALIFRAME = CONFIG.iframeMode; //是否为iframe加载

  //读酷配置文件
  window.DUKUCONFIG = CONFIG.dukuConfig;
  //await
  //path
  //ifrmeDrop

  //嵌套子文档上下文
  window.SUbDOCCONTEXT = CONFIG.subContext;
  window.SUbCONFIGT = CONFIG.subConfig;

  //2014.11.26
  //新客户端模式Client
  //地址:url
  //ifrmeDrop
  //path
  //success
  window.CLIENTCONFIGT = CONFIG.clientConfig;

  //2015.3.11
  //秒秒学客户端配置
  window.MMXCONFIG = CONFIG.mmxConfig;

})(function() {

  //是否为iframe加载
  var iframeMode = false

  //最外层上下文
  var topContext = window

  //读库配置文件
  var dukuConfig

  //客户端配置文件
  var clientConfig

  //秒秒学客户端配置文件
  var mmxConfig

  //子容器上下文
  var subContext

  //子文档模式
  var subConfig


  //兼容ios处理
  //妙妙客户端版处理问题ios版
  try {
    if(top && top.audioHandler) {
      window.audioHandler = top.audioHandler
    }
  } catch(err) {}


  var match = {

    /**
     * 读库iframe加载
     */
    XXTIFRAME: function(context) {
      dukuConfig = context.XXTIFRAME
      topContext = context
      iframeMode = true
    },

    /**
     * 秒秒学在线客户端加载
     * @return {[type]} [description]
     */
    miaomiaoxue: function(context) {
      mmxConfig = context.miaomiaoxue
      topContext = context
      iframeMode = true
    },

    /**
     * 子文档加载
     */
    XXTSUbDOC: function(context) {
      if(!topContext) {
        topContext = context;
      }
      subContext = context;
      iframeMode = true;
      subConfig = context.XXTSUbDOC
    },

    /**
     * 客户端模式
     * 零件动态加载iframe
     */
    XXTClient: function(context) {
      clientConfig = context.XXTClient
      topContext = context;
      iframeMode = true;
    },

    /**
     * pc调试模式
     * @return {[type]} [description]
     */
    iframe: function() {
      if(!iframeMode) {
        iframeMode = true
      }
    }
  }


  /**
   * 匹配配置文件
   * @param  {[type]} context [description]
   * @return {[type]}         [description]
   */
  var scopeMatch = function(context) {
    try {
      if(!context) return;
      'XXTIFRAME,miaomiaoxue,XXTSUbDOC,XXTClient,iframe'.split(',').forEach(function(name) {
        context[name] && match[name](context)
      })
    } catch(er) {}
  }

  //搜索2层作用域
  //1 top
  //2 parent
  scopeMatch(parent)
  //嵌套iframe
  if(parent != top) {
    scopeMatch(top)
  }

  return {
    context: topContext,
    iframeMode: iframeMode,
    subContext: subContext,
    dukuConfig: dukuConfig,
    mmxConfig: mmxConfig,
    clientConfig: clientConfig,
    subConfig: subConfig
  }
}());
/**
 * 电子杂志全局命名
 * @singleton
 */
//sf浏览器调试 不能用hash 否则报错
window.Xut = {}

/**
 * 插件
 * @type {[type]}
 */
Xut.Plugin = {}
Xut.plugins = {}

/**
 * 平台
 * @type {[type]}
 */
Xut.plat = {}

/**
 * 样式
 * @type {[type]}
 */
Xut.style = {}

/**
 * 浅拷贝
 * @param  {[type]} target [description]
 * @param  {[type]} source [description]
 * @return {[type]}        [description]
 */
Xut.mixin = function(target, source) {
  if (!source) {
    source = target
    target = this
  }
  for (var p in source) {
    if (source.hasOwnProperty(p)) {
      target[p] = source[p]
    }
  }
  return target
}

Xut.mixin({

  /**
   * 生成32位UUID的方法
   * @return {[type]}               [description]
   */
  createUUID: (function(uuidRegEx, uuidReplacer) {
    return function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
    };
  })(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0,
      v = c == "x" ? r : (r & 3 | 8);
    return v.toString(16);
  }),

  /**
   * 创建一个唯一的uuid
   * @param  {[type]} pre [description]
   * @return {[type]}     [description]
   */
  guid: function(mark) {
    var id = (+new Date()) + (Math.random() + '').slice(-1);
    return mark ? (mark + id) : Number(id)
  },

  /**
   * 数组化
   * @return {[type]} [description]
   */
  toArray: function() {
    var slice = Array.prototype.slice
    return function(a, i, j) {
      return slice.call(a, i || 0, j || a.length);
    }
  }()
})


/**
 * @class String
 * 格式化字符串
 */
String.format = function(format) {
  var args = Xut.toArray(arguments, 1);
  return format.replace(/\{(\d+)\}/g, function(m, i) {
    return args[i];
  });
}


String.styleFormat = function(format) {
  return format.replace(/\s+/g, " ")
}

/**
 * 设备平台判断
 * @return {[type]} [description]
 */
;
(function() {

  var location = document.location.href
  //在读酷pc端 navigator的值被改写过了!!
  //navigator.appVersion: "xxt 1.0.5260.29725"
  var userAgent = window.navigator.userAgent.toLowerCase()
  var appVersion = window.navigator.appVersion.toLowerCase()

  var isAndroid = device.android() || (/android/gi).test(appVersion)
  var isDesktop = device.desktop()
  var isMacOS = device.find('mac')
  var isIphone = device.iphone()
  var isIpad = device.ipad()
  var isIOS = device.ios()
  var isWebKit = device.find('applewebkit') //webkit内核
  var isWeiXin = device.find('micromessenger') //微信
  var hasTouch = ('ontouchstart' in window) //支持触屏

  //针对win8的处理
  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  //移动端仅仅只支持touch
  var only_touch = hasTouch && MOBILE_REGEX.test(userAgent);
  //判断是否为浏览器
  var boolBrowser = location.indexOf('http') > -1 || location.indexOf('https') > -1
  var isBrowser = boolBrowser ? boolBrowser : !only_touch

  /*ios版本*/
  var iosVersionMatch = isIOS && userAgent.match(/os ([\d_]+)/)
  var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_')

  /*是否支持hasMutationObserverBug*/
  var hasMutationObserver = false
  var iosMainVersion = null
  if (iosVersion) {
    iosMainVersion = Number(iosVersion[0])
    hasMutationObserver = iosMainVersion >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB
  }

  /*安卓版本*/
  var androidVersionMatch = isAndroid && userAgent.match(/android ([\d_]+)/)
  var androidVersion = androidVersionMatch && androidVersionMatch[1].split('_')


  /**
   * 无痕浏览的模式
   * 导致localStorage报错
   * @param  {[type]} typeof localStorage  [description]
   * @return {[type]}        [description]
   */
  var supportStorage = true
  if (typeof localStorage === 'object') {
    try {
      localStorage.setItem('localStorage', 1);
      localStorage.removeItem('localStorage');
    } catch (e) {
      Storage.prototype._setItem = Storage.prototype.setItem;
      Storage.prototype.setItem = function() {};
      supportStorage = false
    }
  }

  /**
   * 平台支持
   */
  Xut.mixin(Xut.plat, {
    has3d: 'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix(),
    isAndroid: isAndroid,
    isIphone: isIphone,
    isIpad: isIpad,
    isIOS: isIOS,
    isMacOS: isMacOS,

    isWeiXin: isWeiXin,

    /**
     * 是否支持
     * @type {[type]}
     */
    supportStorage: supportStorage,

    androidVersion: androidVersion,

    /**
     * 是平板设备
     * ipad
     * android Tablet
     */
    isTablet: device.tablet(),

    /**
     * 是否在支持插件
     * phonegap
     * @type {Boolean}
     */
    hasPlugin: false,

    /**
     * ios版本号
     * @type {[type]}
     */
    iosVersion: iosMainVersion,

    /*
    ios的版本>=10 支持视频行内播放
     */
    supportPlayInline: iosMainVersion >= 10,

    /**
     * 需要修复音频
     * 修复不能自动播放的情况
     * 不是微信 && 手机浏览器 或 ipad
     * @type {[type]}
     */
    fixWebkitAutoAudio: (function() {

      //微信用自己api播放
      if (isWeiXin) {
        return false
      }

      var localhost = /localhost/ig.test(window.location.href)

      //2017.11.28
      //读库客户端支持自动播放
      //只有ios的客户端才可以，客户端内部通过浏览器打开
      if (window.DUKUCONFIG && isIOS && localhost) {
        return false
      }

      //浏览器打开
      if (isBrowser) {

        //pc端测试
        if (localhost) {
          return false
        }

        //移动端ipad 手机不支持自动播放
        if (device.mobile() || device.tablet()) {
          return true
        }

      }

    })(),

    /**
     * 支持触摸
     */
    hasTouch: only_touch,

    /**
     * 游览器平台 解决ios Android浏览器判断问题
     * @type {Boolean}
     */
    isBrowser: isBrowser,

    /**
     * 2015.3.23
     * 可以点击与触摸
     * @type {Boolean}
     */
    isMouseTouch: hasTouch && ('onmousedown' in window) && !only_touch,

    /**
     * 是否桌面
     * @type {Boolean}
     */
    isDesktop: isDesktop,

    /**
     * 是否支持Mutation
     * @type {Boolean}
     */
    supportMutationObserver: !hasMutationObserver
  })


  //私有前缀
  var rdashAlpha = /-([a-z]|[0-9])/ig
  var rmsPrefix = /^-ms-/
  var fcamelCase = function(all, letter) {
    return (letter + '').toUpperCase();
  }
  var camelCase = function(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }
  var prefix = ['webkit', 'Moz', 'ms', 'o']
  var elementStyle = document.createElement('div').style
  var cache = Object.create(null)
  var prefixStyle = function(attr) {
    var name
    //缓存中存在
    if (cache[attr]) {
      return cache[attr];
    }
    //不需要加前缀
    if (attr in elementStyle) {
      return cache[attr] = attr;
    }
    //需要加前缀
    prefix.forEach(function(v) {
      if (camelCase(v + '-' + attr) in elementStyle) {
        name = '-' + v + '-' + attr;
        return cache[attr] = name;
      }
    })
    return name;
  }

  //css3 keyframes
  var transitionEnd = 'transitionend'
  var animationEnd = 'animationend'
  var keyframes = '@keyframes '
  var animation = prefixStyle('animation');
  var adapterPrefix = function() {
    var vendors = animation
    var transitionName = {
      "moz": "transitionend",
      "webkit": "webkitTransitionEnd",
      "ms": "MSTransitionEnd",
      "o": "oTransitionEnd"
    }
    var animationName = {
      "moz": "animationend",
      "webkit": "webkitAnimationEnd",
      "ms": "MSAnimationEnd",
      "o": "oAnimationEnd"
    }
    if (!vendors) return;
    vendors = vendors.split('-');
    if (!vendors[1]) return;
    transitionEnd = transitionName[vendors[1]];
    animationEnd = animationName[vendors[1]];
    keyframes = '@-' + vendors[1] + '-keyframes ';
  }
  adapterPrefix()


  /**
   * 支持转换效果
   * @type {Boolean}
   */
  var hasPerspective = prefixStyle('perspective') in elementStyle
  var translateZ = hasPerspective ? ' translateZ(0)' : ''
  var maskBoxImage = prefixStyle('mask-box-image')

  var reqAnimationFrame = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
    };


  ////////////////////
  /// 样式style支持
  ////////////////////

  function setTranslateStyle(x, y) {
    return 'translate(' + x + 'px,' + y + 'px)' + translateZ
  }
  var transitionDuration = prefixStyle('transition-duration')
  var transform = prefixStyle('transform')

  /**
   * 获取真的node
   * 1 jquery转化成node
   * 2 普通node
   * 3 jquery是svg但是没有lenght有context
   * @param  {[type]} node [description]
   * @return {[type]}      [description]
   */
  function getNode(node) {
    if (!node) {
      console.log('setTranslate没有提供node')
      return false
    }

    /*如果是jquery对象*/
    if (node instanceof $) {
      /*svg对象length=0所以还需要取context*/
      node = node[0] || node['context']
      if (!node) {
        console.log('setTranslate node不存在,需要检测')
        return false
      }
    }

    return node
  }

  Xut.mixin(Xut.style, {

    reqAnimationFrame: reqAnimationFrame,

    /**
     * 不支持蒙版
     * @type {[type]}
     */
    noMaskBoxImage: maskBoxImage == undefined,

    /**
     * 前缀
     * @type {[type]}
     */
    prefixStyle: prefixStyle,

    /**
     * transform
     * @type {[type]}
     */
    transform: transform,
    transition: prefixStyle('transition'),
    transitionDuration: transitionDuration,
    transitionDelay: prefixStyle('transition-delay'),
    transformOrigin: prefixStyle('transform-origin'),
    transitionTimingFunction: prefixStyle('transition-timing-function'),
    transitionEnd: transitionEnd,

    /**
     * css3 admination
     * @type {[type]}
     */
    animation: animation,
    animationDelay: prefixStyle('animation-delay'),
    animationPlayState: prefixStyle('animation-play-state'),
    animationEnd: animationEnd,
    keyframes: keyframes,

    /**
     * 支持3d Z
     * @type {[type]}
     */
    translateZ: translateZ,
    setTranslateZ: function(zValue) {
      return hasPerspective ? ' translateZ(' + zValue + ')' : ''
    },

    /**
     * 设置Translate
     * @param {[type]} node [description]
     * @param {[type]} x    [description]
     * @param {[type]} y    [description]
     */
    setTranslateStyle: setTranslateStyle,

    /**
     * 多种组合
     * translate
     * scale
     * 等等
        Xut.style.setTransform({
          speed,
          translate: {
            x: data.translate.x
            y: data.translate.y
          },
          scale: {
            x: data.scale,
            y: data.scale
          },
          node: this.rootNode
        })
        styleText = `translate3d(${}px,${}px,0px) scale(${data.scale},${data.scale})`
     */
    setTransform: function(options) {
      var node = options.node
      if (node = getNode(node)) {
        var styleText = ''
        var translate = options.translate
        if (translate) {
          var translateX = translate.x || 0
          var translateY = translate.y || 0
          styleText += setTranslateStyle(translateX, translateY)
        }
        var scale = options.scale
        if (scale) {
          var scaleX = scale.x || 1
          var scaleY = scale.y || 1
          styleText += 'scale(' + scaleX + ',' + scaleY + ') '
        }
        if (styleText) {
          /*设置styleText*/
          node.style[transform] = styleText;
          /*设置时间*/
          if (options.speed !== undefined) {
            node.style[transitionDuration] = options.speed + 'ms'
          }
        }
      }
    },

    /**
     * 设置setTranslate
     * 1 node是普通的对象
     * 2 node是jquery对象
     *   如果是svg的情况jquery有context但是lenght为0
     * 3 设置xy
     * 4 设置文本style
     * 5 设置事件
     * @param {[type]} options [description]
     */
    setTranslate: function(options) {
      var node = options.node
      var x = options.x || 0
      var y = options.y || 0
      var speed = options.speed
      if (node = getNode(node)) {
        /*Translate*/
        node.style[transform] = setTranslateStyle(x, y);
        /*设置动画的时间*/
        if (speed !== undefined) {
          node.style[transitionDuration] = speed + 'ms'
        }
      }
    },


    /**
     * 额外样式
     * @type {[type]}
     */
    filter: prefixStyle('filter'),
    maskBoxImage: maskBoxImage,
    borderRadius: prefixStyle('border-radius'),

    /**
     * css3分栏
     * @type {[type]}
     */
    columnWidth: prefixStyle('column-width'),
    columnGap: prefixStyle('column-gap')

  })

})()

/*
 **  frame窗口通信指导
 **  PMS 用于frame窗口之间通信
 **  PMS对象暴露三个接口
 * bind : 用于注册事件，当有窗口发送消息过来并且类匹配时，则会触发注册时相应的回调函数
 * send : 用于向指定的目标窗口发送信息
 * unbind : 取消之肖注册的事件
 *
 * 使用demo
 * 现在假设我们有两个frame窗口,一个是主窗口mainFrame ,一个是子窗口childFrame
 * 现在我们得在两个frame窗口中进行消息传递,则我们可以像下面这样操作
 *
 * 1 、 mainFrame传递消息到childFrame
 *    1.1 childFrame注册事件，在childFrame的js代码中
 *    PMS.bind('onload' , function(e){} , '*')
 *    此时childFrame已经注册了消息处理，当有窗口往childFrame消息事，此处注册的回调就会被执行
 *    参数{onload : 消息类型 , function : 回调函数 , '*' : 消息通信的域}
 *
 *    1.2 此时子窗口已准备，等待其它窗口发送消息的到来
 *    此时mainFrame给childFrame发送一个消息
 *    此处写在mainFrame的代码中
 *    PMS.send({
 *        target : frames[0],       //发送到目标窗口
 *        url :                     //URL
 *        type : 'onload' ,         //消息类型
 *        data : {                  //附带数据
 *            name : 'alice' ,
 *            age : 27
 *        },
 *        success : function(){     //成功回调
 *        },
 *        error : function(e){      //失败回调
 *        }
 *    });
 *
 *
 *   其它frame通信跟上面差不多,
 *   多个frame之间也能相互通信，只要通信目标正确即可
 *
 *   如果是子窗口发信息给父窗口，则像下面之样即可
 *   PMS.send({
 *       target : window.parent
 *       其它参数与上面相同
 *   });
 *
 *    target : 必填
 *    type : 必填
 *    其它参数可选
 *
 *    参考
 *    https://developer.mozilla.org/en-US/docs/DOM/window.postMessage
 *
 *  了解更多可分析下面源码
 *
 */

;
(function(glob) {
  var PMS = function(options) {
    pm.send(options);
  };
  PMS.send = PMS;

  PMS.bind = function(type, fn, origin, hash, async_reply) {
    pm.bind(type, fn, origin, hash, async_reply === true);
  };

  PMS.event = {

    onData: function(fn, origin, hash, async_reply) {
      PMS.bind('onData', fn, origin || '*', hash, async_reply);
    },

    onLoad: function(fn, origin, hash, async_reply) {
      PMS.bind('onLoad', fn, origin || '*', hash, async_reply);
    },

    onDestory: function(fn, origin, hash, async_reply) {
      PMS.bind('onDestory', fn, origin || '*', hash, async_reply);
    },

    onHide: function(fn, origin, hash, async_reply) {
      PMS.bind('onHide', fn, origin || '*', hash, async_reply);
    },

    onShow: function(fn, origin, hash, async_reply) {
      PMS.bind('onShow', fn, origin || '*', hash, async_reply);
    },
    onFullscreen: function(fn, origin, hash, async_reply) {
      PMS.bind('onFullscreen', fn, origin || '*', hash, async_reply);
    }
  };

  PMS.unbind = function(type, fn) {
    pm.unbind(type, fn);
  };

  var extend = function(destination, source) {
    for(var property in source) {
      destination[property] = source[property];
    }
    return destination;
  };

  var pm = {

    send: function(options) {
      var o = extend(pm.defaults, options),
        target = o.target;
      if(!o.target) {
        console.warn("消息目标窗口必须填写!");
        return;
      }
      var msg = {
        data: o.data,
        type: o.type
      };
      if(o.success) {
        msg.callback = pm._callback(o.success);
      }
      if(o.error) {
        msg.errback = pm._callback(o.error);
      }
      if(("postMessage" in target) && !o.hash) {
        pm._bind();
        target.postMessage(JSON.stringify(msg), o.origin || '*');
      }
    },

    bind: function(type, fn, origin, hash, async_reply) {
      pm._replyBind(type, fn, origin, hash, async_reply);
    },

    _replyBind: function(type, fn, origin, hash, isCallback) {
      if(("postMessage" in window) && !hash) {
        pm._bind();
      }
      var l = pm.data("listeners.postmessage");
      if(!l) {
        l = {};
        pm.data("listeners.postmessage", l);
      }
      var fns = l[type];
      if(!fns) {
        fns = [];
        l[type] = fns;
      }
      fns.push({
        fn: fn,
        callback: isCallback,
        origin: origin || $.pm.origin
      });
    },

    unbind: function(type, fn) {
      var l = pm.data("listeners.postmessage"),
        c = pm.data("callbacks.postmessage");
      if(l) {
        if(type) {
          if(fn) {
            var fns = l[type];
            if(fns) {
              var m = [];
              for(var i = 0, len = fns.length; i < len; i++) {
                var o = fns[i];
                if(o.fn !== fn) {
                  m.push(o);
                }
              }
              l[type] = m;
            }
          } else {
            delete l[type];
          }
        } else {
          for(var i in l) {
            delete l[i];
          }
        }
      }

      if(c) {
        if(type) {
          if(fn) {
            var fns = c[type];
            if(fns) {
              var m = [];
              for(var i = 0, len = fns.length; i < len; i++) {
                var o = fns[i];
                if(o.fn !== fn) {
                  m.push(o);
                }
              }
              c[type] = m;
            }
          } else {
            delete c[type];
          }
        } else {
          for(var i in c) {
            delete c[i];
          }
        }
      }
    },

    data: function(k, v) {
      if(v === undefined) {
        return pm._data[k];
      }
      pm._data[k] = v;
      return v;
    },

    _data: {},

    _generate: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },

    _callback: function(fn) {
      var cbs = pm.data("callbacks.postmessage");
      if(!cbs) {
        cbs = {};
        pm.data("callbacks.postmessage", cbs);
      }
      var r = pm._generate();
      cbs[r] = fn;
      return r;
    },

    _bind: function() {
      if(!pm.data("listening.postmessage")) {
        if(window.addEventListener) {
          window.addEventListener("message", pm._dispatch, false);
        } else if(window.attachEvent) {
          window.attachEvent("onmessage", pm._dispatch);
        }
        pm.data("listening.postmessage", 1);
      }
    },
    _dispatch: function(e) {
      try {
        var msg = JSON.parse(e.data);
      } catch(ex) {
        console.warn("消息的数据是无效的json", ex);
        return;
      }
      if(!msg.type) {
        console.warn("必须填写对应的消息类型");
        return;
      }
      var cbs = pm.data("callbacks.postmessage") || {},
        cb = cbs[msg.type];
      if(cb) {
        cb(msg.data);
      } else {
        var l = pm.data("listeners.postmessage") || {};
        var fns = l[msg.type] || [];
        for(var i = 0, len = fns.length; i < len; i++) {
          var o = fns[i];
          if(o.origin && o.origin !== '*' && e.origin !== o.origin) {
            console.warn("消息来源不匹配!", e.origin, o.origin);
            if(msg.errback) {
              var error = {
                message: "消息来源不匹配",
                origin: [e.origin, o.origin]
              };

              pm.send({
                target: e.source,
                data: error,
                type: msg.errback
              });
            }
            continue;
          }

          function sendReply(data) {
            if(msg.callback) {
              pm.send({
                target: e.source,
                data: data,
                type: msg.callback
              });
            }
          }
          try {
            if(o.callback) {
              o.fn(msg.data, sendReply, e);
            } else {
              sendReply(o.fn(msg.data, e));
            }
          } catch(ex) {
            if(msg.errback) {
              pm.send({
                target: e.source,
                data: ex,
                type: msg.errback
              });
            } else {
              throw ex;
            }
          }
        };
      }
    }
  };

  pm.defaults = {
    target: null,
    /* 目标窗口 (required) */
    url: null,
    /* 目标窗口URL (optional) */
    type: null,
    /* 消息类型 (required) */
    data: null,
    /* 消息数据 (optional) */
    success: null,
    /* 成功回调 (optional) */
    error: null,
    /* 失败回调 (optional) */
    origin: "*"
    /* 消息域 (optional) */
  }

  var module = module || 'undefined';
  (typeof module != "undefined" && module.exports) ? (module.exports = PMS) : (typeof define != "undefined" ? (define("PMS", [], function() {
    return PMS;
  })) : (glob.PMS = PMS));
})(this);
/**************************
 *
 *   epub新增加
 *   需要调用2次
 *   一次是因为打包的关系，全局加载
 *   二次是 实际epub模式加载
 *
 * *************************/

/**
 * 动态html文件挂载点
 * 用于content动态加载js文件
 * 目前暂时给epub使用，文本框
 * @type {Object}
 */
window.HTMLCONFIG = {}


/**
 *
 * 2015.10.19新增
 * ibooks处理
 * epub ibooks模式的配置文件
 * 这个是在index.html中会传入几个值
 *
 *   window.IBOOKSCONFIG = {
 *       compiled: true,
 *       pageIndex: 1,
 *       existSvg: true,
 *       screenSize: {
 *           "width": 718,
 *           "height": 958
 *       }
 *   }
 */
var IBOOKSCONFIG = window.IBOOKSCONFIG;

//如果是IBOOS模式处理
//注入保持与数据库H5查询一致
if(IBOOKSCONFIG && IBOOKSCONFIG.data) {
  _.each(IBOOKSCONFIG.data, function(data, tabName) {
    data.item = function(index) {
      return this[index];
    }
  })
  //ios上的ibooks模式
  //直接修改改isBrowser模式
  Xut.plat.isBrowser = true;
  Xut.plat.isIOS = false;
}

//配置ibooks参数
Xut.IBooks = {

  /**
   * 当前页面编号
   * @return {[type]} [description]
   */
  pageIndex: function() {
    if(IBOOKSCONFIG) {
      //当期页面索引1开始
      return IBOOKSCONFIG.pageIndex + 1;
    }
  }(),

  /**
   * 是否存在svg
   * @type {[type]}
   */
  existSvg: IBOOKSCONFIG ? IBOOKSCONFIG.existSvg : false,

  /**
   * 是否启动了ibooks模式
   * @return {[type]} [description]
   */
  Enabled: function() {
    return IBOOKSCONFIG ? true : false;
  }(),

  /**
   * 全部对象
   * @type {[type]}
   */
  CONFIG: IBOOKSCONFIG,

  /**
   * 运行期间
   * @return {[type]} [description]
   */
  runMode: function() {
    //确定为ibooks的运行状态
    //而非预编译状态
    if(IBOOKSCONFIG && !IBOOKSCONFIG.compiled) {
      return true;
    }
    return false;
  },
  /**
   * 编译期间
   * @return {[type]} [description]
   */
  compileMode: function() {
    //确定为ibooks的编译状态
    //而非预编译状态
    if(IBOOKSCONFIG && IBOOKSCONFIG.compiled) {
      return true;
    }
    return false;
  }
};
/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function(global, factory) {

  if(typeof module === "object" && typeof module.exports === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ?
      factory(global, true) :
      function(w) {
        if(!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
  } else {
    factory(global);
  }

  // Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {

  // Support: Firefox 18+
  // Can't be in strict mode, several libs including ASP.NET trace
  // the stack via arguments.caller.callee and Firefox dies if
  // you try to trace through "use strict" call chains. (#13335)
  //

  var arr = [];

  var slice = arr.slice;

  var concat = arr.concat;

  var push = arr.push;

  var indexOf = arr.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var support = {};



  var
    // Use the correct document accordingly with window argument (sandbox)
    document = window.document,

    version = "2.1.3",

    // Define a local copy of jQuery
    jQuery = function(selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    },

    // Support: Android<4.1
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,

    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function(all, letter) {
      return letter.toUpperCase();
    };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,

    constructor: jQuery,

    // Start with an empty selector
    selector: "",

    // The default length of a jQuery object is 0
    length: 0,

    toArray: function() {
      return slice.call(this);
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function(num) {
      return num != null ?

        // Return just the one element from the set
        (num < 0 ? this[num + this.length] : this[num]) :

        // Return all the elements in a clean array
        slice.call(this);
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function(elems) {

      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems);

      // Add the old object onto the stack (as a reference)
      ret.prevObject = this;
      ret.context = this.context;

      // Return the newly-formed element set
      return ret;
    },

    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function(callback, args) {
      return jQuery.each(this, callback, args);
    },

    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },

    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },

    first: function() {
      return this.eq(0);
    },

    last: function() {
      return this.eq(-1);
    },

    eq: function(i) {
      var len = this.length,
        j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },

    end: function() {
      return this.prevObject || this.constructor(null);
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

    // Handle a deep copy situation
    if(typeof target === "boolean") {
      deep = target;

      // Skip the boolean and the target
      target = arguments[i] || {};
      i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if(typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }

    // Extend jQuery itself if only one argument is passed
    if(i === length) {
      target = this;
      i--;
    }

    for(; i < length; i++) {
      // Only deal with non-null/undefined values
      if((options = arguments[i]) != null) {
        // Extend the base object
        for(name in options) {
          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if(target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if(deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if(copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];

            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            target[name] = jQuery.extend(deep, clone, copy);

            // Don't bring in undefined values
          } else if(copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }

    // Return the modified object
    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

    // Assume jQuery is ready without the ready module
    isReady: true,

    error: function(msg) {
      throw new Error(msg);
    },

    noop: function() {},

    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },

    isArray: Array.isArray,

    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },

    isNumeric: function(obj) {
      // parseFloat NaNs numeric-cast false positives (null|true|false|"")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      // adding 1 corrects loss of precision from parseFloat (#15100)
      return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
    },

    isPlainObject: function(obj) {
      // Not plain objects:
      // - Any object or value whose internal [[Class]] property is not "[object Object]"
      // - DOM nodes
      // - window
      if(jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }

      if(obj.constructor &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }

      // If the function hasn't returned already, we're confident that
      // |obj| is a plain object, created by {} or constructed with new Object
      return true;
    },

    isEmptyObject: function(obj) {
      var name;
      for(name in obj) {
        return false;
      }
      return true;
    },

    type: function(obj) {
      if(obj == null) {
        return obj + "";
      }
      // Support: Android<4.0, iOS<6 (functionish RegExp)
      return typeof obj === "object" || typeof obj === "function" ?
        class2type[toString.call(obj)] || "object" :
        typeof obj;
    },

    // Evaluates a script in a global context
    globalEval: function(code) {
      var script,
        indirect = eval;

      code = jQuery.trim(code);

      if(code) {
        // If the code includes a valid, prologue position
        // strict mode pragma, execute code by injecting a
        // script tag into the document.
        if(code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          // Otherwise, avoid the DOM node creation, insertion
          // and removal by using an indirect global eval
          indirect(code);
        }
      }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE9-11+
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },

    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },

    // args is for internal usage only
    each: function(obj, callback, args) {
      var value,
        i = 0,
        length = obj.length,
        isArray = isArraylike(obj);

      if(args) {
        if(isArray) {
          for(; i < length; i++) {
            value = callback.apply(obj[i], args);

            if(value === false) {
              break;
            }
          }
        } else {
          for(i in obj) {
            value = callback.apply(obj[i], args);

            if(value === false) {
              break;
            }
          }
        }

        // A special, fast, case for the most common use of each
      } else {
        if(isArray) {
          for(; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);

            if(value === false) {
              break;
            }
          }
        } else {
          for(i in obj) {
            value = callback.call(obj[i], i, obj[i]);

            if(value === false) {
              break;
            }
          }
        }
      }

      return obj;
    },

    // Support: Android<4.1
    trim: function(text) {
      return text == null ?
        "" :
        (text + "").replace(rtrim, "");
    },

    // results is for internal usage only
    makeArray: function(arr, results) {
      var ret = results || [];

      if(arr != null) {
        if(isArraylike(Object(arr))) {
          jQuery.merge(ret,
            typeof arr === "string" ? [arr] : arr
          );
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },

    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },

    merge: function(first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;

      for(; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;

      return first;
    },

    grep: function(elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;

      // Go through the array, only saving the items
      // that pass the validator function
      for(; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if(callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },

    // arg is for internal usage only
    map: function(elems, callback, arg) {
      var value,
        i = 0,
        length = elems.length,
        isArray = isArraylike(elems),
        ret = [];

      // Go through the array, translating each of the items to their new values
      if(isArray) {
        for(; i < length; i++) {
          value = callback(elems[i], i, arg);

          if(value != null) {
            ret.push(value);
          }
        }

        // Go through every key on the object,
      } else {
        for(i in elems) {
          value = callback(elems[i], i, arg);

          if(value != null) {
            ret.push(value);
          }
        }
      }

      // Flatten any nested arrays
      return concat.apply([], ret);
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function(fn, context) {
      var tmp, args, proxy;

      if(typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }

      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if(!jQuery.isFunction(fn)) {
        return undefined;
      }

      // Simulated bind
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };

      // Set the guid of unique handler to the same of original handler, so it can be removed
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;

      return proxy;
    },

    now: Date.now,

    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  // Populate the class2type map
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArraylike(obj) {
    var length = obj.length,
      type = jQuery.type(obj);

    if(type === "function" || jQuery.isWindow(obj)) {
      return false;
    }

    if(obj.nodeType === 1 && length) {
      return true;
    }

    return type === "array" || length === 0 ||
      typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v2.2.0-pre
     * http://sizzlejs.com/
     *
     * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2014-12-16
     */
    (function(window) {

      var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,

        // Local document vars
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,

        // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if(a === b) {
            hasDuplicate = true;
          }
          return 0;
        },

        // General-purpose constants
        MAX_NEGATIVE = 1 << 31,

        // Instance methods
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
        // http://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
          var i = 0,
            len = list.length;
          for(; i < len; i++) {
            if(list[i] === elem) {
              return i;
            }
          }
          return -1;
        },

        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

        // Regular expressions

        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/css3-syntax/#characters
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

        // Loosely modeled on CSS identifier characters
        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = characterEncoding.replace("w", "w#"),

        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
        // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace +
        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
        "*\\]",

        pseudos = ":(" + characterEncoding + ")(?:\\((" +
        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
        // 3. anything else (capture 2)
        ".*" +
        ")\\)|)",

        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),

        matchExpr = {
          "ID": new RegExp("^#(" + characterEncoding + ")"),
          "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
          "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },

        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,

        rnative = /^[^{]+\{\s*\[native \w/,

        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

        rsibling = /[+~]/,
        rescape = /'|\\/g,

        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          // NaN means non-codepoint
          // Support: Firefox<24
          // Workaround erroneous numeric interpretation of +"0x"
          return high !== high || escapedWhitespace ?
            escaped :
            high < 0 ?
            // BMP codepoint
            String.fromCharCode(high + 0x10000) :
            // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },

        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
          setDocument();
        };

      // Optimize for push.apply( _, NodeList )
      try {
        push.apply(
          (arr = slice.call(preferredDoc.childNodes)),
          preferredDoc.childNodes
        );
        // Support: Android<4.0
        // Detect silently failing push.apply
        arr[preferredDoc.childNodes.length].nodeType;
      } catch(e) {
        push = {
          apply: arr.length ?

            // Leverage slice if possible
            function(target, els) {
              push_native.apply(target, slice.call(els));
            } :

            // Support: IE<9
            // Otherwise append directly
            function(target, els) {
              var j = target.length,
                i = 0;
              // Can't trust NodeList.length
              while((target[j++] = els[i++])) {}
              target.length = j - 1;
            }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var match, elem, m, nodeType,
          // QSA vars
          i, groups, old, nid, newContext, newSelector;

        if((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }

        context = context || document;
        results = results || [];
        nodeType = context.nodeType;

        if(typeof selector !== "string" || !selector ||
          nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

          return results;
        }

        if(!seed && documentIsHTML) {

          // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
          if(nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // Speed-up: Sizzle("#ID")
            if((m = match[1])) {
              if(nodeType === 9) {
                elem = context.getElementById(m);
                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document (jQuery #6963)
                if(elem && elem.parentNode) {
                  // Handle the case where IE, Opera, and Webkit return items
                  // by name instead of ID
                  if(elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                // Context is not a document
                if(context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                  contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }

              // Speed-up: Sizzle("TAG")
            } else if(match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;

              // Speed-up: Sizzle(".CLASS")
            } else if((m = match[3]) && support.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }

          // QSA path
          if(support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType !== 1 && selector;

            // qSA works strangely on Element-rooted queries
            // We can work around this by specifying an extra ID on the root
            // and working up from there (Thanks to Andrew Dupont for the technique)
            // IE 8 doesn't work on object elements
            if(nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
              groups = tokenize(selector);

              if((old = context.getAttribute("id"))) {
                nid = old.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", nid);
              }
              nid = "[id='" + nid + "'] ";

              i = groups.length;
              while(i--) {
                groups[i] = nid + toSelector(groups[i]);
              }
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              newSelector = groups.join(",");
            }

            if(newSelector) {
              try {
                push.apply(results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch(qsaError) {} finally {
                if(!old) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }

        // All others
        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }

      /**
       * Create key-value caches of limited size
       * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
       *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *  deleting the oldest entry
       */
      function createCache() {
        var keys = [];

        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if(keys.push(key + " ") > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }
          return(cache[key + " "] = value);
        }
        return cache;
      }

      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }

      /**
       * Support testing using an element
       * @param {Function} fn Passed the created div and expects a boolean result
       */
      function assert(fn) {
        var div = document.createElement("div");

        try {
          return !!fn(div);
        } catch(e) {
          return false;
        } finally {
          // Remove from its parent by default
          if(div.parentNode) {
            div.parentNode.removeChild(div);
          }
          // release memory in IE
          div = null;
        }
      }

      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */
      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
          i = attrs.length;

        while(i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }

      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */
      function siblingCheck(a, b) {
        var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
          (~b.sourceIndex || MAX_NEGATIVE) -
          (~a.sourceIndex || MAX_NEGATIVE);

        // Use IE sourceIndex if available on both nodes
        if(diff) {
          return diff;
        }

        // Check if b follows a
        if(cur) {
          while((cur = cur.nextSibling)) {
            if(cur === b) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }

      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */
      function createInputPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */
      function createButtonPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return(name === "input" || name === "button") && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */
      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches) {
            var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;

            // Match elements found at the specified indexes
            while(i--) {
              if(seed[(j = matchIndexes[i])]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }

      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */
      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      }

      // Expose support vars for convenience
      support = Sizzle.support = {};

      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */
      isXML = Sizzle.isXML = function(elem) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };

      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */
      setDocument = Sizzle.setDocument = function(node) {
        var hasCompare, parent,
          doc = node ? node.ownerDocument || node : preferredDoc;

        // If no document and documentElement is available, return
        if(doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }

        // Set our document
        document = doc;
        docElem = doc.documentElement;
        parent = doc.defaultView;

        // Support: IE>8
        // If iframe document is assigned to "document" variable and if iframe has been reloaded,
        // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
        // IE6-8 do not support the defaultView property so parent will be undefined
        if(parent && parent !== parent.top) {
          // IE11 does not have attachEvent, so all must suffer
          if(parent.addEventListener) {
            parent.addEventListener("unload", unloadHandler, false);
          } else if(parent.attachEvent) {
            parent.attachEvent("onunload", unloadHandler);
          }
        }

        /* Support tests
        ---------------------------------------------------------------------- */
        documentIsHTML = !isXML(doc);

        /* Attributes
        ---------------------------------------------------------------------- */

        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)
        support.attributes = assert(function(div) {
          div.className = "i";
          return !div.getAttribute("className");
        });

        /* getElement(s)By*
        ---------------------------------------------------------------------- */

        // Check if getElementsByTagName("*") returns only elements
        support.getElementsByTagName = assert(function(div) {
          div.appendChild(doc.createComment(""));
          return !div.getElementsByTagName("*").length;
        });

        // Support: IE<9
        support.getElementsByClassName = rnative.test(doc.getElementsByClassName);

        // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert(function(div) {
          docElem.appendChild(div).id = expando;
          return !doc.getElementsByName || !doc.getElementsByName(expando).length;
        });

        // ID find and filter
        if(support.getById) {
          Expr.find["ID"] = function(id, context) {
            if(typeof context.getElementById !== "undefined" && documentIsHTML) {
              var m = context.getElementById(id);
              // Check parentNode to catch when Blackberry 4.6 returns
              // nodes that are no longer in the document #6963
              return m && m.parentNode ? [m] : [];
            }
          };
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
        } else {
          // Support: IE6/7
          // getElementById is not reliable as a find shortcut
          delete Expr.find["ID"];

          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };
        }

        // Tag
        Expr.find["TAG"] = support.getElementsByTagName ?
          function(tag, context) {
            if(typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);

              // DocumentFragment nodes don't have gEBTN
            } else if(support.qsa) {
              return context.querySelectorAll(tag);
            }
          } :

          function(tag, context) {
            var elem,
              tmp = [],
              i = 0,
              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
              results = context.getElementsByTagName(tag);

            // Filter out possible comments
            if(tag === "*") {
              while((elem = results[i++])) {
                if(elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }

              return tmp;
            }
            return results;
          };

        // Class
        Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
          if(documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };

        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */

        // QSA and matchesSelector support

        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        rbuggyMatches = [];

        // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See http://bugs.jquery.com/ticket/13378
        rbuggyQSA = [];

        if((support.qsa = rnative.test(doc.querySelectorAll))) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function(div) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
              "<select id='" + expando + "-\f]' msallowcapture=''>" +
              "<option selected=''></option></select>";

            // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
            if(div.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            }

            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if(!div.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }

            // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
            if(!div.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if(!div.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }

            // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibing-combinator selector` fails
            if(!div.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });

          assert(function(div) {
            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = doc.createElement("input");
            input.setAttribute("type", "hidden");
            div.appendChild(input).setAttribute("name", "D");

            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if(div.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if(!div.querySelectorAll(":enabled").length) {
              rbuggyQSA.push(":enabled", ":disabled");
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if((support.matchesSelector = rnative.test((matches = docElem.matches ||
            docElem.webkitMatchesSelector ||
            docElem.mozMatchesSelector ||
            docElem.oMatchesSelector ||
            docElem.msMatchesSelector)))) {

          assert(function(div) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(div, "div");

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call(div, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

        /* Contains
        ---------------------------------------------------------------------- */
        hasCompare = rnative.test(docElem.compareDocumentPosition);

        // Element contains another
        // Purposefully does not implement inclusive descendent
        // As in, an element does not contain itself
        contains = hasCompare || rnative.test(docElem.contains) ?
          function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (
              adown.contains ?
              adown.contains(bup) :
              a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
            ));
          } :
          function(a, b) {
            if(b) {
              while((b = b.parentNode)) {
                if(b === a) {
                  return true;
                }
              }
            }
            return false;
          };

        /* Sorting
        ---------------------------------------------------------------------- */

        // Document order sorting
        sortOrder = hasCompare ?
          function(a, b) {

            // Flag for duplicate removal
            if(a === b) {
              hasDuplicate = true;
              return 0;
            }

            // Sort on method existence if only one input has compareDocumentPosition
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if(compare) {
              return compare;
            }

            // Calculate position if both inputs belong to the same document
            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
              a.compareDocumentPosition(b) :

              // Otherwise we know they are disconnected
              1;

            // Disconnected nodes
            if(compare & 1 ||
              (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

              // Choose the first element that is related to our preferred document
              if(a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }
              if(b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                return 1;
              }

              // Maintain original order
              return sortInput ?
                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                0;
            }

            return compare & 4 ? -1 : 1;
          } :
          function(a, b) {
            // Exit early if the nodes are identical
            if(a === b) {
              hasDuplicate = true;
              return 0;
            }

            var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b];

            // Parentless nodes are either documents or disconnected
            if(!aup || !bup) {
              return a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                0;

              // If the nodes are siblings, we can do a quick check
            } else if(aup === bup) {
              return siblingCheck(a, b);
            }

            // Otherwise we need full lists of their ancestors for comparison
            cur = a;
            while((cur = cur.parentNode)) {
              ap.unshift(cur);
            }
            cur = b;
            while((cur = cur.parentNode)) {
              bp.unshift(cur);
            }

            // Walk down the tree looking for a discrepancy
            while(ap[i] === bp[i]) {
              i++;
            }

            return i ?
              // Do a sibling check if the nodes have a common ancestor
              siblingCheck(ap[i], bp[i]) :

              // Otherwise nodes in our document sort first
              ap[i] === preferredDoc ? -1 :
              bp[i] === preferredDoc ? 1 :
              0;
          };

        return doc;
      };

      Sizzle.matches = function(expr, elements) {
        return Sizzle(expr, null, null, elements);
      };

      Sizzle.matchesSelector = function(elem, expr) {
        // Set document vars if needed
        if((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        // Make sure that attribute selectors are quoted
        expr = expr.replace(rattributeQuotes, "='$1']");

        if(support.matchesSelector && documentIsHTML &&
          (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
          (!rbuggyQSA || !rbuggyQSA.test(expr))) {

          try {
            var ret = matches.call(elem, expr);

            // IE 9's matchesSelector returns false on disconnected nodes
            if(ret || support.disconnectedMatch ||
              // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch(e) {}
        }

        return Sizzle(expr, document, null, [elem]).length > 0;
      };

      Sizzle.contains = function(context, elem) {
        // Set document vars if needed
        if((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };

      Sizzle.attr = function(elem, name) {
        // Set document vars if needed
        if((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
          fn(elem, name, !documentIsHTML) :
          undefined;

        return val !== undefined ?
          val :
          support.attributes || !documentIsHTML ?
          elem.getAttribute(name) :
          (val = elem.getAttributeNode(name)) && val.specified ?
          val.value :
          null;
      };

      Sizzle.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };

      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */
      Sizzle.uniqueSort = function(results) {
        var elem,
          duplicates = [],
          j = 0,
          i = 0;

        // Unless we *know* we can detect duplicates, assume their presence
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);

        if(hasDuplicate) {
          while((elem = results[i++])) {
            if(elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while(j--) {
            results.splice(duplicates[j], 1);
          }
        }

        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;

        return results;
      };

      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */
      getText = Sizzle.getText = function(elem) {
        var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

        if(!nodeType) {
          // If no nodeType, this is expected to be an array
          while((node = elem[i++])) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if(nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if(typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for(elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if(nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        // Do not include comment or processing instruction nodes

        return ret;
      };

      Expr = Sizzle.selectors = {

        // Can be adjusted by the user
        cacheLength: 50,

        createPseudo: markFunction,

        match: matchExpr,

        attrHandle: {},

        find: {},

        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
        },

        preFilter: {
          "ATTR": function(match) {
            match[1] = match[1].replace(runescape, funescape);

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

            if(match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },

          "CHILD": function(match) {
            /* matches from matchExpr["CHILD"]
              1 type (only|nth|...)
              2 what (child|of-type)
              3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
              4 xn-component of xn+y argument ([+-]?\d*n|)
              5 sign of xn-component
              6 x of xn-component
              7 sign of y-component
              8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if(match[1].slice(0, 3) === "nth") {
              // nth-* requires argument
              if(!match[3]) {
                Sizzle.error(match[0]);
              }

              // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1
              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +((match[7] + match[8]) || match[3] === "odd");

              // other types prohibit arguments
            } else if(match[3]) {
              Sizzle.error(match[0]);
            }

            return match;
          },

          "PSEUDO": function(match) {
            var excess,
              unquoted = !match[6] && match[2];

            if(matchExpr["CHILD"].test(match[0])) {
              return null;
            }

            // Accept quoted arguments as-is
            if(match[3]) {
              match[2] = match[4] || match[5] || "";

              // Strip excess characters from unquoted arguments
            } else if(unquoted && rpseudo.test(unquoted) &&
              // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) &&
              // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice(0, 3);
          }
        },

        filter: {

          "TAG": function(nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ?
              function() { return true; } :
              function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
          },

          "CLASS": function(className) {
            var pattern = classCache[className + " "];

            return pattern ||
              (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
              classCache(className, function(elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
          },

          "ATTR": function(name, operator, check) {
            return function(elem) {
              var result = Sizzle.attr(elem, name);

              if(result == null) {
                return operator === "!=";
              }
              if(!operator) {
                return true;
              }

              result += "";

              return operator === "=" ? result === check :
                operator === "!=" ? result !== check :
                operator === "^=" ? check && result.indexOf(check) === 0 :
                operator === "*=" ? check && result.indexOf(check) > -1 :
                operator === "$=" ? check && result.slice(-check.length) === check :
                operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                false;
            };
          },

          "CHILD": function(type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";

            return first === 1 && last === 0 ?

              // Shortcut for :nth-*(n)
              function(elem) {
                return !!elem.parentNode;
              } :

              function(elem, context, xml) {
                var cache, outerCache, node, diff, nodeIndex, start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType;

                if(parent) {

                  // :(first|last|only)-(child|of-type)
                  if(simple) {
                    while(dir) {
                      node = elem;
                      while((node = node[dir])) {
                        if(ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      // Reverse direction for :only-* (if we haven't yet done so)
                      start = dir = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }

                  start = [forward ? parent.firstChild : parent.lastChild];

                  // non-xml :nth-child(...) stores cache data on `parent`
                  if(forward && useCache) {
                    // Seek `elem` from a previously-cached index
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = cache[0] === dirruns && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];

                    while((node = ++nodeIndex && node && node[dir] ||

                        // Fallback to seeking `elem` from the start
                        (diff = nodeIndex = 0) || start.pop())) {

                      // When found, cache indexes on `parent` and break
                      if(node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }

                    // Use previously-cached element index if available
                  } else if(useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                    diff = cache[1];

                    // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                  } else {
                    // Use the same loop as above to seek `elem` from the start
                    while((node = ++nodeIndex && node && node[dir] ||
                        (diff = nodeIndex = 0) || start.pop())) {

                      if((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        // Cache the index of each encountered element
                        if(useCache) {
                          (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                        }

                        if(node === elem) {
                          break;
                        }
                      }
                    }
                  }

                  // Incorporate the offset, then check against cycle size
                  diff -= last;
                  return diff === first || (diff % first === 0 && diff / first >= 0);
                }
              };
          },

          "PSEUDO": function(pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
              Sizzle.error("unsupported pseudo: " + pseudo);

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if(fn[expando]) {
              return fn(argument);
            }

            // But maintain support for old signatures
            if(fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                markFunction(function(seed, matches) {
                  var idx,
                    matched = fn(seed, argument),
                    i = matched.length;
                  while(i--) {
                    idx = indexOf(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) :
                function(elem) {
                  return fn(elem, 0, args);
                };
            }

            return fn;
          }
        },

        pseudos: {
          // Potentially complex pseudos
          "not": markFunction(function(selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));

            return matcher[expando] ?
              markFunction(function(seed, matches, context, xml) {
                var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length;

                // Match elements unmatched by `matcher`
                while(i--) {
                  if((elem = unmatched[i])) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) :
              function(elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                // Don't keep the element (issue #299)
                input[0] = null;
                return !results.pop();
              };
          }),

          "has": markFunction(function(selector) {
            return function(elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),

          "contains": markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return(elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
            };
          }),

          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          "lang": markFunction(function(lang) {
            // lang value must be a valid identifier
            if(!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if((elemLang = documentIsHTML ?
                    elem.lang :
                    elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),

          // Miscellaneous
          "target": function(elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },

          "root": function(elem) {
            return elem === docElem;
          },

          "focus": function(elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },

          // Boolean properties
          "enabled": function(elem) {
            return elem.disabled === false;
          },

          "disabled": function(elem) {
            return elem.disabled === true;
          },

          "checked": function(elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return(nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
          },

          "selected": function(elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if(elem.parentNode) {
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },

          // Contents
          "empty": function(elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for(elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if(elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },

          "parent": function(elem) {
            return !Expr.pseudos["empty"](elem);
          },

          // Element/input types
          "header": function(elem) {
            return rheader.test(elem.nodeName);
          },

          "input": function(elem) {
            return rinputs.test(elem.nodeName);
          },

          "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },

          "text": function(elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" &&
              elem.type === "text" &&

              // Support: IE<8
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },

          // Position-in-collection
          "first": createPositionalPseudo(function() {
            return [0];
          }),

          "last": createPositionalPseudo(function(matchIndexes, length) {
            return [length - 1];
          }),

          "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),

          "even": createPositionalPseudo(function(matchIndexes, length) {
            var i = 0;
            for(; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          "odd": createPositionalPseudo(function(matchIndexes, length) {
            var i = 1;
            for(; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for(; --i >= 0;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for(; ++i < length;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };

      Expr.pseudos["nth"] = Expr.pseudos["eq"];

      // Add button/input type pseudos
      for(i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for(i in { submit: true, reset: true }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }

      // Easy API for creating new setFilters
      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      tokenize = Sizzle.tokenize = function(selector, parseOnly) {
        var matched, match, tokens, type,
          soFar, groups, preFilters,
          cached = tokenCache[selector + " "];

        if(cached) {
          return parseOnly ? 0 : cached.slice(0);
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while(soFar) {

          // Comma and first run
          if(!matched || (match = rcomma.exec(soFar))) {
            if(match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push((tokens = []));
          }

          matched = false;

          // Combinators
          if((match = rcombinators.exec(soFar))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          }

          // Filters
          for(type in Expr.filter) {
            if((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if(!matched) {
            break;
          }
        }

        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        return parseOnly ?
          soFar.length :
          soFar ?
          Sizzle.error(selector) :
          // Cache the tokens
          tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
          len = tokens.length,
          selector = "";
        for(; i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;

        return combinator.first ?
          // Check against closest ancestor/preceding element
          function(elem, context, xml) {
            while((elem = elem[dir])) {
              if(elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
          } :

          // Check against all ancestor/preceding elements
          function(elem, context, xml) {
            var oldCache, outerCache,
              newCache = [dirruns, doneName];

            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
            if(xml) {
              while((elem = elem[dir])) {
                if(elem.nodeType === 1 || checkNonElements) {
                  if(matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while((elem = elem[dir])) {
                if(elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if((oldCache = outerCache[dir]) &&
                    oldCache[0] === dirruns && oldCache[1] === doneName) {

                    // Assign to newCache so results back-propagate to previous elements
                    return(newCache[2] = oldCache[2]);
                  } else {
                    // Reuse newcache so results back-propagate to previous elements
                    outerCache[dir] = newCache;

                    // A match means we're done; a fail means we have to keep checking
                    if((newCache[2] = matcher(elem, context, xml))) {
                      return true;
                    }
                  }
                }
              }
            }
          };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1 ?
          function(elem, context, xml) {
            var i = matchers.length;
            while(i--) {
              if(!matchers[i](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } :
          matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
          len = contexts.length;
        for(; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

        for(; i < len; i++) {
          if((elem = unmatched[i])) {
            if(!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if(mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if(postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if(postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml) {
          var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && (seed || !selector) ?
            condense(elems, preMap, preFilter, context, xml) :
            elems,

            matcherOut = matcher ?
            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
            postFinder || (seed ? preFilter : preexisting || postFilter) ?

            // ...intermediate processing is necessary
            [] :

            // ...otherwise use results directly
            results :
            matcherIn;

          // Find primary matches
          if(matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }

          // Apply postFilter
          if(postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while(i--) {
              if((elem = temp[i])) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if(seed) {
            if(postFinder || preFilter) {
              if(postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;
                while(i--) {
                  if((elem = matcherOut[i])) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push((matcherIn[i] = elem));
                  }
                }
                postFinder(null, (matcherOut = []), temp, xml);
              }

              // Move matched elements from seed to results to keep them synchronized
              i = matcherOut.length;
              while(i--) {
                if((elem = matcherOut[i]) &&
                  (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                  seed[temp] = !(results[temp] = elem);
                }
              }
            }

            // Add elements to results, through postFinder if defined
          } else {
            matcherOut = condense(
              matcherOut === results ?
              matcherOut.splice(preexisting, matcherOut.length) :
              matcherOut
            );
            if(postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext, matcher, j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,

          // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
              (checkContext = context).nodeType ?
              matchContext(elem, context, xml) :
              matchAnyContext(elem, context, xml));
            // Avoid hanging onto element (issue #299)
            checkContext = null;
            return ret;
          }];

        for(; i < len; i++) {
          if((matcher = Expr.relative[tokens[i].type])) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

            // Return special upon seeing a positional matcher
            if(matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;
              for(; j < len; j++) {
                if(Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(
                i > 1 && elementMatcher(matchers),
                i > 1 && toSelector(
                  // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                  tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })
                ).replace(rtrim, "$1"),
                matcher,
                i < j && matcherFromTokens(tokens.slice(i, j)),
                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                j < len && toSelector(tokens)
              );
            }
            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
              elems = seed || byElement && Expr.find["TAG"]("*", outermost),
              // Use integer dirruns iff this is the outermost matcher
              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
              len = elems.length;

            if(outermost) {
              outermostContext = context !== document && context;
            }

            // Add elements passing elementMatchers directly to results
            // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for(; i !== len && (elem = elems[i]) != null; i++) {
              if(byElement && elem) {
                j = 0;
                while((matcher = elementMatchers[j++])) {
                  if(matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if(outermost) {
                  dirruns = dirrunsUnique;
                }
              }

              // Track unmatched elements for set filters
              if(bySet) {
                // They will have gone through all possible matchers
                if((elem = !matcher && elem)) {
                  matchedCount--;
                }

                // Lengthen the array for every element, matched or not
                if(seed) {
                  unmatched.push(elem);
                }
              }
            }

            // Apply set filters to unmatched elements
            matchedCount += i;
            if(bySet && i !== matchedCount) {
              j = 0;
              while((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }

              if(seed) {
                // Reintegrate element matches to eliminate the need for sorting
                if(matchedCount > 0) {
                  while(i--) {
                    if(!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }

                // Discard index placeholder values to get only actual matches
                setMatched = condense(setMatched);
              }

              // Add matches to results
              push.apply(results, setMatched);

              // Seedless set matches succeeding multiple successful matchers stipulate sorting
              if(outermost && !seed && setMatched.length > 0 &&
                (matchedCount + setMatchers.length) > 1) {

                Sizzle.uniqueSort(results);
              }
            }

            // Override manipulation of globals by nested matchers
            if(outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }

            return unmatched;
          };

        return bySet ?
          markFunction(superMatcher) :
          superMatcher;
      }

      compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
        var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

        if(!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if(!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while(i--) {
            cached = matcherFromTokens(match[i]);
            if(cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }

          // Cache the compiled function
          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

          // Save selector and tokenization
          cached.selector = selector;
        }
        return cached;
      };

      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */
      select = Sizzle.select = function(selector, context, results, seed) {
        var i, tokens, token, type, find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));

        results = results || [];

        // Try to minimize operations if there is no seed and only one group
        if(match.length === 1) {

          // Take a shortcut and set the context if the root selector is an ID
          tokens = match[0] = match[0].slice(0);
          if(tokens.length > 2 && (token = tokens[0]).type === "ID" &&
            support.getById && context.nodeType === 9 && documentIsHTML &&
            Expr.relative[tokens[1].type]) {

            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if(!context) {
              return results;

              // Precompiled matchers will still verify ancestry, so step up a level
            } else if(compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          }

          // Fetch a seed set for right-to-left matching
          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while(i--) {
            token = tokens[i];

            // Abort if we hit a combinator
            if(Expr.relative[(type = token.type)]) {
              break;
            }
            if((find = Expr.find[type])) {
              // Search, expanding context for leading sibling combinators
              if((seed = find(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                ))) {

                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if(!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        }

        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        (compiled || compile(selector, match))(
          seed,
          context, !documentIsHTML,
          results,
          rsibling.test(selector) && testContext(context.parentNode) || context
        );
        return results;
      };

      // One-time assignments

      // Sort stability
      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

      // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function
      support.detectDuplicates = !!hasDuplicate;

      // Initialize against the default document
      setDocument();

      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*
      support.sortDetached = assert(function(div1) {
        // Should return 1, but returns 4 (following)
        return div1.compareDocumentPosition(document.createElement("div")) & 1;
      });

      // Support: IE<8
      // Prevent attribute/property "interpolation"
      // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
      if(!assert(function(div) {
          div.innerHTML = "<a href='#'></a>";
          return div.firstChild.getAttribute("href") === "#";
        })) {
        addHandle("type|href|height|width", function(elem, name, isXML) {
          if(!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      }

      // Support: IE<9
      // Use defaultValue in place of getAttribute("value")
      if(!support.attributes || !assert(function(div) {
          div.innerHTML = "<input/>";
          div.firstChild.setAttribute("value", "");
          return div.firstChild.getAttribute("value") === "";
        })) {
        addHandle("value", function(elem, name, isXML) {
          if(!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }

      // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies
      if(!assert(function(div) {
          return div.getAttribute("disabled") == null;
        })) {
        addHandle(booleans, function(elem, name, isXML) {
          var val;
          if(!isXML) {
            return elem[name] === true ? name.toLowerCase() :
              (val = elem.getAttributeNode(name)) && val.specified ?
              val.value :
              null;
          }
        });
      }

      return Sizzle;

    })(window);



  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;



  var rneedsContext = jQuery.expr.match.needsContext;

  var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



  var risSimple = /^.[^:#\[\.,]*$/;

  // Implement the identical functionality for filter and not
  function winnow(elements, qualifier, not) {
    if(jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        /* jshint -W018 */
        return !!qualifier.call(elem, i, elem) !== not;
      });

    }

    if(qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return(elem === qualifier) !== not;
      });

    }

    if(typeof qualifier === "string") {
      if(risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }

      qualifier = jQuery.filter(qualifier, elements);
    }

    return jQuery.grep(elements, function(elem) {
      return(indexOf.call(qualifier, elem) >= 0) !== not;
    });
  }

  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];

    if(not) {
      expr = ":not(" + expr + ")";
    }

    return elems.length === 1 && elem.nodeType === 1 ?
      jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
      jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
        return elem.nodeType === 1;
      }));
  };

  jQuery.fn.extend({
    find: function(selector) {
      var i,
        len = this.length,
        ret = [],
        self = this;

      if(typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for(i = 0; i < len; i++) {
            if(jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      for(i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      // Needed because $( selector, context ) becomes $( context ).find( selector )
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(
        this,

        // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test(selector) ?
        jQuery(selector) :
        selector || [],
        false
      ).length;
    }
  });


  // Initialize a jQuery object


  // A central reference to the root jQuery(document)
  var rootjQuery,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

    init = jQuery.fn.init = function(selector, context) {
      var match, elem;

      // HANDLE: $(""), $(null), $(undefined), $(false)
      if(!selector) {
        return this;
      }

      // Handle HTML strings
      if(typeof selector === "string") {
        if(selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];

        } else {
          match = rquickExpr.exec(selector);
        }

        // Match html or make sure no context is specified for #id
        if(match && (match[1] || !context)) {

          // HANDLE: $(html) -> $(array)
          if(match[1]) {
            context = context instanceof jQuery ? context[0] : context;

            // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present
            jQuery.merge(this, jQuery.parseHTML(
              match[1],
              context && context.nodeType ? context.ownerDocument || context : document,
              true
            ));

            // HANDLE: $(html, props)
            if(rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for(match in context) {
                // Properties of context are called as methods if possible
                if(jQuery.isFunction(this[match])) {
                  this[match](context[match]);

                  // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }

            return this;

            // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);

            // Support: Blackberry 4.6
            // gEBID returns nodes no longer in the document (#6963)
            if(elem && elem.parentNode) {
              // Inject the element directly into the jQuery object
              this.length = 1;
              this[0] = elem;
            }

            this.context = document;
            this.selector = selector;
            return this;
          }

          // HANDLE: $(expr, $(...))
        } else if(!context || context.jquery) {
          return(context || rootjQuery).find(selector);

          // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        }

        // HANDLE: $(DOMElement)
      } else if(selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;

        // HANDLE: $(function)
        // Shortcut for document ready
      } else if(jQuery.isFunction(selector)) {
        return typeof rootjQuery.ready !== "undefined" ?
          rootjQuery.ready(selector) :
          // Execute immediately if ready is not present
          selector(jQuery);
      }

      if(selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }

      return jQuery.makeArray(selector, this);
    };

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery(document);


  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };

  jQuery.extend({
    dir: function(elem, dir, until) {
      var matched = [],
        truncate = until !== undefined;

      while((elem = elem[dir]) && elem.nodeType !== 9) {
        if(elem.nodeType === 1) {
          if(truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },

    sibling: function(n, elem) {
      var matched = [];

      for(; n; n = n.nextSibling) {
        if(n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }

      return matched;
    }
  });

  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
        l = targets.length;

      return this.filter(function() {
        var i = 0;
        for(; i < l; i++) {
          if(jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },

    closest: function(selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
        jQuery(selectors, context || this.context) :
        0;

      for(; i < l; i++) {
        for(cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          // Always skip document fragments
          if(cur.nodeType < 11 && (pos ?
              pos.index(cur) > -1 :

              // Don't pass non-elements to Sizzle
              cur.nodeType === 1 &&
              jQuery.find.matchesSelector(cur, selectors))) {

            matched.push(cur);
            break;
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },

    // Determine the position of an element within the set
    index: function(elem) {

      // No argument, return index in parent
      if(!elem) {
        return(this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }

      // Index in selector
      if(typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }

      // Locate the position of the desired element
      return indexOf.call(this,

        // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[0] : elem
      );
    },

    add: function(selector, context) {
      return this.pushStack(
        jQuery.unique(
          jQuery.merge(this.get(), jQuery(selector, context))
        )
      );
    },

    addBack: function(selector) {
      return this.add(selector == null ?
        this.prevObject : this.prevObject.filter(selector)
      );
    }
  });

  function sibling(cur, dir) {
    while((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }

  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);

      if(name.slice(-5) !== "Until") {
        selector = until;
      }

      if(selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if(this.length > 1) {
        // Remove duplicates
        if(!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }

        // Reverse order for parents* and prev-derivatives
        if(rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);



  // String to Object options format cache
  var optionsCache = {};

  // Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *  options: an optional list of space-separated options that will change how
   *      the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *  once:     will ensure the callback list can only be fired once (like a Deferred)
   *
   *  memory:     will keep track of previous values and will call any callback added
   *          after the list has been fired right away with the latest "memorized"
   *          values (like a Deferred)
   *
   *  unique:     will ensure a callback can only be added once (no duplicate in the list)
   *
   *  stopOnFalse:  interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function(options) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ?
      (optionsCache[options] || createOptions(options)) :
      jQuery.extend({}, options);

    var // Last fire value (for non-forgettable lists)
      memory,
      // Flag to know if list was already fired
      fired,
      // Flag to know if list is currently firing
      firing,
      // First callback to fire (used internally by add and fireWith)
      firingStart,
      // End of the loop when firing
      firingLength,
      // Index of currently firing callback (modified by remove if needed)
      firingIndex,
      // Actual callback list
      list = [],
      // Stack of fire calls for repeatable lists
      stack = !options.once && [],
      // Fire callbacks
      fire = function(data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for(; list && firingIndex < firingLength; firingIndex++) {
          if(list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false; // To prevent further calls using add
            break;
          }
        }
        firing = false;
        if(list) {
          if(stack) {
            if(stack.length) {
              fire(stack.shift());
            }
          } else if(memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      },
      // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if(list) {
            // First, we save the current length
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function(_, arg) {
                var type = jQuery.type(arg);
                if(type === "function") {
                  if(!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if(arg && arg.length && type !== "string") {
                  // Inspect recursively
                  add(arg);
                }
              });
            })(arguments);
            // Do we need to add the callbacks to the
            // current firing batch?
            if(firing) {
              firingLength = list.length;
              // With memory, if we're not firing then
              // we should call right away
            } else if(memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function() {
          if(list) {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                // Handle firing indexes
                if(firing) {
                  if(index <= firingLength) {
                    firingLength--;
                  }
                  if(index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        // Remove all callbacks from the list
        empty: function() {
          list = [];
          firingLength = 0;
          return this;
        },
        // Have the list do nothing anymore
        disable: function() {
          list = stack = memory = undefined;
          return this;
        },
        // Is it disabled?
        disabled: function() {
          return !list;
        },
        // Lock the list in its current state
        lock: function() {
          stack = undefined;
          if(!memory) {
            self.disable();
          }
          return this;
        },
        // Is it locked?
        locked: function() {
          return !stack;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function(context, args) {
          if(list && (!fired || stack)) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            if(firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          self.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };

    return self;
  };


  jQuery.extend({

    Deferred: function(func) {
      var tuples = [
          // action, add listener, listener list, final state
          ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
          ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
          ["notify", "progress", jQuery.Callbacks("memory")]
        ],
        state = "pending",
        promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function( /* fnDone, fnFail, fnProgress */ ) {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(i, tuple) {
                var fn = jQuery.isFunction(fns[i]) && fns[i];
                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                deferred[tuple[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if(returned && jQuery.isFunction(returned.promise)) {
                    returned.promise()
                      .done(newDefer.resolve)
                      .fail(newDefer.reject)
                      .progress(newDefer.notify);
                  } else {
                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        },
        deferred = {};

      // Keep pipe for back-compat
      promise.pipe = promise.then;

      // Add list-specific methods
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
          stateString = tuple[3];

        // promise[ done | fail | progress ] = list.add
        promise[tuple[1]] = list.add;

        // Handle state
        if(stateString) {
          list.add(function() {
            // state = [ resolved | rejected ]
            state = stateString;

            // [ reject_list | resolve_list ].disable; progress_list.lock
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }

        // deferred[ resolve | reject | notify ]
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });

      // Make the deferred a promise
      promise.promise(deferred);

      // Call given func if any
      if(func) {
        func.call(deferred, deferred);
      }

      // All done!
      return deferred;
    },

    // Deferred helper
    when: function(subordinate /* , ..., subordinateN */ ) {
      var i = 0,
        resolveValues = slice.call(arguments),
        length = resolveValues.length,

        // the count of uncompleted subordinates
        remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

        // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

        // Update function for both resolve and progress values
        updateFunc = function(i, contexts, values) {
          return function(value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if(values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if(!(--remaining)) {
              deferred.resolveWith(contexts, values);
            }
          };
        },

        progressValues, progressContexts, resolveContexts;

      // Add listeners to Deferred subordinates; treat others as resolved
      if(length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for(; i < length; i++) {
          if(resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise()
              .done(updateFunc(i, resolveContexts, resolveValues))
              .fail(deferred.reject)
              .progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }

      // If we're not waiting on anything, resolve the master
      if(!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }

      return deferred.promise();
    }
  });


  // The deferred used on DOM ready
  var readyList;

  jQuery.fn.ready = function(fn) {
    // Add the callback
    jQuery.ready.promise().done(fn);

    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Hold (or release) the ready event
    holdReady: function(hold) {
      if(hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },

    // Handle when the DOM is ready
    ready: function(wait) {

      // Abort if there are pending holds or we're already ready
      if(wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }

      // Remember that the DOM is ready
      jQuery.isReady = true;

      // If a normal DOM Ready event fired, decrement, and wait if need be
      if(wait !== true && --jQuery.readyWait > 0) {
        return;
      }

      // If there are functions bound, to execute
      readyList.resolveWith(document, [jQuery]);

      // Trigger any bound ready events
      if(jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });

  /**
   * The ready event handler and self cleanup method
   */
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }

  jQuery.ready.promise = function(obj) {
    if(!readyList) {

      readyList = jQuery.Deferred();

      // Catch cases where $(document).ready() is called after the browser event has already occurred.
      // We once tried to use readyState "interactive" here, but it caused issues like the one
      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
      if(document.readyState === "complete") {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        setTimeout(jQuery.ready);

      } else {

        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed, false);

        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };

  // Kick off the DOM ready check even if the user does not
  jQuery.ready.promise();




  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
      len = elems.length,
      bulk = key == null;

    // Sets many values
    if(jQuery.type(key) === "object") {
      chainable = true;
      for(i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }

      // Sets one value
    } else if(value !== undefined) {
      chainable = true;

      if(!jQuery.isFunction(value)) {
        raw = true;
      }

      if(bulk) {
        // Bulk operations run against the entire set
        if(raw) {
          fn.call(elems, value);
          fn = null;

          // ...except when executing function values
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if(fn) {
        for(; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    return chainable ?
      elems :

      // Gets
      bulk ?
      fn.call(elems) :
      len ? fn(elems[0], key) : emptyGet;
  };


  /**
   * Determines whether an object can have data
   */
  jQuery.acceptData = function(owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    /* jshint -W018 */
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };


  function Data() {
    // Support: Android<4,
    // Old WebKit does not have Object.preventExtensions/freeze method,
    // return new empty object instead with no [[set]] accessor
    Object.defineProperty(this.cache = {}, 0, {
      get: function() {
        return {};
      }
    });

    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.accepts = jQuery.acceptData;

  Data.prototype = {
    key: function(owner) {
      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return the key for a frozen object.
      if(!Data.accepts(owner)) {
        return 0;
      }

      var descriptor = {},
        // Check if the owner object already has a cache key
        unlock = owner[this.expando];

      // If not, create one
      if(!unlock) {
        unlock = Data.uid++;

        // Secure it in a non-enumerable, non-writable property
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);

          // Support: Android<4
          // Fallback to a less secure definition
        } catch(e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }

      // Ensure the cache object
      if(!this.cache[unlock]) {
        this.cache[unlock] = {};
      }

      return unlock;
    },
    set: function(owner, data, value) {
      var prop,
        // There may be an unlock assigned to this node,
        // if there is no entry for this "owner", create one inline
        // and set the unlock as though an owner entry had always existed
        unlock = this.key(owner),
        cache = this.cache[unlock];

      // Handle: [ owner, key, value ] args
      if(typeof data === "string") {
        cache[data] = value;

        // Handle: [ owner, { properties } ] args
      } else {
        // Fresh assignments by object are shallow copied
        if(jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
          // Otherwise, copy the properties one-by-one to the cache object
        } else {
          for(prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function(owner, key) {
      // Either a valid cache is found, or will be created.
      // New caches will be created and the unlock returned,
      // allowing direct access to the newly created
      // empty data object. A valid owner object must be provided.
      var cache = this.cache[this.key(owner)];

      return key === undefined ?
        cache : cache[key];
    },
    access: function(owner, key, value) {
      var stored;
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if(key === undefined ||
        ((key && typeof key === "string") && value === undefined)) {

        stored = this.get(owner, key);

        return stored !== undefined ?
          stored : this.get(owner, jQuery.camelCase(key));
      }

      // [*]When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set(owner, key, value);

      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i, name, camel,
        unlock = this.key(owner),
        cache = this.cache[unlock];

      if(key === undefined) {
        this.cache[unlock] = {};

      } else {
        // Support array or space separated string of keys
        if(jQuery.isArray(key)) {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          // Try the string as a key before any manipulation
          if(key in cache) {
            name = [key, camel];
          } else {
            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }

        i = name.length;
        while(i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function(owner) {
      return !jQuery.isEmptyObject(
        this.cache[owner[this.expando]] || {}
      );
    },
    discard: function(owner) {
      if(owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();

  var data_user = new Data();



  //  Implementation Summary
  //
  //  1. Enforce API surface and semantic compatibility with 1.9.x branch
  //  2. Improve the module's maintainability by reducing the storage
  //    paths to a single mechanism.
  //  3. Use the same single mechanism to support "private" and "user" data.
  //  4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //  5. Avoid exposing implementation details on user objects (eg. expando properties)
  //  6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;

  function dataAttr(elem, key, data) {
    var name;

    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if(data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);

      if(typeof data === "string") {
        try {
          data = data === "true" ? true :
            data === "false" ? false :
            data === "null" ? null :
            // Only convert to a number if it doesn't change the string
            +data + "" === data ? +data :
            rbrace.test(data) ? jQuery.parseJSON(data) :
            data;
        } catch(e) {}

        // Make sure we set the data so it isn't changed later
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }

  jQuery.extend({
    hasData: function(elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },

    data: function(elem, name, data) {
      return data_user.access(elem, name, data);
    },

    removeData: function(elem, name) {
      data_user.remove(elem, name);
    },

    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to data_priv methods, these can be deprecated.
    _data: function(elem, name, data) {
      return data_priv.access(elem, name, data);
    },

    _removeData: function(elem, name) {
      data_priv.remove(elem, name);
    }
  });

  jQuery.fn.extend({
    data: function(key, value) {
      var i, name, data,
        elem = this[0],
        attrs = elem && elem.attributes;

      // Gets all values
      if(key === undefined) {
        if(this.length) {
          data = data_user.get(elem);

          if(elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while(i--) {

              // Support: IE11+
              // The attrs elements can be null (#14894)
              if(attrs[i]) {
                name = attrs[i].name;
                if(name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      }

      // Sets multiple values
      if(typeof key === "object") {
        return this.each(function() {
          data_user.set(this, key);
        });
      }

      return access(this, function(value) {
        var data,
          camelKey = jQuery.camelCase(key);

        // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.
        if(elem && value === undefined) {
          // Attempt to get data from the cache
          // with the key as-is
          data = data_user.get(elem, key);
          if(data !== undefined) {
            return data;
          }

          // Attempt to get data from the cache
          // with the key camelized
          data = data_user.get(elem, camelKey);
          if(data !== undefined) {
            return data;
          }

          // Attempt to "discover" the data in
          // HTML5 custom data-* attrs
          data = dataAttr(elem, camelKey, undefined);
          if(data !== undefined) {
            return data;
          }

          // We tried really hard, but the data doesn't exist.
          return;
        }

        // Set the data...
        this.each(function() {
          // First, attempt to store a copy or reference of any
          // data that might've been store with a camelCased key.
          var data = data_user.get(this, camelKey);

          // For HTML5 data-* attribute interop, we have to
          // store property names with dashes in a camelCase form.
          // This might not apply to all properties...*
          data_user.set(this, camelKey, value);

          // *... In the case of properties that might _actually_
          // have dashes, we need to also store a copy of that
          // unchanged property.
          if(key.indexOf("-") !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },

    removeData: function(key) {
      return this.each(function() {
        data_user.remove(this, key);
      });
    }
  });


  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;

      if(elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);

        // Speed up dequeue by getting out quickly if this is just a lookup
        if(data) {
          if(!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },

    dequeue: function(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks(elem, type),
        next = function() {
          jQuery.dequeue(elem, type);
        };

      // If the fx queue is dequeued, always remove the progress sentinel
      if(fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if(fn) {

        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if(type === "fx") {
          queue.unshift("inprogress");
        }

        // Clear up the last queue stop function
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if(!startLength && hooks) {
        hooks.empty.fire();
      }
    },

    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function() {
          data_priv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });

  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;

      if(typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if(arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ?
        this :
        this.each(function() {
          var queue = jQuery.queue(this, type, data);

          // Ensure a hooks for this queue
          jQuery._queueHooks(this, type);

          if(type === "fx" && queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function(type, obj) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
          if(!(--count)) {
            defer.resolveWith(elements, [elements]);
          }
        };

      if(typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";

      while(i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if(tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

  var cssExpand = ["Top", "Right", "Bottom", "Left"];

  var isHidden = function(elem, el) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };

  var rcheckableType = (/^(?:checkbox|radio)$/i);



  (function() {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild(document.createElement("div")),
      input = document.createElement("input");

    // Support: Safari<=5.1
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");

    div.appendChild(input);

    // Support: Safari<=5.1, Android<4.2
    // Older WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

    // Support: IE<=11+
    // Make sure textarea (and checkbox) defaultValue is properly cloned
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;



  support.focusinBubbles = "onfocusin" in window;


  var
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch(err) {}
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {

    global: {},

    add: function(elem, types, handler, data, selector) {

      var handleObjIn, eventHandle, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = data_priv.get(elem);

      // Don't attach events to noData or text/comment nodes (but allow plain objects)
      if(!elemData) {
        return;
      }

      // Caller can pass in an object of custom data in lieu of the handler
      if(handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }

      // Make sure that the handler has a unique ID, used to find/remove it later
      if(!handler.guid) {
        handler.guid = jQuery.guid++;
      }

      // Init the element's event structure and main handler, if this is the first
      if(!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if(!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }

      // Handle multiple events separated by a space
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while(t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // There *must* be a type, no attaching namespace-only handlers
        if(!type) {
          continue;
        }

        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[type] || {};

        // If selector defined, determine special event api type, otherwise given type
        type = (selector ? special.delegateType : special.bindType) || type;

        // Update special based on newly reset type
        special = jQuery.event.special[type] || {};

        // handleObj is passed to all event handlers
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);

        // Init the event handler queue if we're the first
        if(!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;

          // Only use addEventListener if the special events handler returns false
          if(!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if(elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }

        if(special.add) {
          special.add.call(elem, handleObj);

          if(!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }

        // Add to the element's handler list, delegates in front
        if(selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }

        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[type] = true;
      }

    },

    // Detach an event or set of events from an element
    remove: function(elem, types, handler, selector, mappedTypes) {

      var j, origCount, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = data_priv.hasData(elem) && data_priv.get(elem);

      if(!elemData || !(events = elemData.events)) {
        return;
      }

      // Once for each type.namespace in types; type may be omitted
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while(t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // Unbind all events (on this namespace, if provided) for the element
        if(!type) {
          for(type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

        // Remove matching events
        origCount = j = handlers.length;
        while(j--) {
          handleObj = handlers[j];

          if((mappedTypes || origType === handleObj.origType) &&
            (!handler || handler.guid === handleObj.guid) &&
            (!tmp || tmp.test(handleObj.namespace)) &&
            (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if(handleObj.selector) {
              handlers.delegateCount--;
            }
            if(special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }

        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if(origCount && !handlers.length) {
          if(!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      }

      // Remove the expando if it's no longer used
      if(jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },

    trigger: function(event, data, elem, onlyHandlers) {

      var i, cur, tmp, bubbleType, ontype, handle, special,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

      cur = tmp = elem = elem || document;

      // Don't do events on text and comment nodes
      if(elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }

      // focus/blur morphs to focusin/out; ensure we're not firing them right now
      if(rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if(type.indexOf(".") >= 0) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;

      // Caller can pass in a jQuery.Event object, Object, or just an event type string
      event = event[jQuery.expando] ?
        event :
        new jQuery.Event(type, typeof event === "object" && event);

      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ?
        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
        null;

      // Clean up the event in case it is being reused
      event.result = undefined;
      if(!event.target) {
        event.target = elem;
      }

      // Clone any incoming data and prepend the event, creating the handler arg list
      data = data == null ? [event] :
        jQuery.makeArray(data, [event]);

      // Allow special events to draw outside the lines
      special = jQuery.event.special[type] || {};
      if(!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }

      // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
      if(!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

        bubbleType = special.delegateType || type;
        if(!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for(; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }

        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if(tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }

      // Fire handlers on the event path
      i = 0;
      while((cur = eventPath[i++]) && !event.isPropagationStopped()) {

        event.type = i > 1 ?
          bubbleType :
          special.bindType || type;

        // jQuery handler
        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
        if(handle) {
          handle.apply(cur, data);
        }

        // Native handler
        handle = ontype && cur[ontype];
        if(handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if(event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;

      // If nobody prevented the default action, do it now
      if(!onlyHandlers && !event.isDefaultPrevented()) {

        if((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
          jQuery.acceptData(elem)) {

          // Call a native DOM method on the target with the same name name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if(ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if(tmp) {
              elem[ontype] = null;
            }

            // Prevent re-triggering of the same event, since we already bubbled it above
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;

            if(tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },

    dispatch: function(event) {

      // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(event);

      var i, j, ret, matched, handleObj,
        handlerQueue = [],
        args = slice.call(arguments),
        handlers = (data_priv.get(this, "events") || {})[event.type] || [],
        special = jQuery.event.special[event.type] || {};

      // Use the fix-ed jQuery.Event rather than the (read-only) native event
      args[0] = event;
      event.delegateTarget = this;

      // Call the preDispatch hook for the mapped type, and let it bail if desired
      if(special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }

      // Determine handlers
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);

      // Run delegates first; they may want to stop propagation beneath us
      i = 0;
      while((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;

        j = 0;
        while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

          // Triggered event must either 1) have no namespace, or 2) have namespace(s)
          // a subset or equal to those in the bound event (both can have no namespace).
          if(!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

            event.handleObj = handleObj;
            event.data = handleObj.data;

            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
              .apply(matched.elem, args);

            if(ret !== undefined) {
              if((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }

      // Call the postDispatch hook for the mapped type
      if(special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },

    handlers: function(event, handlers) {
      var i, matches, sel, handleObj,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;

      // Find delegate handlers
      // Black-hole SVG <use> instance trees (#13180)
      // Avoid non-left-click bubbling in Firefox (#3861)
      if(delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

        for(; cur !== this; cur = cur.parentNode || this) {

          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if(cur.disabled !== true || event.type !== "click") {
            matches = [];
            for(i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];

              // Don't conflict with Object.prototype properties (#13203)
              sel = handleObj.selector + " ";

              if(matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ?
                  jQuery(sel, this).index(cur) >= 0 :
                  jQuery.find(sel, this, null, [cur]).length;
              }
              if(matches[sel]) {
                matches.push(handleObj);
              }
            }
            if(matches.length) {
              handlerQueue.push({ elem: cur, handlers: matches });
            }
          }
        }
      }

      // Add the remaining (directly-bound) handlers
      if(delegateCount < handlers.length) {
        handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
      }

      return handlerQueue;
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

    fixHooks: {},

    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {

        // Add which for key events
        if(event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }

        return event;
      }
    },

    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var eventDoc, doc, body,
          button = original.button;

        // Calculate pageX/Y if missing and clientX/Y available
        if(event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;

          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }

        // Add which for click: 1 === left; 2 === middle; 3 === right
        // Note: button is not normalized, so don't use it
        if(!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }

        return event;
      }
    },

    fix: function(event) {
      if(event[jQuery.expando]) {
        return event;
      }

      // Create a writable copy of the event object and normalize some properties
      var i, prop, copy,
        type = event.type,
        originalEvent = event,
        fixHook = this.fixHooks[type];

      if(!fixHook) {
        this.fixHooks[type] = fixHook =
          rmouseEvent.test(type) ? this.mouseHooks :
          rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

      event = new jQuery.Event(originalEvent);

      i = copy.length;
      while(i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }

      // Support: Cordova 2.5 (WebKit) (#13255)
      // All events should have a target; Cordova deviceready doesn't
      if(!event.target) {
        event.target = document;
      }

      // Support: Safari 6.0+, Chrome<28
      // Target should not be a text node (#504, #13143)
      if(event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }

      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },

    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function() {
          if(this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if(this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        // For checkbox, fire native event so checked state will be right
        trigger: function() {
          if(this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },

        // For cross-browser consistency, don't fire native .click() on links
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },

      beforeunload: {
        postDispatch: function(event) {

          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if(event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },

    simulate: function(type, elem, event, bubble) {
      // Piggyback on a donor event to simulate a different one.
      // Fake originalEvent to avoid donor's stopPropagation, but if the
      // simulated event prevents default then we do the same on the donor.
      var e = jQuery.extend(
        new jQuery.Event(),
        event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        }
      );
      if(bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if(e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };

  jQuery.removeEvent = function(elem, type, handle) {
    if(elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };

  jQuery.Event = function(src, props) {
    // Allow instantiation without the 'new' keyword
    if(!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }

    // Event object
    if(src && src.type) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = src.defaultPrevented ||
        src.defaultPrevented === undefined &&
        // Support: Android<4.0
        src.returnValue === false ?
        returnTrue :
        returnFalse;

      // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if(props) {
      jQuery.extend(this, props);
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || jQuery.now();

    // Mark it as fixed
    this[jQuery.expando] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,

    preventDefault: function() {
      var e = this.originalEvent;

      this.isDefaultPrevented = returnTrue;

      if(e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;

      this.isPropagationStopped = returnTrue;

      if(e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;

      this.isImmediatePropagationStopped = returnTrue;

      if(e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  };

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // Support: Chrome 15+
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,

      handle: function(event) {
        var ret,
          target = this,
          related = event.relatedTarget,
          handleObj = event.handleObj;

        // For mousenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if(!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });

  // Support: Firefox, Chrome, Safari
  // Create "bubbling" focus and blur events
  if(!support.focusinBubbles) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {

      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };

      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix);

          if(!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix) - 1;

          if(!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);

          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  jQuery.fn.extend({

    on: function(types, selector, data, fn, /*INTERNAL*/ one) {
      var origFn, type;

      // Types can be a map of types/handlers
      if(typeof types === "object") {
        // ( types-Object, selector, data )
        if(typeof selector !== "string") {
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }
        for(type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }

      if(data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if(fn == null) {
        if(typeof selector === "string") {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if(fn === false) {
        fn = returnFalse;
      } else if(!fn) {
        return this;
      }

      if(one === 1) {
        origFn = fn;
        fn = function(event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        // Use same guid so caller can remove using origFn
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj, type;
      if(types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(
          handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
          handleObj.selector,
          handleObj.handler
        );
        return this;
      }
      if(typeof types === "object") {
        // ( types-object [, selector] )
        for(type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if(selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }
      if(fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    },

    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if(elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });


  var
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

    // We have to close these tags to support XHTML (#13200)
    wrapMap = {

      // Support: IE9
      option: [1, "<select multiple='multiple'>", "</select>"],

      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

      _default: [0, "", ""]
    };

  // Support: IE9
  wrapMap.optgroup = wrapMap.option;

  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  // Support: 1.x compatibility
  // Manipulating tables requires a tbody
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") &&
      jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?

      elem.getElementsByTagName("tbody")[0] ||
      elem.appendChild(elem.ownerDocument.createElement("tbody")) :
      elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);

    if(match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  // Mark scripts as having already been evaluated
  function setGlobalEval(elems, refElements) {
    var i = 0,
      l = elems.length;

    for(; i < l; i++) {
      data_priv.set(
        elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval")
      );
    }
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

    if(dest.nodeType !== 1) {
      return;
    }

    // 1. Copy private data: events, handlers, etc.
    if(data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;

      if(events) {
        delete pdataCur.handle;
        pdataCur.events = {};

        for(type in events) {
          for(i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }

    // 2. Copy user data
    if(data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);

      data_user.set(dest, udataCur);
    }
  }

  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :
      context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];

    return tag === undefined || tag && jQuery.nodeName(context, tag) ?
      jQuery.merge([context], ret) :
      ret;
  }

  // Fix IE bugs, see support tests
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();

    // Fails to persist the checked state of a cloned checkbox or radio button.
    if(nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;

      // Fails to return the selected option to the default selected state when cloning options
    } else if(nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  jQuery.extend({
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements,
        clone = elem.cloneNode(true),
        inPage = jQuery.contains(elem.ownerDocument, elem);

      // Fix IE cloning issues
      if(!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
        !jQuery.isXMLDoc(elem)) {

        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for(i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }

      // Copy the events from the original to the clone
      if(dataAndEvents) {
        if(deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for(i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }

      // Preserve script evaluation history
      destElements = getAll(clone, "script");
      if(destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }

      // Return the cloned set
      return clone;
    },

    buildFragment: function(elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

      for(; i < l; i++) {
        elem = elems[i];

        if(elem || elem === 0) {

          // Add nodes directly
          if(jQuery.type(elem) === "object") {
            // Support: QtWebKit, PhantomJS
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

            // Convert non-html into a text node
          } else if(!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));

            // Convert html into DOM nodes
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));

            // Deserialize a standard representation
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;

            if(Xut.IBooks.Enabled) {
              try {
                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
              } catch(e) {
                console.log(wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2])
              }
            } else {
              tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
            }

            // Descend through wrappers to the right content
            j = wrap[0];
            while(j--) {
              tmp = tmp.lastChild;
            }

            // Support: QtWebKit, PhantomJS
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, tmp.childNodes);

            // Remember the top-level container
            tmp = fragment.firstChild;

            // Ensure the created nodes are orphaned (#12392)
            tmp.textContent = "";
          }
        }
      }

      // Remove wrapper from fragment
      fragment.textContent = "";

      i = 0;
      while((elem = nodes[i++])) {

        // #4087 - If origin and destination elements are the same, and this is
        // that element, do not do anything
        if(selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }

        contains = jQuery.contains(elem.ownerDocument, elem);

        // Append to fragment
        tmp = getAll(fragment.appendChild(elem), "script");

        // Preserve script evaluation history
        if(contains) {
          setGlobalEval(tmp);
        }

        // Capture executables
        if(scripts) {
          j = 0;
          while((elem = tmp[j++])) {
            if(rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }

      return fragment;
    },

    cleanData: function(elems) {
      var data, elem, type, key,
        special = jQuery.event.special,
        i = 0;

      for(;
        (elem = elems[i]) !== undefined; i++) {
        if(jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];

          if(key && (data = data_priv.cache[key])) {
            if(data.events) {
              for(type in data.events) {
                if(special[type]) {
                  jQuery.event.remove(elem, type);

                  // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if(data_priv.cache[key]) {
              // Discard any remaining `private` data
              delete data_priv.cache[key];
            }
          }
        }
        // Discard any remaining `user` data
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });

  jQuery.fn.extend({
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ?
          jQuery.text(this) :
          this.empty().each(function() {
            if(this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value;
            }
          });
      }, null, value, arguments.length);
    },

    append: function() {
      return this.domManip(arguments, function(elem) {
        if(this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },

    prepend: function() {
      return this.domManip(arguments, function(elem) {
        if(this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },

    before: function() {
      return this.domManip(arguments, function(elem) {
        if(this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },

    after: function() {
      return this.domManip(arguments, function(elem) {
        if(this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },

    remove: function(selector, keepData /* Internal Use Only */ ) {
      var elem,
        elems = selector ? jQuery.filter(selector, this) : this,
        i = 0;

      for(;
        (elem = elems[i]) != null; i++) {
        if(!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }

        if(elem.parentNode) {
          if(keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }

      return this;
    },

    empty: function() {
      var elem,
        i = 0;

      for(;
        (elem = this[i]) != null; i++) {
        if(elem.nodeType === 1) {

          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false));

          // Remove any remaining nodes
          elem.textContent = "";
        }
      }

      return this;
    },

    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },

    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
          i = 0,
          l = this.length;

        if(value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }

        // See if we can take a shortcut and just use innerHTML
        if(typeof value === "string" && !rnoInnerhtml.test(value) &&
          !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

          value = value.replace(rxhtmlTag, "<$1></$2>");

          try {
            for(; i < l; i++) {
              elem = this[i] || {};

              // Remove element nodes and prevent memory leaks
              if(elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0;

            // If using innerHTML throws an exception, use the fallback method
          } catch(e) {}
        }

        if(elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },

    replaceWith: function() {
      var arg = arguments[0];

      // Make the changes, replacing each context element with the new content
      this.domManip(arguments, function(elem) {
        arg = this.parentNode;

        jQuery.cleanData(getAll(this));

        if(arg) {
          arg.replaceChild(elem, this);
        }
      });

      // Force removal if there was no new content (e.g., from empty arguments)
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },

    detach: function(selector) {
      return this.remove(selector, true);
    },

    domManip: function(args, callback) {

      // Flatten any nested arrays
      args = concat.apply([], args);

      var fragment, first, scripts, hasScripts, node, doc,
        i = 0,
        l = this.length,
        set = this,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);

      // We can't cloneNode fragments that contain checked, in WebKit
      if(isFunction ||
        (l > 1 && typeof value === "string" &&
          !support.checkClone && rchecked.test(value))) {
        return this.each(function(index) {
          var self = set.eq(index);
          if(isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }

      if(l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;

        if(fragment.childNodes.length === 1) {
          fragment = first;
        }

        if(first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;

          // Use the original fragment for the last item instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).
          for(; i < l; i++) {
            node = fragment;

            if(i !== iNoClone) {
              node = jQuery.clone(node, true, true);

              // Keep references to cloned scripts for later restoration
              if(hasScripts) {
                // Support: QtWebKit
                // jQuery.merge because push.apply(_, arraylike) throws
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }

            callback.call(this[i], node, i);
          }

          if(hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;

            // Reenable scripts
            jQuery.map(scripts, restoreScript);

            // Evaluate executable scripts on first document insertion
            for(i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if(rscriptType.test(node.type || "") &&
                !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {

                if(node.src) {
                  // Optional AJAX dependency, but won't run scripts if not present
                  if(jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }

      return this;
    }
  });

  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
        ret = [],
        insert = jQuery(selector),
        last = insert.length - 1,
        i = 0;

      for(; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);

        // Support: QtWebKit
        // .get() because push.apply(_, arraylike) throws
        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });


  var iframe,
    elemdisplay = {};

  /**
   * Retrieve the actual display of a element
   * @param {String} name nodeName of the element
   * @param {Object} doc Document object
   */
  // Called only from within defaultDisplay
  function actualDisplay(name, doc) {
    var style,
      elem = jQuery(doc.createElement(name)).appendTo(doc.body),

      // getDefaultComputedStyle might be reliably used only on attached element
      display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?

      // Use of this method is a temporary fix (more like optimization) until something better comes along,
      // since it was removed from specification and supported only in FF
      style.display : jQuery.css(elem[0], "display");

    // We don't have any data stored on the element,
    // so use "detach" method as fast way to get rid of the element
    elem.detach();

    return display;
  }

  /**
   * Try to determine the default display value of an element
   * @param {String} nodeName
   */
  function defaultDisplay(nodeName) {
    var doc = document,
      display = elemdisplay[nodeName];

    if(!display) {
      display = actualDisplay(nodeName, doc);

      // If the simple way fails, read from inside an iframe
      if(display === "none" || !display) {

        // Use the already-created iframe if possible
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
        doc = iframe[0].contentDocument;

        // Support: IE
        doc.write();
        doc.close();

        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }

      // Store the correct default display
      elemdisplay[nodeName] = display;
    }

    return display;
  }
  var rmargin = (/^margin/);

  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function(elem) {
    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    if(elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }

    return window.getComputedStyle(elem, null);
  };



  function curCSS(elem, name, computed) {
    var width, minWidth, maxWidth, ret,
      style = elem.style;

    computed = computed || getStyles(elem);

    // Support: IE9
    // getPropertyValue is only needed for .css('filter') (#12537)
    if(computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }

    if(computed) {

      if(ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }

      // Support: iOS < 6
      // A tribute to the "awesome hack by Dean Edwards"
      // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
      // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
      if(rnumnonpx.test(ret) && rmargin.test(name)) {

        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;

        // Put in the new values to get a computed value out
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;

        // Revert the changed values
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ?
      // Support: IE
      // IE returns zIndex value as an integer.
      ret + "" :
      ret;
  }


  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function() {
        if(conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        }

        // Hook needed; redefine it so that the support test is not executed again.
        return(this.get = hookFn).apply(this, arguments);
      }
    };
  }


  (function() {
    var pixelPositionVal, boxSizingReliableVal,
      docElem = document.documentElement,
      container = document.createElement("div"),
      div = document.createElement("div");

    if(!div.style) {
      return;
    }

    // Support: IE9-11+
    // Style of cloned element affects source element cloned (#8908)
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
      "position:absolute";
    container.appendChild(div);

    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText =
        // Support: Firefox<29, Android 2.3
        // Vendor-prefix box-sizing
        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
        "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
        "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);

      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";

      docElem.removeChild(container);
    }

    // Support: node.js jsdom
    // Don't assume that getComputedStyle is a property of the global object
    if(window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function() {

          // This test is executed only once but we still do memoizing
          // since we can use the boxSizingReliable pre-computing.
          // No need to check if the test was already performed, though.
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function() {
          if(boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function() {

          // Support: Android 2.3
          // Check if div with explicit width and no margin-right incorrectly
          // gets computed margin-right based on width of container. (#3333)
          // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
          // This support function is only executed once so no memoizing is needed.
          var ret,
            marginDiv = div.appendChild(document.createElement("div"));

          // Reset CSS: box-sizing; display; margin; border; padding
          marginDiv.style.cssText = div.style.cssText =
            // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
            "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);

          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);

          docElem.removeChild(container);
          div.removeChild(marginDiv);

          return ret;
        }
      });
    }
  })();


  // A method for quickly swapping in/out CSS properties to get correct calculations.
  jQuery.swap = function(elem, options, callback, args) {
    var ret, name,
      old = {};

    // Remember the old values, and insert the new ones
    for(name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.apply(elem, args || []);

    // Revert the old values
    for(name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };


  var
    // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
    rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),

    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },

    cssPrefixes = ["Webkit", "O", "Moz", "ms"];

  // Return a css property mapped to a potentially vendor prefixed property
  function vendorPropName(style, name) {

    // Shortcut for names that are not vendor prefixed
    if(name in style) {
      return name;
    }

    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
      origName = name,
      i = cssPrefixes.length;

    while(i--) {
      name = cssPrefixes[i] + capName;
      if(name in style) {
        return name;
      }
    }

    return origName;
  }

  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ?
      // Guard against undefined "subtract", e.g., when used as in cssHooks
      Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
      value;
  }

  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ?
      // If we already have the right measurement, avoid augmentation
      4 :
      // Otherwise initialize for horizontal or vertical properties
      name === "width" ? 1 : 0,

      val = 0;

    for(; i < 4; i += 2) {
      // Both box models exclude margin, so add it if we want it
      if(extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }

      if(isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if(extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }

        // At this point, extra isn't border nor margin, so remove border
        if(extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        // At this point, extra isn't content, so add padding
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

        // At this point, extra isn't content nor padding, so add border
        if(extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }

    return val;
  }

  function getWidthOrHeight(elem, name, extra) {

    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
      val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
      styles = getStyles(elem),
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

    // Some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if(val <= 0 || val == null) {
      // Fall back to computed then uncomputed css if necessary
      val = curCSS(elem, name, styles);
      if(val < 0 || val == null) {
        val = elem.style[name];
      }

      // Computed unit is not pixels. Stop here and return.
      if(rnumnonpx.test(val)) {
        return val;
      }

      // Check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style
      valueIsBorderBox = isBorderBox &&
        (support.boxSizingReliable() || val === elem.style[name]);

      // Normalize "", auto, and prepare for extra
      val = parseFloat(val) || 0;
    }

    // Use the active box-sizing model to add/subtract irrelevant styles
    return(val +
      augmentWidthOrHeight(
        elem,
        name,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles
      )
    ) + "px";
  }

  function showHide(elements, show) {
    var display, elem, hidden,
      values = [],
      index = 0,
      length = elements.length;

    for(; index < length; index++) {
      elem = elements[index];
      if(!elem.style) {
        continue;
      }

      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if(show) {
        // Reset the inline display of this element to learn if it is
        // being hidden by cascaded rules or not
        if(!values[index] && display === "none") {
          elem.style.display = "";
        }

        // Set elements which have been overridden with display: none
        // in a stylesheet to whatever the default browser style is
        // for such an element
        if(elem.style.display === "" && isHidden(elem)) {
          values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);

        if(display !== "none" || !hidden) {
          data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for(index = 0; index < length; index++) {
      elem = elements[index];
      if(!elem.style) {
        continue;
      }
      if(!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }

    return elements;
  }

  jQuery.extend({

    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function(elem, computed) {
          if(computed) {

            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },

    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
      "float": "cssFloat"
    },

    // Get and set the style property on a DOM Node
    style: function(elem, name, value, extra) {

      // Don't set styles on text and comment nodes
      if(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }

      // Make sure that we're working with the right name
      var ret, type, hooks,
        origName = jQuery.camelCase(name),
        style = elem.style;

      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

      // Gets hook for the prefixed version, then unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // Check if we're setting a value
      if(value !== undefined) {
        type = typeof value;

        // Convert "+=" or "-=" to relative numbers (#7345)
        if(type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          // Fixes bug #9237
          type = "number";
        }

        // Make sure that null and NaN values aren't set (#7116)
        if(value == null || value !== value) {
          return;
        }

        // If a number, add 'px' to the (except for certain CSS properties)
        if(type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        }

        // Support: IE9-11+
        // background-* props affect original clone's values
        if(!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }

        // If a hook was provided, use that value, otherwise just set the specified value
        if(!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }

      } else {
        // If a hook was provided get the non-computed value from there
        if(hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }

        // Otherwise just get the value from the style object
        return style[name];
      }
    },

    css: function(elem, name, extra, styles) {
      var val, num, hooks,
        origName = jQuery.camelCase(name);

      // Make sure that we're working with the right name
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

      // Try prefixed name followed by the unprefixed name
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // If a hook was provided get the computed value from there
      if(hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }

      // Otherwise, if a way to get the computed value exists, use that
      if(val === undefined) {
        val = curCSS(elem, name, styles);
      }

      // Convert "normal" to computed value
      if(val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }

      // Make numeric if forced or a qualifier was provided and val looks numeric
      if(extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });

  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if(computed) {

          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ?
            jQuery.swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, name, extra);
            }) :
            getWidthOrHeight(elem, name, extra);
        }
      },

      set: function(elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ?
          augmentWidthOrHeight(
            elem,
            name,
            extra,
            jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            styles
          ) : 0
        );
      }
    };
  });

  // Support: Android 2.3
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
    function(elem, computed) {
      if(computed) {
        return jQuery.swap(elem, { "display": "inline-block" },
          curCSS, [elem, "marginRight"]);
      }
    }
  );

  // These hooks are used by animate to expand properties
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function(value) {
        var i = 0,
          expanded = {},

          // Assumes a single number if not a string
          parts = typeof value === "string" ? value.split(" ") : [value];

        for(; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] =
            parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if(!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });

  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles, len,
          map = {},
          i = 0;

        if(jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for(; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ?
          jQuery.style(elem, name, value) :
          jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if(typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function() {
        if(isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });


  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;

  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];

      return hooks && hooks.get ?
        hooks.get(this) :
        Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];

      if(this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](
          percent, this.options.duration * percent, 0, 1, this.options.duration
        );
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;

      if(this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if(hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };

  Tween.prototype.init.prototype = Tween.prototype;

  Tween.propHooks = {
    _default: {
      get: function(tween) {
        var result;

        if(tween.elem[tween.prop] != null &&
          (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }

        // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.
        result = jQuery.css(tween.elem, tween.prop, "");
        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if(jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if(tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };

  // Support: IE9
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function(tween) {
      if(tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };

  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };

  jQuery.fx = Tween.prototype.init;

  // Back Compat <1.8 extension point
  jQuery.fx.step = {};




  var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
    rrun = /queueHooks$/,
    animationPrefilters = [defaultPrefilter],
    tweeners = {
      "*": [function(prop, value) {
        var tween = this.createTween(prop, value),
          target = tween.cur(),
          parts = rfxnum.exec(value),
          unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

          // Starting value computation is required for potential unit mismatches
          start = (jQuery.cssNumber[prop] || unit !== "px" && +target) &&
          rfxnum.exec(jQuery.css(tween.elem, prop)),
          scale = 1,
          maxIterations = 20;

        if(start && start[3] !== unit) {
          // Trust units reported by jQuery.css
          unit = unit || start[3];

          // Make sure we update the tween properties later on
          parts = parts || [];

          // Iteratively approximate from a nonzero starting point
          start = +target || 1;

          do {
            // If previous iteration zeroed out, double until we get *something*.
            // Use string for doubling so we don't accidentally see scale as unchanged below
            scale = scale || ".5";

            // Adjust and apply
            start = start / scale;
            jQuery.style(tween.elem, prop, start + unit);

            // Update scale, tolerating zero or NaN from tween.cur(),
            // break the loop if scale is unchanged or perfect, or if we've just had enough
          } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
        }

        // Update tween properties
        if(parts) {
          start = tween.start = +start || +target || 0;
          tween.unit = unit;
          // If a +=/-= token was provided, we're doing a relative animation
          tween.end = parts[1] ?
            start + (parts[1] + 1) * parts[2] :
            +parts[2];
        }

        return tween;
      }]
    };

  // Animations created synchronously will run synchronously
  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return(fxNow = jQuery.now());
  }

  // Generate parameters to create a standard animation
  function genFx(type, includeWidth) {
    var which,
      i = 0,
      attrs = { height: type };

    // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for(; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if(includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
      collection = (tweeners[prop] || []).concat(tweeners["*"]),
      index = 0,
      length = collection.length;
    for(; index < length; index++) {
      if((tween = collection[index].call(animation, prop, value))) {

        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    /* jshint validthis: true */
    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHidden(elem),
      dataShow = data_priv.get(elem, "fxshow");

    // Handle queue: false promises
    if(!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if(hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if(!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;

      anim.always(function() {
        // Ensure the complete handler is called before this completes
        anim.always(function() {
          hooks.unqueued--;
          if(!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }

    // Height/width overflow pass
    if(elem.nodeType === 1 && ("height" in props || "width" in props)) {
      // Make sure that nothing sneaks out
      // Record all 3 overflow attributes because IE9-10 do not
      // change the overflow attribute when overflowX and
      // overflowY are set to the same value
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];

      // Set display property to inline-block for height/width
      // animations on inline elements that are having width/height animated
      display = jQuery.css(elem, "display");

      // Test default display if display is currently "none"
      checkDisplay = display === "none" ?
        data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

      if(checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }

    if(opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }

    // show/hide pass
    for(prop in props) {
      value = props[prop];
      if(rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if(value === (hidden ? "hide" : "show")) {

          // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
          if(value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

        // Any non-fx value stops us from restoring the original display value
      } else {
        display = undefined;
      }
    }

    if(!jQuery.isEmptyObject(orig)) {
      if(dataShow) {
        if("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }

      // Store state if its toggle - enables .stop().toggle() to "reverse"
      if(toggle) {
        dataShow.hidden = !hidden;
      }
      if(hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;

        data_priv.remove(elem, "fxshow");
        for(prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for(prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

        if(!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if(hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }

      // If this is a noop like .hide().hide(), restore an overwritten display value
    } else if((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for(index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if(jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if(index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];
      if(hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];

        // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"
        for(index in value) {
          if(!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = animationPrefilters.length,
      deferred = jQuery.Deferred().always(function() {
        // Don't match elem in the :animated selector
        delete tick.elem;
      }),
      tick = function() {
        if(stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

        for(; index < length; index++) {
          animation.tweens[index].run(percent);
        }

        deferred.notifyWith(elem, [animation, percent, remaining]);

        if(percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      },
      animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end,
            animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index = 0,
            // If we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;
          if(stopped) {
            return this;
          }
          stopped = true;
          for(; index < length; index++) {
            animation.tweens[index].run(1);
          }

          // Resolve when we played the last frame; otherwise, reject
          if(gotoEnd) {
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }),
      props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for(; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if(result) {
        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if(jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }

    jQuery.fx.timer(
      jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      })
    );

    // attach callbacks from options
    return animation.progress(animation.opts.progress)
      .done(animation.opts.done, animation.opts.complete)
      .fail(animation.opts.fail)
      .always(animation.opts.always);
  }

  jQuery.Animation = jQuery.extend(Animation, {

    tweener: function(props, callback) {
      if(jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }

      var prop,
        index = 0,
        length = props.length;

      for(; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },

    prefilter: function(callback, prepend) {
      if(prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });

  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing ||
        jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
      opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

    // Normalize opt.queue - true/undefined/null -> "fx"
    if(opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function() {
      if(jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }

      if(opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {

      // Show any hidden elements after setting opacity to 0
      return this.filter(isHidden).css("opacity", 0).show()

        // Animate to the value specified
        .end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
        optall = jQuery.speed(speed, easing, callback),
        doAnimation = function() {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall);

          // Empty animations, or finishing resolves immediately
          if(empty || data_priv.get(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;

      return empty || optall.queue === false ?
        this.each(doAnimation) :
        this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if(typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if(clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }

      return this.each(function() {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = jQuery.timers,
          data = data_priv.get(this);

        if(index) {
          if(data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for(index in data) {
            if(data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for(index = timers.length; index--;) {
          if(timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }

        // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.
        if(dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if(type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
          data = data_priv.get(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;

        // Enable finishing flag on private data
        data.finish = true;

        // Empty the queue first
        jQuery.queue(this, type, []);

        if(hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }

        // Look for any active animations, and finish them
        for(index = timers.length; index--;) {
          if(timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }

        // Look for any animations in the old queue and finish them
        for(index = 0; index < length; index++) {
          if(queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }

        // Turn off finishing flag
        delete data.finish;
      });
    }
  });

  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ?
        cssFn.apply(this, arguments) :
        this.animate(genFx(name, true), speed, easing, callback);
    };
  });

  // Generate shortcuts for custom animations
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: { opacity: "show" },
    fadeOut: { opacity: "hide" },
    fadeToggle: { opacity: "toggle" }
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });

  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
      i = 0,
      timers = jQuery.timers;

    fxNow = jQuery.now();

    for(; i < timers.length; i++) {
      timer = timers[i];
      // Checks the timer has not already been removed
      if(!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if(!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };

  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if(timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function() {
    if(!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };

  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  };


  // Based off of the plugin by Clint Helfers, with permission.
  // http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";

    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };


  (function() {
    var input = document.createElement("input"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));

    input.type = "checkbox";

    // Support: iOS<=5.1, Android<=4.2+
    // Default value for a checkbox should be "on"
    support.checkOn = input.value !== "";

    // Support: IE<=11+
    // Must access selectedIndex to make default options select
    support.optSelected = opt.selected;

    // Support: Android<=2.3
    // Options inside disabled selects are incorrectly marked as disabled
    select.disabled = true;
    support.optDisabled = !opt.disabled;

    // Support: IE<=11+
    // An input loses its value after becoming a radio
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();


  var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle;

  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },

    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });

  jQuery.extend({
    attr: function(elem, name, value) {
      var hooks, ret,
        nType = elem.nodeType;

      // don't get/set attributes on text, comment and attribute nodes
      if(!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      // Fallback to prop when attributes are not supported
      if(typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }

      // All attributes are lowercase
      // Grab necessary hook if one is defined
      if(nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] ||
          (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }

      if(value !== undefined) {

        if(value === null) {
          jQuery.removeAttr(elem, name);

        } else if(hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;

        } else {
          elem.setAttribute(name, value + "");
          return value;
        }

      } else if(hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;

      } else {
        ret = jQuery.find.attr(elem, name);

        // Non-existent attributes return null, we normalize to undefined
        return ret == null ?
          undefined :
          ret;
      }
    },

    removeAttr: function(elem, value) {
      var name, propName,
        i = 0,
        attrNames = value && value.match(rnotwhite);

      if(attrNames && elem.nodeType === 1) {
        while((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;

          // Boolean attributes get special treatment (#10870)
          if(jQuery.expr.match.bool.test(name)) {
            // Set corresponding property to false
            elem[propName] = false;
          }

          elem.removeAttribute(name);
        }
      }
    },

    attrHooks: {
      type: {
        set: function(elem, value) {
          if(!support.radioValue && value === "radio" &&
            jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if(val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    }
  });

  // Hooks for boolean attributes
  boolHook = {
    set: function(elem, value, name) {
      if(value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function(elem, name, isXML) {
      var ret, handle;
      if(!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ?
          name.toLowerCase() :
          null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });




  var rfocusable = /^(?:input|select|textarea|button)$/i;

  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },

    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });

  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },

    prop: function(elem, name, value) {
      var ret, hooks, notxml,
        nType = elem.nodeType;

      // Don't get/set properties on text, comment and attribute nodes
      if(!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

      if(notxml) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if(value !== undefined) {
        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
          ret :
          (elem[name] = value);

      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ?
          ret :
          elem[name];
      }
    },

    propHooks: {
      tabIndex: {
        get: function(elem) {
          return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ?
            elem.tabIndex :
            -1;
        }
      }
    }
  });

  if(!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if(parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }

  jQuery.each([
    "tabIndex",
    "readOnly",
    "maxLength",
    "cellSpacing",
    "cellPadding",
    "rowSpan",
    "colSpan",
    "useMap",
    "frameBorder",
    "contentEditable"
  ], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });




  var rclass = /[\t\r\n\f]/g;

  jQuery.fn.extend({
    addClass: function(value) {
      var classes, elem, cur, clazz, j, finalValue,
        proceed = typeof value === "string" && value,
        i = 0,
        len = this.length;

      if(jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }

      if(proceed) {
        // The disjunction here is for better compressibility (see removeClass)
        classes = (value || "").match(rnotwhite) || [];

        for(; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ?
            (" " + elem.className + " ").replace(rclass, " ") :
            " "
          );

          if(cur) {
            j = 0;
            while((clazz = classes[j++])) {
              if(cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }

            // only assign if different to avoid unneeded rendering.
            finalValue = jQuery.trim(cur);
            if(elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }

      return this;
    },

    removeClass: function(value) {
      var classes, elem, cur, clazz, j, finalValue,
        proceed = arguments.length === 0 || typeof value === "string" && value,
        i = 0,
        len = this.length;

      if(jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if(proceed) {
        classes = (value || "").match(rnotwhite) || [];

        for(; i < len; i++) {
          elem = this[i];
          // This expression is here for better compressibility (see addClass)
          cur = elem.nodeType === 1 && (elem.className ?
            (" " + elem.className + " ").replace(rclass, " ") :
            ""
          );

          if(cur) {
            j = 0;
            while((clazz = classes[j++])) {
              // Remove *all* instances
              while(cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }

            // Only assign if different to avoid unneeded rendering.
            finalValue = value ? jQuery.trim(cur) : "";
            if(elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }

      return this;
    },

    toggleClass: function(value, stateVal) {
      var type = typeof value;

      if(typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if(jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }

      return this.each(function() {
        if(type === "string") {
          // Toggle individual class names
          var className,
            i = 0,
            self = jQuery(this),
            classNames = value.match(rnotwhite) || [];

          while((className = classNames[i++])) {
            // Check each className given, space separated list
            if(self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }

          // Toggle whole class name
        } else if(type === strundefined || type === "boolean") {
          if(this.className) {
            // store className if set
            data_priv.set(this, "__className__", this.className);
          }

          // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.
          this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
        }
      });
    },

    hasClass: function(selector) {
      var className = " " + selector + " ",
        i = 0,
        l = this.length;
      for(; i < l; i++) {
        if(this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }

      return false;
    }
  });




  var rreturn = /\r/g;

  jQuery.fn.extend({
    val: function(value) {
      var hooks, ret, isFunction,
        elem = this[0];

      if(!arguments.length) {
        if(elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if(hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value;

          return typeof ret === "string" ?
            // Handle most common string cases
            ret.replace(rreturn, "") :
            // Handle cases where value is null/undef or number
            ret == null ? "" : ret;
        }

        return;
      }

      isFunction = jQuery.isFunction(value);

      return this.each(function(i) {
        var val;

        if(this.nodeType !== 1) {
          return;
        }

        if(isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }

        // Treat null/undefined as ""; convert numbers to string
        if(val == null) {
          val = "";

        } else if(typeof val === "number") {
          val += "";

        } else if(jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

        // If set returns undefined, fall back to normal setting
        if(!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });

  jQuery.extend({
    valHooks: {
      option: {
        get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ?
            val :
            // Support: IE10-11+
            // option.text throws exceptions (#14686, #14858)
            jQuery.trim(jQuery.text(elem));
        }
      },
      select: {
        get: function(elem) {
          var value, option,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one" || index < 0,
            values = one ? null : [],
            max = one ? index + 1 : options.length,
            i = index < 0 ?
            max :
            one ? index : 0;

          // Loop through all the selected options
          for(; i < max; i++) {
            option = options[i];

            // IE6-9 doesn't update selected after form reset (#2551)
            if((option.selected || i === index) &&
              // Don't return options that are disabled or in a disabled optgroup
              (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
              (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

              // Get the specific value for the option
              value = jQuery(option).val();

              // We don't need an array for one selects
              if(one) {
                return value;
              }

              // Multi-Selects return an array
              values.push(value);
            }
          }

          return values;
        },

        set: function(elem, value) {
          var optionSet, option,
            options = elem.options,
            values = jQuery.makeArray(value),
            i = options.length;

          while(i--) {
            option = options[i];
            if((option.selected = jQuery.inArray(option.value, values) >= 0)) {
              optionSet = true;
            }
          }

          // Force browsers to behave consistently when non-matching value is set
          if(!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  });

  // Radios and checkboxes getter/setter
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {
      set: function(elem, value) {
        if(jQuery.isArray(value)) {
          return(elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
        }
      }
    };
    if(!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });




  // Return jQuery for attributes-only inclusion


  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {

    // Handle event binding
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ?
        this.on(name, null, data, fn) :
        this.trigger(name);
    };
  });

  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },

    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },

    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });


  var nonce = jQuery.now();

  var rquery = (/\?/);



  // Support: Android 2.3
  // Workaround failure to string-cast null input
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };


  // Cross-browser xml parsing
  jQuery.parseXML = function(data) {
    var xml, tmp;
    if(!data || typeof data !== "string") {
      return null;
    }

    // Support: IE9
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch(e) {
      xml = undefined;
    }

    if(!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };


  var
    rhash = /#.*$/,
    rts = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"),

    // Document location
    ajaxLocation = window.location.href,

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports(structure) {

    // dataTypeExpression is optional and defaults to "*"
    return function(dataTypeExpression, func) {

      if(typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

      if(jQuery.isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while((dataType = dataTypes[i++])) {
          // Prepend if requested
          if(dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);

            // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

    var inspected = {},
      seekingTransport = (structure === transports);

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if(typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if(seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend(target, src) {
    var key, deep,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for(key in src) {
      if(src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if(deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }

  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses(s, jqXHR, responses) {

    var ct, type, finalDataType, firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while(dataTypes[0] === "*") {
      dataTypes.shift();
      if(ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }

    // Check if we're dealing with a known content-type
    if(ct) {
      for(type in contents) {
        if(contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }

    // Check to see if we have a response for the expected dataType
    if(dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for(type in responses) {
        if(!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if(!firstDataType) {
          firstDataType = type;
        }
      }
      // Or just use first one
      finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if(finalDataType) {
      if(finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }

  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev,
      converters = {},
      // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if(dataTypes[1]) {
      for(conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift();

    // Convert to each sequential dataType
    while(current) {

      if(s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }

      // Apply the dataFilter if provided
      if(!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if(current) {

        // There's only work to do if current dataType is non-auto
        if(current === "*") {

          current = prev;

          // Convert response if prev dataType is non-auto and differs from current
        } else if(prev !== "*" && prev !== current) {

          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current];

          // If none found, seek a pair
          if(!conv) {
            for(conv2 in converters) {

              // If conv2 outputs current
              tmp = conv2.split(" ");
              if(tmp[1] === current) {

                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] ||
                  converters["* " + tmp[0]];
                if(conv) {
                  // Condense equivalence converters
                  if(conv === true) {
                    conv = converters[conv2];

                    // Otherwise, insert the intermediate dataType
                  } else if(converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }

          // Apply converter (if not an equivalence)
          if(conv !== true) {

            // Unless errors are allowed to bubble, catch and return them
            if(conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch(e) {
                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
              }
            }
          }
        }
      }
    }

    return { state: "success", data: response };
  }

  jQuery.extend({

    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},

    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */

      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },

      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },

      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },

      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {

        // Convert anything to text
        "* text": String,

        // Text to html (true = no transformation)
        "text html": true,

        // Evaluate text as a json expression
        "text json": jQuery.parseJSON,

        // Parse text as xml
        "text xml": jQuery.parseXML
      },

      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function(target, settings) {
      return settings ?

        // Building a settings object
        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

        // Extending ajaxSettings
        ajaxExtend(jQuery.ajaxSettings, target);
    },

    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),

    // Main method
    ajax: function(url, options) {

      // If url is an object, simulate pre-1.5 signature
      if(typeof url === "object") {
        options = url;
        url = undefined;
      }

      // Force options to be an object
      options = options || {};

      var transport,
        // URL without anti-cache param
        cacheURL,
        // Response headers
        responseHeadersString,
        responseHeaders,
        // timeout handle
        timeoutTimer,
        // Cross-domain detection vars
        parts,
        // To know if global events are to be dispatched
        fireGlobals,
        // Loop variable
        i,
        // Create the final options object
        s = jQuery.ajaxSetup({}, options),
        // Callbacks context
        callbackContext = s.context || s,
        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ?
        jQuery(callbackContext) :
        jQuery.event,
        // Deferreds
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks("once memory"),
        // Status-dependent callbacks
        statusCode = s.statusCode || {},
        // Headers (they are sent all at once)
        requestHeaders = {},
        requestHeadersNames = {},
        // The jqXHR state
        state = 0,
        // Default abort message
        strAbort = "canceled",
        // Fake xhr
        jqXHR = {
          readyState: 0,

          // Builds headers hashtable if needed
          getResponseHeader: function(key) {
            var match;
            if(state === 2) {
              if(!responseHeaders) {
                responseHeaders = {};
                while((match = rheaders.exec(responseHeadersString))) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },

          // Raw string
          getAllResponseHeaders: function() {
            return state === 2 ? responseHeadersString : null;
          },

          // Caches the header
          setRequestHeader: function(name, value) {
            var lname = name.toLowerCase();
            if(!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },

          // Overrides response content-type header
          overrideMimeType: function(type) {
            if(!state) {
              s.mimeType = type;
            }
            return this;
          },

          // Status-dependent callbacks
          statusCode: function(map) {
            var code;
            if(map) {
              if(state < 2) {
                for(code in map) {
                  // Lazy-add the new callback in a way that preserves old ones
                  statusCode[code] = [statusCode[code], map[code]];
                }
              } else {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },

          // Cancel the request
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if(transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };

      // Attach deferreds
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;

      // Remove hash character (#7531: and string promotion)
      // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available
      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "")
        .replace(rprotocol, ajaxLocParts[1] + "//");

      // Alias method option to type as per ticket #12004
      s.type = options.method || options.type || s.method || s.type;

      // Extract dataTypes list
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

      // A cross-domain request is in order when we have a protocol:host:port mismatch
      if(s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts &&
          (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
            (parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
            (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
        );
      }

      // Convert data if not already a string
      if(s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }

      // Apply prefilters
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

      // If request was aborted inside a prefilter, stop there
      if(state === 2) {
        return jqXHR;
      }

      // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
      fireGlobals = jQuery.event && s.global;

      // Watch for a new set of requests
      if(fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }

      // Uppercase the type
      s.type = s.type.toUpperCase();

      // Determine if request has content
      s.hasContent = !rnoContent.test(s.type);

      // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      cacheURL = s.url;

      // More options handling for requests with no content
      if(!s.hasContent) {

        // If data is available, append data to url
        if(s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          // #9682: remove data so that it's not used in an eventual retry
          delete s.data;
        }

        // Add anti-cache in url if needed
        if(s.cache === false) {
          s.url = rts.test(cacheURL) ?

            // If there is already a '_' parameter, set its value
            cacheURL.replace(rts, "$1_=" + nonce++) :

            // Otherwise add one to the end
            cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }

      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      if(s.ifModified) {
        if(jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if(jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }

      // Set the correct header, if data is being sent
      if(s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }

      // Set the Accepts header for the server, depending on the dataType
      jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
        s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
        s.accepts["*"]
      );

      // Check for headers option
      for(i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }

      // Allow custom headers/mimetypes and early abort
      if(s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        // Abort if not done already and return
        return jqXHR.abort();
      }

      // Aborting is no longer a cancellation
      strAbort = "abort";

      // Install callbacks on deferreds
      for(i in { success: 1, error: 1, complete: 1 }) {
        jqXHR[i](s[i]);
      }

      // Get transport
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

      // If no transport, we auto-abort
      if(!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;

        // Send global event
        if(fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        // Timeout
        if(s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch(e) {
          // Propagate exception as error if not done
          if(state < 2) {
            done(-1, e);
            // Simply rethrow otherwise
          } else {
            throw e;
          }
        }
      }

      // Callback for when everything is done
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified,
          statusText = nativeStatusText;

        // Called once
        if(state === 2) {
          return;
        }

        // State is "done" now
        state = 2;

        // Clear timeout if it exists
        if(timeoutTimer) {
          clearTimeout(timeoutTimer);
        }

        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;

        // Cache response headers
        responseHeadersString = headers || "";

        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;

        // Determine if successful
        isSuccess = status >= 200 && status < 300 || status === 304;

        // Get response data
        if(responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }

        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert(s, response, jqXHR, isSuccess);

        // If successful, handle type chaining
        if(isSuccess) {

          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if(s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if(modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if(modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }

          // if no content
          if(status === 204 || s.type === "HEAD") {
            statusText = "nocontent";

            // if not modified
          } else if(status === 304) {
            statusText = "notmodified";

            // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;
          if(status || !statusText) {
            statusText = "error";
            if(status < 0) {
              status = 0;
            }
          }
        }

        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";

        // Success/Error
        if(isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }

        // Status-dependent callbacks
        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if(fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }

        // Complete
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if(fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          // Handle the global AJAX counter
          if(!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },

    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },

    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });

  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if(jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }

      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });


  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };


  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;

      if(jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }

      if(this[0]) {

        // The elements to wrap the target around
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if(this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function() {
          var elem = this;

          while(elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },

    wrapInner: function(html) {
      if(jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function() {
        var self = jQuery(this),
          contents = self.contents();

        if(contents.length) {
          contents.wrapAll(html);

        } else {
          self.append(html);
        }
      });
    },

    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);

      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },

    unwrap: function() {
      return this.parent().each(function() {
        if(!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });


  jQuery.expr.filters.hidden = function(elem) {
    // Support: Opera <= 12.12
    // Opera reports offsetWidths and offsetHeights less than zero on some elements
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };




  var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if(jQuery.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function(i, v) {
        if(traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);

        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });

    } else if(!traditional && jQuery.type(obj) === "object") {
      // Serialize object item.
      for(name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function(a, traditional) {
    var prefix,
      s = [],
      add = function(key, value) {
        // If value is a function, invoke it and return its value
        value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
      };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if(traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if(jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      // Serialize the form elements
      jQuery.each(a, function() {
        add(this.name, this.value);
      });

    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for(prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }

    // Return the resulting serialization
    return s.join("&").replace(r20, "+");
  };

  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
          // Can add propHook for "elements" to filter or add form elements
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        })
        .filter(function() {
          var type = this.type;

          // Use .is( ":disabled" ) so that fieldset[disabled] works
          return this.name && !jQuery(this).is(":disabled") &&
            rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
            (this.checked || !rcheckableType.test(type));
        })
        .map(function(i, elem) {
          var val = jQuery(this).val();

          return val == null ?
            null :
            jQuery.isArray(val) ?
            jQuery.map(val, function(val) {
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
    }
  });


  jQuery.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest();
    } catch(e) {}
  };

  var xhrId = 0,
    xhrCallbacks = {},
    xhrSuccessStatus = {
      // file protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE9
      // #1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    },
    xhrSupported = jQuery.ajaxSettings.xhr();

  // Support: IE9
  // Open requests must be manually aborted on unload (#5280)
  // See https://support.microsoft.com/kb/2856746 for more info
  if(window.attachEvent) {
    window.attachEvent("onunload", function() {
      for(var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }

  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;

  jQuery.ajaxTransport(function(options) {
    var callback;

    // Cross domain only allowed if supported through XMLHttpRequest
    if(support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
            xhr = options.xhr(),
            id = ++xhrId;

          xhr.open(options.type, options.url, options.async, options.username, options.password);

          // Apply custom fields if provided
          if(options.xhrFields) {
            for(i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }

          // Override mime type if needed
          if(options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }

          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if(!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }

          // Set headers
          for(i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }

          // Callback
          callback = function(type) {
            return function() {
              if(callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;

                if(type === "abort") {
                  xhr.abort();
                } else if(type === "error") {
                  complete(
                    // file: protocol always yields status 0; see #8605, #14207
                    xhr.status,
                    xhr.statusText
                  );
                } else {
                  complete(
                    xhrSuccessStatus[xhr.status] || xhr.status,
                    xhr.statusText,
                    // Support: IE9
                    // Accessing binary-data responseText throws an exception
                    // (#11426)
                    typeof xhr.responseText === "string" ? {
                      text: xhr.responseText
                    } : undefined,
                    xhr.getAllResponseHeaders()
                  );
                }
              }
            };
          };

          // Listen to events
          xhr.onload = callback();
          xhr.onerror = callback("error");

          // Create the abort callback
          callback = xhrCallbacks[id] = callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch(e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if(callback) {
              throw e;
            }
          }
        },

        abort: function() {
          if(callback) {
            callback();
          }
        }
      };
    }
  });




  // Install script dataType
  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });

  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter("script", function(s) {
    if(s.cache === undefined) {
      s.cache = false;
    }
    if(s.crossDomain) {
      s.type = "GET";
    }
  });

  // Bind script tag hack transport
  jQuery.ajaxTransport("script", function(s) {
    // This transport only deals with cross domain requests
    if(s.crossDomain) {
      var script, callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on(
            "load error",
            callback = function(evt) {
              script.remove();
              callback = null;
              if(evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            }
          );
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if(callback) {
            callback();
          }
        }
      };
    }
  });




  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

    var callbackName, overwritten, responseContainer,
      jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
        "url" :
        typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
      );

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if(jsonProp || s.dataTypes[0] === "jsonp") {

      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
        s.jsonpCallback() :
        s.jsonpCallback;

      // Insert callback into url or form data
      if(jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if(s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }

      // Use data converter to retrieve json after script execution
      s.converters["script json"] = function() {
        if(!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };

      // force json dataType
      s.dataTypes[0] = "json";

      // Install callback
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };

      // Clean-up function (fires after converters)
      jqXHR.always(function() {
        // Restore preexisting value
        window[callbackName] = overwritten;

        // Save back as free
        if(s[callbackName]) {
          // make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback;

          // save the callback name for future use
          oldCallbacks.push(callbackName);
        }

        // Call if it was a function and we have a response
        if(responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      });

      // Delegate to script
      return "script";
    }
  });




  // data: string of html
  // context (optional): If specified, the fragment will be created in this context, defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function(data, context, keepScripts) {
    if(!data || typeof data !== "string") {
      return null;
    }
    if(typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;

    var parsed = rsingleTag.exec(data),
      scripts = !keepScripts && [];

    // Single tag
    if(parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = jQuery.buildFragment([data], context, scripts);

    if(scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };


  // Keep a copy of the old load method
  var _load = jQuery.fn.load;

  /**
   * Load a url into a page
   */
  jQuery.fn.load = function(url, params, callback) {
    if(typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }

    var selector, type, response,
      self = this,
      off = url.indexOf(" ");

    if(off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }

    // If it's a function
    if(jQuery.isFunction(params)) {

      // We assume that it's the callback
      callback = params;
      params = undefined;

      // Otherwise, build a param string
    } else if(params && typeof params === "object") {
      type = "POST";
    }

    // If we have elements to modify, make the request
    if(self.length > 0) {
      jQuery.ajax({
        url: url,

        // if "type" variable is undefined, then "GET" method will be used
        type: type,
        dataType: "html",
        data: params
      }).done(function(responseText) {

        // Save response for use in complete callback
        response = arguments;

        self.html(selector ?

          // If a selector was specified, locate the right elements in a dummy div
          // Exclude scripts to avoid IE 'Permission Denied' errors
          jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

          // Otherwise use the full result
          responseText);

      }).complete(callback && function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }

    return this;
  };




  // Attach a bunch of functions for handling common AJAX events
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });




  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };




  var docElem = window.document.documentElement;

  /**
   * Gets a window from an element
   */
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }

  jQuery.offset = {
    setOffset: function(elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
        position = jQuery.css(elem, "position"),
        curElem = jQuery(elem),
        props = {};

      // Set position first, in-case top/left are set even on static elem
      if(position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") &&
        (curCSSTop + curCSSLeft).indexOf("auto") > -1;

      // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed
      if(calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;

      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if(jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }

      if(options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if(options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }

      if("using" in options) {
        options.using.call(elem, props);

      } else {
        curElem.css(props);
      }
    }
  };

  jQuery.fn.extend({
    offset: function(options) {
      if(arguments.length) {
        return options === undefined ?
          this :
          this.each(function(i) {
            jQuery.offset.setOffset(this, options, i);
          });
      }

      var docElem, win,
        elem = this[0],
        box = { top: 0, left: 0 },
        doc = elem && elem.ownerDocument;

      if(!doc) {
        return;
      }

      docElem = doc.documentElement;

      // Make sure it's not a disconnected DOM node
      if(!jQuery.contains(docElem, elem)) {
        return box;
      }

      // Support: BlackBerry 5, iOS 3 (original iPhone)
      // If we don't have gBCR, just use 0,0 rather than error
      if(typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },

    position: function() {
      if(!this[0]) {
        return;
      }

      var offsetParent, offset,
        elem = this[0],
        parentOffset = { top: 0, left: 0 };

      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
      if(jQuery.css(elem, "position") === "fixed") {
        // Assume getBoundingClientRect is there when computed position is fixed
        offset = elem.getBoundingClientRect();

      } else {
        // Get *real* offsetParent
        offsetParent = this.offsetParent();

        // Get correct offsets
        offset = this.offset();
        if(!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }

        // Add offsetParent borders
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }

      // Subtract parent offsets and element margins
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },

    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent || docElem;

        while(offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || docElem;
      });
    }
  });

  // Create scrollLeft and scrollTop methods
  jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);

        if(val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if(win) {
          win.scrollTo(!top ? val : window.pageXOffset,
            top ? val : window.pageYOffset
          );

        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });

  // Support: Safari<7+, Chrome<37+
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
      function(elem, computed) {
        if(computed) {
          computed = curCSS(elem, prop);
          // If curCSS returns percentage, fallback to offset
          return rnumnonpx.test(computed) ?
            jQuery(elem).position()[prop] + "px" :
            computed;
        }
      }
    );
  });


  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
    jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function(defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
          extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

        return access(this, function(elem, type, value) {
          var doc;

          if(jQuery.isWindow(elem)) {
            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
            // isn't a whole lot we can do. See pull request at this URL for discussion:
            // https://github.com/jquery/jquery/pull/764
            return elem.document.documentElement["client" + name];
          }

          // Get document width or height
          if(elem.nodeType === 9) {
            doc = elem.documentElement;

            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest
            return Math.max(
              elem.body["scroll" + name], doc["scroll" + name],
              elem.body["offset" + name], doc["offset" + name],
              doc["client" + name]
            );
          }

          return value === undefined ?
            // Get width or height on the element, requesting but not forcing parseFloat
            jQuery.css(elem, type, extra) :

            // Set width or height on the element
            jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });


  // The number of elements contained in the matched element set
  jQuery.fn.size = function() {
    return this.length;
  };

  jQuery.fn.andSelf = jQuery.fn.addBack;




  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.

  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

  if(typeof define === "function" && define.amd) {
    define("jquery", [], function() {
      return jQuery;
    });
  }




  var
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,

    // Map over the $ in case of overwrite
    _$ = window.$;

  jQuery.noConflict = function(deep) {
    if(window.$ === jQuery) {
      window.$ = _$;
    }

    if(deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if(typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }




  return jQuery;

}));
/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2014 Rico Sta. Cruz
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */

/* jshint expr: true */

;
(function(root, factory) {

  if(typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else if(typeof exports === 'object') {
    module.exports = factory(require('jquery'));
  } else {
    factory(root.jQuery);
  }

}(this, function($) {

  $.transit = {
    version: "0.9.12",

    // Map of $.css() keys to values for 'transitionProperty'.
    // See https://developer.mozilla.org/en/CSS/CSS_transitions#Properties_that_can_be_animated
    propertyMap: {
      marginLeft: 'margin',
      marginRight: 'margin',
      marginBottom: 'margin',
      marginTop: 'margin',
      paddingLeft: 'padding',
      paddingRight: 'padding',
      paddingBottom: 'padding',
      paddingTop: 'padding'
    },

    // Will simply transition "instantly" if false
    enabled: true,

    // Set this to false if you don't want to use the transition end property.
    useTransitionEnd: false
  };

  var div = document.createElement('div');
  var support = {};

  // Helper function to get the proper vendor property name.
  // (`transition` => `WebkitTransition`)
  function getVendorPropertyName(prop) {
    // Handle unprefixed versions (FF16+, for example)
    if(prop in div.style) return prop;

    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

    for(var i = 0; i < prefixes.length; ++i) {
      var vendorProp = prefixes[i] + prop_;
      if(vendorProp in div.style) { return vendorProp; }
    }
  }

  // Helper function to check if transform3D is supported.
  // Should return true for Webkits and Firefox 10+.
  function checkTransform3dSupport() {
    div.style[support.transform] = '';
    div.style[support.transform] = 'rotateY(90deg)';
    return div.style[support.transform] !== '';
  }

  var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

  // Check for the browser's transitions support.
  support.transition = getVendorPropertyName('transition');
  support.transitionDelay = getVendorPropertyName('transitionDelay');
  support.transform = getVendorPropertyName('transform');
  support.transformOrigin = getVendorPropertyName('transformOrigin');
  support.filter = getVendorPropertyName('Filter');
  support.transform3d = checkTransform3dSupport();

  var eventNames = {
    'transition': 'transitionend',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd',
    'WebkitTransition': 'webkitTransitionEnd',
    'msTransition': 'MSTransitionEnd'
  };

  // Detect the 'transitionend' event needed.
  var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;

  // Populate jQuery's `$.support` with the vendor prefixes we know.
  // As per [jQuery's cssHooks documentation](http://api.jquery.com/jQuery.cssHooks/),
  // we set $.support.transition to a string of the actual property name used.
  for(var key in support) {
    if(support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {
      $.support[key] = support[key];
    }
  }

  // Avoid memory leak in IE.
  div = null;

  // ## $.cssEase
  // List of easing aliases that you can use with `$.fn.transition`.
  $.cssEase = {
    '_default': 'ease',
    'in': 'ease-in',
    'out': 'ease-out',
    'in-out': 'ease-in-out',
    'snap': 'cubic-bezier(0,1,.5,1)',
    // Penner equations
    'easeInCubic': 'cubic-bezier(.550,.055,.675,.190)',
    'easeOutCubic': 'cubic-bezier(.215,.61,.355,1)',
    'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
    'easeInCirc': 'cubic-bezier(.6,.04,.98,.335)',
    'easeOutCirc': 'cubic-bezier(.075,.82,.165,1)',
    'easeInOutCirc': 'cubic-bezier(.785,.135,.15,.86)',
    'easeInExpo': 'cubic-bezier(.95,.05,.795,.035)',
    'easeOutExpo': 'cubic-bezier(.19,1,.22,1)',
    'easeInOutExpo': 'cubic-bezier(1,0,0,1)',
    'easeInQuad': 'cubic-bezier(.55,.085,.68,.53)',
    'easeOutQuad': 'cubic-bezier(.25,.46,.45,.94)',
    'easeInOutQuad': 'cubic-bezier(.455,.03,.515,.955)',
    'easeInQuart': 'cubic-bezier(.895,.03,.685,.22)',
    'easeOutQuart': 'cubic-bezier(.165,.84,.44,1)',
    'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
    'easeInQuint': 'cubic-bezier(.755,.05,.855,.06)',
    'easeOutQuint': 'cubic-bezier(.23,1,.32,1)',
    'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
    'easeInSine': 'cubic-bezier(.47,0,.745,.715)',
    'easeOutSine': 'cubic-bezier(.39,.575,.565,1)',
    'easeInOutSine': 'cubic-bezier(.445,.05,.55,.95)',
    'easeInBack': 'cubic-bezier(.6,-.28,.735,.045)',
    'easeOutBack': 'cubic-bezier(.175, .885,.32,1.275)',
    'easeInOutBack': 'cubic-bezier(.68,-.55,.265,1.55)'
  };

  // ## 'transform' CSS hook
  // Allows you to use the `transform` property in CSS.
  //
  //     $("#hello").css({ transform: "rotate(90deg)" });
  //
  //     $("#hello").css('transform');
  //     //=> { rotate: '90deg' }
  //
  $.cssHooks['transit:transform'] = {
    // The getter returns a `Transform` object.
    get: function(elem) {
      return $(elem).data('transform') || new Transform();
    },

    // The setter accepts a `Transform` object or a string.
    set: function(elem, v) {
      var value = v;

      if(!(value instanceof Transform)) {
        value = new Transform(value);
      }

      // We've seen the 3D version of Scale() not work in Chrome when the
      // element being scaled extends outside of the viewport.  Thus, we're
      // forcing Chrome to not use the 3d transforms as well.  Not sure if
      // translate is affectede, but not risking it.  Detection code from
      // http://davidwalsh.name/detecting-google-chrome-javascript
      if(support.transform === 'WebkitTransform' && !isChrome) {
        elem.style[support.transform] = value.toString(true);
      } else {
        elem.style[support.transform] = value.toString();
      }

      $(elem).data('transform', value);
    }
  };

  // Add a CSS hook for `.css({ transform: '...' })`.
  // In jQuery 1.8+, this will intentionally override the default `transform`
  // CSS hook so it'll play well with Transit. (see issue #62)
  $.cssHooks.transform = {
    set: $.cssHooks['transit:transform'].set
  };

  // ## 'filter' CSS hook
  // Allows you to use the `filter` property in CSS.
  //
  //     $("#hello").css({ filter: 'blur(10px)' });
  //
  $.cssHooks.filter = {
    get: function(elem) {
      return elem.style[support.filter];
    },
    set: function(elem, value) {
      elem.style[support.filter] = value;
    }
  };

  // jQuery 1.8+ supports prefix-free transitions, so these polyfills will not
  // be necessary.
  if($.fn.jquery < "1.8") {
    // ## 'transformOrigin' CSS hook
    // Allows the use for `transformOrigin` to define where scaling and rotation
    // is pivoted.
    //
    //     $("#hello").css({ transformOrigin: '0 0' });
    //
    $.cssHooks.transformOrigin = {
      get: function(elem) {
        return elem.style[support.transformOrigin];
      },
      set: function(elem, value) {
        elem.style[support.transformOrigin] = value;
      }
    };

    // ## 'transition' CSS hook
    // Allows you to use the `transition` property in CSS.
    //
    //     $("#hello").css({ transition: 'all 0 ease 0' });
    //
    $.cssHooks.transition = {
      get: function(elem) {
        return elem.style[support.transition];
      },
      set: function(elem, value) {
        elem.style[support.transition] = value;
      }
    };
  }

  // ## Other CSS hooks
  // Allows you to rotate, scale and translate.
  registerCssHook('scale');
  registerCssHook('scaleX');
  registerCssHook('scaleY');
  registerCssHook('translate');
  registerCssHook('rotate');
  registerCssHook('rotateX');
  registerCssHook('rotateY');
  registerCssHook('rotate3d');
  registerCssHook('perspective');
  registerCssHook('skewX');
  registerCssHook('skewY');
  registerCssHook('x', true);
  registerCssHook('y', true);

  // ## Transform class
  // This is the main class of a transformation property that powers
  // `$.fn.css({ transform: '...' })`.
  //
  // This is, in essence, a dictionary object with key/values as `-transform`
  // properties.
  //
  //     var t = new Transform("rotate(90) scale(4)");
  //
  //     t.rotate             //=> "90deg"
  //     t.scale              //=> "4,4"
  //
  // Setters are accounted for.
  //
  //     t.set('rotate', 4)
  //     t.rotate             //=> "4deg"
  //
  // Convert it to a CSS string using the `toString()` and `toString(true)` (for WebKit)
  // functions.
  //
  //     t.toString()         //=> "rotate(90deg) scale(4,4)"
  //     t.toString(true)     //=> "rotate(90deg) scale3d(4,4,0)" (WebKit version)
  //
  function Transform(str) {
    if(typeof str === 'string') { this.parse(str); }
    return this;
  }

  Transform.prototype = {
    // ### setFromString()
    // Sets a property from a string.
    //
    //     t.setFromString('scale', '2,4');
    //     // Same as set('scale', '2', '4');
    //
    setFromString: function(prop, val) {
      var args =
        (typeof val === 'string') ? val.split(',') :
        (val.constructor === Array) ? val : [val];

      args.unshift(prop);

      Transform.prototype.set.apply(this, args);
    },

    // ### set()
    // Sets a property.
    //
    //     t.set('scale', 2, 4);
    //
    set: function(prop) {
      var args = Array.prototype.slice.apply(arguments, [1]);
      if(this.setter[prop]) {
        this.setter[prop].apply(this, args);
      } else {
        this[prop] = args.join(',');
      }
    },

    get: function(prop) {
      if(this.getter[prop]) {
        return this.getter[prop].apply(this);
      } else {
        return this[prop] || 0;
      }
    },

    setter: {
      // ### rotate
      //
      //     .css({ rotate: 30 })
      //     .css({ rotate: "30" })
      //     .css({ rotate: "30deg" })
      //     .css({ rotate: "30deg" })
      //
      rotate: function(theta) {
        this.rotate = unit(theta, 'deg');
      },

      rotateX: function(theta) {
        this.rotateX = unit(theta, 'deg');
      },

      rotateY: function(theta) {
        this.rotateY = unit(theta, 'deg');
      },

      // ### scale
      //
      //     .css({ scale: 9 })      //=> "scale(9,9)"
      //     .css({ scale: '3,2' })  //=> "scale(3,2)"
      //
      scale: function(x, y) {
        if(y === undefined) { y = x; }
        this.scale = x + "," + y;
      },

      // ### skewX + skewY
      skewX: function(x) {
        this.skewX = unit(x, 'deg');
      },

      skewY: function(y) {
        this.skewY = unit(y, 'deg');
      },

      // ### perspectvie
      perspective: function(dist) {
        this.perspective = unit(dist, 'px');
      },

      // ### x / y
      // Translations. Notice how this keeps the other value.
      //
      //     .css({ x: 4 })       //=> "translate(4px, 0)"
      //     .css({ y: 10 })      //=> "translate(4px, 10px)"
      //
      x: function(x) {
        this.set('translate', x, null);
      },

      y: function(y) {
        this.set('translate', null, y);
      },

      // ### translate
      // Notice how this keeps the other value.
      //
      //     .css({ translate: '2, 5' })    //=> "translate(2px, 5px)"
      //
      translate: function(x, y) {
        if(this._translateX === undefined) { this._translateX = 0; }
        if(this._translateY === undefined) { this._translateY = 0; }

        if(x !== null && x !== undefined) { this._translateX = unit(x, 'px'); }
        if(y !== null && y !== undefined) { this._translateY = unit(y, 'px'); }

        this.translate = this._translateX + "," + this._translateY;
      }
    },

    getter: {
      x: function() {
        return this._translateX || 0;
      },

      y: function() {
        return this._translateY || 0;
      },

      scale: function() {
        var s = (this.scale || "1,1").split(',');
        if(s[0]) { s[0] = parseFloat(s[0]); }
        if(s[1]) { s[1] = parseFloat(s[1]); }

        // "2.5,2.5" => 2.5
        // "2.5,1" => [2.5,1]
        return(s[0] === s[1]) ? s[0] : s;
      },

      rotate3d: function() {
        var s = (this.rotate3d || "0,0,0,0deg").split(',');
        for(var i = 0; i <= 3; ++i) {
          if(s[i]) { s[i] = parseFloat(s[i]); }
        }
        if(s[3]) { s[3] = unit(s[3], 'deg'); }

        return s;
      }
    },

    // ### parse()
    // Parses from a string. Called on constructor.
    parse: function(str) {
      var self = this;
      str.replace(/([a-zA-Z0-9]+)\((.*?)\)/g, function(x, prop, val) {
        self.setFromString(prop, val);
      });
    },

    // ### toString()
    // Converts to a `transition` CSS property string. If `use3d` is given,
    // it converts to a `-webkit-transition` CSS property string instead.
    toString: function(use3d) {
      var re = [];

      for(var i in this) {
        if(this.hasOwnProperty(i)) {
          // Don't use 3D transformations if the browser can't support it.
          if((!support.transform3d) && (
              (i === 'rotateX') ||
              (i === 'rotateY') ||
              (i === 'perspective') ||
              (i === 'transformOrigin'))) { continue; }

          if(i[0] !== '_') {
            if(use3d && (i === 'scale')) {
              re.push(i + "3d(" + this[i] + ",1)");
            } else if(use3d && (i === 'translate')) {
              re.push(i + "3d(" + this[i] + ",0)");
            } else {
              re.push(i + "(" + this[i] + ")");
            }
          }
        }
      }

      return re.join(" ");
    }
  };

  function callOrQueue(self, queue, fn) {
    if(queue === true) {
      self.queue(fn);
    } else if(queue) {
      self.queue(queue, fn);
    } else {
      self.each(function() {
        fn.call(this);
      });
    }
  }

  // ### getProperties(dict)
  // Returns properties (for `transition-property`) for dictionary `props`. The
  // value of `props` is what you would expect in `$.css(...)`.
  function getProperties(props) {
    var re = [];

    $.each(props, function(key) {
      key = $.camelCase(key); // Convert "text-align" => "textAlign"
      key = $.transit.propertyMap[key] || $.cssProps[key] || key;
      key = uncamel(key); // Convert back to dasherized

      // Get vendor specify propertie
      if(support[key])
        key = uncamel(support[key]);

      if($.inArray(key, re) === -1) { re.push(key); }
    });

    return re;
  }

  // ### getTransition()
  // Returns the transition string to be used for the `transition` CSS property.
  //
  // Example:
  //
  //     getTransition({ opacity: 1, rotate: 30 }, 500, 'ease');
  //     //=> 'opacity 500ms ease, -webkit-transform 500ms ease'
  //
  function getTransition(properties, duration, easing, delay) {
    // Get the CSS properties needed.
    var props = getProperties(properties);

    // Account for aliases (`in` => `ease-in`).
    if($.cssEase[easing]) { easing = $.cssEase[easing]; }

    // Build the duration/easing/delay attributes for it.
    var attribs = '' + toMS(duration) + ' ' + easing;
    if(parseInt(delay, 10) > 0) { attribs += ' ' + toMS(delay); }

    // For more properties, add them this way:
    // "margin 200ms ease, padding 200ms ease, ..."
    var transitions = [];
    $.each(props, function(i, name) {
      transitions.push(name + ' ' + attribs);
    });

    return transitions.join(', ');
  }

  // ## $.fn.transition
  // Works like $.fn.animate(), but uses CSS transitions.
  //
  //     $("...").transition({ opacity: 0.1, scale: 0.3 });
  //
  //     // Specific duration
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500);
  //
  //     // With duration and easing
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in');
  //
  //     // With callback
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, function() { ... });
  //
  //     // With everything
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in', function() { ... });
  //
  //     // Alternate syntax
  //     $("...").transition({
  //       opacity: 0.1,
  //       duration: 200,
  //       delay: 40,
  //       easing: 'in',
  //       complete: function() { /* ... */ }
  //      });
  //
  $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {
    var self = this;
    var delay = 0;
    var queue = true;

    var theseProperties = $.extend(true, {}, properties);

    // Account for `.transition(properties, callback)`.
    if(typeof duration === 'function') {
      callback = duration;
      duration = undefined;
    }

    // Account for `.transition(properties, options)`.
    if(typeof duration === 'object') {
      easing = duration.easing;
      delay = duration.delay || 0;
      queue = typeof duration.queue === "undefined" ? true : duration.queue;
      callback = duration.complete;
      duration = duration.duration;
    }

    // Account for `.transition(properties, duration, callback)`.
    if(typeof easing === 'function') {
      callback = easing;
      easing = undefined;
    }

    // Alternate syntax.
    if(typeof theseProperties.easing !== 'undefined') {
      easing = theseProperties.easing;
      delete theseProperties.easing;
    }

    if(typeof theseProperties.duration !== 'undefined') {
      duration = theseProperties.duration;
      delete theseProperties.duration;
    }

    if(typeof theseProperties.complete !== 'undefined') {
      callback = theseProperties.complete;
      delete theseProperties.complete;
    }

    if(typeof theseProperties.queue !== 'undefined') {
      queue = theseProperties.queue;
      delete theseProperties.queue;
    }

    if(typeof theseProperties.delay !== 'undefined') {
      delay = theseProperties.delay;
      delete theseProperties.delay;
    }

    // Set defaults. (`400` duration, `ease` easing)
    if(typeof duration === 'undefined') { duration = $.fx.speeds._default; }
    if(typeof easing === 'undefined') { easing = $.cssEase._default; }

    duration = toMS(duration);

    // Build the `transition` property.
    var transitionValue = getTransition(theseProperties, duration, easing, delay);

    // Compute delay until callback.
    // If this becomes 0, don't bother setting the transition property.
    var work = $.transit.enabled && support.transition;
    var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;

    // If there's nothing to do...
    if(i === 0) {
      var fn = function(next) {
        self.css(theseProperties);
        if(callback) { callback.apply(self); }
        if(next) { next(); }
      };

      callOrQueue(self, queue, fn);
      return self;
    }

    // Save the old transitions of each element so we can restore it later.
    var oldTransitions = {};

    var run = function(nextCall) {
      var bound = false;

      // Prepare the callback.
      var cb = function() {
        if(bound) { self.unbind(transitionEnd, cb); }

        if(i > 0) {
          self.each(function() {
            this.style[support.transition] = (oldTransitions[this] || null);
          });
        }

        if(typeof callback === 'function') { callback.apply(self); }
        if(typeof nextCall === 'function') { nextCall(); }
      };

      if((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {
        // Use the 'transitionend' event if it's available.
        bound = true;
        self.bind(transitionEnd, cb);
      } else {
        // Fallback to timers if the 'transitionend' event isn't supported.
        window.setTimeout(cb, i);
      }

      // Apply transitions.
      self.each(function() {
        if(i > 0) {
          this.style[support.transition] = transitionValue;
        }
        $(this).css(theseProperties);
      });
    };

    // Defer running. This allows the browser to paint any pending CSS it hasn't
    // painted yet before doing the transitions.
    var deferredRun = function(next) {
      this.offsetWidth = this.offsetWidth; // force a repaint
      run(next);
    };

    // Use jQuery's fx queue.
    callOrQueue(self, queue, deferredRun);

    // Chainability.
    return this;
  };

  function registerCssHook(prop, isPixels) {
    // For certain properties, the 'px' should not be implied.
    if(!isPixels) { $.cssNumber[prop] = true; }

    $.transit.propertyMap[prop] = support.transform;

    $.cssHooks[prop] = {
      get: function(elem) {
        var t = $(elem).css('transit:transform');
        return t.get(prop);
      },

      set: function(elem, value) {
        var t = $(elem).css('transit:transform');
        t.setFromString(prop, value);

        $(elem).css({ 'transit:transform': t });
      }
    };

  }

  // ### uncamel(str)
  // Converts a camelcase string to a dasherized string.
  // (`marginLeft` => `margin-left`)
  function uncamel(str) {
    return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
  }

  // ### unit(number, unit)
  // Ensures that number `number` has a unit. If no unit is found, assume the
  // default is `unit`.
  //
  //     unit(2, 'px')          //=> "2px"
  //     unit("30deg", 'rad')   //=> "30deg"
  //
  function unit(i, units) {
    if((typeof i === "string") && (!i.match(/^[\-0-9\.]+$/))) {
      return i;
    } else {
      return "" + i + units;
    }
  }

  // ### toMS(duration)
  // Converts given `duration` to a millisecond string.
  //
  // toMS('fast') => $.fx.speeds[i] => "200ms"
  // toMS('normal') //=> $.fx.speeds._default => "400ms"
  // toMS(10) //=> '10ms'
  // toMS('100ms') //=> '100ms'  
  //
  function toMS(duration) {
    var i = duration;

    // Allow string durations like 'fast' and 'slow', without overriding numeric values.
    if(typeof i === 'string' && (!i.match(/^[\-0-9\.]+/))) { i = $.fx.speeds[i] || $.fx.speeds._default; }

    return unit(i, 'ms');
  }

  // Export some functions for testable-ness.
  $.transit.getTransitionValue = getTransition;

  return $;
}));
//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype,
    ObjProto = Object.prototype,
    FuncProto = Function.prototype;

  //use the faster Date.now if available.
  var getTime = (Date.now || function() {
    return new Date().getTime();
  });

  // Create quick reference variables for speed access to core prototypes.
  var
    push = ArrayProto.push,
    slice = ArrayProto.slice,
    concat = ArrayProto.concat,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach = ArrayProto.forEach,
    nativeMap = ArrayProto.map,
    nativeReduce = ArrayProto.reduce,
    nativeReduceRight = ArrayProto.reduceRight,
    nativeFilter = ArrayProto.filter,
    nativeEvery = ArrayProto.every,
    nativeSome = ArrayProto.some,
    nativeIndexOf = ArrayProto.indexOf,
    nativeLastIndexOf = ArrayProto.lastIndexOf,
    nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeBind = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if(obj instanceof _) return obj;
    if(!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if(typeof exports !== 'undefined') {
    if(typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if(obj == null) return;
    if(nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if(obj.length === +obj.length) {
      for(var i = 0, length = obj.length; i < length; i++) {
        if(iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for(var i = 0, length = keys.length; i < length; i++) {
        if(iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if(obj == null) return results;
    if(nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if(obj == null) obj = [];
    if(nativeReduce && obj.reduce === nativeReduce) {
      if(context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if(!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if(!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if(obj == null) obj = [];
    if(nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if(context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if(length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if(!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if(!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if(iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if(obj == null) return results;
    if(nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if(iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if(obj == null) return result;
    if(nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if(!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if(obj == null) return result;
    if(nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if(result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if(obj == null) return false;
    if(nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return(isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value) { return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if(_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for(var key in attrs) {
        if(attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if(!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if(!iterator && _.isEmpty(obj)) return -Infinity;
    var result = { computed: -Infinity, value: -Infinity };
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = { value: value, computed: computed });
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if(!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if(!iterator && _.isEmpty(obj)) return Infinity;
    var result = { computed: Infinity, value: Infinity };
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = { value: value, computed: computed });
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if(n == null || guard) {
      if(obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj) { return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = value == null ? _.identity : lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if(a !== b) {
        if(a > b || a === void 0) return 1;
        if(a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0,
      high = array.length;
    while(low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if(!obj) return [];
    if(_.isArray(obj)) return slice.call(obj);
    if(obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if(obj == null) return 0;
    return(obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if(array == null) return void 0;
    return(n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if(array == null) return void 0;
    if((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if(shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if(_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if(_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if(isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value) { return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for(var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if(list == null) return {};
    var result = {};
    for(var i = 0, length = list.length; i < length; i++) {
      if(values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if(array == null) return -1;
    var i = 0,
      length = array.length;
    if(isSorted) {
      if(typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if(nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for(; i < length; i++)
      if(array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if(array == null) return -1;
    var hasIndex = from != null;
    if(nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while(i--)
      if(array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if(arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function() {};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if(nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if(!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if(!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if(Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if(funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function() { return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : getTime();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = getTime();
      if(!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if(remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if(!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = getTime();
      var later = function() {
        var last = getTime() - timestamp;
        if(last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if(!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      };
      var callNow = immediate && !timeout;
      if(!timeout) {
        timeout = setTimeout(later, wait);
      }
      if(callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false,
      memo;
    return function() {
      if(ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for(var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if(--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if(obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for(var key in obj)
      if(_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for(var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for(var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for(var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for(var key in obj) {
      if(_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if(source) {
        for(var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if(key in obj) copy[key] = obj[key];
    });
    return copy;
  };

  // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for(var key in obj) {
      if(!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if(source) {
        for(var prop in source) {
          if(obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if(!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if(a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if(a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if(a instanceof _) a = a._wrapped;
    if(b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if(className != toString.call(b)) return false;
    switch(className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
        // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase;
    }
    if(typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while(length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if(aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor,
      bCtor = b.constructor;
    if(aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
        _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0,
      result = true;
    // Recursively compare objects and arrays.
    if(className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if(result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while(size--) {
          if(!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for(var key in a) {
        if(_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if(!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if(result) {
        for(key in b) {
          if(_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if(obj == null) return true;
    if(_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for(var key in obj)
      if(_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if(!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if(typeof(/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for(var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if(max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if(string == null) return '';
      return('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if(object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if(escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if(interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if(evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if(!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch(e) {
      e.source = source;
      throw e;
    }

    if(data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);
/*! iScroll v5.1.1 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license

代码修改
431 this._execEvent('beforeScrollStart',point); 增加point传递
578 this._execEvent('scrollCancel',point);
632 增加代码接口
    this._execEvent('momentum', newY, time, easing);
428 增加代码
    中断
    this._execEvent('intermit', e);

*/
;
(function (window, document, Math) {
  var rAF = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (callback) { window.setTimeout(callback, 1000 / 60); };

  var utils = (function () {
    var me = {};

    var _elementStyle = document.createElement('div').style;
    var _vendor = (function () {
      var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
        transform,
        i = 0,
        l = vendors.length;

      for (; i < l; i++) {
        transform = vendors[i] + 'ransform';
        if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
      }

      return false;
    })();

    function _prefixStyle(style) {
      if (_vendor === false) return false;
      if (_vendor === '') return style;
      return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
    }

    me.getTime = Date.now || function getTime() {
      return new Date().getTime();
    };

    me.extend = function (target, obj) {
      for (var i in obj) {
        target[i] = obj[i];
      }
    };

    me.addEvent = function (el, type, fn, capture) {
      el.addEventListener(type, fn, !!capture);
    };

    me.removeEvent = function (el, type, fn, capture) {
      el.removeEventListener(type, fn, !!capture);
    };

    me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
      var distance = current - start,
        speed = Math.abs(distance) / time,
        destination,
        duration;

      deceleration = deceleration === undefined ? 0.0006 : deceleration;

      destination = current + (speed * speed) / (2 * deceleration) * (distance < 0 ? -1 : 1);
      duration = speed / deceleration;

      if (destination < lowerMargin) {
        destination = wrapperSize ? lowerMargin - (wrapperSize / 2.5 * (speed / 8)) : lowerMargin;
        distance = Math.abs(destination - current);
        duration = distance / speed;
      } else if (destination > 0) {
        destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
        distance = Math.abs(current) + destination;
        duration = distance / speed;
      }

      return {
        destination: Math.round(destination),
        duration: duration
      };
    };

    var _transform = _prefixStyle('transform');

    me.extend(me, {
      hasTransform: _transform !== false,
      hasPerspective: _prefixStyle('perspective') in _elementStyle,
      hasTouch: 'ontouchstart' in window,
      hasPointer: navigator.msPointerEnabled,
      hasTransition: _prefixStyle('transition') in _elementStyle
    });

    // This should find all Android browsers lower than build 535.19 (both stock browser and webview)
    me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !(/Chrome\/\d/.test(window.navigator.appVersion));

    me.extend(me.style = {}, {
      transform: _transform,
      transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
      transitionDuration: _prefixStyle('transitionDuration'),
      transitionDelay: _prefixStyle('transitionDelay'),
      transformOrigin: _prefixStyle('transformOrigin')
    });

    me.hasClass = function (e, c) {
      var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
      return re.test(e.className);
    };

    me.addClass = function (e, c) {
      if (me.hasClass(e, c)) {
        return;
      }

      var newclass = e.className.split(' ');
      newclass.push(c);
      e.className = newclass.join(' ');
    };

    me.removeClass = function (e, c) {
      if (!me.hasClass(e, c)) {
        return;
      }

      var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
      e.className = e.className.replace(re, ' ');
    };

    me.offset = function (el) {
      var left = -el.offsetLeft,
        top = -el.offsetTop;

      // jshint -W084
      while (el = el.offsetParent) {
        left -= el.offsetLeft;
        top -= el.offsetTop;
      }
      // jshint +W084

      return {
        left: left,
        top: top
      };
    };

    me.preventDefaultException = function (el, exceptions) {
      for (var i in exceptions) {
        if (exceptions[i].test(el[i])) {
          return true;
        }
      }

      return false;
    };

    me.extend(me.eventType = {}, {
      touchstart: 1,
      touchmove: 1,
      touchend: 1,

      mousedown: 2,
      mousemove: 2,
      mouseup: 2,

      MSPointerDown: 3,
      MSPointerMove: 3,
      MSPointerUp: 3
    });

    me.extend(me.ease = {}, {
      quadratic: {
        style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
        fn: function (k) {
          return k * (2 - k);
        }
      },
      circular: {
        style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
        fn: function (k) {
          return Math.sqrt(1 - (--k * k));
        }
      },
      back: {
        style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
        fn: function (k) {
          var b = 4;
          return (k = k - 1) * k * ((b + 1) * k + b) + 1;
        }
      },
      bounce: {
        style: '',
        fn: function (k) {
          if ((k /= 1) < (1 / 2.75)) {
            return 7.5625 * k * k;
          } else if (k < (2 / 2.75)) {
            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
          } else if (k < (2.5 / 2.75)) {
            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
          } else {
            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
          }
        }
      },
      elastic: {
        style: '',
        fn: function (k) {
          var f = 0.22,
            e = 0.4;

          if (k === 0) {
            return 0;
          }
          if (k == 1) {
            return 1;
          }

          return (e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1);
        }
      }
    });

    me.tap = function (e, eventName) {
      var ev = document.createEvent('Event');
      ev.initEvent(eventName, true, true);
      ev.pageX = e.pageX;
      ev.pageY = e.pageY;
      e.target.dispatchEvent(ev);
    };

    me.click = function (e) {
      var target = e.target,
        ev;

      if (!(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName)) {
        ev = document.createEvent('MouseEvents');
        ev.initMouseEvent('click', true, true, e.view, 1,
          target.screenX, target.screenY, target.clientX, target.clientY,
          e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
          0, null);

        ev._constructed = true;
        target.dispatchEvent(ev);
      }
    };

    return me;
  })();

  function IScroll(el, options) {
    this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
    this.scroller = this.wrapper.children[0];
    this.scrollerStyle = this.scroller.style; // cache style for better performance

    this.options = {

      resizeScrollbars: true,

      mouseWheelSpeed: 20,

      snapThreshold: 0.334,

      // INSERT POINT: OPTIONS

      startX: 0,
      startY: 0,
      scrollY: true,
      directionLockThreshold: 5,
      momentum: true,

      bounce: true,
      bounceTime: 600,
      bounceEasing: '',

      preventDefault: true,
      preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|TSPAN)$/ },

      HWCompositing: true,
      useTransition: true,
      useTransform: true
    };

    for (var i in options) {
      this.options[i] = options[i];
    }

    // Normalize options
    this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

    this.options.useTransition = utils.hasTransition && this.options.useTransition;
    this.options.useTransform = utils.hasTransform && this.options.useTransform;

    this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
    this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

    // If you want eventPassthrough I have to lock one of the axes
    this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
    this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

    // With eventPassthrough we also need lockDirection mechanism
    this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
    this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

    this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

    this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

    if (this.options.tap === true) {
      this.options.tap = 'tap';
    }

    if (this.options.shrinkScrollbars == 'scale') {
      this.options.useTransition = false;
    }

    this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

    if (this.options.probeType == 3) {
      this.options.useTransition = false;
    }

    // INSERT POINT: NORMALIZATION

    // Some defaults
    this.x = 0;
    this.y = 0;
    this.directionX = 0;
    this.directionY = 0;
    this._events = {};

    // INSERT POINT: DEFAULTS

    this._init();
    this.refresh();

    this.scrollTo(this.options.startX, this.options.startY);
    this.enable();
  }

  IScroll.prototype = {
    version: '5.1.1',

    _init: function () {
      this._initEvents();

      if (this.options.scrollbars || this.options.indicators) {
        this._initIndicators();
      }

      if (this.options.mouseWheel) {
        this._initWheel();
      }

      if (this.options.snap) {
        this._initSnap();
      }

      if (this.options.keyBindings) {
        this._initKeys();
      }

      // INSERT POINT: _init

    },

    destroy: function () {
      this._initEvents(true);

      this._execEvent('destroy');
    },

    _transitionEnd: function (e) {
      if (e.target != this.scroller || !this.isInTransition) {
        return;
      }

      this._transitionTime();
      if (!this.resetPosition(this.options.bounceTime)) {
        this.isInTransition = false;
        this._execEvent('scrollEnd', e);
      }
    },

    _start: function (e) {
      // React to left mouse button only
      if (utils.eventType[e.type] != 1) {
        if (e.button !== 0) {
          return;
        }
      }


      if (!this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated)) {
        return;
      }

      if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
        e.preventDefault();
      }

      if (this.options.stopPropagation) {
        e.stopPropagation();
      }

      var point = e.touches ? e.touches[0] : e,
        pos;

      this.initiated = utils.eventType[e.type];
      this.moved = false;
      this.distX = 0;
      this.distY = 0;
      this.directionX = 0;
      this.directionY = 0;
      this.directionLocked = 0;

      this._transitionTime();

      this.startTime = utils.getTime();

      if (this.options.useTransition && this.isInTransition) {
        this.isInTransition = false;
        pos = this.getComputedPosition();
        this._execEvent('intermit', Math.round(pos.y));
        this._translate(Math.round(pos.x), Math.round(pos.y));
        this._execEvent('scrollEnd', e);
      } else if (!this.options.useTransition && this.isAnimating) {
        this.isAnimating = false;
        this._execEvent('scrollEnd', e);
      }

      this.startX = this.x;
      this.startY = this.y;
      this.absStartX = this.x;
      this.absStartY = this.y;
      this.pointX = point.pageX;
      this.pointY = point.pageY;

      this._execEvent('beforeScrollStart', point);
    },

    _move: function (e) {
      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
        return;
      }

      if (this.options.preventDefault) { // increases performance on Android? TODO: check!
        e.preventDefault();
      }

      var point = e.touches ? e.touches[0] : e,
        deltaX = point.pageX - this.pointX,
        deltaY = point.pageY - this.pointY,
        timestamp = utils.getTime(),
        newX, newY,
        absDistX, absDistY;

      this.pointX = point.pageX;
      this.pointY = point.pageY;

      this.distX += deltaX;
      this.distY += deltaY;
      absDistX = Math.abs(this.distX);
      absDistY = Math.abs(this.distY);

      // We need to move at least 10 pixels for the scrolling to initiate
      if (timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10)) {
        return;
      }

      // If you are scrolling in one direction lock the other
      if (!this.directionLocked && !this.options.freeScroll) {
        if (absDistX > absDistY + this.options.directionLockThreshold) {
          this.directionLocked = 'h'; // lock horizontally
        } else if (absDistY >= absDistX + this.options.directionLockThreshold) {
          this.directionLocked = 'v'; // lock vertically
        } else {
          this.directionLocked = 'n'; // no lock
        }
      }

      if (this.directionLocked == 'h') {
        if (this.options.eventPassthrough == 'vertical') {
          e.preventDefault();
        } else if (this.options.eventPassthrough == 'horizontal') {
          this.initiated = false;
          return;
        }

        deltaY = 0;
      } else if (this.directionLocked == 'v') {
        if (this.options.eventPassthrough == 'horizontal') {
          e.preventDefault();
        } else if (this.options.eventPassthrough == 'vertical') {
          this.initiated = false;
          return;
        }

        deltaX = 0;
      }

      deltaX = this.hasHorizontalScroll ? deltaX : 0;
      deltaY = this.hasVerticalScroll ? deltaY : 0;

      newX = this.x + deltaX;
      newY = this.y + deltaY;

      // Slow down if outside of the boundaries
      if (newX > 0 || newX < this.maxScrollX) {
        newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
      }
      if (newY > 0 || newY < this.maxScrollY) {
        newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
      }

      this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
      this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

      if (!this.moved) {
        this._execEvent('scrollStart');
      }

      this.moved = true;

      this._translate(newX, newY);

      /* REPLACE START: _move */
      if (timestamp - this.startTime > 300) {
        this.startTime = timestamp;
        this.startX = this.x;
        this.startY = this.y;

        if (this.options.probeType == 1) {
          this._execEvent('scroll', e);
        }
      }

      if (this.options.probeType > 1) {
        this._execEvent('scroll', e);
      }
      /* REPLACE END: _move */

    },

    _end: function (e) {
      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
        return;
      }

      if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
        e.preventDefault();
      }

      var point = e.changedTouches ? e.changedTouches[0] : e,
        momentumX,
        momentumY,
        duration = utils.getTime() - this.startTime,
        newX = Math.round(this.x),
        newY = Math.round(this.y),
        distanceX = Math.abs(newX - this.startX),
        distanceY = Math.abs(newY - this.startY),
        time = 0,
        easing = '';

      this.isInTransition = 0;
      this.initiated = 0;
      this.endTime = utils.getTime();

      // reset if we are outside of the boundaries
      if (this.resetPosition(this.options.bounceTime)) {
        return;
      }

      this.scrollTo(newX, newY); // ensures that the last position is rounded

      // we scrolled less than 10 pixels
      if (!this.moved) {
        if (this.options.tap) {
          utils.tap(e, this.options.tap);
        }

        if (this.options.click) {
          utils.click(e);
        }

        this._execEvent('scrollCancel', point);
        return;
      }

      if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
        this._execEvent('flick');
        return;
      }

      // start momentum animation if needed
      if (this.options.momentum && duration < 300) {
        momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
        momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
        newX = momentumX.destination;
        newY = momentumY.destination;
        time = Math.max(momentumX.duration, momentumY.duration);
        this.isInTransition = 1;
      }


      if (this.options.snap) {
        var snap = this._nearestSnap(newX, newY);
        this.currentPage = snap;
        time = this.options.snapSpeed || Math.max(
          Math.max(
            Math.min(Math.abs(newX - snap.x), 1000),
            Math.min(Math.abs(newY - snap.y), 1000)
          ), 300);
        newX = snap.x;
        newY = snap.y;

        this.directionX = 0;
        this.directionY = 0;
        easing = this.options.bounceEasing;
      }

      // INSERT POINT: _end

      if (newX != this.x || newY != this.y) {
        // change easing function when scroller goes out of the boundaries
        if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
          easing = utils.ease.quadratic;
        }

        this.scrollTo(newX, newY, time, easing);

        /*增加*/
        this._execEvent('momentum', newY, time, easing);
        return;
      }

      this._execEvent('scrollEnd', e);
    },

    _resize: function () {
      var that = this;

      clearTimeout(this.resizeTimeout);

      this.resizeTimeout = setTimeout(function () {
        that.refresh();
      }, this.options.resizePolling);
    },

    resetPosition: function (time) {
      var x = this.x,
        y = this.y;

      time = time || 0;

      if (!this.hasHorizontalScroll || this.x > 0) {
        x = 0;
      } else if (this.x < this.maxScrollX) {
        x = this.maxScrollX;
      }

      if (!this.hasVerticalScroll || this.y > 0) {
        y = 0;
      } else if (this.y < this.maxScrollY) {
        y = this.maxScrollY;
      }

      if (x == this.x && y == this.y) {
        return false;
      }

      this.scrollTo(x, y, time, this.options.bounceEasing);

      return true;
    },

    disable: function () {
      this.enabled = false;
    },

    enable: function () {
      this.enabled = true;
    },

    refresh: function () {
      var rf = this.wrapper.offsetHeight; // Force reflow

      this.wrapperWidth = this.wrapper.clientWidth;
      this.wrapperHeight = this.wrapper.clientHeight;

      /* REPLACE START: refresh */

      this.scrollerWidth = this.scroller.offsetWidth;
      this.scrollerHeight = this.scroller.offsetHeight;

      this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
      this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

      /* REPLACE END: refresh */

      this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
      this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

      if (!this.hasHorizontalScroll) {
        this.maxScrollX = 0;
        this.scrollerWidth = this.wrapperWidth;
      }

      if (!this.hasVerticalScroll) {
        this.maxScrollY = 0;
        this.scrollerHeight = this.wrapperHeight;
      }

      this.endTime = 0;
      this.directionX = 0;
      this.directionY = 0;

      this.wrapperOffset = utils.offset(this.wrapper);

      this._execEvent('refresh');

      this.resetPosition();

      // INSERT POINT: _refresh

    },

    on: function (type, fn) {
      if (!this._events[type]) {
        this._events[type] = [];
      }

      this._events[type].push(fn);
    },

    off: function (type, fn) {
      if (!this._events[type]) {
        return;
      }

      var index = this._events[type].indexOf(fn);

      if (index > -1) {
        this._events[type].splice(index, 1);
      }
    },

    _execEvent: function (type, e) {
      if (!this._events[type]) {
        return;
      }

      var i = 0,
        l = this._events[type].length;

      if (!l) {
        return;
      }

      for (; i < l; i++) {
        this._events[type][i].apply(this, [].slice.call(arguments, 1));
      }
    },

    scrollBy: function (x, y, time, easing) {
      x = this.x + x;
      y = this.y + y;
      time = time || 0;

      this.scrollTo(x, y, time, easing);
    },

    scrollTo: function (x, y, time, easing) {
      easing = easing || utils.ease.circular;

      this.isInTransition = this.options.useTransition && time > 0;

      if (!time || (this.options.useTransition && easing.style)) {
        this._transitionTimingFunction(easing.style);
        this._transitionTime(time);
        this._translate(x, y);
      } else {
        this._animate(x, y, time, easing.fn);
      }
    },

    scrollToElement: function (el, time, offsetX, offsetY, easing) {
      el = el.nodeType ? el : this.scroller.querySelector(el);

      if (!el) {
        return;
      }

      var pos = utils.offset(el);

      pos.left -= this.wrapperOffset.left;
      pos.top -= this.wrapperOffset.top;

      // if offsetX/Y are true we center the element to the screen
      if (offsetX === true) {
        offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
      }
      if (offsetY === true) {
        offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
      }

      pos.left -= offsetX || 0;
      pos.top -= offsetY || 0;

      pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
      pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

      time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

      this.scrollTo(pos.left, pos.top, time, easing);
    },

    _transitionTime: function (time) {
      time = time || 0;

      this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

      if (!time && utils.isBadAndroid) {
        this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
      }


      if (this.indicators) {
        for (var i = this.indicators.length; i--;) {
          this.indicators[i].transitionTime(time);
        }
      }


      // INSERT POINT: _transitionTime

    },

    _transitionTimingFunction: function (easing) {
      this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


      if (this.indicators) {
        for (var i = this.indicators.length; i--;) {
          this.indicators[i].transitionTimingFunction(easing);
        }
      }


      // INSERT POINT: _transitionTimingFunction

    },

    _translate: function (x, y) {
      if (this.options.useTransform) {

        /* REPLACE START: _translate */

        this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

        /* REPLACE END: _translate */

      } else {
        x = Math.round(x);
        y = Math.round(y);
        this.scrollerStyle.left = x + 'px';
        this.scrollerStyle.top = y + 'px';
      }

      this.x = x;
      this.y = y;

      if (this.indicators) {
        for (var i = this.indicators.length; i--;) {
          this.indicators[i].updatePosition();
        }
      }


      // INSERT POINT: _translate

    },

    _initEvents: function (remove) {
      var eventType = remove ? utils.removeEvent : utils.addEvent,
        target = this.options.bindToWrapper ? this.wrapper : window;

      eventType(window, 'orientationchange', this);
      eventType(window, 'resize', this);

      if (this.options.click) {
        eventType(this.wrapper, 'click', this, true);
      }

      if (!this.options.disableMouse) {
        eventType(this.wrapper, 'mousedown', this);
        eventType(target, 'mousemove', this);
        eventType(target, 'mousecancel', this);
        eventType(target, 'mouseup', this);
      }

      if (utils.hasPointer && !this.options.disablePointer) {
        eventType(this.wrapper, 'MSPointerDown', this);
        eventType(target, 'MSPointerMove', this);
        eventType(target, 'MSPointerCancel', this);
        eventType(target, 'MSPointerUp', this);
      }

      if (utils.hasTouch && !this.options.disableTouch) {
        eventType(this.wrapper, 'touchstart', this);
        eventType(target, 'touchmove', this);
        eventType(target, 'touchcancel', this);
        eventType(target, 'touchend', this);
      }

      eventType(this.scroller, 'transitionend', this);
      eventType(this.scroller, 'webkitTransitionEnd', this);
      eventType(this.scroller, 'oTransitionEnd', this);
      eventType(this.scroller, 'MSTransitionEnd', this);
    },

    getComputedPosition: function () {
      var matrix = window.getComputedStyle(this.scroller, null),
        x, y;

      if (this.options.useTransform) {
        matrix = matrix[utils.style.transform].split(')')[0].split(', ');
        x = +(matrix[12] || matrix[4]);
        y = +(matrix[13] || matrix[5]);
      } else {
        x = +matrix.left.replace(/[^-\d.]/g, '');
        y = +matrix.top.replace(/[^-\d.]/g, '');
      }

      return { x: x, y: y };
    },

    _initIndicators: function () {
      var interactive = this.options.interactiveScrollbars,
        customStyle = typeof this.options.scrollbars != 'string',
        indicators = [],
        indicator;

      var that = this;

      this.indicators = [];

      if (this.options.scrollbars) {
        // Vertical scrollbar
        if (this.options.scrollY) {
          indicator = {
            el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
            interactive: interactive,
            defaultScrollbars: true,
            customStyle: customStyle,
            resize: this.options.resizeScrollbars,
            shrink: this.options.shrinkScrollbars,
            fade: this.options.fadeScrollbars,
            listenX: false
          };

          this.wrapper.appendChild(indicator.el);
          indicators.push(indicator);
        }

        // Horizontal scrollbar
        if (this.options.scrollX) {
          indicator = {
            el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
            interactive: interactive,
            defaultScrollbars: true,
            customStyle: customStyle,
            resize: this.options.resizeScrollbars,
            shrink: this.options.shrinkScrollbars,
            fade: this.options.fadeScrollbars,
            listenY: false
          };

          this.wrapper.appendChild(indicator.el);
          indicators.push(indicator);
        }
      }

      if (this.options.indicators) {
        // TODO: check concat compatibility
        indicators = indicators.concat(this.options.indicators);
      }

      for (var i = indicators.length; i--;) {
        this.indicators.push(new Indicator(this, indicators[i]));
      }

      // TODO: check if we can use array.map (wide compatibility and performance issues)
      function _indicatorsMap(fn) {
        for (var i = that.indicators.length; i--;) {
          fn.call(that.indicators[i]);
        }
      }

      if (this.options.fadeScrollbars) {
        this.on('scrollEnd', function () {
          _indicatorsMap(function () {
            this.fade();
          });
        });

        this.on('scrollCancel', function () {
          _indicatorsMap(function () {
            this.fade();
          });
        });

        this.on('scrollStart', function () {
          _indicatorsMap(function () {
            this.fade(1);
          });
        });

        this.on('beforeScrollStart', function () {
          _indicatorsMap(function () {
            this.fade(1, true);
          });
        });
      }


      this.on('refresh', function () {
        _indicatorsMap(function () {
          this.refresh();
        });
      });

      this.on('destroy', function () {
        _indicatorsMap(function () {
          this.destroy();
        });

        delete this.indicators;
      });
    },

    _initWheel: function () {
      utils.addEvent(this.wrapper, 'wheel', this);
      utils.addEvent(this.wrapper, 'mousewheel', this);
      utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

      this.on('destroy', function () {
        utils.removeEvent(this.wrapper, 'wheel', this);
        utils.removeEvent(this.wrapper, 'mousewheel', this);
        utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
      });
    },

    _wheel: function (e) {
      if (!this.enabled) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      var wheelDeltaX, wheelDeltaY,
        newX, newY,
        that = this;

      if (this.wheelTimeout === undefined) {
        that._execEvent('scrollStart');
      }

      // Execute the scrollEnd event after 400ms the wheel stopped scrolling
      clearTimeout(this.wheelTimeout);
      this.wheelTimeout = setTimeout(function () {
        that._execEvent('scrollEnd', e);
        that.wheelTimeout = undefined;
      }, 400);

      if ('deltaX' in e) {
        wheelDeltaX = -e.deltaX;
        wheelDeltaY = -e.deltaY;
      } else if ('wheelDeltaX' in e) {
        wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
        wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
      } else if ('wheelDelta' in e) {
        wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
      } else if ('detail' in e) {
        wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
      } else {
        return;
      }

      wheelDeltaX *= this.options.invertWheelDirection;
      wheelDeltaY *= this.options.invertWheelDirection;

      if (!this.hasVerticalScroll) {
        wheelDeltaX = wheelDeltaY;
        wheelDeltaY = 0;
      }

      if (this.options.snap) {
        newX = this.currentPage.pageX;
        newY = this.currentPage.pageY;

        if (wheelDeltaX > 0) {
          newX--;
        } else if (wheelDeltaX < 0) {
          newX++;
        }

        if (wheelDeltaY > 0) {
          newY--;
        } else if (wheelDeltaY < 0) {
          newY++;
        }

        this.goToPage(newX, newY);

        return;
      }

      newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
      newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

      if (newX > 0) {
        newX = 0;
      } else if (newX < this.maxScrollX) {
        newX = this.maxScrollX;
      }

      if (newY > 0) {
        newY = 0;
      } else if (newY < this.maxScrollY) {
        newY = this.maxScrollY;
      }

      this.scrollTo(newX, newY, 0);

      if (this.options.probeType > 1) {
        this._execEvent('scroll', e);
      }

      // INSERT POINT: _wheel
    },

    _initSnap: function () {
      this.currentPage = {};

      if (typeof this.options.snap == 'string') {
        this.options.snap = this.scroller.querySelectorAll(this.options.snap);
      }

      this.on('refresh', function () {
        var i = 0,
          l,
          m = 0,
          n,
          cx, cy,
          x = 0,
          y,
          stepX = this.options.snapStepX || this.wrapperWidth,
          stepY = this.options.snapStepY || this.wrapperHeight,
          el;

        this.pages = [];

        if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
          return;
        }

        if (this.options.snap === true) {
          cx = Math.round(stepX / 2);
          cy = Math.round(stepY / 2);

          while (x > -this.scrollerWidth) {
            this.pages[i] = [];
            l = 0;
            y = 0;

            while (y > -this.scrollerHeight) {
              this.pages[i][l] = {
                x: Math.max(x, this.maxScrollX),
                y: Math.max(y, this.maxScrollY),
                width: stepX,
                height: stepY,
                cx: x - cx,
                cy: y - cy
              };

              y -= stepY;
              l++;
            }

            x -= stepX;
            i++;
          }
        } else {
          el = this.options.snap;
          l = el.length;
          n = -1;

          for (; i < l; i++) {
            if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
              m = 0;
              n++;
            }

            if (!this.pages[m]) {
              this.pages[m] = [];
            }

            x = Math.max(-el[i].offsetLeft, this.maxScrollX);
            y = Math.max(-el[i].offsetTop, this.maxScrollY);
            cx = x - Math.round(el[i].offsetWidth / 2);
            cy = y - Math.round(el[i].offsetHeight / 2);

            this.pages[m][n] = {
              x: x,
              y: y,
              width: el[i].offsetWidth,
              height: el[i].offsetHeight,
              cx: cx,
              cy: cy
            };

            if (x > this.maxScrollX) {
              m++;
            }
          }
        }

        this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

        // Update snap threshold if needed
        if (this.options.snapThreshold % 1 === 0) {
          this.snapThresholdX = this.options.snapThreshold;
          this.snapThresholdY = this.options.snapThreshold;
        } else {
          this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
          this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
        }
      });

      this.on('flick', function () {
        var time = this.options.snapSpeed || Math.max(
          Math.max(
            Math.min(Math.abs(this.x - this.startX), 1000),
            Math.min(Math.abs(this.y - this.startY), 1000)
          ), 300);

        this.goToPage(
          this.currentPage.pageX + this.directionX,
          this.currentPage.pageY + this.directionY,
          time
        );
      });
    },

    _nearestSnap: function (x, y) {
      if (!this.pages.length) {
        return { x: 0, y: 0, pageX: 0, pageY: 0 };
      }

      var i = 0,
        l = this.pages.length,
        m = 0;

      // Check if we exceeded the snap threshold
      if (Math.abs(x - this.absStartX) < this.snapThresholdX &&
        Math.abs(y - this.absStartY) < this.snapThresholdY) {
        return this.currentPage;
      }

      if (x > 0) {
        x = 0;
      } else if (x < this.maxScrollX) {
        x = this.maxScrollX;
      }

      if (y > 0) {
        y = 0;
      } else if (y < this.maxScrollY) {
        y = this.maxScrollY;
      }

      for (; i < l; i++) {
        if (x >= this.pages[i][0].cx) {
          x = this.pages[i][0].x;
          break;
        }
      }

      l = this.pages[i].length;

      for (; m < l; m++) {
        if (y >= this.pages[0][m].cy) {
          y = this.pages[0][m].y;
          break;
        }
      }

      if (i == this.currentPage.pageX) {
        i += this.directionX;

        if (i < 0) {
          i = 0;
        } else if (i >= this.pages.length) {
          i = this.pages.length - 1;
        }

        x = this.pages[i][0].x;
      }

      if (m == this.currentPage.pageY) {
        m += this.directionY;

        if (m < 0) {
          m = 0;
        } else if (m >= this.pages[0].length) {
          m = this.pages[0].length - 1;
        }

        y = this.pages[0][m].y;
      }

      return {
        x: x,
        y: y,
        pageX: i,
        pageY: m
      };
    },

    goToPage: function (x, y, time, easing) {
      easing = easing || this.options.bounceEasing;

      if (x >= this.pages.length) {
        x = this.pages.length - 1;
      } else if (x < 0) {
        x = 0;
      }

      if (y >= this.pages[x].length) {
        y = this.pages[x].length - 1;
      } else if (y < 0) {
        y = 0;
      }

      var posX = this.pages[x][y].x,
        posY = this.pages[x][y].y;

      time = time === undefined ? this.options.snapSpeed || Math.max(
        Math.max(
          Math.min(Math.abs(posX - this.x), 1000),
          Math.min(Math.abs(posY - this.y), 1000)
        ), 300) : time;

      this.currentPage = {
        x: posX,
        y: posY,
        pageX: x,
        pageY: y
      };
      this._execEvent('scrollEnd', {});
      this.scrollTo(posX, posY, time, easing);
    },

    next: function (time, easing) {
      var x = this.currentPage.pageX,
        y = this.currentPage.pageY;

      x++;

      if (x >= this.pages.length && this.hasVerticalScroll) {
        x = 0;
        y++;
      }

      this.goToPage(x, y, time, easing);
    },

    prev: function (time, easing) {
      var x = this.currentPage.pageX,
        y = this.currentPage.pageY;

      x--;

      if (x < 0 && this.hasVerticalScroll) {
        x = 0;
        y--;
      }

      this.goToPage(x, y, time, easing);
    },

    _initKeys: function (e) {
      // default key bindings
      var keys = {
        pageUp: 33,
        pageDown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40
      };
      var i;

      // if you give me characters I give you keycode
      if (typeof this.options.keyBindings == 'object') {
        for (i in this.options.keyBindings) {
          if (typeof this.options.keyBindings[i] == 'string') {
            this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
          }
        }
      } else {
        this.options.keyBindings = {};
      }

      for (i in keys) {
        this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
      }

      utils.addEvent(window, 'keydown', this);

      this.on('destroy', function () {
        utils.removeEvent(window, 'keydown', this);
      });
    },

    _key: function (e) {
      if (!this.enabled) {
        return;
      }

      var snap = this.options.snap, // we are using this alot, better to cache it
        newX = snap ? this.currentPage.pageX : this.x,
        newY = snap ? this.currentPage.pageY : this.y,
        now = utils.getTime(),
        prevTime = this.keyTime || 0,
        acceleration = 0.250,
        pos;

      if (this.options.useTransition && this.isInTransition) {
        pos = this.getComputedPosition();

        this._translate(Math.round(pos.x), Math.round(pos.y));
        this.isInTransition = false;
      }

      this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

      switch (e.keyCode) {
        case this.options.keyBindings.pageUp:
          if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
            newX += snap ? 1 : this.wrapperWidth;
          } else {
            newY += snap ? 1 : this.wrapperHeight;
          }
          break;
        case this.options.keyBindings.pageDown:
          if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
            newX -= snap ? 1 : this.wrapperWidth;
          } else {
            newY -= snap ? 1 : this.wrapperHeight;
          }
          break;
        case this.options.keyBindings.end:
          newX = snap ? this.pages.length - 1 : this.maxScrollX;
          newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
          break;
        case this.options.keyBindings.home:
          newX = 0;
          newY = 0;
          break;
        case this.options.keyBindings.left:
          newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
          break;
        case this.options.keyBindings.up:
          newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
          break;
        case this.options.keyBindings.right:
          newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
          break;
        case this.options.keyBindings.down:
          newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
          break;
        default:
          return;
      }

      if (snap) {
        this.goToPage(newX, newY);
        return;
      }

      if (newX > 0) {
        newX = 0;
        this.keyAcceleration = 0;
      } else if (newX < this.maxScrollX) {
        newX = this.maxScrollX;
        this.keyAcceleration = 0;
      }

      if (newY > 0) {
        newY = 0;
        this.keyAcceleration = 0;
      } else if (newY < this.maxScrollY) {
        newY = this.maxScrollY;
        this.keyAcceleration = 0;
      }

      this.scrollTo(newX, newY, 0);

      this.keyTime = now;
    },

    _animate: function (destX, destY, duration, easingFn) {
      var that = this,
        startX = this.x,
        startY = this.y,
        startTime = utils.getTime(),
        destTime = startTime + duration;

      function step() {
        var now = utils.getTime(),
          newX, newY,
          easing;

        if (now >= destTime) {
          that.isAnimating = false;
          that._translate(destX, destY);

          if (!that.resetPosition(that.options.bounceTime)) {
            that._execEvent('scrollEnd', {});
          }

          return;
        }

        now = (now - startTime) / duration;
        easing = easingFn(now);
        newX = (destX - startX) * easing + startX;
        newY = (destY - startY) * easing + startY;
        that._translate(newX, newY);

        if (that.isAnimating) {
          rAF(step);
        }

        if (that.options.probeType == 3) {
          that._execEvent('scroll', {});
        }
      }

      this.isAnimating = true;
      step();
    },

    handleEvent: function (e) {
      switch (e.type) {
        case 'touchstart':
        case 'MSPointerDown':
        case 'mousedown':
          this._start(e);
          break;
        case 'touchmove':
        case 'MSPointerMove':
        case 'mousemove':
          this._move(e);
          break;
        case 'touchend':
        case 'MSPointerUp':
        case 'mouseup':
        case 'touchcancel':
        case 'MSPointerCancel':
        case 'mousecancel':
          this._end(e);
          break;
        case 'orientationchange':
        case 'resize':
          this._resize();
          break;
        case 'transitionend':
        case 'webkitTransitionEnd':
        case 'oTransitionEnd':
        case 'MSTransitionEnd':
          this._transitionEnd(e);
          break;
        case 'wheel':
        case 'DOMMouseScroll':
        case 'mousewheel':
          this._wheel(e);
          break;
        case 'keydown':
          this._key(e);
          break;
        case 'click':
          if (!e._constructed) {
            e.preventDefault();
            e.stopPropagation();
          }
          break;
      }
    }
  };

  function createDefaultScrollbar(direction, interactive, type) {
    var scrollbar = document.createElement('div'),
      indicator = document.createElement('div');

    if (type === true) {
      scrollbar.style.cssText = 'position:absolute;z-index:9999';
      indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
    }

    indicator.className = 'iScrollIndicator';

    if (direction == 'h') {
      if (type === true) {
        scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
        indicator.style.height = '100%';
      }
      scrollbar.className = 'iScrollHorizontalScrollbar';
    } else {
      if (type === true) {
        scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
        indicator.style.width = '100%';
      }
      scrollbar.className = 'iScrollVerticalScrollbar';
    }

    scrollbar.style.cssText += ';overflow:hidden';

    if (!interactive) {
      scrollbar.style.pointerEvents = 'none';
    }

    scrollbar.appendChild(indicator);

    return scrollbar;
  }

  function Indicator(scroller, options) {
    this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
    this.wrapperStyle = this.wrapper.style;
    this.indicator = this.wrapper.children[0];
    this.indicatorStyle = this.indicator.style;
    this.scroller = scroller;

    this.options = {
      listenX: true,
      listenY: true,
      interactive: false,
      resize: true,
      defaultScrollbars: false,
      shrink: false,
      fade: false,
      speedRatioX: 0,
      speedRatioY: 0
    };

    for (var i in options) {
      this.options[i] = options[i];
    }

    this.sizeRatioX = 1;
    this.sizeRatioY = 1;
    this.maxPosX = 0;
    this.maxPosY = 0;

    if (this.options.interactive) {
      if (!this.options.disableTouch) {
        utils.addEvent(this.indicator, 'touchstart', this);
        utils.addEvent(window, 'touchend', this);
      }
      if (!this.options.disablePointer) {
        utils.addEvent(this.indicator, 'MSPointerDown', this);
        utils.addEvent(window, 'MSPointerUp', this);
      }
      if (!this.options.disableMouse) {
        utils.addEvent(this.indicator, 'mousedown', this);
        utils.addEvent(window, 'mouseup', this);
      }
    }

    if (this.options.fade) {
      this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
      this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
      this.wrapperStyle.opacity = '0';
    }
  }

  Indicator.prototype = {
    handleEvent: function (e) {
      switch (e.type) {
        case 'touchstart':
        case 'MSPointerDown':
        case 'mousedown':
          this._start(e);
          break;
        case 'touchmove':
        case 'MSPointerMove':
        case 'mousemove':
          this._move(e);
          break;
        case 'touchend':
        case 'MSPointerUp':
        case 'mouseup':
        case 'touchcancel':
        case 'MSPointerCancel':
        case 'mousecancel':
          this._end(e);
          break;
      }
    },

    destroy: function () {
      if (this.options.interactive) {
        utils.removeEvent(this.indicator, 'touchstart', this);
        utils.removeEvent(this.indicator, 'MSPointerDown', this);
        utils.removeEvent(this.indicator, 'mousedown', this);

        utils.removeEvent(window, 'touchmove', this);
        utils.removeEvent(window, 'MSPointerMove', this);
        utils.removeEvent(window, 'mousemove', this);

        utils.removeEvent(window, 'touchend', this);
        utils.removeEvent(window, 'MSPointerUp', this);
        utils.removeEvent(window, 'mouseup', this);
      }

      if (this.options.defaultScrollbars) {
        this.wrapper.parentNode.removeChild(this.wrapper);
      }
    },

    _start: function (e) {
      var point = e.touches ? e.touches[0] : e;

      e.preventDefault();
      e.stopPropagation();

      this.transitionTime();

      this.initiated = true;
      this.moved = false;
      this.lastPointX = point.pageX;
      this.lastPointY = point.pageY;

      this.startTime = utils.getTime();

      if (!this.options.disableTouch) {
        utils.addEvent(window, 'touchmove', this);
      }
      if (!this.options.disablePointer) {
        utils.addEvent(window, 'MSPointerMove', this);
      }
      if (!this.options.disableMouse) {
        utils.addEvent(window, 'mousemove', this);
      }

      this.scroller._execEvent('beforeScrollStart');
    },

    _move: function (e) {

      var point = e.touches ? e.touches[0] : e,
        deltaX, deltaY,
        newX, newY,
        timestamp = utils.getTime();


      if (!this.moved) {
        this.scroller._execEvent('scrollStart');
      }

      this.moved = true;

      deltaX = point.pageX - this.lastPointX;
      this.lastPointX = point.pageX;

      deltaY = point.pageY - this.lastPointY;
      this.lastPointY = point.pageY;

      newX = this.x + deltaX;
      newY = this.y + deltaY;

      this._pos(newX, newY);


      if (this.scroller.options.probeType == 1 && timestamp - this.startTime > 300) {
        this.startTime = timestamp;
        this.scroller._execEvent('scroll', e);
      } else if (this.scroller.options.probeType > 1) {
        this.scroller._execEvent('scroll', e);
      }


      // INSERT POINT: indicator._move

      e.preventDefault();
      e.stopPropagation();
    },

    _end: function (e) {
      if (!this.initiated) {
        return;
      }

      this.initiated = false;

      e.preventDefault();
      e.stopPropagation();

      utils.removeEvent(window, 'touchmove', this);
      utils.removeEvent(window, 'MSPointerMove', this);
      utils.removeEvent(window, 'mousemove', this);

      if (this.scroller.options.snap) {
        var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

        var time = this.options.snapSpeed || Math.max(
          Math.max(
            Math.min(Math.abs(this.scroller.x - snap.x), 1000),
            Math.min(Math.abs(this.scroller.y - snap.y), 1000)
          ), 300);

        if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
          this.scroller.directionX = 0;
          this.scroller.directionY = 0;
          this.scroller.currentPage = snap;
          this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
        }
      }

      if (this.moved) {
        this.scroller._execEvent('scrollEnd', e);
      }
    },

    transitionTime: function (time) {
      time = time || 0;
      this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

      if (!time && utils.isBadAndroid) {
        this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
      }
    },

    transitionTimingFunction: function (easing) {
      this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
    },

    refresh: function () {
      this.transitionTime();

      if (this.options.listenX && !this.options.listenY) {
        this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
      } else if (this.options.listenY && !this.options.listenX) {
        this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
      } else {
        this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
      }

      if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
        utils.addClass(this.wrapper, 'iScrollBothScrollbars');
        utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

        if (this.options.defaultScrollbars && this.options.customStyle) {
          if (this.options.listenX) {
            this.wrapper.style.right = '8px';
          } else {
            this.wrapper.style.bottom = '8px';
          }
        }
      } else {
        utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
        utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

        if (this.options.defaultScrollbars && this.options.customStyle) {
          if (this.options.listenX) {
            this.wrapper.style.right = '2px';
          } else {
            this.wrapper.style.bottom = '2px';
          }
        }
      }

      var r = this.wrapper.offsetHeight; // force refresh

      if (this.options.listenX) {
        this.wrapperWidth = this.wrapper.clientWidth;
        if (this.options.resize) {
          this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
          this.indicatorStyle.width = this.indicatorWidth + 'px';
        } else {
          this.indicatorWidth = this.indicator.clientWidth;
        }

        this.maxPosX = this.wrapperWidth - this.indicatorWidth;

        if (this.options.shrink == 'clip') {
          this.minBoundaryX = -this.indicatorWidth + 8;
          this.maxBoundaryX = this.wrapperWidth - 8;
        } else {
          this.minBoundaryX = 0;
          this.maxBoundaryX = this.maxPosX;
        }

        this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
      }

      if (this.options.listenY) {
        this.wrapperHeight = this.wrapper.clientHeight;
        if (this.options.resize) {
          this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
          this.indicatorStyle.height = this.indicatorHeight + 'px';
        } else {
          this.indicatorHeight = this.indicator.clientHeight;
        }

        this.maxPosY = this.wrapperHeight - this.indicatorHeight;

        if (this.options.shrink == 'clip') {
          this.minBoundaryY = -this.indicatorHeight + 8;
          this.maxBoundaryY = this.wrapperHeight - 8;
        } else {
          this.minBoundaryY = 0;
          this.maxBoundaryY = this.maxPosY;
        }

        this.maxPosY = this.wrapperHeight - this.indicatorHeight;

        this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
      }

      this.updatePosition();
    },

    updatePosition: function () {
      var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
        y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

      if (!this.options.ignoreBoundaries) {
        if (x < this.minBoundaryX) {
          if (this.options.shrink == 'scale') {
            this.width = Math.max(this.indicatorWidth + x, 8);
            this.indicatorStyle.width = this.width + 'px';
          }
          x = this.minBoundaryX;
        } else if (x > this.maxBoundaryX) {
          if (this.options.shrink == 'scale') {
            this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
            this.indicatorStyle.width = this.width + 'px';
            x = this.maxPosX + this.indicatorWidth - this.width;
          } else {
            x = this.maxBoundaryX;
          }
        } else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
          this.width = this.indicatorWidth;
          this.indicatorStyle.width = this.width + 'px';
        }

        if (y < this.minBoundaryY) {
          if (this.options.shrink == 'scale') {
            this.height = Math.max(this.indicatorHeight + y * 3, 8);
            this.indicatorStyle.height = this.height + 'px';
          }
          y = this.minBoundaryY;
        } else if (y > this.maxBoundaryY) {
          if (this.options.shrink == 'scale') {
            this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
            this.indicatorStyle.height = this.height + 'px';
            y = this.maxPosY + this.indicatorHeight - this.height;
          } else {
            y = this.maxBoundaryY;
          }
        } else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
          this.height = this.indicatorHeight;
          this.indicatorStyle.height = this.height + 'px';
        }
      }

      this.x = x;
      this.y = y;

      if (this.scroller.options.useTransform) {
        this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
      } else {
        this.indicatorStyle.left = x + 'px';
        this.indicatorStyle.top = y + 'px';
      }
    },

    _pos: function (x, y) {
      if (x < 0) {
        x = 0;
      } else if (x > this.maxPosX) {
        x = this.maxPosX;
      }

      if (y < 0) {
        y = 0;
      } else if (y > this.maxPosY) {
        y = this.maxPosY;
      }

      x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
      y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

      this.scroller.scrollTo(x, y);
    },

    fade: function (val, hold) {
      if (hold && !this.visible) {
        return;
      }

      clearTimeout(this.fadeTimeout);
      this.fadeTimeout = null;

      var time = val ? 250 : 500,
        delay = val ? 0 : 300;

      val = val ? '1' : '0';

      this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

      this.fadeTimeout = setTimeout((function (val) {
        this.wrapperStyle.opacity = val;
        this.visible = +val;
      }).bind(this, val), delay);
    }
  };

  IScroll.utils = utils;

  if (typeof module != 'undefined' && module.exports) {
    module.exports = IScroll;
  } else {
    window.iScroll = IScroll;
  }

})(window, document, Math);

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');

  var TYPE_FUNCTION = 'function';

  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
    if(Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }
    return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
    var i;

    if(!obj) {
      return;
    }

    if(obj.forEach) {
      obj.forEach(iterator, context);
    } else if(obj.length !== undefined) {
      i = 0;
      while(i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for(i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge]
   * @returns {Object} dest
   */
  function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while(i < keys.length) {
      if(!merge || (merge && dest[keys[i]] === undefined)) {
        dest[keys[i]] = src[keys[i]];
      }
      i++;
    }
    return dest;
  }

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  function merge(dest, src) {
    return extend(dest, src, true);
  }

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
    var baseP = base.prototype,
      childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if(properties) {
      extend(childP, properties);
    }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
    if(typeof val == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
    return(val1 === undefined) ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
      target.addEventListener(type, handler, false);
    });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
      target.removeEventListener(type, handler, false);
    });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
    while(node) {
      if(node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
    if(src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;
      while(i < src.length) {
        if((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
          return i;
        }
        i++;
      }
      return -1;
    }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while(i < src.length) {
      var val = key ? src[i][key] : src[i];
      if(inArray(values, val) < 0) {
        results.push(src[i]);
      }
      values[i] = val;
      i++;
    }

    if(sort) {
      if(!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }

    return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while(i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = (prefix) ? prefix + camelProp : property;

      if(prop in obj) {
        return prop;
      }
      i++;
    }
    return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;

  function uniqueId() {
    return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return(doc.defaultView || doc.parentWindow);
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';

  var COMPUTE_INTERVAL = 25;

  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;

  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;

  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    var pixiContext = manager.options.pixiContext;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    // 小包装的处理句柄，用来为manager启动状态和作用域
    this.domHandler = function(ev) {
      if(boolOrFn(manager.options.enable, [manager])) {
        if(pixiContext) {
          self.handler(ev.originalEvent);
        } else {
          self.handler(ev);
        }
      }
    };

    if(pixiContext) {
      pixiContext.mousedown = pixiContext.touchstart = function(ev) {
        manager.options.returnStart(ev.originalEvent);
        self.domHandler(ev)
      }
      pixiContext.mousemove = pixiContext.touchmove = function(ev) {
        manager.options.returnMove(ev.originalEvent);
        self.domHandler(ev)
      }
      pixiContext.mouseup = pixiContext.touchend = this.domHandler
    } else {
      this.init();
    }
  }

  Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() {},

    /**
     * bind the events
     * 开始绑定事件
     */
    init: function() {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      //move up事件绑到window上面
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };

  /**
   * 用个这Manager构造器创建一个输入类型的管理
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if(inputClass) {
      Type = inputClass;
    } else if(SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if(SUPPORT_ONLY_TOUCH) {
      Type = TouchInput; //移动手机端
    } else if(!SUPPORT_TOUCH) {
      Type = MouseInput; //桌面
    } else {
      Type = TouchMouseInput;
    }
    return new(Type)(manager, inputHandler);
  }

  /**
   * handle input events
   * 处理输入事件
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
    //触发点数量
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    //输入的顺序
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    //取布尔值
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if(isFirst) {
      manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    // 计算缩放、旋转等
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    //运行识别器
    manager.recognize(input);
    manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * 扩展数据和一些有用的属性如缩放、旋转、速度等
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if(!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    // 多点判断
    if(pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if(pointersLength === 1) {
      session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if(hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }
    input.target = target;
  }

  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if(input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };

      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
      deltaTime = input.timeStamp - last.timeStamp,
      velocity, velocityX, velocityY, direction;

    if(input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = last.deltaX - input.deltaX;
      var deltaY = last.deltaY - input.deltaY;

      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);

      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while(i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }

    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if(pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }

    var x = 0,
      y = 0,
      i = 0;
    while(i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }

    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
    if(x === y) {
      return DIRECTION_NONE;
    }

    if(abs(x) >= abs(y)) {
      return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
    if(!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
      y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
    if(!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
      y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };

  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';


  /**
   * 鼠标输入，桌面PC
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    //用来禁止TouchMouse事件
    this.allow = true; // used by Input.TouchMouse to disable mouse events
    //鼠标按下的状态
    this.pressed = false; // mousedown state
    Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
      //定义的事件类型
      // mousedown: 1
      // mousemove: 2
      // mouseup: 4
      var eventType = MOUSE_INPUT_MAP[ev.type];


      // on start we want to have the left mouse button down
      // 开始我们按下鼠标左键
      if(eventType & INPUT_START && ev.button === 0) {
        //按下标记
        this.pressed = true;
      }

      //如果是移动事件，并且不是左键触发  
      if(eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      }

      // mouse must be down, and mouse events are allowed (see the TouchMouse input)
      // 如果鼠标不是通过按下触发的，算错误的处理，直接返回
      if(!this.pressed || !this.allow) {
        return;
      }

      //如果是up事件
      if(eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  });

  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if(window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
  }

  inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;

      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

      var isTouch = (pointerType == INPUT_TYPE_TOUCH);

      // get index of the event in the store
      var storeIndex = inArray(store, ev.pointerId, 'pointerId');

      // start and mouse must be down
      if(eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if(storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if(eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      }

      // it not found, so the pointer hasn't been down (so it's probably a hover)
      if(storeIndex < 0) {
        return;
      }

      // update the event in the store
      store[storeIndex] = ev;

      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if(removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  });

  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };

  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

      // should we handle the touch events?
      if(type === INPUT_START) {
        this.started = true;
      }

      if(!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type);

      // when done, reset the started state
      if(type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if(type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };

  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);
      if(!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if(type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }

    var i,
      targetTouches,
      changedTouches = toArray(ev.changedTouches),
      changedTargetTouches = [],
      target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
      return hasParent(touch.target, target);
    });

    // collect touches
    if(type === INPUT_START) {
      i = 0;
      while(i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while(i < changedTouches.length) {
      if(targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      }

      // cleanup removed touches
      if(type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }
      i++;
    }

    if(!changedTargetTouches.length) {
      return;
    }

    return [
      // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
      uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
      changedTargetTouches
    ];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */
  function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
  }

  inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
        isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

      // when we're in a touch event, so  block all upcoming mouse events
      // most mobile browser also emit mouseevents, right after touchstart
      if(isTouch) {
        this.mouse.allow = false;
      } else if(isMouse && !this.mouse.allow) {
        return;
      }

      // reset the allowMouse when we're done
      if(inputEvent & (INPUT_END | INPUT_CANCEL)) {
        this.mouse.allow = true;
      }

      this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }

  TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
      // find out the touch-action by the event handlers
      if(value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if(NATIVE_TOUCH_ACTION) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }
      this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
      this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
      var actions = [];
      each(this.manager.recognizers, function(recognizer) {
        if(boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
      // not needed with native support for the touchAction property
      if(NATIVE_TOUCH_ACTION) {
        return;
      }

      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection;

      // if the touch action did prevented once this session
      if(this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

      if(hasNone ||
        (hasPanY && direction & DIRECTION_HORIZONTAL) ||
        (hasPanX && direction & DIRECTION_VERTICAL)) {
        return this.preventSrc(srcEvent);
      }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
    // none
    if(inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if(hasPanX && hasPanY) {
      return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if(hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if(inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
  }

  /**
   * 识别器流程
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * 每一个识别器都要需要继承基类
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
  }

  Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
      extend(this.options, options);

      // also update the touchAction, in case something changed about the directions/enabled state
      this.manager && this.manager.touchAction.update();
      return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
      if(invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if(!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }
      return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
      if(invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
      if(invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if(inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }
      return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
      if(invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);
      if(index > -1) {
        this.requireFail.splice(index, 1);
      }
      return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
      return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
      var self = this;
      var state = this.state;

      function emit(withState) {
        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
      }

      // 'panstart' and 'panmove'
      if(state < STATE_ENDED) {
        emit(true);
      }

      emit(); // simple 'eventName' events

      // panend and pancancel
      if(state >= STATE_ENDED) {
        emit(true);
      }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
      if(this.canEmit()) {
        return this.emit(input);
      }
      // it's failing anyway
      this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
      var i = 0;
      while(i < this.requireFail.length) {
        if(!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }
        i++;
      }
      return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      // 拷贝一份新的输入对象
      var inputDataClone = extend({}, inputData);

      // is is enabled and allow recognizing?
      if(!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      }

      // reset when we've reached the end
      if(this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone);

      // the recognizer has recognized a gesture
      // so trigger an event
      if(this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) {}, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() {},

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() {}
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
    if(state & STATE_CANCELLED) {
      return 'cancel';
    } else if(state & STATE_ENDED) {
      return 'end';
    } else if(state & STATE_CHANGED) {
      return 'move';
    } else if(state & STATE_BEGAN) {
      return 'start';
    }
    return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
    if(direction == DIRECTION_DOWN) {
      return 'down';
    } else if(direction == DIRECTION_UP) {
      return 'up';
    } else if(direction == DIRECTION_LEFT) {
      return 'left';
    } else if(direction == DIRECTION_RIGHT) {
      return 'right';
    }
    return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if(manager) {
      return manager.get(otherRecognizer);
    }
    return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
      var state = this.state;
      var eventType = input.eventType;

      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input);

      // on cancel input and we've recognized before, return STATE_CANCELLED
      if(isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if(isRecognized || isValid) {
        if(eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if(!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }
        return state | STATE_CHANGED;
      }
      return STATE_FAILED;
    }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },

    getTouchAction: function() {
      var direction = this.options.direction;
      var actions = [];
      if(direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }
      if(direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }
      return actions;
    },

    directionTest: function(input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY;

      // lock to axis?
      if(!(direction & options.direction)) {
        if(options.direction & DIRECTION_HORIZONTAL) {
          direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }
      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) &&
        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;

      var direction = directionStr(input.direction);
      if(direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this._super.emit.call(this, input);
    }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },

    getTouchAction: function() {
      return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
      return this._super.attrTest.call(this, input) &&
        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
      this._super.emit.call(this, input);
      if(input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        this.manager.emit(this.options.event + inOut, input);
      }
    }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: 'press',
      pointers: 1,
      time: 500, // minimal time of the pointer to be pressed
      threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
      return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;

      this._input = input;

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if(!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
        this.reset();
      } else if(input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function() {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if(input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }
      return STATE_FAILED;
    },

    reset: function() {
      clearTimeout(this._timer);
    },

    emit: function(input) {
      if(this.state !== STATE_RECOGNIZED) {
        return;
      }

      if(input && (input.eventType & INPUT_END)) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },

    getTouchAction: function() {
      return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
      return this._super.attrTest.call(this, input) &&
        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.65,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },

    getTouchAction: function() {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
      var direction = this.options.direction;
      var velocity;

      if(direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.velocity;
      } else if(direction & DIRECTION_HORIZONTAL) {
        velocity = input.velocityX;
      } else if(direction & DIRECTION_VERTICAL) {
        velocity = input.velocityY;
      }

      return this._super.attrTest.call(this, input) &&
        direction & input.direction &&
        input.distance > this.options.threshold &&
        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
      var direction = directionStr(input.direction);
      if(direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300, // max time between the multi-tap taps
      time: 250, // max time of the pointer to be down (like finger on the screen)
      threshold: 2, // a minimal movement is ok, but keep it low
      posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
      return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
      var options = this.options;

      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;

      this.reset();

      if((input.eventType & INPUT_START) && (this.count === 0)) {
        return this.failTimeout();
      }

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if(validMovement && validTouchTime && validPointers) {
        if(input.eventType != INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if(!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input;

        // if tap count matches we have recognized it,
        // else it has began recognizing...
        var tapCount = this.count % options.taps;
        if(tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if(!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }
      return STATE_FAILED;
    },

    failTimeout: function() {
      this._timer = setTimeoutContext(function() {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },

    reset: function() {
      clearTimeout(this._timer);
    },

    emit: function() {
      if(this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });


  /**
   * Simple way to create an manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
    options = options || {};
    //配置手势识别器参数
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.4';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * 如果DOM事件被触发设置设置DOM事件
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
      // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
      [RotateRecognizer, { enable: false }],
      [PinchRecognizer, { enable: false },
        ['rotate']
      ],
      [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
      [PanRecognizer, { direction: DIRECTION_HORIZONTAL },
        ['swipe']
      ],
      [TapRecognizer],
      [TapRecognizer, { event: 'doubletap', taps: 2 },
        ['tap']
      ],
      [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: 'none',

      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: 'none',

      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: 'none',

      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: 'none',

      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: 'none',

      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };

  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    //存在on回调
    //swipe [callback1,callback2...]
    //tap [callback1,callback2...]
    this.handlers = {};

    this.session = {};

    //存放手势对象
    this.recognizers = [];

    this.element = element;

    //创建一个输入环境的实例对象
    //绑定事件与增加处理的句柄回调函数
    this.input = createInputInstance(this);

    //用于处理元素对touchAction的属性的支持
    if(!this.options.pixiContext) {
      this.touchAction = new TouchAction(this, this.options.touchAction);
      toggleCssProps(this, true);
    }

    //默认初始化手势
    each(options.recognizers, function(item) {
      //构建手势对象，增加到手势容器里面
      var recognizer = this.add(new(item[0])(item[1]));
      //如果有合并的手势处理
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }

  Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
      extend(this.options, options);

      // Options that need a little more setup
      if(options.touchAction) {
        this.touchAction.update();
      }
      if(options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }
      return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
      var session = this.session;
      if(session.stopped) {
        return;
      }

      // run the touch-action polyfill
      this.touchAction && this.touchAction.preventDefaults(inputData);

      var recognizer;
      var recognizers = this.recognizers;

      // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`
      var curRecognizer = session.curRecognizer;

      // reset when the last recognizer is recognized
      // or when we're in a new session
      if(!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
        curRecognizer = session.curRecognizer = null;
      }

      var i = 0;
      while(i < recognizers.length) {
        recognizer = recognizers[i];
        // find out if we are allowed try to recognize the input for this one.
        // 果我们允许尝试识别的输入，找到它
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.
        if(session.stopped !== FORCED_STOP && ( // 1
            !curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) { // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        }

        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer
        if(!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }
        i++;
      }
    },

    /**
     * get a recognizer by its event name.
     * 通过手势的事件名得到手势对象
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
      if(recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;
      for(var i = 0; i < recognizers.length; i++) {
        if(recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }
      return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
      if(invokeArrayArg(recognizer, 'add', this)) {
        return this;
      }

      // remove existing
      // 如果存在指定手势，删除
      var existing = this.get(recognizer.options.event);
      if(existing) {
        this.remove(existing);
      }

      //加入管理队列
      this.recognizers.push(recognizer);
      recognizer.manager = this;

      //更新touchAction属性
      this.touchAction && this.touchAction.update();
      return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
      if(invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }

      var recognizers = this.recognizers;
      recognizer = this.get(recognizer);
      recognizers.splice(inArray(recognizers, recognizer), 1);

      this.touchAction && this.touchAction.update();
      return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function(event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function(event) {
        if(!handler) {
          delete handlers[event];
        } else {
          handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
      // we also want to trigger dom events
      if(this.options.domEvents) {
        triggerDomEvent(event, data);
      }

      // no handlers, so skip it all
      var handlers = this.handlers[event] && this.handlers[event].slice();
      if(!handlers || !handlers.length) {
        return;
      }

      data.type = event;
      data.preventDefault = function() {
        data.srcEvent.preventDefault();
      };

      var i = 0;
      while(i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
      this.element && toggleCssProps(this, false);

      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
      element.style[prefixed(element.style, name)] = add ? value : '';
    });
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }

  extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  });

  if(typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
      return Hammer;
    });
  } else if(typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
  } else {
    window[exportName] = Hammer;
  }

})(window, document, 'Hammer');
(function(fn) {
  /* istanbul ignore if  */
  if(typeof module === 'undefined') {
    this.charming = fn;
  } else {
    module.exports = fn;
  }
})(function(elem, opts) {

  'use strict';

  opts = opts || {};
  var tagName = opts.tagName || 'span';
  var classPrefix = opts.classPrefix != null ? opts.classPrefix : 'char';

  var count = 1;

  var inject = function(elem) {
    var parentNode = elem.parentNode;
    var str = elem.nodeValue;
    var len = str.length;
    var i = -1;
    while(++i < len) {
      var node = document.createElement(tagName);
      if(classPrefix) {
        node.className = classPrefix + count;
        count++;
      }
      node.appendChild(document.createTextNode(str[i]));
      parentNode.insertBefore(node, elem);
    }
    parentNode.removeChild(elem);
  };

  (function traverse(elem) {
    var childNodes = [].slice.call(elem.childNodes); // static array of nodes
    var len = childNodes.length;
    var i = -1;
    while(++i < len) {
      traverse(childNodes[i]);
    }
    if(elem.nodeType === Node.TEXT_NODE) {
      inject(elem);
    }
  })(elem);

  return elem;

});
/*
 * Anime v1.1.3
 * http://anime-js.com
 * JavaScript animation engine
 * Copyright (c) 2016 Julian Garnier
 * http://juliangarnier.com
 * Released under the MIT license
 */

(function(root, factory) {
  if(typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if(typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.anime = factory();
  }
}(this, function() {

  var version = '1.1.3';

  // Defaults

  var defaultSettings = {
    duration: 1000,
    delay: 0,
    loop: false,
    autoplay: true,
    direction: 'normal',
    easing: 'easeOutElastic',
    elasticity: 400,
    round: false,
    begin: undefined,
    update: undefined,
    complete: undefined
  }

  // Transforms

  var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY'];
  var transform, transformStr = 'transform';

  // Utils

  var is = {
    arr: function(a) {
      return Array.isArray(a)
    },
    obj: function(a) {
      return Object.prototype.toString.call(a).indexOf('Object') > -1
    },
    svg: function(a) {
      return a instanceof SVGElement
    },
    dom: function(a) {
      return a.nodeType || is.svg(a)
    },
    num: function(a) {
      return !isNaN(parseInt(a))
    },
    str: function(a) {
      return typeof a === 'string'
    },
    fnc: function(a) {
      return typeof a === 'function'
    },
    und: function(a) {
      return typeof a === 'undefined'
    },
    nul: function(a) {
      return typeof a === 'null'
    },
    hex: function(a) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)
    },
    rgb: function(a) {
      return /^rgb/.test(a)
    },
    hsl: function(a) {
      return /^hsl/.test(a)
    },
    col: function(a) {
      return(is.hex(a) || is.rgb(a) || is.hsl(a))
    }
  }

  // Easings functions adapted from http://jqueryui.com/

  var easings = (function() {
    var eases = {};
    var names = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
    var functions = {
      Sine: function(t) {
        return 1 + Math.sin(Math.PI / 2 * t - Math.PI / 2);
      },
      Circ: function(t) {
        return 1 - Math.sqrt(1 - t * t);
      },
      Elastic: function(t, m) {
        if(t === 0 || t === 1) return t;
        var p = (1 - Math.min(m, 998) / 1000),
          st = t / 1,
          st1 = st - 1,
          s = p / (2 * Math.PI) * Math.asin(1);
        return -(Math.pow(2, 10 * st1) * Math.sin((st1 - s) * (2 * Math.PI) / p));
      },
      Back: function(t) {
        return t * t * (3 * t - 2);
      },
      Bounce: function(t) {
        var pow2, bounce = 4;
        while(t < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      }
    }
    names.forEach(function(name, i) {
      functions[name] = function(t) {
        return Math.pow(t, i + 2);
      }
    });
    Object.keys(functions).forEach(function(name) {
      var easeIn = functions[name];
      eases['easeIn' + name] = easeIn;
      eases['easeOut' + name] = function(t, m) {
        return 1 - easeIn(1 - t, m);
      };
      eases['easeInOut' + name] = function(t, m) {
        return t < 0.5 ? easeIn(t * 2, m) / 2 : 1 - easeIn(t * -2 + 2, m) / 2;
      };
      eases['easeOutIn' + name] = function(t, m) {
        return t < 0.5 ? (1 - easeIn(1 - 2 * t, m)) / 2 : (easeIn(t * 2 - 1, m) + 1) / 2;
      };
    });
    eases.linear = function(t) {
      return t;
    };
    return eases;
  })();

  // Strings

  var numberToString = function(val) {
    return(is.str(val)) ? val : val + '';
  }

  var stringToHyphens = function(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }

  var selectString = function(str) {
    if(is.col(str)) return false;
    try {
      var nodes = document.querySelectorAll(str);
      return nodes;
    } catch(e) {
      return false;
    }
  }

  // Numbers

  var random = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Arrays

  var flattenArray = function(arr) {
    return arr.reduce(function(a, b) {
      return a.concat(is.arr(b) ? flattenArray(b) : b);
    }, []);
  }

  var toArray = function(o) {
    if(is.arr(o)) return o;
    if(is.str(o)) o = selectString(o) || o;
    if(o instanceof NodeList || o instanceof HTMLCollection) return [].slice.call(o);
    return [o];
  }

  var arrayContains = function(arr, val) {
    return arr.some(function(a) {
      return a === val;
    });
  }

  var groupArrayByProps = function(arr, propsArr) {
    var groups = {};
    arr.forEach(function(o) {
      var group = JSON.stringify(propsArr.map(function(p) {
        return o[p];
      }));
      groups[group] = groups[group] || [];
      groups[group].push(o);
    });
    return Object.keys(groups).map(function(group) {
      return groups[group];
    });
  }

  var removeArrayDuplicates = function(arr) {
    return arr.filter(function(item, pos, self) {
      return self.indexOf(item) === pos;
    });
  }

  // Objects

  var cloneObject = function(o) {
    var newObject = {};
    for(var p in o) newObject[p] = o[p];
    return newObject;
  }

  var mergeObjects = function(o1, o2) {
    for(var p in o2) o1[p] = !is.und(o1[p]) ? o1[p] : o2[p];
    return o1;
  }

  // Colors

  var hexToRgb = function(hex) {
    var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    var hex = hex.replace(rgx, function(m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    var r = parseInt(rgb[1], 16);
    var g = parseInt(rgb[2], 16);
    var b = parseInt(rgb[3], 16);
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  }

  var hslToRgb = function(hsl) {
    var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hsl);
    var h = parseInt(hsl[1]) / 360;
    var s = parseInt(hsl[2]) / 100;
    var l = parseInt(hsl[3]) / 100;
    var hue2rgb = function(p, q, t) {
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1 / 6) return p + (q - p) * 6 * t;
      if(t < 1 / 2) return q;
      if(t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    var r, g, b;
    if(s == 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return 'rgb(' + r * 255 + ',' + g * 255 + ',' + b * 255 + ')';
  }

  var colorToRgb = function(val) {
    if(is.rgb(val)) return val;
    if(is.hex(val)) return hexToRgb(val);
    if(is.hsl(val)) return hslToRgb(val);
  }

  // Units

  var getUnit = function(val) {
    return /([\+\-]?[0-9|auto\.]+)(%|px|pt|em|rem|in|cm|mm|ex|pc|vw|vh|deg)?/.exec(val)[2];
  }

  var addDefaultTransformUnit = function(prop, val, intialVal) {
    if(getUnit(val)) return val;
    if(prop.indexOf('translate') > -1) return getUnit(intialVal) ? val + getUnit(intialVal) : val + 'px';
    if(prop.indexOf('rotate') > -1 || prop.indexOf('skew') > -1) return val + 'deg';
    return val;
  }

  // Values

  var getCSSValue = function(el, prop) {
    // First check if prop is a valid CSS property
    if(prop in el.style) {
      // Then return the property value or fallback to '0' when getPropertyValue fails
      return getComputedStyle(el).getPropertyValue(stringToHyphens(prop)) || '0';
    }
  }

  var getTransformValue = function(el, prop) {
    var defaultVal = prop.indexOf('scale') > -1 ? 1 : 0;
    var str = el.style.transform;
    if(!str) return defaultVal;
    var rgx = /(\w+)\((.+?)\)/g;
    var match = [];
    var props = [];
    var values = [];
    while(match = rgx.exec(str)) {
      props.push(match[1]);
      values.push(match[2]);
    }
    var val = values.filter(function(f, i) {
      return props[i] === prop;
    });
    return val.length ? val[0] : defaultVal;
  }

  var getAnimationType = function(el, prop) {
    if(is.dom(el) && arrayContains(validTransforms, prop)) return 'transform';
    if(is.dom(el) && (el.getAttribute(prop) || (is.svg(el) && el[prop]))) return 'attribute';
    if(is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) return 'css';
    if(!is.nul(el[prop]) && !is.und(el[prop])) return 'object';
  }

  var getInitialTargetValue = function(target, prop) {
    switch(getAnimationType(target, prop)) {
      case 'transform':
        return getTransformValue(target, prop);
      case 'css':
        return getCSSValue(target, prop);
      case 'attribute':
        return target.getAttribute(prop);
    }
    return target[prop] || 0;
  }

  var getValidValue = function(values, val, originalCSS) {
    if(is.col(val)) return colorToRgb(val);
    if(getUnit(val)) return val;
    var unit = getUnit(values.to) ? getUnit(values.to) : getUnit(values.from);
    if(!unit && originalCSS) unit = getUnit(originalCSS);
    return unit ? val + unit : val;
  }

  var decomposeValue = function(val) {
    var rgx = /-?\d*\.?\d+/g;
    return {
      original: val,
      numbers: numberToString(val).match(rgx) ? numberToString(val).match(rgx).map(Number) : [0],
      strings: numberToString(val).split(rgx)
    }
  }

  var recomposeValue = function(numbers, strings, initialStrings) {
    return strings.reduce(function(a, b, i) {
      var b = (b ? b : initialStrings[i - 1]);
      return a + numbers[i - 1] + b;
    });
  }

  // Animatables

  var getAnimatables = function(targets) {
    var targets = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
    return targets.map(function(t, i) {
      return { target: t, id: i };
    });
  }

  // Properties

  var getProperties = function(params, settings) {
    var props = [];
    for(var p in params) {
      if(!defaultSettings.hasOwnProperty(p) && p !== 'targets') {
        var prop = is.obj(params[p]) ? cloneObject(params[p]) : { value: params[p] };
        prop.name = p;
        props.push(mergeObjects(prop, settings));
      }
    }
    return props;
  }

  var getPropertiesValues = function(target, prop, value, i) {
    var values = toArray(is.fnc(value) ? value(target, i) : value);
    return {
      from: (values.length > 1) ? values[0] : getInitialTargetValue(target, prop),
      to: (values.length > 1) ? values[1] : values[0]
    }
  }

  // Tweens

  var getTweenValues = function(prop, values, type, target) {
    var valid = {};
    if(type === 'transform') {
      valid.from = prop + '(' + addDefaultTransformUnit(prop, values.from, values.to) + ')';
      valid.to = prop + '(' + addDefaultTransformUnit(prop, values.to) + ')';
    } else {
      var originalCSS = (type === 'css') ? getCSSValue(target, prop) : undefined;
      valid.from = getValidValue(values, values.from, originalCSS);
      valid.to = getValidValue(values, values.to, originalCSS);
    }
    return { from: decomposeValue(valid.from), to: decomposeValue(valid.to) };
  }

  var getTweensProps = function(animatables, props) {
    var tweensProps = [];
    animatables.forEach(function(animatable, i) {
      var target = animatable.target;
      return props.forEach(function(prop) {
        var animType = getAnimationType(target, prop.name);
        if(animType) {
          var values = getPropertiesValues(target, prop.name, prop.value, i);
          var tween = cloneObject(prop);
          tween.animatables = animatable;
          tween.type = animType;
          tween.from = getTweenValues(prop.name, values, tween.type, target).from;
          tween.to = getTweenValues(prop.name, values, tween.type, target).to;
          tween.round = (is.col(values.from) || tween.round) ? 1 : 0;
          tween.delay = (is.fnc(tween.delay) ? tween.delay(target, i, animatables.length) : tween.delay) / animation.speed;
          tween.duration = (is.fnc(tween.duration) ? tween.duration(target, i, animatables.length) : tween.duration) / animation.speed;
          tweensProps.push(tween);
        }
      });
    });
    return tweensProps;
  }

  var getTweens = function(animatables, props) {
    var tweensProps = getTweensProps(animatables, props);
    var splittedProps = groupArrayByProps(tweensProps, ['name', 'from', 'to', 'delay', 'duration']);
    return splittedProps.map(function(tweenProps) {
      var tween = cloneObject(tweenProps[0]);
      tween.animatables = tweenProps.map(function(p) {
        return p.animatables
      });
      tween.totalDuration = tween.delay + tween.duration;
      return tween;
    });
  }

  var reverseTweens = function(anim, delays) {
    anim.tweens.forEach(function(tween) {
      var toVal = tween.to;
      var fromVal = tween.from;
      var delayVal = anim.duration - (tween.delay + tween.duration);
      tween.from = toVal;
      tween.to = fromVal;
      if(delays) tween.delay = delayVal;
    });
    anim.reversed = anim.reversed ? false : true;
  }

  var getTweensDuration = function(tweens) {
    return Math.max.apply(Math, tweens.map(function(tween) {
      return tween.totalDuration;
    }));
  }

  var getTweensDelay = function(tweens) {
    return Math.min.apply(Math, tweens.map(function(tween) {
      return tween.delay;
    }));
  }

  // will-change

  var getWillChange = function(anim) {
    var props = [];
    var els = [];
    anim.tweens.forEach(function(tween) {
      if(tween.type === 'css' || tween.type === 'transform') {
        props.push(tween.type === 'css' ? stringToHyphens(tween.name) : 'transform');
        tween.animatables.forEach(function(animatable) { els.push(animatable.target); });
      }
    });
    return {
      properties: removeArrayDuplicates(props).join(', '),
      elements: removeArrayDuplicates(els)
    }
  }

  var setWillChange = function(anim) {
    var willChange = getWillChange(anim);
    willChange.elements.forEach(function(element) {
      element.style.willChange = willChange.properties;
    });
  }

  var removeWillChange = function(anim) {
    var willChange = getWillChange(anim);
    willChange.elements.forEach(function(element) {
      element.style.removeProperty('will-change');
    });
  }

  /* Svg path */

  var getPathProps = function(path) {
    var el = is.str(path) ? selectString(path)[0] : path;
    return {
      path: el,
      value: el.getTotalLength()
    }
  }

  var snapProgressToPath = function(tween, progress) {
    var pathEl = tween.path;
    var pathProgress = tween.value * progress;
    var point = function(offset) {
      var o = offset || 0;
      var p = progress > 1 ? tween.value + o : pathProgress + o;
      return pathEl.getPointAtLength(p);
    }
    var p = point();
    var p0 = point(-1);
    var p1 = point(+1);
    switch(tween.name) {
      case 'translateX':
        return p.x;
      case 'translateY':
        return p.y;
      case 'rotate':
        return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
    }
  }

  // Progress

  var getTweenProgress = function(tween, time) {
    var elapsed = Math.min(Math.max(time - tween.delay, 0), tween.duration);
    var percent = elapsed / tween.duration;
    var progress = tween.to.numbers.map(function(number, p) {
      var start = tween.from.numbers[p];
      var eased = easings[tween.easing](percent, tween.elasticity);
      var val = tween.path ? snapProgressToPath(tween, eased) : start + eased * (number - start);
      val = tween.round ? Math.round(val * tween.round) / tween.round : val;
      return val;
    });
    return recomposeValue(progress, tween.to.strings, tween.from.strings);
  }

  var setAnimationProgress = function(anim, time) {
    var transforms;
    anim.currentTime = time;
    anim.progress = (time / anim.duration) * 100;
    for(var t = 0; t < anim.tweens.length; t++) {
      var tween = anim.tweens[t];
      tween.currentValue = getTweenProgress(tween, time);
      var progress = tween.currentValue;
      for(var a = 0; a < tween.animatables.length; a++) {
        var animatable = tween.animatables[a];
        var id = animatable.id;
        var target = animatable.target;
        var name = tween.name;
        switch(tween.type) {
          case 'css':
            target.style[name] = progress;
            break;
          case 'attribute':
            target.setAttribute(name, progress);
            break;
          case 'object':
            target[name] = progress;
            break;
          case 'transform':
            if(!transforms) transforms = {};
            if(!transforms[id]) transforms[id] = [];
            transforms[id].push(progress);
            break;
        }
      }
    }
    if(transforms) {
      if(!transform) transform = (getCSSValue(document.body, transformStr) ? '' : '-webkit-') + transformStr;
      for(var t in transforms) {
        anim.animatables[t].target.style[transform] = transforms[t].join(' ');
      }
    }
  }

  // Animation

  var createAnimation = function(params) {
    var anim = {};
    anim.animatables = getAnimatables(params.targets);
    anim.settings = mergeObjects(params, defaultSettings);
    anim.properties = getProperties(params, anim.settings);
    anim.tweens = getTweens(anim.animatables, anim.properties);
    anim.duration = anim.tweens.length ? getTweensDuration(anim.tweens) : params.duration;
    anim.delay = anim.tweens.length ? getTweensDelay(anim.tweens) : params.delay;
    anim.currentTime = 0;
    anim.progress = 0;
    anim.ended = false;
    return anim;
  }

  // Public

  var animations = [];
  var raf = 0;

  var engine = (function() {
    var play = function() { raf = requestAnimationFrame(step); };
    var step = function(t) {
      if(animations.length) {
        for(var i = 0; i < animations.length; i++) animations[i].tick(t);
        play();
      } else {
        cancelAnimationFrame(raf);
        raf = 0;
      }
    }
    return play;
  })();

  var animation = function(params) {

    var anim = createAnimation(params);
    var time = {};

    anim.tick = function(now) {
      anim.ended = false;
      if(!time.start) time.start = now;
      time.current = Math.min(Math.max(time.last + now - time.start, 0), anim.duration);
      setAnimationProgress(anim, time.current);
      var s = anim.settings;
      if(time.current >= anim.delay) {
        if(s.begin) s.begin(anim);
        s.begin = undefined;
        if(s.update) s.update(anim);
      }
      if(time.current >= anim.duration) {
        if(s.loop) {
          time.start = now;
          if(s.direction === 'alternate') reverseTweens(anim, true);
          if(is.num(s.loop)) s.loop--;
        } else {
          anim.ended = true;
          anim.pause();
          if(s.complete) s.complete(anim);
        }
        time.last = 0;
      }
    }

    anim.seek = function(progress) {
      setAnimationProgress(anim, (progress / 100) * anim.duration);
    }

    anim.pause = function() {
      removeWillChange(anim);
      var i = animations.indexOf(anim);
      if(i > -1) animations.splice(i, 1);
    }

    anim.play = function(params) {
      anim.pause();
      if(params) anim = mergeObjects(createAnimation(mergeObjects(params, anim.settings)), anim);
      time.start = 0;
      time.last = anim.ended ? 0 : anim.currentTime;
      var s = anim.settings;
      if(s.direction === 'reverse') reverseTweens(anim);
      if(s.direction === 'alternate' && !s.loop) s.loop = 1;
      setWillChange(anim);
      animations.push(anim);
      if(!raf) engine();
    }

    anim.restart = function() {
      if(anim.reversed) reverseTweens(anim);
      anim.pause();
      anim.seek(0);
      anim.play();
    }

    if(anim.settings.autoplay) anim.play();

    return anim;

  }

  // Remove one or multiple targets from all active animations.

  var remove = function(elements) {
    var targets = flattenArray(is.arr(elements) ? elements.map(toArray) : toArray(elements));
    for(var i = animations.length - 1; i >= 0; i--) {
      var animation = animations[i];
      var tweens = animation.tweens;
      for(var t = tweens.length - 1; t >= 0; t--) {
        var animatables = tweens[t].animatables;
        for(var a = animatables.length - 1; a >= 0; a--) {
          if(arrayContains(targets, animatables[a].target)) {
            animatables.splice(a, 1);
            if(!animatables.length) tweens.splice(t, 1);
            if(!tweens.length) animation.pause();
          }
        }
      }
    }
  }

  animation.version = version;
  animation.speed = 1;
  animation.list = animations;
  animation.remove = remove;
  animation.easings = easings;
  animation.getValue = getInitialTargetValue;
  animation.path = getPathProps;
  animation.random = random;

  return animation;

}));
/**
 * TextFx.js
 * http://www.codrops.com
 *
 * Licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
 * 
 * Copyright 2016, Codrops
 * http://www.codrops.com
 */
;
(function(window) {

  'use strict';

  /**
   * Equation of a line.
   */
  function lineEq(y2, y1, x2, x1, currentVal) {
    // y = mx + b
    var m = (y2 - y1) / (x2 - x1),
      b = y1 - m * x1;

    return m * currentVal + b;
  }

  function TextFx(el) {
    this.el = el;
    this._init();
  }

  TextFx.prototype.effects = {
    'fx1': { in: {
        duration: 1000,
        delay: function(el, index) {
          return 75 + index * 40;
        },
        easing: 'easeOutElastic',
        elasticity: 650,
        opacity: {
          value: 1,
          easing: 'easeOutExpo',
        },
        translateY: ['50%', '0%']
      },
      out: {
        duration: 400,
        delay: function(el, index) {
          return index * 40;
        },
        easing: 'easeOutExpo',
        opacity: 0,
        translateY: '-100%'
      }
    },
    'fx2': { in: {
        duration: 800,
        delay: function(el, index) {
          return index * 50;
        },
        easing: 'easeOutElastic',
        opacity: 1,
        translateY: function(el, index) {
          return index % 2 === 0 ? ['-80%', '0%'] : ['80%', '0%'];
        }
      },
      out: {
        duration: 800,
        delay: function(el, index) {
          return index * 50;
        },
        easing: 'easeOutExpo',
        opacity: 0,
        translateY: function(el, index) {
          return index % 2 === 0 ? '80%' : '-80%';
        }
      }
    },
    'fx3': { in: {
        duration: 700,
        delay: function(el, index) {
          return index * 50;
        },
        easing: 'easeOutCirc',
        opacity: 1,
        translateX: function(el, index) {
          return [(50 + index * 10), 0]
        }
      },
      out: {
        duration: 0,
        opacity: 0
      }
    },
    'fx4': { in: {
        duration: 650,
        easing: 'easeOutQuint',
        delay: function(el, index) {
          return 450 + (el.parentNode.children.length - index - 1) * 30;
        },
        opacity: 1,
        translateX: function(el, index) {
          return [-1 * el.offsetLeft, 0];
        }
      },
      out: {
        duration: 1,
        delay: 400,
        opacity: 0
      }
    },
    'fx5': { in: {
        duration: 250,
        delay: function(el, index) {
          return 200 + index * 25;
        },
        easing: 'easeOutCubic',
        opacity: 1,
        translateY: ['-50%', '0%']
      },
      out: {
        duration: 250,
        delay: function(el, index) {
          return index * 25;
        },
        easing: 'easeOutCubic',
        opacity: 0,
        translateY: '50%'
      }
    },
    'fx6': { in: {
        duration: function(el, index) {
          return anime.random(800, 1000)
        },
        delay: function(el, index) {
          return anime.random(0, 75)
        },
        easing: 'easeInOutExpo',
        opacity: 1,
        translateY: ['-300%', '0%'],
        rotateZ: function(el, index) {
          return [anime.random(-50, 50), 0];
        }
      },
      out: {
        duration: function(el, index) {
          return anime.random(800, 1000)
        },
        delay: function(el, index) {
          return anime.random(0, 80)
        },
        easing: 'easeInOutExpo',
        opacity: 0,
        translateY: '300%',
        rotateZ: function(el, index) {
          return anime.random(-50, 50);
        }
      }
    },
    'fx7': { in: {
        duration: 800,
        delay: function(el, index) {
          return 600 + index * 150;
        },
        easing: 'easeInOutQuint',
        opacity: 1,
        scaleY: [8, 1],
        scaleX: [0.5, 1],
        translateY: ['-100%', '0%']
      },
      out: {
        duration: 800,
        delay: function(el, index) {
          return index * 150;
        },
        easing: 'easeInQuint',
        opacity: 0,
        scaleY: {
          value: 8,
          delay: function(el, index) {
            return 100 + index * 150;
          },
        },
        scaleX: 0.5,
        translateY: '100%'
      }
    },
    'fx8': {
      perspective: 1000,
      origin: '50% 100%',
      in: {
        duration: 400,
        delay: function(el, index) {
          return index * 50;
        },
        easing: 'easeOutSine',
        opacity: 1,
        rotateY: [-90, 0]
      },
      out: {
        duration: 200,
        delay: function(el, index) {
          return index * 50;
        },
        easing: 'easeOutSine',
        opacity: 0,
        rotateY: 45
      }
    },
    'fx9': {
      perspective: 1000,
      in: {
        duration: 400,
        delay: function(el, index) {
          return 100 + index * 50;
        },
        easing: 'easeOutExpo',
        opacity: 1,
        rotateX: [110, 0]
      },
      out: {
        duration: 400,
        delay: function(el, index) {
          return index * 50;
        },
        easing: 'easeOutExpo',
        opacity: 0,
        rotateX: -110
      }
    },

    'fx10': {
      perspective: 1000,
      origin: '50% 100%',
      in: {
        duration: 400,
        delay: function(el, index) {
          return 200 + index * 20;
        },
        easing: 'easeOutExpo',
        opacity: 1,
        rotateY: [-90, 0]
      },
      out: {
        duration: 400,
        delay: function(el, index) {
          return index * 20;
        },
        easing: 'easeOutExpo',
        opacity: 0,
        rotateY: 90
      }
    },
    'fx11': {
      perspective: 1000,
      origin: '50% 100%',
      in: {
        duration: 400,
        delay: function(el, index) {
          return 200 + index * 30;
        },
        easing: 'easeOutExpo',
        opacity: 1,
        rotateX: [90, 0]
      },
      out: {
        duration: 400,
        delay: function(el, index) {
          return index * 30;
        },
        easing: 'easeOutExpo',
        opacity: 0,
        rotateX: -90
      }
    },
    'fx12': { in: {
        duration: 700,
        delay: function(el, index) {
          return(el.parentNode.children.length - index - 1) * 80;
        },
        easing: 'easeOutElastic',
        opacity: 1,
        translateY: function(el, index) {
          return index % 2 === 0 ? ['-80%', '0%'] : ['80%', '0%'];
        },
        rotateZ: [90, 0]
      },
      out: {
        duration: 500,
        delay: function(el, index) {
          return(el.parentNode.children.length - index - 1) * 80;
        },
        easing: 'easeOutExpo',
        opacity: 0,
        translateY: function(el, index) {
          return index % 2 === 0 ? '80%' : '-80%';
        },
        rotateZ: function(el, index) {
          return index % 2 === 0 ? -25 : 25;
        }
      }
    },
    'fx13': {
      perspective: 1000,
      in: {
        duration: 700,
        delay: function(el, index) {
          return 550 + index * 50;
        },
        easing: 'easeOutQuint',
        opacity: {
          value: 1,
          easing: 'linear',
        },
        translateY: ['-150%', '0%'],
        rotateY: [180, 0]
      },
      out: {
        duration: 700,
        delay: function(el, index) {
          return index * 60;
        },
        easing: 'easeInQuint',
        opacity: {
          value: 0,
          easing: 'linear',
        },
        translateY: '150%',
        rotateY: -180
      }
    },
    'fx14': { in: {
        duration: 600,
        easing: 'easeOutQuart',
        opacity: 1,
        translateY: function(el, index) {
          return index % 2 === 0 ? ['-40%', '0%'] : ['40%', '0%'];
        },
        rotateZ: [10, 0]
      },
      out: {
        duration: 0,
        opacity: 0
      }
    },

    'fx15': { in: {
        duration: 400,
        delay: function(el, index) {
          return 150 + (el.parentNode.children.length - index - 1) * 20;
        },
        easing: 'easeOutQuad',
        opacity: 1,
        translateY: ['100%', '0%']
      },
      out: {
        duration: 400,
        delay: function(el, index) {
          return(el.parentNode.children.length - index - 1) * 20;
        },
        easing: 'easeInOutQuad',
        opacity: 0,
        translateY: '-100%'
      }
    },

    'fx16': { in: {
        duration: 1000,
        delay: function(el, index) {
          return 100 + index * 30;
        },
        easing: 'easeOutElastic',
        elasticity: anime.random(400, 700),
        opacity: 1,
        rotateZ: function(el, index) {
          return [anime.random(20, 40), 0];
        }
      },
      out: {
        duration: 0,
        opacity: 0
      }
    },

    'fx17': { in: {
        duration: 800,
        easing: 'easeOutExpo',
        opacity: 1,
        translateY: function(el, index) {
          var p = el.parentNode,
            lastElOffW = p.lastElementChild.offsetWidth,
            firstElOffL = p.firstElementChild.offsetLeft,
            w = p.offsetWidth - lastElOffW - firstElOffL - (p.offsetWidth - lastElOffW - p.lastElementChild.offsetLeft),
            tyVal = lineEq(0, 200, firstElOffL + w / 2, firstElOffL, el.offsetLeft);

          return [Math.abs(tyVal) + 50 + '%', '0%'];
        },
        rotateZ: function(el, index) {
          var p = el.parentNode,
            lastElOffW = p.lastElementChild.offsetWidth,
            firstElOffL = p.firstElementChild.offsetLeft,
            w = p.offsetWidth - lastElOffW - p.firstElementChild.offsetLeft - (p.offsetWidth - lastElOffW - p.lastElementChild.offsetLeft),
            rz = lineEq(90, -90, firstElOffL + w, firstElOffL, el.offsetLeft);

          return [rz, 0];
        }
      },
      out: {
        duration: 500,
        easing: 'easeOutExpo',
        opacity: 0,
        translateY: '-150%'
      }
    },
    'fx18': { in: {
        duration: 500,
        easing: 'easeOutExpo',
        delay: function(el, index) {
          return 200 + index * 30;
        },
        opacity: 1,
        rotateZ: [20, 0],
        translateY: function(el, index) {
          var p = el.parentNode,
            lastElOffW = p.lastElementChild.offsetWidth,
            firstElOffL = p.firstElementChild.offsetLeft,
            w = p.offsetWidth - lastElOffW - firstElOffL - (p.offsetWidth - lastElOffW - p.lastElementChild.offsetLeft),
            tyVal = lineEq(-130, -60, firstElOffL + w, firstElOffL, el.offsetLeft);

          return [Math.abs(tyVal) + '%', '0%'];
        }
      },
      out: {
        duration: 400,
        easing: 'easeOutExpo',
        delay: function(el, index) {
          return(el.parentNode.children.length - index - 1) * 30;
        },
        opacity: 0,
        rotateZ: 20,
        translateY: function(el, index) {
          var p = el.parentNode,
            lastElOffW = p.lastElementChild.offsetWidth,
            firstElOffL = p.firstElementChild.offsetLeft,
            w = p.offsetWidth - lastElOffW - firstElOffL - (p.offsetWidth - lastElOffW - p.lastElementChild.offsetLeft),
            tyVal = lineEq(-60, -130, firstElOffL + w, firstElOffL, el.offsetLeft);

          return tyVal + '%';
        }
      }
    }
  };

  TextFx.prototype._init = function() {
    this.el.classList.add('letter-effect');
    // Split word(s) into letters/spans.
    charming(this.el, { classPrefix: 'letter' });
    this.letters = [].slice.call(this.el.querySelectorAll('span'));
    this.lettersTotal = this.letters.length;
  };

  TextFx.prototype._stop = function() {
    anime.remove(this.letters);
    this.letters.forEach(function(letter) { letter.style.WebkitTransform = letter.style.transform = ''; });
  };

  TextFx.prototype.show = function(effect, callback) {
    this._stop();
    arguments.length ? this._animate('in', effect, callback) : this.letters.forEach(function(letter) { letter.style.opacity = 1; });
  };

  TextFx.prototype.hide = function(effect, callback) {
    this._stop();
    arguments.length ? this._animate('out', effect, callback) : this.letters.forEach(function(letter) { letter.style.opacity = 0; });
  };

  TextFx.prototype._animate = function(direction, effect, callback) {
    var effecSettings = typeof effect === 'string' ? this.effects[effect] : effect;

    if(effecSettings.perspective != undefined) {
      this.el.style.WebkitPerspective = this.el.style.perspective = effecSettings.perspective + 'px';
    }
    if(effecSettings.origin != undefined) {
      this.letters.forEach(function(letter) {
        letter.style.WebkitTransformOrigin = letter.style.transformOrigin = effecSettings.origin;
      });
    }

    // Custom effect
    var iscustom = this._checkCustomFx(direction, effect, callback);

    var animOpts = effecSettings[direction],
      target = this.letters;

    target.forEach(function(t, p) {
      if(t.innerHTML === ' ') {
        target.splice(p, 1);
      }
    });

    animOpts.targets = target;

    if(!iscustom) {
      animOpts.complete = callback;
    }

    anime(animOpts);
  };

  /**
   * Extra stuff for an effect.. this is just an example for effect 17.
   * TODO! (for now, just some quick way to implement something different only for fx17)
   */
  TextFx.prototype._checkCustomFx = function(direction, effect, callback) {
    var custom = typeof effect === 'string' && effect === 'fx17' && direction === 'out';

    if(custom) {
      var tmp = document.createElement('div');
      tmp.style.width = tmp.style.height = '100%';
      tmp.style.top = tmp.style.left = 0;
      tmp.style.background = '#e24b1e';
      tmp.style.position = 'absolute';
      tmp.style.WebkitTransform = tmp.style.transform = 'scale3d(0,1,1)';
      tmp.style.WebkitTransformOrigin = tmp.style.transformOrigin = '0% 50%';
      this.el.appendChild(tmp);
      var self = this;
      anime({
        targets: tmp,
        duration: 400,
        easing: 'easeInOutCubic',
        scaleX: [0, 1],
        complete: function() {
          tmp.style.WebkitTransformOrigin = tmp.style.transformOrigin = '100% 50%';
          anime({
            targets: tmp,
            duration: 400,
            easing: 'easeInOutCubic',
            scaleX: [1, 0],
            complete: function() {
              self.el.removeChild(tmp);
              if(typeof callback === 'function') {
                callback();
              }
            }
          });
        }
      });
    }

    return custom;
  };

  window.TextFx = TextFx;

})(window);
(function(factory) {
  if(typeof define === 'function' && define.amd) {
    define(['jquery', 'hammerjs'], factory);
  } else if(typeof exports === 'object') {
    factory(require('jquery'), require('hammerjs'));
  } else {
    factory(jQuery, Hammer);
  }
}(function($, Hammer) {
  function hammerify(el, options) {
    var $el = $(el);
    if(!$el.data("hammer")) {
      $el.data("hammer", new Hammer($el[0], options));
    }
  }

  $.fn.hammer = function(options) {
    return this.each(function() {
      hammerify(this, options);
    });
  };

  // extend the emit method to also trigger jQuery events
  Hammer.Manager.prototype.emit = (function(originalEmit) {
    return function(type, data) {
      originalEmit.call(this, type, data);
      $(this.element).trigger({
        type: type,
        gesture: data
      });
    };
  })(Hammer.Manager.prototype.emit);
}));
/*! jQuery UI - v1.12.1 - 2016-11-14
 * http://jqueryui.com
 * Includes: widget.js, keycode.js, widgets/mouse.js, widgets/slider.js
 * Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(factory) {
  if(typeof define === "function" && define.amd) {

    // AMD. Register as an anonymous module.
    define(["jquery"], factory);
  } else {

    // Browser globals
    factory(jQuery);
  }
}(function($) {

  $.ui = $.ui || {};

  var version = $.ui.version = "1.12.1";


  /*!
   * jQuery UI Widget 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Widget
  //>>group: Core
  //>>description: Provides a factory for creating stateful widgets with a common API.
  //>>docs: http://api.jqueryui.com/jQuery.widget/
  //>>demos: http://jqueryui.com/widget/



  var widgetUuid = 0;
  var widgetSlice = Array.prototype.slice;

  $.cleanData = (function(orig) {
    return function(elems) {
      var events, elem, i;
      for(i = 0;
        (elem = elems[i]) != null; i++) {
        try {

          // Only trigger remove when necessary to save time
          events = $._data(elem, "events");
          if(events && events.remove) {
            $(elem).triggerHandler("remove");
          }

          // Http://bugs.jquery.com/ticket/8235
        } catch(e) {}
      }
      orig(elems);
    };
  })($.cleanData);

  $.widget = function(name, base, prototype) {
    var existingConstructor, constructor, basePrototype;

    // ProxiedPrototype allows the provided prototype to remain unmodified
    // so that it can be used as a mixin for multiple widgets (#8876)
    var proxiedPrototype = {};

    var namespace = name.split(".")[0];
    name = name.split(".")[1];
    var fullName = namespace + "-" + name;

    if(!prototype) {
      prototype = base;
      base = $.Widget;
    }

    if($.isArray(prototype)) {
      prototype = $.extend.apply(null, [{}].concat(prototype));
    }

    // Create selector for plugin
    $.expr[":"][fullName.toLowerCase()] = function(elem) {
      return !!$.data(elem, fullName);
    };

    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function(options, element) {

      // Allow instantiation without "new" keyword
      if(!this._createWidget) {
        return new constructor(options, element);
      }

      // Allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if(arguments.length) {
        this._createWidget(options, element);
      }
    };

    // Extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,

      // Copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend({}, prototype),

      // Track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
    });

    basePrototype = new base();

    // We need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function(prop, value) {
      if(!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = (function() {
        function _super() {
          return base.prototype[prop].apply(this, arguments);
        }

        function _superApply(args) {
          return base.prototype[prop].apply(this, args);
        }

        return function() {
          var __super = this._super;
          var __superApply = this._superApply;
          var returnValue;

          this._super = _super;
          this._superApply = _superApply;

          returnValue = value.apply(this, arguments);

          this._super = __super;
          this._superApply = __superApply;

          return returnValue;
        };
      })();
    });
    constructor.prototype = $.widget.extend(basePrototype, {

      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
    }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if(existingConstructor) {
      $.each(existingConstructor._childConstructors, function(i, child) {
        var childPrototype = child.prototype;

        // Redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor,
          child._proto);
      });

      // Remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }

    $.widget.bridge(name, constructor);

    return constructor;
  };

  $.widget.extend = function(target) {
    var input = widgetSlice.call(arguments, 1);
    var inputIndex = 0;
    var inputLength = input.length;
    var key;
    var value;

    for(; inputIndex < inputLength; inputIndex++) {
      for(key in input[inputIndex]) {
        value = input[inputIndex][key];
        if(input[inputIndex].hasOwnProperty(key) && value !== undefined) {

          // Clone objects
          if($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ?
              $.widget.extend({}, target[key], value) :

              // Don't extend strings, arrays, etc. with objects
              $.widget.extend({}, value);

            // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };

  $.widget.bridge = function(name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function(options) {
      var isMethodCall = typeof options === "string";
      var args = widgetSlice.call(arguments, 1);
      var returnValue = this;

      if(isMethodCall) {

        // If this is an empty collection, we need to have the instance method
        // return undefined instead of the jQuery instance
        if(!this.length && options === "instance") {
          returnValue = undefined;
        } else {
          this.each(function() {
            var methodValue;
            var instance = $.data(this, fullName);

            if(options === "instance") {
              returnValue = instance;
              return false;
            }

            if(!instance) {
              return $.error("cannot call methods on " + name +
                " prior to initialization; " +
                "attempted to call method '" + options + "'");
            }

            if(!$.isFunction(instance[options]) || options.charAt(0) === "_") {
              return $.error("no such method '" + options + "' for " + name +
                " widget instance");
            }

            methodValue = instance[options].apply(instance, args);

            if(methodValue !== instance && methodValue !== undefined) {
              returnValue = methodValue && methodValue.jquery ?
                returnValue.pushStack(methodValue.get()) :
                methodValue;
              return false;
            }
          });
        }
      } else {

        // Allow multiple hashes to be passed on init
        if(args.length) {
          options = $.widget.extend.apply(null, [options].concat(args));
        }

        this.each(function() {
          var instance = $.data(this, fullName);
          if(instance) {
            instance.option(options || {});
            if(instance._init) {
              instance._init();
            }
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }

      return returnValue;
    };
  };

  $.Widget = function( /* options, element */ ) {};
  $.Widget._childConstructors = [];

  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",

    options: {
      classes: {},
      disabled: false,

      // Callbacks
      create: null
    },

    _createWidget: function(options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = widgetUuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;

      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      this.classesElementLookup = {};

      if(element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function(event) {
            if(event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ?

          // Element within the document
          element.ownerDocument :

          // Element is window or document
          element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }

      this.options = $.widget.extend({},
        this.options,
        this._getCreateOptions(),
        options);

      this._create();

      if(this.options.disabled) {
        this._setOptionDisabled(this.options.disabled);
      }

      this._trigger("create", null, this._getCreateEventData());
      this._init();
    },

    _getCreateOptions: function() {
      return {};
    },

    _getCreateEventData: $.noop,

    _create: $.noop,

    _init: $.noop,

    destroy: function() {
      var that = this;

      this._destroy();
      $.each(this.classesElementLookup, function(key, value) {
        that._removeClass(value, key);
      });

      // We can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element
        .off(this.eventNamespace)
        .removeData(this.widgetFullName);
      this.widget()
        .off(this.eventNamespace)
        .removeAttr("aria-disabled");

      // Clean up events and states
      this.bindings.off(this.eventNamespace);
    },

    _destroy: $.noop,

    widget: function() {
      return this.element;
    },

    option: function(key, value) {
      var options = key;
      var parts;
      var curOption;
      var i;

      if(arguments.length === 0) {

        // Don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }

      if(typeof key === "string") {

        // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split(".");
        key = parts.shift();
        if(parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for(i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if(arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if(arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }

      this._setOptions(options);

      return this;
    },

    _setOptions: function(options) {
      var key;

      for(key in options) {
        this._setOption(key, options[key]);
      }

      return this;
    },

    _setOption: function(key, value) {
      if(key === "classes") {
        this._setOptionClasses(value);
      }

      this.options[key] = value;

      if(key === "disabled") {
        this._setOptionDisabled(value);
      }

      return this;
    },

    _setOptionClasses: function(value) {
      var classKey, elements, currentElements;

      for(classKey in value) {
        currentElements = this.classesElementLookup[classKey];
        if(value[classKey] === this.options.classes[classKey] ||
          !currentElements ||
          !currentElements.length) {
          continue;
        }

        // We are doing this to create a new jQuery object because the _removeClass() call
        // on the next line is going to destroy the reference to the current elements being
        // tracked. We need to save a copy of this collection so that we can add the new classes
        // below.
        elements = $(currentElements.get());
        this._removeClass(currentElements, classKey);

        // We don't use _addClass() here, because that uses this.options.classes
        // for generating the string of classes. We want to use the value passed in from
        // _setOption(), this is the new value of the classes option which was passed to
        // _setOption(). We pass this value directly to _classes().
        elements.addClass(this._classes({
          element: elements,
          keys: classKey,
          classes: value,
          add: true
        }));
      }
    },

    _setOptionDisabled: function(value) {
      this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);

      // If the widget is becoming disabled, then nothing is interactive
      if(value) {
        this._removeClass(this.hoverable, null, "ui-state-hover");
        this._removeClass(this.focusable, null, "ui-state-focus");
      }
    },

    enable: function() {
      return this._setOptions({ disabled: false });
    },

    disable: function() {
      return this._setOptions({ disabled: true });
    },

    _classes: function(options) {
      var full = [];
      var that = this;

      options = $.extend({
        element: this.element,
        classes: this.options.classes || {}
      }, options);

      function processClassString(classes, checkOption) {
        var current, i;
        for(i = 0; i < classes.length; i++) {
          current = that.classesElementLookup[classes[i]] || $();
          if(options.add) {
            current = $($.unique(current.get().concat(options.element.get())));
          } else {
            current = $(current.not(options.element).get());
          }
          that.classesElementLookup[classes[i]] = current;
          full.push(classes[i]);
          if(checkOption && options.classes[classes[i]]) {
            full.push(options.classes[classes[i]]);
          }
        }
      }

      this._on(options.element, {
        "remove": "_untrackClassesElement"
      });

      if(options.keys) {
        processClassString(options.keys.match(/\S+/g) || [], true);
      }
      if(options.extra) {
        processClassString(options.extra.match(/\S+/g) || []);
      }

      return full.join(" ");
    },

    _untrackClassesElement: function(event) {
      var that = this;
      $.each(that.classesElementLookup, function(key, value) {
        if($.inArray(event.target, value) !== -1) {
          that.classesElementLookup[key] = $(value.not(event.target).get());
        }
      });
    },

    _removeClass: function(element, keys, extra) {
      return this._toggleClass(element, keys, extra, false);
    },

    _addClass: function(element, keys, extra) {
      return this._toggleClass(element, keys, extra, true);
    },

    _toggleClass: function(element, keys, extra, add) {
      add = (typeof add === "boolean") ? add : extra;
      var shift = (typeof element === "string" || element === null),
        options = {
          extra: shift ? keys : extra,
          keys: shift ? element : keys,
          element: shift ? this.element : element,
          add: add
        };
      options.element.toggleClass(this._classes(options), add);
      return this;
    },

    _on: function(suppressDisabledCheck, element, handlers) {
      var delegateElement;
      var instance = this;

      // No suppressDisabledCheck flag, shuffle arguments
      if(typeof suppressDisabledCheck !== "boolean") {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }

      // No element argument, shuffle and use this.element
      if(!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }

      $.each(handlers, function(event, handler) {
        function handlerProxy() {

          // Allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if(!suppressDisabledCheck &&
            (instance.options.disabled === true ||
              $(this).hasClass("ui-state-disabled"))) {
            return;
          }
          return(typeof handler === "string" ? instance[handler] : handler)
            .apply(instance, arguments);
        }

        // Copy the guid so direct unbinding works
        if(typeof handler !== "string") {
          handlerProxy.guid = handler.guid =
            handler.guid || handlerProxy.guid || $.guid++;
        }

        var match = event.match(/^([\w:-]*)\s*(.*)$/);
        var eventName = match[1] + instance.eventNamespace;
        var selector = match[2];

        if(selector) {
          delegateElement.on(eventName, selector, handlerProxy);
        } else {
          element.on(eventName, handlerProxy);
        }
      });
    },

    _off: function(element, eventName) {
      eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") +
        this.eventNamespace;
      element.off(eventName).off(eventName);

      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $(this.bindings.not(element).get());
      this.focusable = $(this.focusable.not(element).get());
      this.hoverable = $(this.hoverable.not(element).get());
    },

    _delay: function(handler, delay) {
      function handlerProxy() {
        return(typeof handler === "string" ? instance[handler] : handler)
          .apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },

    _hoverable: function(element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function(event) {
          this._addClass($(event.currentTarget), null, "ui-state-hover");
        },
        mouseleave: function(event) {
          this._removeClass($(event.currentTarget), null, "ui-state-hover");
        }
      });
    },

    _focusable: function(element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function(event) {
          this._addClass($(event.currentTarget), null, "ui-state-focus");
        },
        focusout: function(event) {
          this._removeClass($(event.currentTarget), null, "ui-state-focus");
        }
      });
    },

    _trigger: function(type, event, data) {
      var prop, orig;
      var callback = this.options[type];

      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ?
        type :
        this.widgetEventPrefix + type).toLowerCase();

      // The original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];

      // Copy original event properties over to the new event
      orig = event.originalEvent;
      if(orig) {
        for(prop in orig) {
          if(!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }

      this.element.trigger(event, data);
      return !($.isFunction(callback) &&
        callback.apply(this.element[0], [event].concat(data)) === false ||
        event.isDefaultPrevented());
    }
  };

  $.each({ show: "fadeIn", hide: "fadeOut" }, function(method, defaultEffect) {
    $.Widget.prototype["_" + method] = function(element, options, callback) {
      if(typeof options === "string") {
        options = { effect: options };
      }

      var hasOptions;
      var effectName = !options ?
        method :
        options === true || typeof options === "number" ?
        defaultEffect :
        options.effect || defaultEffect;

      options = options || {};
      if(typeof options === "number") {
        options = { duration: options };
      }

      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;

      if(options.delay) {
        element.delay(options.delay);
      }

      if(hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if(effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function(next) {
          $(this)[method]();
          if(callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });

  var widget = $.widget;


  /*!
   * jQuery UI Keycode 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Keycode
  //>>group: Core
  //>>description: Provide keycodes as keynames
  //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


  var keycode = $.ui.keyCode = {
    BACKSPACE: 8,
    COMMA: 188,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    LEFT: 37,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SPACE: 32,
    TAB: 9,
    UP: 38
  };




  // This file is deprecated
  var ie = $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

  /*!
   * jQuery UI Mouse 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Mouse
  //>>group: Widgets
  //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
  //>>docs: http://api.jqueryui.com/mouse/



  var mouseHandled = false;
  $(document).on("mouseup", function() {
    mouseHandled = false;
  });

  var widgetsMouse = $.widget("ui.mouse", {
    version: "1.12.1",
    options: {
      cancel: "input, textarea, button, select, option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function() {
      var that = this;

      this.element
        .on("mousedown." + this.widgetName, function(event) {
          return that._mouseDown(event);
        })
        .on("click." + this.widgetName, function(event) {
          if(true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
            $.removeData(event.target, that.widgetName + ".preventClickEvent");
            event.stopImmediatePropagation();
            return false;
          }
        });

      this.started = false;
    },

    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function() {
      this.element.off("." + this.widgetName);
      if(this._mouseMoveDelegate) {
        this.document
          .off("mousemove." + this.widgetName, this._mouseMoveDelegate)
          .off("mouseup." + this.widgetName, this._mouseUpDelegate);
      }
    },

    _mouseDown: function(event) {

      // don't let more than one widget handle mouseStart
      if(mouseHandled) {
        return;
      }

      this._mouseMoved = false;

      // We may have missed mouseup (out of window)
      (this._mouseStarted && this._mouseUp(event));

      this._mouseDownEvent = event;

      var that = this,
        btnIsLeft = (event.which === 1),

        // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ?
          $(event.target).closest(this.options.cancel).length : false);
      if(!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }

      this.mouseDelayMet = !this.options.delay;
      if(!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function() {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }

      if(this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = (this._mouseStart(event) !== false);
        if(!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }

      // Click event may never have fired (Gecko & Opera)
      if(true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
        $.removeData(event.target, this.widgetName + ".preventClickEvent");
      }

      // These delegates are required to keep context
      this._mouseMoveDelegate = function(event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function(event) {
        return that._mouseUp(event);
      };

      this.document
        .on("mousemove." + this.widgetName, this._mouseMoveDelegate)
        .on("mouseup." + this.widgetName, this._mouseUpDelegate);

      event.preventDefault();

      mouseHandled = true;
      return true;
    },

    _mouseMove: function(event) {

      // Only check for mouseups outside the document if you've moved inside the document
      // at least once. This prevents the firing of mouseup in the case of IE<9, which will
      // fire a mousemove event if content is placed under the cursor. See #7778
      // Support: IE <9
      if(this._mouseMoved) {

        // IE mouseup check - mouseup happened when mouse was out of window
        if($.ui.ie && (!document.documentMode || document.documentMode < 9) &&
          !event.button) {
          return this._mouseUp(event);

          // Iframe mouseup check - mouseup occurred in another document
        } else if(!event.which) {

          // Support: Safari <=8 - 9
          // Safari sets which to 0 if you press any of the following keys
          // during a drag (#14461)
          if(event.originalEvent.altKey || event.originalEvent.ctrlKey ||
            event.originalEvent.metaKey || event.originalEvent.shiftKey) {
            this.ignoreMissingWhich = true;
          } else if(!this.ignoreMissingWhich) {
            return this._mouseUp(event);
          }
        }
      }

      if(event.which || event.button) {
        this._mouseMoved = true;
      }

      if(this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }

      if(this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted =
          (this._mouseStart(this._mouseDownEvent, event) !== false);
        (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
      }

      return !this._mouseStarted;
    },

    _mouseUp: function(event) {
      this.document
        .off("mousemove." + this.widgetName, this._mouseMoveDelegate)
        .off("mouseup." + this.widgetName, this._mouseUpDelegate);

      if(this._mouseStarted) {
        this._mouseStarted = false;

        if(event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + ".preventClickEvent", true);
        }

        this._mouseStop(event);
      }

      if(this._mouseDelayTimer) {
        clearTimeout(this._mouseDelayTimer);
        delete this._mouseDelayTimer;
      }

      this.ignoreMissingWhich = false;
      mouseHandled = false;
      event.preventDefault();
    },

    _mouseDistanceMet: function(event) {
      return(Math.max(
        Math.abs(this._mouseDownEvent.pageX - event.pageX),
        Math.abs(this._mouseDownEvent.pageY - event.pageY)
      ) >= this.options.distance);
    },

    _mouseDelayMet: function( /* event */ ) {
      return this.mouseDelayMet;
    },

    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function( /* event */ ) {},
    _mouseDrag: function( /* event */ ) {},
    _mouseStop: function( /* event */ ) {},
    _mouseCapture: function( /* event */ ) { return true; }
  });


  /*!
   * jQuery UI Slider 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Slider
  //>>group: Widgets
  //>>description: Displays a flexible slider with ranges and accessibility via keyboard.
  //>>docs: http://api.jqueryui.com/slider/
  //>>demos: http://jqueryui.com/slider/
  //>>css.structure: ../../themes/base/core.css
  //>>css.structure: ../../themes/base/slider.css
  //>>css.theme: ../../themes/base/theme.css



  var widgetsSlider = $.widget("ui.slider", $.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "slide",

    options: {
      animate: false,
      classes: {
        "ui-slider": "ui-corner-all",
        "ui-slider-handle": "ui-corner-all",

        // Note: ui-widget-header isn't the most fittingly semantic framework class for this
        // element, but worked best visually with a variety of themes
        "ui-slider-range": "ui-corner-all ui-widget-header"
      },
      distance: 0,
      max: 100,
      min: 0,
      orientation: "horizontal",
      range: false,
      step: 1,
      value: 0,
      values: null,

      // Callbacks
      change: null,
      slide: null,
      start: null,
      stop: null
    },

    // Number of pages in a slider
    // (how many times can you page up/down to go through the whole range)
    numPages: 5,

    _create: function() {
      this._keySliding = false;
      this._mouseSliding = false;
      this._animateOff = true;
      this._handleIndex = null;
      this._detectOrientation();
      this._mouseInit();
      this._calculateNewMax();

      this._addClass("ui-slider ui-slider-" + this.orientation,
        "ui-widget ui-widget-content");

      this._refresh();

      this._animateOff = false;
    },

    _refresh: function() {
      this._createRange();
      this._createHandles();
      this._setupEvents();
      this._refreshValue();
    },

    _createHandles: function() {
      var i, handleCount,
        options = this.options,
        existingHandles = this.element.find(".ui-slider-handle"),
        handle = "<span tabindex='0'></span>",
        handles = [];

      handleCount = (options.values && options.values.length) || 1;

      if(existingHandles.length > handleCount) {
        existingHandles.slice(handleCount).remove();
        existingHandles = existingHandles.slice(0, handleCount);
      }

      for(i = existingHandles.length; i < handleCount; i++) {
        handles.push(handle);
      }

      this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

      this._addClass(this.handles, "ui-slider-handle", "ui-state-default");

      this.handle = this.handles.eq(0);

      this.handles.each(function(i) {
        $(this)
          .data("ui-slider-handle-index", i)
          .attr("tabIndex", 0);
      });
    },

    _createRange: function() {
      var options = this.options;

      if(options.range) {
        if(options.range === true) {
          if(!options.values) {
            options.values = [this._valueMin(), this._valueMin()];
          } else if(options.values.length && options.values.length !== 2) {
            options.values = [options.values[0], options.values[0]];
          } else if($.isArray(options.values)) {
            options.values = options.values.slice(0);
          }
        }

        if(!this.range || !this.range.length) {
          this.range = $("<div>")
            .appendTo(this.element);

          this._addClass(this.range, "ui-slider-range");
        } else {
          this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max");

          // Handle range switching from true to min/max
          this.range.css({
            "left": "",
            "bottom": ""
          });
        }
        if(options.range === "min" || options.range === "max") {
          this._addClass(this.range, "ui-slider-range-" + options.range);
        }
      } else {
        if(this.range) {
          this.range.remove();
        }
        this.range = null;
      }
    },

    _setupEvents: function() {
      this._off(this.handles);
      this._on(this.handles, this._handleEvents);
      this._hoverable(this.handles);
      this._focusable(this.handles);
    },

    _destroy: function() {
      this.handles.remove();
      if(this.range) {
        this.range.remove();
      }

      this._mouseDestroy();
    },

    _mouseCapture: function(event) {
      var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
        that = this,
        o = this.options;

      if(o.disabled) {
        return false;
      }

      this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      };
      this.elementOffset = this.element.offset();

      position = { x: event.pageX, y: event.pageY };
      normValue = this._normValueFromMouse(position);
      distance = this._valueMax() - this._valueMin() + 1;
      this.handles.each(function(i) {
        var thisDistance = Math.abs(normValue - that.values(i));
        if((distance > thisDistance) ||
          (distance === thisDistance &&
            (i === that._lastChangedValue || that.values(i) === o.min))) {
          distance = thisDistance;
          closestHandle = $(this);
          index = i;
        }
      });

      allowed = this._start(event, index);
      if(allowed === false) {
        return false;
      }
      this._mouseSliding = true;

      this._handleIndex = index;

      this._addClass(closestHandle, null, "ui-state-active");
      closestHandle.trigger("focus");

      offset = closestHandle.offset();
      mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
      this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
        left: event.pageX - offset.left - (closestHandle.width() / 2),
        top: event.pageY - offset.top -
          (closestHandle.height() / 2) -
          (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) -
          (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) +
          (parseInt(closestHandle.css("marginTop"), 10) || 0)
      };

      if(!this.handles.hasClass("ui-state-hover")) {
        this._slide(event, index, normValue);
      }
      this._animateOff = true;
      return true;
    },

    _mouseStart: function() {
      return true;
    },

    _mouseDrag: function(event) {

      var position = { x: event.pageX, y: event.pageY },
        normValue = this._normValueFromMouse(position);

      this._slide(event, this._handleIndex, normValue);

      return false;
    },

    _mouseStop: function(event) {
      this._removeClass(this.handles, null, "ui-state-active");
      this._mouseSliding = false;

      this._stop(event, this._handleIndex);
      this._change(event, this._handleIndex);

      this._handleIndex = null;
      this._clickOffset = null;
      this._animateOff = false;

      return false;
    },

    _detectOrientation: function() {
      this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
    },

    _normValueFromMouse: function(position) {
      var pixelTotal,
        pixelMouse,
        percentMouse,
        valueTotal,
        valueMouse;

      if(this.orientation === "horizontal") {
        pixelTotal = this.elementSize.width;
        pixelMouse = position.x - this.elementOffset.left -
          (this._clickOffset ? this._clickOffset.left : 0);
      } else {
        pixelTotal = this.elementSize.height;
        pixelMouse = position.y - this.elementOffset.top -
          (this._clickOffset ? this._clickOffset.top : 0);
      }

      percentMouse = (pixelMouse / pixelTotal);
      if(percentMouse > 1) {
        percentMouse = 1;
      }
      if(percentMouse < 0) {
        percentMouse = 0;
      }
      if(this.orientation === "vertical") {
        percentMouse = 1 - percentMouse;
      }

      valueTotal = this._valueMax() - this._valueMin();
      valueMouse = this._valueMin() + percentMouse * valueTotal;

      return this._trimAlignValue(valueMouse);
    },

    _uiHash: function(index, value, values) {
      var uiHash = {
        handle: this.handles[index],
        handleIndex: index,
        value: value !== undefined ? value : this.value()
      };

      if(this._hasMultipleValues()) {
        uiHash.value = value !== undefined ? value : this.values(index);
        uiHash.values = values || this.values();
      }

      return uiHash;
    },

    _hasMultipleValues: function() {
      return this.options.values && this.options.values.length;
    },

    _start: function(event, index) {
      return this._trigger("start", event, this._uiHash(index));
    },

    _slide: function(event, index, newVal) {
      var allowed, otherVal,
        currentValue = this.value(),
        newValues = this.values();

      if(this._hasMultipleValues()) {
        otherVal = this.values(index ? 0 : 1);
        currentValue = this.values(index);

        if(this.options.values.length === 2 && this.options.range === true) {
          newVal = index === 0 ? Math.min(otherVal, newVal) : Math.max(otherVal, newVal);
        }

        newValues[index] = newVal;
      }

      if(newVal === currentValue) {
        return;
      }

      allowed = this._trigger("slide", event, this._uiHash(index, newVal, newValues));

      // A slide can be canceled by returning false from the slide callback
      if(allowed === false) {
        return;
      }

      if(this._hasMultipleValues()) {
        this.values(index, newVal);
      } else {
        this.value(newVal);
      }
    },

    _stop: function(event, index) {
      this._trigger("stop", event, this._uiHash(index));
    },

    _change: function(event, index) {
      if(!this._keySliding && !this._mouseSliding) {

        //store the last changed value index for reference when handles overlap
        this._lastChangedValue = index;
        this._trigger("change", event, this._uiHash(index));
      }
    },

    value: function(newValue) {
      if(arguments.length) {
        this.options.value = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, 0);
        return;
      }

      return this._value();
    },

    values: function(index, newValue) {
      var vals,
        newValues,
        i;

      if(arguments.length > 1) {
        this.options.values[index] = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, index);
        return;
      }

      if(arguments.length) {
        if($.isArray(arguments[0])) {
          vals = this.options.values;
          newValues = arguments[0];
          for(i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(newValues[i]);
            this._change(null, i);
          }
          this._refreshValue();
        } else {
          if(this._hasMultipleValues()) {
            return this._values(index);
          } else {
            return this.value();
          }
        }
      } else {
        return this._values();
      }
    },

    _setOption: function(key, value) {
      var i,
        valsLength = 0;

      if(key === "range" && this.options.range === true) {
        if(value === "min") {
          this.options.value = this._values(0);
          this.options.values = null;
        } else if(value === "max") {
          this.options.value = this._values(this.options.values.length - 1);
          this.options.values = null;
        }
      }

      if($.isArray(this.options.values)) {
        valsLength = this.options.values.length;
      }

      this._super(key, value);

      switch(key) {
        case "orientation":
          this._detectOrientation();
          this._removeClass("ui-slider-horizontal ui-slider-vertical")
            ._addClass("ui-slider-" + this.orientation);
          this._refreshValue();
          if(this.options.range) {
            this._refreshRange(value);
          }

          // Reset positioning from previous orientation
          this.handles.css(value === "horizontal" ? "bottom" : "left", "");
          break;
        case "value":
          this._animateOff = true;
          this._refreshValue();
          this._change(null, 0);
          this._animateOff = false;
          break;
        case "values":
          this._animateOff = true;
          this._refreshValue();

          // Start from the last handle to prevent unreachable handles (#9046)
          for(i = valsLength - 1; i >= 0; i--) {
            this._change(null, i);
          }
          this._animateOff = false;
          break;
        case "step":
        case "min":
        case "max":
          this._animateOff = true;
          this._calculateNewMax();
          this._refreshValue();
          this._animateOff = false;
          break;
        case "range":
          this._animateOff = true;
          this._refresh();
          this._animateOff = false;
          break;
      }
    },

    _setOptionDisabled: function(value) {
      this._super(value);

      this._toggleClass(null, "ui-state-disabled", !!value);
    },

    //internal value getter
    // _value() returns value trimmed by min and max, aligned by step
    _value: function() {
      var val = this.options.value;
      val = this._trimAlignValue(val);

      return val;
    },

    //internal values getter
    // _values() returns array of values trimmed by min and max, aligned by step
    // _values( index ) returns single value trimmed by min and max, aligned by step
    _values: function(index) {
      var val,
        vals,
        i;

      if(arguments.length) {
        val = this.options.values[index];
        val = this._trimAlignValue(val);

        return val;
      } else if(this._hasMultipleValues()) {

        // .slice() creates a copy of the array
        // this copy gets trimmed by min and max and then returned
        vals = this.options.values.slice();
        for(i = 0; i < vals.length; i += 1) {
          vals[i] = this._trimAlignValue(vals[i]);
        }

        return vals;
      } else {
        return [];
      }
    },

    // Returns the step-aligned value that val is closest to, between (inclusive) min and max
    _trimAlignValue: function(val) {
      if(val <= this._valueMin()) {
        return this._valueMin();
      }
      if(val >= this._valueMax()) {
        return this._valueMax();
      }
      var step = (this.options.step > 0) ? this.options.step : 1,
        valModStep = (val - this._valueMin()) % step,
        alignValue = val - valModStep;

      if(Math.abs(valModStep) * 2 >= step) {
        alignValue += (valModStep > 0) ? step : (-step);
      }

      // Since JavaScript has problems with large floats, round
      // the final value to 5 digits after the decimal point (see #4124)
      return parseFloat(alignValue.toFixed(5));
    },

    _calculateNewMax: function() {
      var max = this.options.max,
        min = this._valueMin(),
        step = this.options.step,
        aboveMin = Math.round((max - min) / step) * step;
      max = aboveMin + min;
      if(max > this.options.max) {

        //If max is not divisible by step, rounding off may increase its value
        max -= step;
      }
      this.max = parseFloat(max.toFixed(this._precision()));
    },

    _precision: function() {
      var precision = this._precisionOf(this.options.step);
      if(this.options.min !== null) {
        precision = Math.max(precision, this._precisionOf(this.options.min));
      }
      return precision;
    },

    _precisionOf: function(num) {
      var str = num.toString(),
        decimal = str.indexOf(".");
      return decimal === -1 ? 0 : str.length - decimal - 1;
    },

    _valueMin: function() {
      return this.options.min;
    },

    _valueMax: function() {
      return this.max;
    },

    _refreshRange: function(orientation) {
      if(orientation === "vertical") {
        this.range.css({ "width": "", "left": "" });
      }
      if(orientation === "horizontal") {
        this.range.css({ "height": "", "bottom": "" });
      }
    },

    _refreshValue: function() {
      var lastValPercent, valPercent, value, valueMin, valueMax,
        oRange = this.options.range,
        o = this.options,
        that = this,
        animate = (!this._animateOff) ? o.animate : false,
        _set = {};

      if(this._hasMultipleValues()) {
        this.handles.each(function(i) {
          valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() -
            that._valueMin()) * 100;
          _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
          $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
          if(that.options.range === true) {
            if(that.orientation === "horizontal") {
              if(i === 0) {
                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                  left: valPercent + "%"
                }, o.animate);
              }
              if(i === 1) {
                that.range[animate ? "animate" : "css"]({
                  width: (valPercent - lastValPercent) + "%"
                }, {
                  queue: false,
                  duration: o.animate
                });
              }
            } else {
              if(i === 0) {
                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                  bottom: (valPercent) + "%"
                }, o.animate);
              }
              if(i === 1) {
                that.range[animate ? "animate" : "css"]({
                  height: (valPercent - lastValPercent) + "%"
                }, {
                  queue: false,
                  duration: o.animate
                });
              }
            }
          }
          lastValPercent = valPercent;
        });
      } else {
        value = this.value();
        valueMin = this._valueMin();
        valueMax = this._valueMax();
        valPercent = (valueMax !== valueMin) ?
          (value - valueMin) / (valueMax - valueMin) * 100 :
          0;
        _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
        this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

        if(oRange === "min" && this.orientation === "horizontal") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            width: valPercent + "%"
          }, o.animate);
        }
        if(oRange === "max" && this.orientation === "horizontal") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            width: (100 - valPercent) + "%"
          }, o.animate);
        }
        if(oRange === "min" && this.orientation === "vertical") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            height: valPercent + "%"
          }, o.animate);
        }
        if(oRange === "max" && this.orientation === "vertical") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            height: (100 - valPercent) + "%"
          }, o.animate);
        }
      }
    },

    _handleEvents: {
      keydown: function(event) {
        var allowed, curVal, newVal, step,
          index = $(event.target).data("ui-slider-handle-index");

        switch(event.keyCode) {
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_UP:
          case $.ui.keyCode.PAGE_DOWN:
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            event.preventDefault();
            if(!this._keySliding) {
              this._keySliding = true;
              this._addClass($(event.target), null, "ui-state-active");
              allowed = this._start(event, index);
              if(allowed === false) {
                return;
              }
            }
            break;
        }

        step = this.options.step;
        if(this._hasMultipleValues()) {
          curVal = newVal = this.values(index);
        } else {
          curVal = newVal = this.value();
        }

        switch(event.keyCode) {
          case $.ui.keyCode.HOME:
            newVal = this._valueMin();
            break;
          case $.ui.keyCode.END:
            newVal = this._valueMax();
            break;
          case $.ui.keyCode.PAGE_UP:
            newVal = this._trimAlignValue(
              curVal + ((this._valueMax() - this._valueMin()) / this.numPages)
            );
            break;
          case $.ui.keyCode.PAGE_DOWN:
            newVal = this._trimAlignValue(
              curVal - ((this._valueMax() - this._valueMin()) / this.numPages));
            break;
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
            if(curVal === this._valueMax()) {
              return;
            }
            newVal = this._trimAlignValue(curVal + step);
            break;
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            if(curVal === this._valueMin()) {
              return;
            }
            newVal = this._trimAlignValue(curVal - step);
            break;
        }

        this._slide(event, index, newVal);
      },
      keyup: function(event) {
        var index = $(event.target).data("ui-slider-handle-index");

        if(this._keySliding) {
          this._keySliding = false;
          this._stop(event, index);
          this._change(event, index);
          this._removeClass($(event.target), null, "ui-state-active");
        }
      }
    }
  });




}));

/*!
 * jQuery UI Touch Punch 0.2.3
 *
 * Copyright 2011–2014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
(function($) {

  // Detect touch support
  $.support.touch = 'ontouchend' in document;

  // Ignore browsers without touch support
  if(!$.support.touch) {
    return;
  }

  var mouseProto = $.ui.mouse.prototype,
    _mouseInit = mouseProto._mouseInit,
    _mouseDestroy = mouseProto._mouseDestroy,
    touchHandled;

  /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */
  function simulateMouseEvent(event, simulatedType) {

    // Ignore multi-touch events
    if(event.originalEvent.touches.length > 1) {
      return;
    }

    event.preventDefault();

    var touch = event.originalEvent.changedTouches[0],
      simulatedEvent = document.createEvent('MouseEvents');

    // Initialize the simulated mouse event using the touch event's coordinates
    simulatedEvent.initMouseEvent(
      simulatedType, // type
      true, // bubbles                    
      true, // cancelable                 
      window, // view                       
      1, // detail                     
      touch.screenX, // screenX                    
      touch.screenY, // screenY                    
      touch.clientX, // clientX                    
      touch.clientY, // clientY                    
      false, // ctrlKey                    
      false, // altKey                     
      false, // shiftKey                   
      false, // metaKey                    
      0, // button                     
      null // relatedTarget              
    );

    // Dispatch the simulated event to the target element
    event.target.dispatchEvent(simulatedEvent);
  }

  /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */
  mouseProto._touchStart = function(event) {

    var self = this;

    // Ignore the event if another widget is already being handled
    if(touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
      return;
    }

    // Set the flag to prevent other widgets from inheriting the touch event
    touchHandled = true;

    // Track movement to determine if interaction was a click
    self._touchMoved = false;

    // Simulate the mouseover event
    simulateMouseEvent(event, 'mouseover');

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');

    // Simulate the mousedown event
    simulateMouseEvent(event, 'mousedown');
  };

  /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */
  mouseProto._touchMove = function(event) {

    // Ignore event if not handled
    if(!touchHandled) {
      return;
    }

    // Interaction was not a click
    this._touchMoved = true;

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');
  };

  /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */
  mouseProto._touchEnd = function(event) {

    // Ignore event if not handled
    if(!touchHandled) {
      return;
    }

    // Simulate the mouseup event
    simulateMouseEvent(event, 'mouseup');

    // Simulate the mouseout event
    simulateMouseEvent(event, 'mouseout');

    // If the touch interaction did not move, it should trigger a click
    if(!this._touchMoved) {

      // Simulate the click event
      simulateMouseEvent(event, 'click');
    }

    // Unset the flag to allow other widgets to inherit the touch event
    touchHandled = false;
  };

  /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */
  mouseProto._mouseInit = function() {

    var self = this;

    // Delegate the touch handlers to the widget's element
    self.element.bind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });

    // Call the original $.ui.mouse init method
    _mouseInit.call(self);
  };

  /**
   * Remove the touch event handlers
   */
  mouseProto._mouseDestroy = function() {

    var self = this;

    // Delegate the touch handlers to the widget's element
    self.element.unbind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });

    // Call the original $.ui.mouse destroy method
    _mouseDestroy.call(self);
  };

})(jQuery);
/**
 * 修改代码
 * 1 503处，增加控制条开始隐藏
 */

;
(function ($) {

  var clickName = function () {
    if (Xut.plat.isMouseTouch) {
      return "touchend mouseup"
    }
    return Xut.plat.hasTouch ? 'touchend' : 'mouseup'
  }();


  var testVideoElement = $("<video />")[0];
  var nativeSupport = (typeof testVideoElement.canPlayType != 'undefined');
  var nativeFullScreenSupport = (
    (typeof testVideoElement.webkitEnterFullScreen != 'undefined') ? 'webkit' :
    (typeof testVideoElement.mozRequestFullScreen != 'undefined') ? 'mozGecko' :
    false);


  // webkitEnterFullScreen fails under Chrome at the moment
  if (navigator.userAgent.match('Chrome')) nativeFullScreenSupport = false;


  // width: this.options.width,
  // height: this.options.height,
  // poster: this.options.poster,
  // autoplay: this.options.autoplay,
  // preload: this.options.preload,
  // controls: this.options.controls,
  // autobuffer: this.options.autobuffer

  var defaults = {
    autoplay: false,
    controls: true,
    preload: "auto",
    poster: null,
    srcs: []
  };

  defaults.useNative = nativeSupport;
  defaults.useNativeFullScreen = nativeFullScreenSupport;

  var FlareVideo = function (parent, options) {

    this._class = FlareVideo;

    this.parent = parent;
    this.options = $.extend({}, defaults, options);

    /*
      <source src="horse.ogg" type="audio/ogg">
      media/src/type
     */
    this.sources = this.options.srcs || this.options.sources;

    this.useNative = this.options.useNative;
    // Only use full screen on HTML 5 atm
    this.options.useFullScreen = !!this.useNative;

    this.state = null;
    this.canPlay = false;
    this.inFullScreen = false;
    this.loaded = false;
    this.readyList = [];

    /*创建父容器*/
    this.setupElement();
    /*创建HTML5元素*/
    this.setupNative();
    /*绑定事件*/
    this.setupEvents();
    /*创建控制条*/
    this.setupControls();

    this.change("initial");

    /*开始加载视频*/
    this._load();

    /*绑定监控工具条的显示隐藏控制*/
    this.initHideIdie = false
    if (this.options.controls) {
      this.createIdleTimer();
    }
  };


  FlareVideo.fn = FlareVideo.prototype;


  FlareVideo.fn.clearTimeout = function () {
    if (this.checkTimer) {
      clearTimeout(this.checkTimer);
      this.checkTimer = null
    }
  }

  /**
   * 控制条显示检测时间
   * @param  {[type]} options [description]
   * @return {[type]}         [description]
   */
  FlareVideo.fn.createIdleTimer = function () {

    var self = this
    var idle = false;

    /*检测的定时器*/
    var checkTimer = null

    self.triggerIdle = function (e, time) {

      var time = time || 2000

      /*如果点击是控制条区域，那么控制条不关闭，重新计算时间*/
      if (e && e.target && e.target.className !== 'video') {
        self.clearTimeout()
        self.checkTimer = setTimeout(self.triggerIdle, time);
        return
      }

      if (idle) {
        idle = false;
        self.idle("idle", true);
        /*通过手动触发，取消自动关闭*/
        self.clearTimeout()
      } else {
        idle = true;
        self.idle("idle", false);
        self.checkTimer = setTimeout(self.triggerIdle, time);
      }
    }

    this.element.on(clickName, self.triggerIdle);

    /*如果触发了控制条*/
    this.controls.on('touchmove mousemove', function (e) {
      self.triggerIdle(e, 3000)
    })
  };

  /**
   * 隐藏控制条
   * 开始播放第一次调用2S后隐藏控制条
   * @return {[type]} [description]
   */
  FlareVideo.fn.hideIdleTimer = function () {
    /*只处理第一次的隐藏*/
    if (!this.initHideIdie) {
      this.initHideIdie = true
      this.triggerIdle()
    }
  }


  /**
   * 异步流程控制
   * @param  {Function} callback [description]
   * @return {[type]}            [description]
   */
  FlareVideo.fn.ready = function (callback) {
    this.readyList.push(callback);
    if (this.loaded) callback.call(this);
  };

  /**
   * 提供视频的加载接口
   * 合并Source对象的属性传递
   * @param  {[type]} srcs [description]
   * @return {[type]}      [description]
   */
  FlareVideo.fn._load = function () {

    if (typeof this.sources == "string")
      this.sources = {
        src: this.sources
      };

    if (!$.isArray(this.sources))
      this.sources = [this.sources];

    this.ready(function () {
      this.change("loading");
      this.video.loadSources(this.sources);
    });
  };


  FlareVideo.fn.seek = function (offset) {
    this.video.setCurrentTime(offset);
  }

  FlareVideo.fn.setVolume = function (num) {
    this.video.setVolume(num);
  };

  FlareVideo.fn.getVolume = function () {
    return this.video.getVolume();
  };

  FlareVideo.fn.mute = function (state) {
    if (typeof state == "undefined") state = true;
    this.setVolume(state ? 1 : 0);
  };


  FlareVideo.fn.bind = function () {
    this.videoElement.bind.apply(this.videoElement, arguments);
  };

  FlareVideo.fn.one = function () {
    this.videoElement.one.apply(this.videoElement, arguments);
  };

  FlareVideo.fn.trigger = function () {
    this.videoElement.trigger.apply(this.videoElement, arguments);
  };

  // Proxy jQuery events
  var events = ["click", "dblclick",
    "onerror", "onloadeddata", "oncanplay",
    "ondurationchange", "ontimeupdate",
    "onpause", "onplay", "onended", "onvolumechange"
  ];
  for (var i = 0; i < events.length; i++) {
    (function () {
      var functName = events[i];
      var eventName = functName.replace(/^(on)/, "");
      FlareVideo.fn[functName] = function () {
        var args = $.makeArray(arguments);
        args.unshift(eventName);
        this.bind.apply(this, args);
      };
    })();
  }

  //////////////
  /// 私有方法
  ///////////////


  /**
   * 视频父节点
   * @return {[type]} [description]
   */
  FlareVideo.fn.setupElement = function () {
    this.element = $("<div />");
    this.element.addClass("flareVideo");
    this.element.css('visibility', 'hidden')
    this.parent.append(this.element);
  };

  /**
   * 视频节点
   * @return {[type]} [description]
   */
  FlareVideo.fn.setupNative = function () {
    this.videoElement = $("<video />");
    this.videoElement.addClass("video");
    this.videoElement.attr({
      width: this.options.width,
      height: this.options.height,
      poster: this.options.poster,
      autoplay: this.options.autoplay,
      preload: this.options.preload,
      controls: false, //默认关闭自己的控制条
      autobuffer: this.options.autobuffer
    });

    this.element.append(this.videoElement);
    this.video = this.videoElement[0];

    var self = this;


    ////////////////
    /// 扩展视频方法
    ////////////////
    this.video.loadSources = function (srcs) {
      self.videoElement.empty();
      for (var i in srcs) {
        var srcEl = $("<source />");
        srcEl.attr(srcs[i]);
        self.videoElement.append(srcEl);
      }
      self.video.load();
    };

    this.video.getStartTime = function () {
      return (this.startTime || 0);
    };

    this.video.getEndTime = function () {
      if (this.duration == Infinity && this.buffered) {
        return (this.buffered.end(this.buffered.length - 1));
      } else {
        return ((this.startTime || 0) + this.duration);
      }
    };

    this.video.getCurrentTime = function () {
      try {
        return this.currentTime;
      } catch (e) {
        return 0;
      }
    };

    this.video.setCurrentTime = function (val) {
      this.currentTime = val;
    }
    this.video.getVolume = function () {
      return this.volume;
    };
    this.video.setVolume = function (val) {
      this.volume = val;
    };
    this.video.enterFullScreen = function () {
      // Because we don't know when full screen is exited
      self.inFullScreen = false;
      this.webkitEnterFullScreen();
    };
    this.video.exitFullScreen = function () {
      this.webkitExitFullScreen();
    };

    this.loaded = true;
  };

  /**
   * 绑定视频反馈事件
   * @return {[type]} [description]
   */
  FlareVideo.fn.setupEvents = function () {

    /*暂停*/
    this.onpause($.proxy(function () {
      this.element.removeClass("playing");
      this.change("paused");
    }, this));

    /*播放*/
    this.onplay($.proxy(function () {
      this.element.addClass("playing");
      this.change("playing");
    }, this));

    /*结束*/
    this.onended($.proxy(function () {
      this.element.removeClass("playing");
      this.fullScreen(false);
      this.stop()
      this.change("ended");
    }, this));

    /*错误*/
    this.onerror($.proxy(function (e) {
      this.change("error");
      console.error("Error - " + this.video.error);
    }, this));

    /*提示该视频已准备好开始播放*/
    this.oncanplay($.proxy(function () {
      this.hideIdleTimer()
      this.canPlay = true;
      this.controls.removeClass("disabled");
      this.element.css('visibility', 'visible')
    }, this));

  };

  /**
   * 创建控制条
   * @return {[type]} [description]
   */
  FlareVideo.fn.setupControls = function () {

    if (!this.options.controls) return;

    this.controls = $("<div />");
    this.controls.addClass("controls");
    this.controls.addClass("disabled");

    this.setupBeforeButtons();
    this.setupTiming()
    this.setupSeek();
    this.setupAfterButtons();

    /*开始隐藏*/
    // this.element.addClass("idle");

    this.element.append(this.controls);
  };

  /**
   * 创建控制条按钮
   * @return {[type]} [description]
   */
  FlareVideo.fn.setupBeforeButtons = function () {
    var play = $("<div />");
    play.addClass("play");

    var self = this

    /*点击播放停止按钮*/
    play.on(clickName, function (e) {
      if (!self.canPlay) return;
      self.play();
      return false
    });
    this.controls.append(play);

    var pause = $("<div />");
    pause.addClass("pause");

    pause.on(clickName, function () {
      if (!self.canPlay) return;
      self.pause();
      return false
    });
    this.controls.append(pause);
  };

  FlareVideo.fn.setupAfterButtons = function () {
    var self = this
    var fullScreen = $("<div />");
    fullScreen.addClass("fullScreen");
    //fullScreen.text("Full Screen");
    fullScreen.on(clickName, function () {
      self.toggleFullScreen()
      return false
    });
    if (!this.options.useFullScreen) {
      fullScreen.addClass("disabled");
    }
    this.controls.append(fullScreen);

    /*关闭按钮*/
    var close = $("<div />");
    close.addClass("close");
    close.on(clickName, function () {
      self.trigger("close")
      return false
    });

    this.controls.append(close);
  };



  /**
   * 创建拖动条
   * @return {[type]} [description]
   */
  FlareVideo.fn.setupSeek = function () {
    var seek = $("<div />");
    seek.addClass("seek");

    var seekRange = this.createRange();
    seekRange.addClass("seekRange");
    seekRange.setValue(0);

    /*被改变的最终值*/
    seekRange.change($.proxy(function () {
      this.seek(seekRange.getValue());
    }, this));

    /*当指定音频/视频的时长数据发生变化时，发生 durationchange 事件。*/
    this.ondurationchange($.proxy(function () {
      seekRange.setOptions({
        min: this.video.getStartTime(),
        max: this.video.getEndTime(),
        value: this.video.getCurrentTime()
      });
    }, this));

    /*视频运行，更新时间*/
    this.ontimeupdate($.proxy(function () {
      seekRange.setOptions({
        max: this.video.getEndTime(),
        value: this.video.getCurrentTime()
      });
    }, this));

    seek.append(seekRange);
    this.controls.append(seek);
  };

  /**
   * 创建拖动条的圆点
   * @return {[type]} [description]
   */
  FlareVideo.fn.createRange = function () {
    var result = $("<div />");
    if (!result.slider)
      throw "jQuery UI with the slider component is required."

    var banChange = false
    var preOptions

    result.slider({
      start: function (event, ui) {
        /*点击的时候确保滚动条位置正确*/
        if (preOptions) {
          result.slider("option", preOptions);
        }
        banChange = true
      },
      stop: function (event, ui) {
        banChange = false
      }
    });

    var currentValue = 0;
    result.getValue = function () {
      return currentValue;
    };

    result.setValue = function (value) {
      if (result.find(".ui-slider-handle:first").hasClass("ui-state-active")) return;
      currentValue = value;
      result.slider("option", "value", value);
    };

    result.setOptions = function (options) {
      if (!banChange) {
        preOptions = options
        result.slider("option", options);
      }
    };

    result.bind("slidestop", function (e, ui) {
      currentValue = ui.value;
      result.trigger("change")
    });
    return result;
  }

  /**
   * 创建显示进度时间
   * @return {[type]} [description]
   */
  FlareVideo.fn.setupTiming = function () {

    var scheduleTime = $("<div />");
    scheduleTime.addClass('scheduleTime')

    var timeChange = $("<div />");
    timeChange.addClass("timeChange");
    scheduleTime.append(timeChange);

    var timeUn = $("<div>/</div>");
    timeUn.addClass("timeUn");
    scheduleTime.append(timeUn);

    var timeMax = $("<div />");
    timeMax.addClass("timeMax");
    scheduleTime.append(timeMax);


    // // timeToGo.addClass("timeMin");
    var pad = function (num) {
      if (num < 10)
        return "0" + num;
      return num;
    }

    var secondsFormat = function (sec) {
      var result = [];
      var minutes = Math.floor(sec / 60);
      var hours = Math.floor(sec / 3600);
      var seconds = (sec == 0) ? 0 : (sec % 60)
      seconds = Math.round(seconds);
      if (hours > 0) {
        result.push(pad(hours));
      }
      result.push(pad(minutes));
      result.push(pad(seconds));
      return result.join(":");
    };


    this.ontimeupdate($.proxy(function () {
      timeMax.text(secondsFormat(this.video.getEndTime()))
      //timeToGo.text(secondsFormat(this.video.getCurrentTime()));
      timeChange.text(secondsFormat(this.video.getCurrentTime()))
    }, this));

    /*视频准备好后出发一次，更新总时间*/
    this.videoElement.one("canplay", $.proxy(function () {
      timeMax.text(secondsFormat(this.video.getEndTime() - this.video.getCurrentTime()))
      this.videoElement.trigger("timeupdate");
    }, this));

    //this.controls.append(timeToGo);
    this.controls.append(scheduleTime);
  };



  /**
   * 切换工具栏的状态
   * @param  {[type]} e      [description]
   * @param  {[type]} toggle [description]
   * @return {[type]}        [description]
   */
  FlareVideo.fn.idle = function (e, toggle) {
    if (toggle) {
      if (this.state == "playing")
        this.element.addClass("idle");
    } else {
      this.element.removeClass("idle");
    }
  }

  /**
   * 触发改变
   * @param  {[type]} state [description]
   * @return {[type]}       [description]
   */
  FlareVideo.fn.change = function (state) {
    this.state = state;
    this.element.attr("data-state", this.state);
    this.element.trigger("state.fv", this.state);
  }



  //////////////
  ///对外接口
  //////////////

  FlareVideo.fn.play = function () {
    this.video.play();
  };

  FlareVideo.fn.pause = function () {
    this.video.pause();
  };

  FlareVideo.fn.stop = function () {
    this.seek(0);
    this.pause();
  };

  FlareVideo.fn.remove = function () {
    this.triggerIdle = null
    this.clearTimeout()
    if (this.controls) {
      this.controls.remove()
      this.controls = null
    }
    this.element.remove();
    this.videoElement = null
    this.parent = null
    this.element = null
  };

  FlareVideo.fn.fullScreen = function (state) {
    if (typeof state == "undefined") {
      state = true
    };

    this.inFullScreen = state;

    switch (this.options.useNativeFullScreen) {
      case 'webkit':
        this.video[state ? "enterFullScreen" : "exitFullScreen"]();
        break;
      case 'mozGecko':
        this.video[state ? "mozRequestFullScreen" : "mozCancelFullScreen"]();
        break;
      default:
        (state ? $("body") : this.parent).prepend(this.element);
        var isPlaying = (this.state == "playing");
        this.element[state ? "addClass" : "removeClass"]("fullScreen");
        if (isPlaying) this.ready($.proxy(this.play, this));
    }
  };

  FlareVideo.fn.togglePlay = function () {
    if (this.state == "playing") {
      this.pause();
    } else {
      this.play();
    }
  };

  /*切换全屏与窗口化*/
  FlareVideo.fn.toggleFullScreen = function () {
    this.fullScreen(!this.inFullScreen);
  };


  $.fn.flareVideo = function (options, callback) {
    return (new FlareVideo(this, options));
  };

  window.FlareVideo = FlareVideo;

})(jQuery);

//苗苗学
//嵌套iframe都不加载cordove
if(!Xut.plat.isBrowser && !MMXCONFIG) {
  //IOS
  if(Xut.plat.isIOS) {


    // Platform: ios
    // 91157c2e1bf3eb098c7e2ab31404e895ccb0df2a
    /*
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
     */
    ;
    (function() {
      var PLATFORM_VERSION_BUILD_LABEL = '3.7.0';
      // file: src/scripts/require.js

      /*jshint -W079 */
      /*jshint -W020 */

      var require,
        define;

      (function() {
        var modules = {},
          // Stack of moduleIds currently being built.
          requireStack = [],
          // Map of module ID -> index into requireStack of modules currently being built.
          inProgressModules = {},
          SEPARATOR = ".";



        function build(module) {
          var factory = module.factory,
            localRequire = function(id) {
              var resultantId = id;
              //Its a relative path, so lop off the last portion and add the id (minus "./")
              if(id.charAt(0) === ".") {
                resultantId = module.id.slice(0, module.id.lastIndexOf(SEPARATOR)) + SEPARATOR + id.slice(2);
              }
              return require(resultantId);
            };
          module.exports = {};
          delete module.factory;
          factory(localRequire, module.exports, module);
          return module.exports;
        }

        require = function(id) {
          if(!modules[id]) {
            throw "module " + id + " not found";
          } else if(id in inProgressModules) {
            var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;
            throw "Cycle in require graph: " + cycle;
          }
          if(modules[id].factory) {
            try {
              inProgressModules[id] = requireStack.length;
              requireStack.push(id);
              return build(modules[id]);
            } finally {
              delete inProgressModules[id];
              requireStack.pop();
            }
          }
          return modules[id].exports;
        };

        define = function(id, factory) {
          if(modules[id]) {
            throw "module " + id + " already defined";
          }

          modules[id] = {
            id: id,
            factory: factory
          };
        };

        define.remove = function(id) {
          delete modules[id];
        };

        define.moduleMap = modules;
      })();

      //Export for use in node
      if(typeof module === "object" && typeof require === "function") {
        module.exports.require = require;
        module.exports.define = define;
      }

      // file: src/cordova.js
      define("cordova", function(require, exports, module) {


        var channel = require('cordova/channel');
        var platform = require('cordova/platform');

        /**
         * Intercept calls to addEventListener + removeEventListener and handle deviceready,
         * resume, and pause events.
         */
        var m_document_addEventListener = document.addEventListener;
        var m_document_removeEventListener = document.removeEventListener;
        var m_window_addEventListener = window.addEventListener;
        var m_window_removeEventListener = window.removeEventListener;

        /**
         * Houses custom event handlers to intercept on document + window event listeners.
         */
        var documentEventHandlers = {},
          windowEventHandlers = {};

        document.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if(typeof documentEventHandlers[e] != 'undefined') {
            documentEventHandlers[e].subscribe(handler);
          } else {
            m_document_addEventListener.call(document, evt, handler, capture);
          }
        };

        window.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if(typeof windowEventHandlers[e] != 'undefined') {
            windowEventHandlers[e].subscribe(handler);
          } else {
            m_window_addEventListener.call(window, evt, handler, capture);
          }
        };

        document.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if(typeof documentEventHandlers[e] != "undefined") {
            documentEventHandlers[e].unsubscribe(handler);
          } else {
            m_document_removeEventListener.call(document, evt, handler, capture);
          }
        };

        window.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if(typeof windowEventHandlers[e] != "undefined") {
            windowEventHandlers[e].unsubscribe(handler);
          } else {
            m_window_removeEventListener.call(window, evt, handler, capture);
          }
        };

        function createEvent(type, data) {
          var event = document.createEvent('Events');
          event.initEvent(type, false, false);
          if(data) {
            for(var i in data) {
              if(data.hasOwnProperty(i)) {
                event[i] = data[i];
              }
            }
          }
          return event;
        }


        var cordova = {
          define: define,
          require: require,
          version: PLATFORM_VERSION_BUILD_LABEL,
          platformVersion: PLATFORM_VERSION_BUILD_LABEL,
          platformId: platform.id,
          /**
           * Methods to add/remove your own addEventListener hijacking on document + window.
           */
          addWindowEventHandler: function(event) {
            return(windowEventHandlers[event] = channel.create(event));
          },
          addStickyDocumentEventHandler: function(event) {
            return(documentEventHandlers[event] = channel.createSticky(event));
          },
          addDocumentEventHandler: function(event) {
            return(documentEventHandlers[event] = channel.create(event));
          },
          removeWindowEventHandler: function(event) {
            delete windowEventHandlers[event];
          },
          removeDocumentEventHandler: function(event) {
            delete documentEventHandlers[event];
          },
          /**
           * Retrieve original event handlers that were replaced by Cordova
           *
           * @return object
           */
          getOriginalHandlers: function() {
            return {
              'document': {
                'addEventListener': m_document_addEventListener,
                'removeEventListener': m_document_removeEventListener
              },
              'window': {
                'addEventListener': m_window_addEventListener,
                'removeEventListener': m_window_removeEventListener
              }
            };
          },
          /**
           * Method to fire event from native code
           * bNoDetach is required for events which cause an exception which needs to be caught in native code
           */
          fireDocumentEvent: function(type, data, bNoDetach) {
            var evt = createEvent(type, data);
            if(typeof documentEventHandlers[type] != 'undefined') {
              if(bNoDetach) {
                documentEventHandlers[type].fire(evt);
              } else {
                setTimeout(function() {
                  // Fire deviceready on listeners that were registered before cordova.js was loaded.
                  if(type == 'deviceready') {
                    document.dispatchEvent(evt);
                  }
                  documentEventHandlers[type].fire(evt);
                }, 0);
              }
            } else {
              document.dispatchEvent(evt);
            }
          },
          fireWindowEvent: function(type, data) {
            var evt = createEvent(type, data);
            if(typeof windowEventHandlers[type] != 'undefined') {
              setTimeout(function() {
                windowEventHandlers[type].fire(evt);
              }, 0);
            } else {
              window.dispatchEvent(evt);
            }
          },

          /**
           * Plugin callback mechanism.
           */
          // Randomize the starting callbackId to avoid collisions after refreshing or navigating.
          // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.
          callbackId: Math.floor(Math.random() * 2000000000),
          callbacks: {},
          callbackStatus: {
            NO_RESULT: 0,
            OK: 1,
            CLASS_NOT_FOUND_EXCEPTION: 2,
            ILLEGAL_ACCESS_EXCEPTION: 3,
            INSTANTIATION_EXCEPTION: 4,
            MALFORMED_URL_EXCEPTION: 5,
            IO_EXCEPTION: 6,
            INVALID_ACTION: 7,
            JSON_EXCEPTION: 8,
            ERROR: 9
          },

          /**
           * Called by native code when returning successful result from an action.
           */
          callbackSuccess: function(callbackId, args) {
            cordova.callbackFromNative(callbackId, true, args.status, [args.message], args.keepCallback);
          },

          /**
           * Called by native code when returning error result from an action.
           */
          callbackError: function(callbackId, args) {
            // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.
            // Derive success from status.
            cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);
          },

          /**
           * Called by native code when returning the result from an action.
           */
          callbackFromNative: function(callbackId, isSuccess, status, args, keepCallback) {
            try {
              var callback = cordova.callbacks[callbackId];
              if(callback) {
                if(isSuccess && status == cordova.callbackStatus.OK) {
                  callback.success && callback.success.apply(null, args);
                } else {
                  callback.fail && callback.fail.apply(null, args);
                }

                // Clear callback if not expecting any more results
                if(!keepCallback) {
                  delete cordova.callbacks[callbackId];
                }
              }
            } catch(err) {
              var msg = "Error in " + (isSuccess ? "Success" : "Error") + " callbackId: " + callbackId + " : " + err;
              console && console.log && console.log(msg);
              cordova.fireWindowEvent("cordovacallbackerror", {
                'message': msg
              });
              throw err;
            }
          },
          addConstructor: function(func) {
            channel.onCordovaReady.subscribe(function() {
              try {
                func();
              } catch(e) {
                console.log("Failed to run constructor: " + e);
              }
            });
          }
        };


        module.exports = cordova;

      });

      // file: src/common/argscheck.js
      define("cordova/argscheck", function(require, exports, module) {

        var exec = require('cordova/exec');
        var utils = require('cordova/utils');

        var moduleExports = module.exports;

        var typeMap = {
          'A': 'Array',
          'D': 'Date',
          'N': 'Number',
          'S': 'String',
          'F': 'Function',
          'O': 'Object'
        };

        function extractParamName(callee, argIndex) {
          return(/.*?\((.*?)\)/).exec(callee)[1].split(', ')[argIndex];
        }

        function checkArgs(spec, functionName, args, opt_callee) {
          if(!moduleExports.enableChecks) {
            return;
          }
          var errMsg = null;
          var typeName;
          for(var i = 0; i < spec.length; ++i) {
            var c = spec.charAt(i),
              cUpper = c.toUpperCase(),
              arg = args[i];
            // Asterix means allow anything.
            if(c == '*') {
              continue;
            }
            typeName = utils.typeName(arg);
            if((arg === null || arg === undefined) && c == cUpper) {
              continue;
            }
            if(typeName != typeMap[cUpper]) {
              errMsg = 'Expected ' + typeMap[cUpper];
              break;
            }
          }
          if(errMsg) {
            errMsg += ', but got ' + typeName + '.';
            errMsg = 'Wrong type for parameter "' + extractParamName(opt_callee || args.callee, i) + '" of ' + functionName + ': ' + errMsg;
            // Don't log when running unit tests.
            if(typeof jasmine == 'undefined') {
              console.error(errMsg);
            }
            throw TypeError(errMsg);
          }
        }

        function getValue(value, defaultValue) {
          return value === undefined ? defaultValue : value;
        }

        moduleExports.checkArgs = checkArgs;
        moduleExports.getValue = getValue;
        moduleExports.enableChecks = true;


      });

      // file: src/common/base64.js
      define("cordova/base64", function(require, exports, module) {

        var base64 = exports;

        base64.fromArrayBuffer = function(arrayBuffer) {
          var array = new Uint8Array(arrayBuffer);
          return uint8ToBase64(array);
        };

        base64.toArrayBuffer = function(str) {
          var decodedStr = typeof atob != 'undefined' ? atob(str) : new Buffer(str, 'base64').toString('binary');
          var arrayBuffer = new ArrayBuffer(decodedStr.length);
          var array = new Uint8Array(arrayBuffer);
          for(var i = 0, len = decodedStr.length; i < len; i++) {
            array[i] = decodedStr.charCodeAt(i);
          }
          return arrayBuffer;
        };

        //------------------------------------------------------------------------------

        /* This code is based on the performance tests at http://jsperf.com/b64tests
         * This 12-bit-at-a-time algorithm was the best performing version on all
         * platforms tested.
         */

        var b64_6bit = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var b64_12bit;

        var b64_12bitTable = function() {
          b64_12bit = [];
          for(var i = 0; i < 64; i++) {
            for(var j = 0; j < 64; j++) {
              b64_12bit[i * 64 + j] = b64_6bit[i] + b64_6bit[j];
            }
          }
          b64_12bitTable = function() {
            return b64_12bit;
          };
          return b64_12bit;
        };

        function uint8ToBase64(rawData) {
          var numBytes = rawData.byteLength;
          var output = "";
          var segment;
          var table = b64_12bitTable();
          for(var i = 0; i < numBytes - 2; i += 3) {
            segment = (rawData[i] << 16) + (rawData[i + 1] << 8) + rawData[i + 2];
            output += table[segment >> 12];
            output += table[segment & 0xfff];
          }
          if(numBytes - i == 2) {
            segment = (rawData[i] << 16) + (rawData[i + 1] << 8);
            output += table[segment >> 12];
            output += b64_6bit[(segment & 0xfff) >> 6];
            output += '=';
          } else if(numBytes - i == 1) {
            segment = (rawData[i] << 16);
            output += table[segment >> 12];
            output += '==';
          }
          return output;
        }

      });

      // file: src/common/builder.js
      define("cordova/builder", function(require, exports, module) {

        var utils = require('cordova/utils');

        function each(objects, func, context) {
          for(var prop in objects) {
            if(objects.hasOwnProperty(prop)) {
              func.apply(context, [objects[prop], prop]);
            }
          }
        }

        function clobber(obj, key, value) {
          exports.replaceHookForTesting(obj, key);
          obj[key] = value;
          // Getters can only be overridden by getters.
          if(obj[key] !== value) {
            utils.defineGetter(obj, key, function() {
              return value;
            });
          }
        }

        function assignOrWrapInDeprecateGetter(obj, key, value, message) {
          if(message) {
            utils.defineGetter(obj, key, function() {
              console.log(message);
              delete obj[key];
              clobber(obj, key, value);
              return value;
            });
          } else {
            clobber(obj, key, value);
          }
        }

        function include(parent, objects, clobber, merge) {
          each(objects, function(obj, key) {
            try {
              var result = obj.path ? require(obj.path) : {};

              if(clobber) {
                // Clobber if it doesn't exist.
                if(typeof parent[key] === 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else if(typeof obj.path !== 'undefined') {
                  // If merging, merge properties onto parent, otherwise, clobber.
                  if(merge) {
                    recursiveMerge(parent[key], result);
                  } else {
                    assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                  }
                }
                result = parent[key];
              } else {
                // Overwrite if not currently defined.
                if(typeof parent[key] == 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else {
                  // Set result to what already exists, so we can build children into it if they exist.
                  result = parent[key];
                }
              }

              if(obj.children) {
                include(result, obj.children, clobber, merge);
              }
            } catch(e) {
              utils.alert('Exception building Cordova JS globals: ' + e + ' for key "' + key + '"');
            }
          });
        }

        /**
         * Merge properties from one object onto another recursively.  Properties from
         * the src object will overwrite existing target property.
         *
         * @param target Object to merge properties into.
         * @param src Object to merge properties from.
         */
        function recursiveMerge(target, src) {
          for(var prop in src) {
            if(src.hasOwnProperty(prop)) {
              if(target.prototype && target.prototype.constructor === target) {
                // If the target object is a constructor override off prototype.
                clobber(target.prototype, prop, src[prop]);
              } else {
                if(typeof src[prop] === 'object' && typeof target[prop] === 'object') {
                  recursiveMerge(target[prop], src[prop]);
                } else {
                  clobber(target, prop, src[prop]);
                }
              }
            }
          }
        }

        exports.buildIntoButDoNotClobber = function(objects, target) {
          include(target, objects, false, false);
        };
        exports.buildIntoAndClobber = function(objects, target) {
          include(target, objects, true, false);
        };
        exports.buildIntoAndMerge = function(objects, target) {
          include(target, objects, true, true);
        };
        exports.recursiveMerge = recursiveMerge;
        exports.assignOrWrapInDeprecateGetter = assignOrWrapInDeprecateGetter;
        exports.replaceHookForTesting = function() {};

      });

      // file: src/common/channel.js
      define("cordova/channel", function(require, exports, module) {

        var utils = require('cordova/utils'),
          nextGuid = 1;

        /**
         * Custom pub-sub "channel" that can have functions subscribed to it
         * This object is used to define and control firing of events for
         * cordova initialization, as well as for custom events thereafter.
         *
         * The order of events during page load and Cordova startup is as follows:
         *
         * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.
         * onNativeReady*              Internal event that indicates the Cordova native side is ready.
         * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.
         * onDeviceReady*              User event fired to indicate that Cordova is ready
         * onResume                    User event fired to indicate a start/resume lifecycle event
         * onPause                     User event fired to indicate a pause lifecycle event
         * onDestroy*                  Internal event fired when app is being destroyed (User should use window.onunload event, not this one).
         *
         * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.
         * All listeners that subscribe after the event is fired will be executed right away.
         *
         * The only Cordova events that user code should register for are:
         *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript
         *      pause                 App has moved to background
         *      resume                App has returned to foreground
         *
         * Listeners can be registered as:
         *      document.addEventListener("deviceready", myDeviceReadyListener, false);
         *      document.addEventListener("resume", myResumeListener, false);
         *      document.addEventListener("pause", myPauseListener, false);
         *
         * The DOM lifecycle events should be used for saving and restoring state
         *      window.onload
         *      window.onunload
         *
         */

        /**
         * Channel
         * @constructor
         * @param type  String the channel name
         */
        var Channel = function(type, sticky) {
            this.type = type;
            // Map of guid -> function.
            this.handlers = {};
            // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
            this.state = sticky ? 1 : 0;
            // Used in sticky mode to remember args passed to fire().
            this.fireArgs = null;
            // Used by onHasSubscribersChange to know if there are any listeners.
            this.numHandlers = 0;
            // Function that is called when the first listener is subscribed, or when
            // the last listener is unsubscribed.
            this.onHasSubscribersChange = null;
          },
          channel = {
            /**
             * Calls the provided function only after all of the channels specified
             * have been fired. All channels must be sticky channels.
             */
            join: function(h, c) {
              var len = c.length,
                i = len,
                f = function() {
                  if(!(--i)) h();
                };
              for(var j = 0; j < len; j++) {
                if(c[j].state === 0) {
                  throw Error('Can only use join with sticky channels.');
                }
                c[j].subscribe(f);
              }
              if(!len) h();
            },
            create: function(type) {
              return channel[type] = new Channel(type, false);
            },
            createSticky: function(type) {
              return channel[type] = new Channel(type, true);
            },

            /**
             * cordova Channels that must fire before "deviceready" is fired.
             */
            deviceReadyChannelsArray: [],
            deviceReadyChannelsMap: {},

            /**
             * Indicate that a feature needs to be initialized before it is ready to be used.
             * This holds up Cordova's "deviceready" event until the feature has been initialized
             * and Cordova.initComplete(feature) is called.
             *
             * @param feature {String}     The unique feature name
             */
            waitForInitialization: function(feature) {
              if(feature) {
                var c = channel[feature] || this.createSticky(feature);
                this.deviceReadyChannelsMap[feature] = c;
                this.deviceReadyChannelsArray.push(c);
              }
            },

            /**
             * Indicate that initialization code has completed and the feature is ready to be used.
             *
             * @param feature {String}     The unique feature name
             */
            initializationComplete: function(feature) {
              var c = this.deviceReadyChannelsMap[feature];
              if(c) {
                c.fire();
              }
            }
          };

        function forceFunction(f) {
          if(typeof f != 'function') throw "Function required as first argument!";
        }

        /**
         * Subscribes the given function to the channel. Any time that
         * Channel.fire is called so too will the function.
         * Optionally specify an execution context for the function
         * and a guid that can be used to stop subscribing to the channel.
         * Returns the guid.
         */
        Channel.prototype.subscribe = function(f, c) {
          // need a function to call
          forceFunction(f);
          if(this.state == 2) {
            f.apply(c || this, this.fireArgs);
            return;
          }

          var func = f,
            guid = f.observer_guid;
          if(typeof c == "object") {
            func = utils.close(c, f);
          }

          if(!guid) {
            // first time any channel has seen this subscriber
            guid = '' + nextGuid++;
          }
          func.observer_guid = guid;
          f.observer_guid = guid;

          // Don't add the same handler more than once.
          if(!this.handlers[guid]) {
            this.handlers[guid] = func;
            this.numHandlers++;
            if(this.numHandlers == 1) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Unsubscribes the function with the given guid from the channel.
         */
        Channel.prototype.unsubscribe = function(f) {
          // need a function to unsubscribe
          forceFunction(f);

          var guid = f.observer_guid,
            handler = this.handlers[guid];
          if(handler) {
            delete this.handlers[guid];
            this.numHandlers--;
            if(this.numHandlers === 0) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Calls all functions subscribed to this channel.
         */
        Channel.prototype.fire = function(e) {
          var fail = false,
            fireArgs = Array.prototype.slice.call(arguments);
          // Apply stickiness.
          if(this.state == 1) {
            this.state = 2;
            this.fireArgs = fireArgs;
          }
          if(this.numHandlers) {
            // Copy the values first so that it is safe to modify it from within
            // callbacks.
            var toCall = [];
            for(var item in this.handlers) {
              toCall.push(this.handlers[item]);
            }
            for(var i = 0; i < toCall.length; ++i) {
              toCall[i].apply(this, fireArgs);
            }
            if(this.state == 2 && this.numHandlers) {
              this.numHandlers = 0;
              this.handlers = {};
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };


        // defining them here so they are ready super fast!
        // DOM event that is received when the web page is loaded and parsed.
        channel.createSticky('onDOMContentLoaded');

        // Event to indicate the Cordova native side is ready.
        channel.createSticky('onNativeReady');

        // Event to indicate that all Cordova JavaScript objects have been created
        // and it's time to run plugin constructors.
        channel.createSticky('onCordovaReady');

        // Event to indicate that all automatically loaded JS plugins are loaded and ready.
        // FIXME remove this
        channel.createSticky('onPluginsReady');

        // Event to indicate that Cordova is ready
        channel.createSticky('onDeviceReady');

        // Event to indicate a resume lifecycle event
        channel.create('onResume');

        // Event to indicate a pause lifecycle event
        channel.create('onPause');

        // Event to indicate a destroy lifecycle event
        channel.createSticky('onDestroy');

        // Channels that must fire before "deviceready" is fired.
        channel.waitForInitialization('onCordovaReady');
        channel.waitForInitialization('onDOMContentLoaded');

        module.exports = channel;

      });

      // file: src/ios/exec.js
      define("cordova/exec", function(require, exports, module) {

        /**
         * Creates a gap bridge iframe used to notify the native code about queued
         * commands.
         */
        var cordova = require('cordova'),
          channel = require('cordova/channel'),
          utils = require('cordova/utils'),
          base64 = require('cordova/base64'),
          // XHR mode does not work on iOS 4.2.
          // XHR mode's main advantage is working around a bug in -webkit-scroll, which
          // doesn't exist only on iOS 5.x devices.
          // IFRAME_NAV is the fastest.
          // IFRAME_HASH could be made to enable synchronous bridge calls if we wanted this feature.
          jsToNativeModes = {
            IFRAME_NAV: 0,
            XHR_NO_PAYLOAD: 1,
            XHR_WITH_PAYLOAD: 2,
            XHR_OPTIONAL_PAYLOAD: 3,
            IFRAME_HASH_NO_PAYLOAD: 4,
            // Bundling the payload turns out to be slower. Probably since it has to be URI encoded / decoded.
            IFRAME_HASH_WITH_PAYLOAD: 5,
            WK_WEBVIEW_BINDING: 6
          },
          bridgeMode,
          execIframe,
          execHashIframe,
          hashToggle = 1,
          execXhr,
          requestCount = 0,
          vcHeaderValue = null,
          commandQueue = [], // Contains pending JS->Native messages.
          isInContextOfEvalJs = 0;

        function createExecIframe(src, unloadListener) {
          var iframe = document.createElement("iframe");
          iframe.style.display = 'none';
          // Both the unload listener and the src must be set before adding the iframe
          // to the document in order to avoid race conditions. Callbacks from native
          // can happen within the appendChild() call!
          iframe.onunload = unloadListener;
          iframe.src = src;
          document.body.appendChild(iframe);
          return iframe;
        }

        function createHashIframe() {
          var ret = createExecIframe('about:blank');
          // Hash changes don't work on about:blank, so switch it to file:///.
          ret.contentWindow.history.replaceState(null, null, 'file:///#');
          return ret;
        }

        function shouldBundleCommandJson() {
          if(bridgeMode === jsToNativeModes.XHR_WITH_PAYLOAD) {
            return true;
          }
          if(bridgeMode === jsToNativeModes.XHR_OPTIONAL_PAYLOAD) {
            var payloadLength = 0;
            for(var i = 0; i < commandQueue.length; ++i) {
              payloadLength += commandQueue[i].length;
            }
            // The value here was determined using the benchmark within CordovaLibApp on an iPad 3.
            return payloadLength < 4500;
          }
          return false;
        }

        function massageArgsJsToNative(args) {
          if(!args || utils.typeName(args) != 'Array') {
            return args;
          }
          var ret = [];
          args.forEach(function(arg, i) {
            if(utils.typeName(arg) == 'ArrayBuffer') {
              ret.push({
                'CDVType': 'ArrayBuffer',
                'data': base64.fromArrayBuffer(arg)
              });
            } else {
              ret.push(arg);
            }
          });
          return ret;
        }

        function massageMessageNativeToJs(message) {
          if(message.CDVType == 'ArrayBuffer') {
            var stringToArrayBuffer = function(str) {
              var ret = new Uint8Array(str.length);
              for(var i = 0; i < str.length; i++) {
                ret[i] = str.charCodeAt(i);
              }
              return ret.buffer;
            };
            var base64ToArrayBuffer = function(b64) {
              return stringToArrayBuffer(atob(b64));
            };
            message = base64ToArrayBuffer(message.data);
          }
          return message;
        }

        function convertMessageToArgsNativeToJs(message) {
          var args = [];
          if(!message || !message.hasOwnProperty('CDVType')) {
            args.push(message);
          } else if(message.CDVType == 'MultiPart') {
            message.messages.forEach(function(e) {
              args.push(massageMessageNativeToJs(e));
            });
          } else {
            args.push(massageMessageNativeToJs(message));
          }
          return args;
        }

        function iOSExec() {
          if(bridgeMode === undefined) {
            bridgeMode = jsToNativeModes.IFRAME_NAV;
          }

          if(window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.cordova && window.webkit.messageHandlers.cordova.postMessage) {
            bridgeMode = jsToNativeModes.WK_WEBVIEW_BINDING;
          }

          var successCallback, failCallback, service, action, actionArgs, splitCommand;
          var callbackId = null;
          if(typeof arguments[0] !== "string") {
            // FORMAT ONE
            successCallback = arguments[0];
            failCallback = arguments[1];
            service = arguments[2];
            action = arguments[3];
            actionArgs = arguments[4];

            // Since we need to maintain backwards compatibility, we have to pass
            // an invalid callbackId even if no callback was provided since plugins
            // will be expecting it. The Cordova.exec() implementation allocates
            // an invalid callbackId and passes it even if no callbacks were given.
            callbackId = 'INVALID';
          } else {
            // FORMAT TWO, REMOVED
            try {
              splitCommand = arguments[0].split(".");
              action = splitCommand.pop();
              service = splitCommand.join(".");
              actionArgs = Array.prototype.splice.call(arguments, 1);

              console.log('The old format of this exec call has been removed (deprecated since 2.1). Change to: ' +
                "cordova.exec(null, null, \"" + service + "\", \"" + action + "\"," + JSON.stringify(actionArgs) + ");"
              );
              return;
            } catch(e) {}
          }

          // If actionArgs is not provided, default to an empty array
          actionArgs = actionArgs || [];

          // Register the callbacks and add the callbackId to the positional
          // arguments if given.
          if(successCallback || failCallback) {
            callbackId = service + cordova.callbackId++;
            cordova.callbacks[callbackId] = {
              success: successCallback,
              fail: failCallback
            };
          }

          actionArgs = massageArgsJsToNative(actionArgs);

          var command = [callbackId, service, action, actionArgs];

          // Stringify and queue the command. We stringify to command now to
          // effectively clone the command arguments in case they are mutated before
          // the command is executed.
          commandQueue.push(JSON.stringify(command));

          if(bridgeMode === jsToNativeModes.WK_WEBVIEW_BINDING) {
            window.webkit.messageHandlers.cordova.postMessage(command);
          } else {
            // If we're in the context of a stringByEvaluatingJavaScriptFromString call,
            // then the queue will be flushed when it returns; no need for a poke.
            // Also, if there is already a command in the queue, then we've already
            // poked the native side, so there is no reason to do so again.
            if(!isInContextOfEvalJs && commandQueue.length == 1) {
              switch(bridgeMode) {
                case jsToNativeModes.XHR_NO_PAYLOAD:
                case jsToNativeModes.XHR_WITH_PAYLOAD:
                case jsToNativeModes.XHR_OPTIONAL_PAYLOAD:
                  pokeNativeViaXhr();
                  break;
                default: // iframe-based.
                  pokeNativeViaIframe();
              }
            }
          }
        }

        function pokeNativeViaXhr() {
          // This prevents sending an XHR when there is already one being sent.
          // This should happen only in rare circumstances (refer to unit tests).
          if(execXhr && execXhr.readyState != 4) {
            execXhr = null;
          }
          // Re-using the XHR improves exec() performance by about 10%.
          execXhr = execXhr || new XMLHttpRequest();
          // Changing this to a GET will make the XHR reach the URIProtocol on 4.2.
          // For some reason it still doesn't work though...
          // Add a timestamp to the query param to prevent caching.
          execXhr.open('HEAD', "/!gap_exec?" + (+new Date()), true);
          if(!vcHeaderValue) {
            vcHeaderValue = /.*\((.*)\)$/.exec(navigator.userAgent)[1];
          }
          execXhr.setRequestHeader('vc', vcHeaderValue);
          execXhr.setRequestHeader('rc', ++requestCount);
          if(shouldBundleCommandJson()) {
            execXhr.setRequestHeader('cmds', iOSExec.nativeFetchMessages());
          }
          execXhr.send(null);
        }

        function onIframeUnload() {
          execIframe = null;
          setTimeout(pokeNativeViaIframe, 0);
        }

        function pokeNativeViaIframe() {
          // CB-5488 - Don't attempt to create iframe before document.body is available.
          if(!document.body) {
            setTimeout(pokeNativeViaIframe);
            return;
          }
          if(bridgeMode === jsToNativeModes.IFRAME_HASH_NO_PAYLOAD || bridgeMode === jsToNativeModes.IFRAME_HASH_WITH_PAYLOAD) {
            // TODO: This bridge mode doesn't properly support being removed from the DOM (CB-7735)
            execHashIframe = execHashIframe || createHashIframe();
            // Check if they've removed it from the DOM, and put it back if so.
            if(!execHashIframe.contentWindow) {
              execHashIframe = createHashIframe();
            }
            // The delegate method is called only when the hash changes, so toggle it back and forth.
            hashToggle = hashToggle ^ 3;
            var hashValue = '%0' + hashToggle;
            if(bridgeMode === jsToNativeModes.IFRAME_HASH_WITH_PAYLOAD) {
              hashValue += iOSExec.nativeFetchMessages();
            }
            execHashIframe.contentWindow.location.hash = hashValue;
          } else {
            // Check if they've removed it from the DOM, and put it back if so.
            if(execIframe && execIframe.contentWindow) {
              // Listen for unload, since it can happen (CB-7735) that the iframe gets
              // removed from the DOM before it gets a chance to poke the native side.
              execIframe.contentWindow.onunload = onIframeUnload;
              execIframe.src = 'gap://ready';
            } else {
              execIframe = createExecIframe('gap://ready', onIframeUnload);
            }
          }
        }

        iOSExec.jsToNativeModes = jsToNativeModes;

        iOSExec.setJsToNativeBridgeMode = function(mode) {
          // Remove the iFrame since it may be no longer required, and its existence
          // can trigger browser bugs.
          // https://issues.apache.org/jira/browse/CB-593
          if(execIframe) {
            execIframe.parentNode.removeChild(execIframe);
            execIframe = null;
          }
          bridgeMode = mode;
        };

        iOSExec.nativeFetchMessages = function() {
          // Stop listing for window detatch once native side confirms poke.
          if(execIframe && execIframe.contentWindow) {
            execIframe.contentWindow.onunload = null;
          }
          // Each entry in commandQueue is a JSON string already.
          if(!commandQueue.length) {
            return '';
          }
          var json = '[' + commandQueue.join(',') + ']';
          commandQueue.length = 0;
          return json;
        };

        iOSExec.nativeCallback = function(callbackId, status, message, keepCallback) {
          return iOSExec.nativeEvalAndFetch(function() {
            var success = status === 0 || status === 1;
            var args = convertMessageToArgsNativeToJs(message);
            cordova.callbackFromNative(callbackId, success, status, args, keepCallback);
          });
        };

        iOSExec.nativeEvalAndFetch = function(func) {
          // This shouldn't be nested, but better to be safe.
          isInContextOfEvalJs++;
          try {
            func();
            return iOSExec.nativeFetchMessages();
          } finally {
            isInContextOfEvalJs--;
          }
        };

        module.exports = iOSExec;

      });

      // file: src/common/exec/proxy.js
      define("cordova/exec/proxy", function(require, exports, module) {


        // internal map of proxy function
        var CommandProxyMap = {};

        module.exports = {

          // example: cordova.commandProxy.add("Accelerometer",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);
          add: function(id, proxyObj) {
            console.log("adding proxy for " + id);
            CommandProxyMap[id] = proxyObj;
            return proxyObj;
          },

          // cordova.commandProxy.remove("Accelerometer");
          remove: function(id) {
            var proxy = CommandProxyMap[id];
            delete CommandProxyMap[id];
            CommandProxyMap[id] = null;
            return proxy;
          },

          get: function(service, action) {
            return(CommandProxyMap[service] ? CommandProxyMap[service][action] : null);
          }
        };
      });

      // file: src/common/init.js
      define("cordova/init", function(require, exports, module) {

        var channel = require('cordova/channel');
        var cordova = require('cordova');
        var modulemapper = require('cordova/modulemapper');
        var platform = require('cordova/platform');
        var pluginloader = require('cordova/pluginloader');
        var utils = require('cordova/utils');

        var platformInitChannelsArray = [channel.onNativeReady, channel.onPluginsReady];

        function logUnfiredChannels(arr) {
          for(var i = 0; i < arr.length; ++i) {
            if(arr[i].state != 2) {
              console.log('Channel not fired: ' + arr[i].type);
            }
          }
        }

        window.setTimeout(function() {
          if(channel.onDeviceReady.state != 2) {
            console.log('deviceready has not fired after 5 seconds.');
            logUnfiredChannels(platformInitChannelsArray);
            logUnfiredChannels(channel.deviceReadyChannelsArray);
          }
        }, 5000);

        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        function replaceNavigator(origNavigator) {
          var CordovaNavigator = function() {};
          CordovaNavigator.prototype = origNavigator;
          var newNavigator = new CordovaNavigator();
          // This work-around really only applies to new APIs that are newer than Function.bind.
          // Without it, APIs such as getGamepads() break.
          if(CordovaNavigator.bind) {
            for(var key in origNavigator) {
              if(typeof origNavigator[key] == 'function') {
                newNavigator[key] = origNavigator[key].bind(origNavigator);
              } else {
                (function(k) {
                  utils.defineGetterSetter(newNavigator, key, function() {
                    return origNavigator[k];
                  });
                })(key);
              }
            }
          }
          return newNavigator;
        }

        if(window.navigator) {
          window.navigator = replaceNavigator(window.navigator);
        }

        if(!window.console) {
          window.console = {
            log: function() {}
          };
        }
        if(!window.console.warn) {
          window.console.warn = function(msg) {
            this.log("warn: " + msg);
          };
        }

        // Register pause, resume and deviceready channels as events on document.
        channel.onPause = cordova.addDocumentEventHandler('pause');
        channel.onResume = cordova.addDocumentEventHandler('resume');
        channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

        // Listen for DOMContentLoaded and notify our channel subscribers.
        if(document.readyState == 'complete' || document.readyState == 'interactive') {
          channel.onDOMContentLoaded.fire();
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            channel.onDOMContentLoaded.fire();
          }, false);
        }

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if(window._nativeReady) {
          channel.onNativeReady.fire();
        }

        modulemapper.clobbers('cordova', 'cordova');
        modulemapper.clobbers('cordova/exec', 'cordova.exec');
        modulemapper.clobbers('cordova/exec', 'Cordova.exec');

        // Call the platform-specific initialization.
        platform.bootstrap && platform.bootstrap();

        // Wrap in a setTimeout to support the use-case of having plugin JS appended to cordova.js.
        // The delay allows the attached modules to be defined before the plugin loader looks for them.
        setTimeout(function() {
          pluginloader.load(function() {
            channel.onPluginsReady.fire();
          });
        }, 0);

        /**
         * Create all cordova objects once native side is ready.
         */
        channel.join(function() {
          modulemapper.mapModules(window);

          platform.initialize && platform.initialize();

          // Fire event to notify that all objects are created
          channel.onCordovaReady.fire();

          // Fire onDeviceReady event once page has fully loaded, all
          // constructors have run and cordova info has been received from native
          // side.
          channel.join(function() {
            require('cordova').fireDocumentEvent('deviceready');
          }, channel.deviceReadyChannelsArray);

        }, platformInitChannelsArray);


      });

      // file: src/common/init_b.js
      define("cordova/init_b", function(require, exports, module) {

        var channel = require('cordova/channel');
        var cordova = require('cordova');
        var platform = require('cordova/platform');
        var utils = require('cordova/utils');

        var platformInitChannelsArray = [channel.onDOMContentLoaded, channel.onNativeReady];

        // setting exec
        cordova.exec = require('cordova/exec');

        function logUnfiredChannels(arr) {
          for(var i = 0; i < arr.length; ++i) {
            if(arr[i].state != 2) {
              console.log('Channel not fired: ' + arr[i].type);
            }
          }
        }

        window.setTimeout(function() {
          if(channel.onDeviceReady.state != 2) {
            console.log('deviceready has not fired after 5 seconds.');
            logUnfiredChannels(platformInitChannelsArray);
            logUnfiredChannels(channel.deviceReadyChannelsArray);
          }
        }, 5000);

        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        function replaceNavigator(origNavigator) {
          var CordovaNavigator = function() {};
          CordovaNavigator.prototype = origNavigator;
          var newNavigator = new CordovaNavigator();
          // This work-around really only applies to new APIs that are newer than Function.bind.
          // Without it, APIs such as getGamepads() break.
          if(CordovaNavigator.bind) {
            for(var key in origNavigator) {
              if(typeof origNavigator[key] == 'function') {
                newNavigator[key] = origNavigator[key].bind(origNavigator);
              } else {
                (function(k) {
                  utils.defineGetterSetter(newNavigator, key, function() {
                    return origNavigator[k];
                  });
                })(key);
              }
            }
          }
          return newNavigator;
        }
        if(window.navigator) {
          window.navigator = replaceNavigator(window.navigator);
        }

        if(!window.console) {
          window.console = {
            log: function() {}
          };
        }
        if(!window.console.warn) {
          window.console.warn = function(msg) {
            this.log("warn: " + msg);
          };
        }

        // Register pause, resume and deviceready channels as events on document.
        channel.onPause = cordova.addDocumentEventHandler('pause');
        channel.onResume = cordova.addDocumentEventHandler('resume');
        channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

        // Listen for DOMContentLoaded and notify our channel subscribers.
        if(document.readyState == 'complete' || document.readyState == 'interactive') {
          channel.onDOMContentLoaded.fire();
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            channel.onDOMContentLoaded.fire();
          }, false);
        }

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if(window._nativeReady) {
          channel.onNativeReady.fire();
        }

        // Call the platform-specific initialization.
        platform.bootstrap && platform.bootstrap();

        /**
         * Create all cordova objects once native side is ready.
         */
        channel.join(function() {

          platform.initialize && platform.initialize();

          // Fire event to notify that all objects are created
          channel.onCordovaReady.fire();

          // Fire onDeviceReady event once page has fully loaded, all
          // constructors have run and cordova info has been received from native
          // side.
          channel.join(function() {
            require('cordova').fireDocumentEvent('deviceready');
          }, channel.deviceReadyChannelsArray);

        }, platformInitChannelsArray);

      });

      // file: src/common/modulemapper.js
      define("cordova/modulemapper", function(require, exports, module) {

        var builder = require('cordova/builder'),
          moduleMap = define.moduleMap,
          symbolList,
          deprecationMap;

        exports.reset = function() {
          symbolList = [];
          deprecationMap = {};
        };

        function addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {
          if(!(moduleName in moduleMap)) {
            throw new Error('Module ' + moduleName + ' does not exist.');
          }
          symbolList.push(strategy, moduleName, symbolPath);
          if(opt_deprecationMessage) {
            deprecationMap[symbolPath] = opt_deprecationMessage;
          }
        }

        // Note: Android 2.3 does have Function.bind().
        exports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('c', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('m', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('d', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.runs = function(moduleName) {
          addEntry('r', moduleName, null);
        };

        function prepareNamespace(symbolPath, context) {
          if(!symbolPath) {
            return context;
          }
          var parts = symbolPath.split('.');
          var cur = context;
          for(var i = 0, part; part = parts[i]; ++i) {
            cur = cur[part] = cur[part] || {};
          }
          return cur;
        }

        exports.mapModules = function(context) {
          var origSymbols = {};
          context.CDV_origSymbols = origSymbols;
          for(var i = 0, len = symbolList.length; i < len; i += 3) {
            var strategy = symbolList[i];
            var moduleName = symbolList[i + 1];
            var module = require(moduleName);
            // <runs/>
            if(strategy == 'r') {
              continue;
            }
            var symbolPath = symbolList[i + 2];
            var lastDot = symbolPath.lastIndexOf('.');
            var namespace = symbolPath.substr(0, lastDot);
            var lastName = symbolPath.substr(lastDot + 1);

            var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;
            var parentObj = prepareNamespace(namespace, context);
            var target = parentObj[lastName];

            if(strategy == 'm' && target) {
              builder.recursiveMerge(target, module);
            } else if((strategy == 'd' && !target) || (strategy != 'd')) {
              if(!(symbolPath in origSymbols)) {
                origSymbols[symbolPath] = target;
              }
              builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);
            }
          }
        };

        exports.getOriginalSymbol = function(context, symbolPath) {
          var origSymbols = context.CDV_origSymbols;
          if(origSymbols && (symbolPath in origSymbols)) {
            return origSymbols[symbolPath];
          }
          var parts = symbolPath.split('.');
          var obj = context;
          for(var i = 0; i < parts.length; ++i) {
            obj = obj && obj[parts[i]];
          }
          return obj;
        };

        exports.reset();


      });

      // file: src/ios/platform.js
      define("cordova/platform", function(require, exports, module) {

        module.exports = {
          id: 'ios',
          bootstrap: function() {
            require('cordova/channel').onNativeReady.fire();
          }
        };


      });

      // file: src/common/pluginloader.js
      define("cordova/pluginloader", function(require, exports, module) {

        var modulemapper = require('cordova/modulemapper');
        var urlutil = require('cordova/urlutil');

        // Helper function to inject a <script> tag.
        // Exported for testing.
        exports.injectScript = function(url, onload, onerror) {
          var script = document.createElement("script");
          // onload fires even when script fails loads with an error.
          script.onload = onload;
          // onerror fires for malformed URLs.
          script.onerror = onerror;
          script.src = url;
          document.head.appendChild(script);
        };

        function injectIfNecessary(id, url, onload, onerror) {
          onerror = onerror || onload;
          if(id in define.moduleMap) {
            onload();
          } else {
            exports.injectScript(url, function() {
              if(id in define.moduleMap) {
                onload();
              } else {
                onerror();
              }
            }, onerror);
          }
        }

        function onScriptLoadingComplete(moduleList, finishPluginLoading) {
          // Loop through all the plugins and then through their clobbers and merges.
          for(var i = 0, module; module = moduleList[i]; i++) {
            if(module.clobbers && module.clobbers.length) {
              for(var j = 0; j < module.clobbers.length; j++) {
                modulemapper.clobbers(module.id, module.clobbers[j]);
              }
            }

            if(module.merges && module.merges.length) {
              for(var k = 0; k < module.merges.length; k++) {
                modulemapper.merges(module.id, module.merges[k]);
              }
            }

            // Finally, if runs is truthy we want to simply require() the module.
            if(module.runs) {
              modulemapper.runs(module.id);
            }
          }

          finishPluginLoading();
        }

        // Handler for the cordova_plugins.js content.
        // See plugman's plugin_loader.js for the details of this object.
        // This function is only called if the really is a plugins array that isn't empty.
        // Otherwise the onerror response handler will just call finishPluginLoading().
        function handlePluginsObject(path, moduleList, finishPluginLoading) {
          // Now inject the scripts.
          var scriptCounter = moduleList.length;

          if(!scriptCounter) {
            finishPluginLoading();
            return;
          }

          function scriptLoadedCallback() {
            if(!--scriptCounter) {
              onScriptLoadingComplete(moduleList, finishPluginLoading);
            }
          }

          for(var i = 0; i < moduleList.length; i++) {
            injectIfNecessary(moduleList[i].id, path + moduleList[i].file, scriptLoadedCallback);
          }
        }

        function findCordovaPath() {
          var path = null;
          var scripts = document.getElementsByTagName('script');
          var term = '/cordova.js';
          for(var n = scripts.length - 1; n > -1; n--) {
            var src = scripts[n].src.replace(/\?.*$/, ''); // Strip any query param (CB-6007).
            if(src.indexOf(term) == (src.length - term.length)) {
              path = src.substring(0, src.length - term.length) + '/';
              break;
            }
          }
          return path;
        }

        // Tries to load all plugins' js-modules.
        // This is an async process, but onDeviceReady is blocked on onPluginsReady.
        // onPluginsReady is fired when there are no plugins to load, or they are all done.
        exports.load = function(callback) {
          var pathPrefix = findCordovaPath();
          if(pathPrefix === null) {
            console.log('Could not find cordova.js script tag. Plugin loading may fail.');
            pathPrefix = '';
          }
          injectIfNecessary('cordova/plugin_list', pathPrefix + 'cordova_plugins.js', function() {
            var moduleList = require("cordova/plugin_list");
            handlePluginsObject(pathPrefix, moduleList, callback);
          }, callback);
        };


      });

      // file: src/common/urlutil.js
      define("cordova/urlutil", function(require, exports, module) {


        /**
         * For already absolute URLs, returns what is passed in.
         * For relative URLs, converts them to absolute ones.
         */
        exports.makeAbsolute = function makeAbsolute(url) {
          var anchorEl = document.createElement('a');
          anchorEl.href = url;
          return anchorEl.href;
        };


      });

      // file: src/common/utils.js
      define("cordova/utils", function(require, exports, module) {

        var utils = exports;

        /**
         * Defines a property getter / setter for obj[key].
         */
        utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {
          if(Object.defineProperty) {
            var desc = {
              get: getFunc,
              configurable: true
            };
            if(opt_setFunc) {
              desc.set = opt_setFunc;
            }
            Object.defineProperty(obj, key, desc);
          } else {
            obj.__defineGetter__(key, getFunc);
            if(opt_setFunc) {
              obj.__defineSetter__(key, opt_setFunc);
            }
          }
        };

        /**
         * Defines a property getter for obj[key].
         */
        utils.defineGetter = utils.defineGetterSetter;

        utils.arrayIndexOf = function(a, item) {
          if(a.indexOf) {
            return a.indexOf(item);
          }
          var len = a.length;
          for(var i = 0; i < len; ++i) {
            if(a[i] == item) {
              return i;
            }
          }
          return -1;
        };

        /**
         * Returns whether the item was found in the array.
         */
        utils.arrayRemove = function(a, item) {
          var index = utils.arrayIndexOf(a, item);
          if(index != -1) {
            a.splice(index, 1);
          }
          return index != -1;
        };

        utils.typeName = function(val) {
          return Object.prototype.toString.call(val).slice(8, -1);
        };

        /**
         * Returns an indication of whether the argument is an array or not
         */
        utils.isArray = function(a) {
          return utils.typeName(a) == 'Array';
        };

        /**
         * Returns an indication of whether the argument is a Date or not
         */
        utils.isDate = function(d) {
          return utils.typeName(d) == 'Date';
        };

        /**
         * Does a deep clone of the object.
         */
        utils.clone = function(obj) {
          if(!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {
            return obj;
          }

          var retVal, i;

          if(utils.isArray(obj)) {
            retVal = [];
            for(i = 0; i < obj.length; ++i) {
              retVal.push(utils.clone(obj[i]));
            }
            return retVal;
          }

          retVal = {};
          for(i in obj) {
            if(!(i in retVal) || retVal[i] != obj[i]) {
              retVal[i] = utils.clone(obj[i]);
            }
          }
          return retVal;
        };

        /**
         * Returns a wrapped version of the function
         */
        utils.close = function(context, func, params) {
          if(typeof params == 'undefined') {
            return function() {
              return func.apply(context, arguments);
            };
          } else {
            return function() {
              return func.apply(context, params);
            };
          }
        };

        /**
         * Create a UUID
         */
        utils.createUUID = function() {
          return UUIDcreatePart(4) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(6);
        };

        /**
         * Extends a child object from a parent object using classical inheritance
         * pattern.
         */
        utils.extend = (function() {
          // proxy used to establish prototype chain
          var F = function() {};
          // extend Child from Parent
          return function(Child, Parent) {
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.__super__ = Parent.prototype;
            Child.prototype.constructor = Child;
          };
        }());

        /**
         * Alerts a message in any available way: alert or console.log.
         */
        utils.alert = function(msg) {
          if(window.alert) {
            window.alert(msg);
          } else if(console && console.log) {
            console.log(msg);
          }
        };


        //------------------------------------------------------------------------------
        function UUIDcreatePart(length) {
          var uuidpart = "";
          for(var i = 0; i < length; i++) {
            var uuidchar = parseInt((Math.random() * 256), 10).toString(16);
            if(uuidchar.length == 1) {
              uuidchar = "0" + uuidchar;
            }
            uuidpart += uuidchar;
          }
          return uuidpart;
        }


      });

      /************************日志插件**********************/

      define("org.apache.cordova.console-via-logger", function(require, exports, module) {
        /*
         *
         * Licensed to the Apache Software Foundation (ASF) under one
         * or more contributor license agreements.  See the NOTICE file
         * distributed with this work for additional information
         * regarding copyright ownership.  The ASF licenses this file
         * to you under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance
         * with the License.  You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing,
         * software distributed under the License is distributed on an
         * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
         * KIND, either express or implied.  See the License for the
         * specific language governing permissions and limitations
         * under the License.
         *
         */

        //------------------------------------------------------------------------------

        var logger = require("cordova/plugin/logger");
        var utils = require("cordova/utils");

        //------------------------------------------------------------------------------
        // object that we're exporting
        //------------------------------------------------------------------------------
        var console = module.exports;

        //------------------------------------------------------------------------------
        // copy of the original console object
        //------------------------------------------------------------------------------
        var WinConsole = window.console;

        //------------------------------------------------------------------------------
        // whether to use the logger
        //------------------------------------------------------------------------------
        var UseLogger = false;

        //------------------------------------------------------------------------------
        // Timers
        //------------------------------------------------------------------------------
        var Timers = {};

        //------------------------------------------------------------------------------
        // used for unimplemented methods
        //------------------------------------------------------------------------------
        function noop() {}

        //------------------------------------------------------------------------------
        // used for unimplemented methods
        //------------------------------------------------------------------------------
        console.useLogger = function(value) {
          if(arguments.length) UseLogger = !!value;

          if(UseLogger) {
            if(logger.useConsole()) {
              throw new Error("console and logger are too intertwingly");
            }
          }

          return UseLogger;
        };

        //------------------------------------------------------------------------------
        console.log = function() {
          if(logger.useConsole()) return;
          logger.log.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.error = function() {
          if(logger.useConsole()) return;
          logger.error.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.warn = function() {
          if(logger.useConsole()) return;
          logger.warn.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.info = function() {
          if(logger.useConsole()) return;
          logger.info.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.debug = function() {
          if(logger.useConsole()) return;
          logger.debug.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.assert = function(expression) {
          if(expression) return;

          var message = logger.format.apply(logger.format, [].slice.call(arguments, 1));
          console.log("ASSERT: " + message);
        };

        //------------------------------------------------------------------------------
        console.clear = function() {};

        //------------------------------------------------------------------------------
        console.dir = function(object) {
          console.log("%o", object);
        };

        //------------------------------------------------------------------------------
        console.dirxml = function(node) {
          console.log(node.innerHTML);
        };

        //------------------------------------------------------------------------------
        console.trace = noop;

        //------------------------------------------------------------------------------
        console.group = console.log;

        //------------------------------------------------------------------------------
        console.groupCollapsed = console.log;

        //------------------------------------------------------------------------------
        console.groupEnd = noop;

        //------------------------------------------------------------------------------
        console.time = function(name) {
          Timers[name] = new Date().valueOf();
        };

        //------------------------------------------------------------------------------
        console.timeEnd = function(name) {
          var timeStart = Timers[name];
          if(!timeStart) {
            console.warn("unknown timer: " + name);
            return;
          }

          var timeElapsed = new Date().valueOf() - timeStart;
          console.log(name + ": " + timeElapsed + "ms");
        };

        //------------------------------------------------------------------------------
        console.timeStamp = noop;

        //------------------------------------------------------------------------------
        console.profile = noop;

        //------------------------------------------------------------------------------
        console.profileEnd = noop;

        //------------------------------------------------------------------------------
        console.count = noop;

        //------------------------------------------------------------------------------
        console.exception = console.log;

        //------------------------------------------------------------------------------
        console.table = function(data, columns) {
          console.log("%o", data);
        };

        //------------------------------------------------------------------------------
        // return a new function that calls both functions passed as args
        //------------------------------------------------------------------------------
        function wrappedOrigCall(orgFunc, newFunc) {
          return function() {
            var args = [].slice.call(arguments);
            try { orgFunc.apply(WinConsole, args); } catch(e) {}
            try { newFunc.apply(console, args); } catch(e) {}
          };
        }

        //------------------------------------------------------------------------------
        // For every function that exists in the original console object, that
        // also exists in the new console object, wrap the new console method
        // with one that calls both
        //------------------------------------------------------------------------------
        for(var key in console) {
          if(typeof WinConsole[key] == "function") {
            console[key] = wrappedOrigCall(WinConsole[key], console[key]);
          }
        }

      });

      define("cordova/plugin/logger", function(require, exports, module) {
        /*
         *
         * Licensed to the Apache Software Foundation (ASF) under one
         * or more contributor license agreements.  See the NOTICE file
         * distributed with this work for additional information
         * regarding copyright ownership.  The ASF licenses this file
         * to you under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance
         * with the License.  You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing,
         * software distributed under the License is distributed on an
         * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
         * KIND, either express or implied.  See the License for the
         * specific language governing permissions and limitations
         * under the License.
         *
         */

        //------------------------------------------------------------------------------
        // The logger module exports the following properties/functions:
        //
        // LOG                          - constant for the level LOG
        // ERROR                        - constant for the level ERROR
        // WARN                         - constant for the level WARN
        // INFO                         - constant for the level INFO
        // DEBUG                        - constant for the level DEBUG
        // logLevel()                   - returns current log level
        // logLevel(value)              - sets and returns a new log level
        // useConsole()                 - returns whether logger is using console
        // useConsole(value)            - sets and returns whether logger is using console
        // log(message,...)             - logs a message at level LOG
        // error(message,...)           - logs a message at level ERROR
        // warn(message,...)            - logs a message at level WARN
        // info(message,...)            - logs a message at level INFO
        // debug(message,...)           - logs a message at level DEBUG
        // logLevel(level,message,...)  - logs a message specified level
        //
        //------------------------------------------------------------------------------

        var logger = exports;

        var exec = require('cordova/exec');
        var utils = require('cordova/utils');

        var UseConsole = false;
        var UseLogger = true;
        var Queued = [];
        var DeviceReady = false;
        var CurrentLevel;

        var originalConsole = console;

        /**
         * Logging levels
         */

        var Levels = [
          "LOG",
          "ERROR",
          "WARN",
          "INFO",
          "DEBUG"
        ];

        /*
         * add the logging levels to the logger object and
         * to a separate levelsMap object for testing
         */

        var LevelsMap = {};
        for(var i = 0; i < Levels.length; i++) {
          var level = Levels[i];
          LevelsMap[level] = i;
          logger[level] = level;
        }

        CurrentLevel = LevelsMap.WARN;

        /**
         * Getter/Setter for the logging level
         *
         * Returns the current logging level.
         *
         * When a value is passed, sets the logging level to that value.
         * The values should be one of the following constants:
         *    logger.LOG
         *    logger.ERROR
         *    logger.WARN
         *    logger.INFO
         *    logger.DEBUG
         *
         * The value used determines which messages get printed.  The logging
         * values above are in order, and only messages logged at the logging
         * level or above will actually be displayed to the user.  E.g., the
         * default level is WARN, so only messages logged with LOG, ERROR, or
         * WARN will be displayed; INFO and DEBUG messages will be ignored.
         */
        logger.level = function(value) {
          if(arguments.length) {
            if(LevelsMap[value] === null) {
              throw new Error("invalid logging level: " + value);
            }
            CurrentLevel = LevelsMap[value];
          }

          return Levels[CurrentLevel];
        };

        /**
         * Getter/Setter for the useConsole functionality
         *
         * When useConsole is true, the logger will log via the
         * browser 'console' object.
         */
        logger.useConsole = function(value) {
          if(arguments.length) UseConsole = !!value;

          if(UseConsole) {
            if(typeof console == "undefined") {
              throw new Error("global console object is not defined");
            }

            if(typeof console.log != "function") {
              throw new Error("global console object does not have a log function");
            }

            if(typeof console.useLogger == "function") {
              if(console.useLogger()) {
                throw new Error("console and logger are too intertwingly");
              }
            }
          }

          return UseConsole;
        };

        /**
         * Getter/Setter for the useLogger functionality
         *
         * When useLogger is true, the logger will log via the
         * native Logger plugin.
         */
        logger.useLogger = function(value) {
          // Enforce boolean
          if(arguments.length) UseLogger = !!value;
          return UseLogger;
        };

        /**
         * Logs a message at the LOG level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.log = function(message) { logWithArgs("LOG", arguments); };

        /**
         * Logs a message at the ERROR level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.error = function(message) { logWithArgs("ERROR", arguments); };

        /**
         * Logs a message at the WARN level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.warn = function(message) { logWithArgs("WARN", arguments); };

        /**
         * Logs a message at the INFO level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.info = function(message) { logWithArgs("INFO", arguments); };

        /**
         * Logs a message at the DEBUG level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.debug = function(message) { logWithArgs("DEBUG", arguments); };

        // log at the specified level with args
        function logWithArgs(level, args) {
          args = [level].concat([].slice.call(args));
          logger.logLevel.apply(logger, args);
        }

        // return the correct formatString for an object
        function formatStringForMessage(message) {
          return(typeof message === "string") ? "" : "%o";
        }

        /**
         * Logs a message at the specified level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.logLevel = function(level /* , ... */ ) {
          // format the message with the parameters
          var formatArgs = [].slice.call(arguments, 1);
          var fmtString = formatStringForMessage(formatArgs[0]);
          if(fmtString.length > 0) {
            formatArgs.unshift(fmtString); // add formatString
          }

          var message = logger.format.apply(logger.format, formatArgs);

          if(LevelsMap[level] === null) {
            throw new Error("invalid logging level: " + level);
          }

          if(LevelsMap[level] > CurrentLevel) return;

          // queue the message if not yet at deviceready
          if(!DeviceReady && !UseConsole) {
            Queued.push([level, message]);
            return;
          }

          // Log using the native logger if that is enabled
          if(UseLogger) {
            exec(null, null, "Console", "logLevel", [level, message]);
          }

          // Log using the console if that is enabled
          if(UseConsole) {
            // make sure console is not using logger
            if(console.useLogger()) {
              throw new Error("console and logger are too intertwingly");
            }

            // log to the console
            switch(level) {
              case logger.LOG:
                originalConsole.log(message);
                break;
              case logger.ERROR:
                originalConsole.log("ERROR: " + message);
                break;
              case logger.WARN:
                originalConsole.log("WARN: " + message);
                break;
              case logger.INFO:
                originalConsole.log("INFO: " + message);
                break;
              case logger.DEBUG:
                originalConsole.log("DEBUG: " + message);
                break;
            }
          }
        };


        /**
         * Formats a string and arguments following it ala console.log()
         *
         * Any remaining arguments will be appended to the formatted string.
         *
         * for rationale, see FireBug's Console API:
         *    http://getfirebug.com/wiki/index.php/Console_API
         */
        logger.format = function(formatString, args) {
          return __format(arguments[0], [].slice.call(arguments, 1)).join(' ');
        };


        //------------------------------------------------------------------------------
        /**
         * Formats a string and arguments following it ala vsprintf()
         *
         * format chars:
         *   %j - format arg as JSON
         *   %o - format arg as JSON
         *   %c - format arg as ''
         *   %% - replace with '%'
         * any other char following % will format it's
         * arg via toString().
         *
         * Returns an array containing the formatted string and any remaining
         * arguments.
         */
        function __format(formatString, args) {
          if(formatString === null || formatString === undefined) return [""];
          if(arguments.length == 1) return [formatString.toString()];

          if(typeof formatString != "string")
            formatString = formatString.toString();

          var pattern = /(.*?)%(.)(.*)/;
          var rest = formatString;
          var result = [];

          while(args.length) {
            var match = pattern.exec(rest);
            if(!match) break;

            var arg = args.shift();
            rest = match[3];
            result.push(match[1]);

            if(match[2] == '%') {
              result.push('%');
              args.unshift(arg);
              continue;
            }

            result.push(__formatted(arg, match[2]));
          }

          result.push(rest);

          var remainingArgs = [].slice.call(args);
          remainingArgs.unshift(result.join(''));
          return remainingArgs;
        }

        function __formatted(object, formatChar) {

          try {
            switch(formatChar) {
              case 'j':
              case 'o':
                return JSON.stringify(object);
              case 'c':
                return '';
            }
          } catch(e) {
            return "error JSON.stringify()ing argument: " + e;
          }

          if((object === null) || (object === undefined)) {
            return Object.prototype.toString.call(object);
          }

          return object.toString();
        }


        //------------------------------------------------------------------------------
        // when deviceready fires, log queued messages
        logger.__onDeviceReady = function() {
          if(DeviceReady) return;

          DeviceReady = true;

          for(var i = 0; i < Queued.length; i++) {
            var messageArgs = Queued[i];
            logger.logLevel(messageArgs[0], messageArgs[1]);
          }

          Queued = null;
        };

        // add a deviceready event to log queued messages
        document.addEventListener("deviceready", logger.__onDeviceReady, false);

      });

      /**************音频插件****************/
      define("org.apache.cordova.media.Media", function(require, exports, module) {
        /*
         *
         * Licensed to the Apache Software Foundation (ASF) under one
         * or more contributor license agreements.  See the NOTICE file
         * distributed with this work for additional information
         * regarding copyright ownership.  The ASF licenses this file
         * to you under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance
         * with the License.  You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing,
         * software distributed under the License is distributed on an
         * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
         * KIND, either express or implied.  See the License for the
         * specific language governing permissions and limitations
         * under the License.
         *
         */

        var argscheck = require('cordova/argscheck'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec');

        var mediaObjects = {};

        /**
         * This class provides access to the device media, interfaces to both sound and video
         *
         * @constructor
         * @param src                   The file name or url to play
         * @param successCallback       The callback to be called when the file is done playing or recording.
         *                                  successCallback()
         * @param errorCallback         The callback to be called if there is an error.
         *                                  errorCallback(int errorCode) - OPTIONAL
         * @param statusCallback        The callback to be called when media status has changed.
         *                                  statusCallback(int statusCode) - OPTIONAL
         */
        var Media = function(src, successCallback, errorCallback, statusCallback) {
          argscheck.checkArgs('SFFF', 'Media', arguments);
          this.id = utils.createUUID();
          mediaObjects[this.id] = this;
          this.src = src;
          this.successCallback = successCallback;
          this.errorCallback = errorCallback;
          this.statusCallback = statusCallback;
          this._duration = -1;
          this._position = -1;
          exec(null, this.errorCallback, "Media", "create", [this.id, this.src]);
        };

        // Media messages
        Media.MEDIA_STATE = 1;
        Media.MEDIA_DURATION = 2;
        Media.MEDIA_POSITION = 3;
        Media.MEDIA_ERROR = 9;

        // Media states
        Media.MEDIA_NONE = 0;
        Media.MEDIA_STARTING = 1;
        Media.MEDIA_RUNNING = 2;
        Media.MEDIA_PAUSED = 3;
        Media.MEDIA_STOPPED = 4;
        Media.MEDIA_MSG = ["None", "Starting", "Running", "Paused", "Stopped"];

        // "static" function to return existing objs.
        Media.get = function(id) {
          return mediaObjects[id];
        };

        /**
         * Start or resume playing audio file.
         */
        Media.prototype.play = function(options) {
          exec(null, null, "Media", "startPlayingAudio", [this.id, this.src, options]);
        };

        /**
         * Stop playing audio file.
         */
        Media.prototype.stop = function() {
          var me = this;
          exec(function() {
            me._position = 0;
          }, this.errorCallback, "Media", "stopPlayingAudio", [this.id]);
        };

        /**
         * Seek or jump to a new time in the track..
         */
        Media.prototype.seekTo = function(milliseconds) {
          var me = this;
          exec(function(p) {
            me._position = p;
          }, this.errorCallback, "Media", "seekToAudio", [this.id, milliseconds]);
        };

        /**
         * Pause playing audio file.
         */
        Media.prototype.pause = function() {
          exec(null, this.errorCallback, "Media", "pausePlayingAudio", [this.id]);
        };

        /**
         * Get duration of an audio file.
         * The duration is only set for audio that is playing, paused or stopped.
         *
         * @return      duration or -1 if not known.
         */
        Media.prototype.getDuration = function() {
          return this._duration;
        };

        /**
         * Get position of audio.
         */
        Media.prototype.getCurrentPosition = function(success, fail) {
          var me = this;
          exec(function(p) {
            me._position = p;
            success(p);
          }, fail, "Media", "getCurrentPositionAudio", [this.id]);
        };

        /**
         * Start recording audio file.
         */
        Media.prototype.startRecord = function() {
          exec(null, this.errorCallback, "Media", "startRecordingAudio", [this.id, this.src]);
        };

        /**
         * Stop recording audio file.
         */
        Media.prototype.stopRecord = function() {
          exec(null, this.errorCallback, "Media", "stopRecordingAudio", [this.id]);
        };

        /**
         * Release the resources.
         */
        Media.prototype.release = function() {
          exec(null, this.errorCallback, "Media", "release", [this.id]);
        };

        /**
         * Adjust the volume.
         */
        Media.prototype.setVolume = function(volume) {
          exec(null, null, "Media", "setVolume", [this.id, volume]);
        };

        /**
         * Audio has status update.
         * PRIVATE
         *
         * @param id            The media object id (string)
         * @param msgType       The 'type' of update this is
         * @param value         Use of value is determined by the msgType
         */
        Media.onStatus = function(id, msgType, value) {

          var media = mediaObjects[id];

          if(media) {
            switch(msgType) {
              case Media.MEDIA_STATE:
                media.statusCallback && media.statusCallback(value);
                if(value == Media.MEDIA_STOPPED) {
                  media.successCallback && media.successCallback();
                }
                break;
              case Media.MEDIA_DURATION:
                media._duration = value;
                break;
              case Media.MEDIA_ERROR:
                media.errorCallback && media.errorCallback(value);
                break;
              case Media.MEDIA_POSITION:
                media._position = Number(value);
                break;
              default:
                console.error && console.error("Unhandled Media.onStatus :: " + msgType);
                break;
            }
          } else {
            console.error && console.error("Received Media.onStatus callback for unknown media :: " + id);
          }

        };

        module.exports = Media;

      });

      define("org.apache.cordova.media.MediaError", function(require, exports, module) {
        /*
         *
         * Licensed to the Apache Software Foundation (ASF) under one
         * or more contributor license agreements.  See the NOTICE file
         * distributed with this work for additional information
         * regarding copyright ownership.  The ASF licenses this file
         * to you under the Apache License, Version 2.0 (the
         * "License"); you may not use this file except in compliance
         * with the License.  You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing,
         * software distributed under the License is distributed on an
         * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
         * KIND, either express or implied.  See the License for the
         * specific language governing permissions and limitations
         * under the License.
         *
         */

        /**
         * This class contains information about any Media errors.
         */
        /*
         According to :: http://dev.w3.org/html5/spec-author-view/video.html#mediaerror
         We should never be creating these objects, we should just implement the interface
         which has 1 property for an instance, 'code'

         instead of doing :
            errorCallbackFunction( new MediaError(3,'msg') );
        we should simply use a literal :
            errorCallbackFunction( {'code':3} );
         */

        var _MediaError = window.MediaError;


        if(!_MediaError) {
          window.MediaError = _MediaError = function(code, msg) {
            this.code = (typeof code != 'undefined') ? code : null;
            this.message = msg || ""; // message is NON-standard! do not use!
          };
        }

        _MediaError.MEDIA_ERR_NONE_ACTIVE = _MediaError.MEDIA_ERR_NONE_ACTIVE || 0;
        _MediaError.MEDIA_ERR_ABORTED = _MediaError.MEDIA_ERR_ABORTED || 1;
        _MediaError.MEDIA_ERR_NETWORK = _MediaError.MEDIA_ERR_NETWORK || 2;
        _MediaError.MEDIA_ERR_DECODE = _MediaError.MEDIA_ERR_DECODE || 3;
        _MediaError.MEDIA_ERR_NONE_SUPPORTED = _MediaError.MEDIA_ERR_NONE_SUPPORTED || 4;
        // TODO: MediaError.MEDIA_ERR_NONE_SUPPORTED is legacy, the W3 spec now defines it as below.
        // as defined by http://dev.w3.org/html5/spec-author-view/video.html#error-codes
        _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 4;

        module.exports = _MediaError;

      });

      //插件列表
      define("cordova/plugin_list", function(require, exports, module) {
        module.exports = [];
      });


      //*****************************************************************
      window.cordova = require('cordova');
      // file: src/scripts/bootstrap.js

      require('cordova/init');

      window.console = require('org.apache.cordova.console-via-logger');
      window.Media = require('org.apache.cordova.media.Media');

    })();

  } else if(Xut.plat.isAndroid) {

    // commit 71223711fb1591b1255d871140d959fd9095f0c3

    // File generated at :: Mon Jan 21 2013 13:45:08 GMT-0800 (PST)

    /*
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
     
         http://www.apache.org/licenses/LICENSE-2.0
     
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
    */

    ;
    (function() {

      // file: lib/scripts/require.js

      var require,
        define;

      (function() {
        var modules = {};
        // Stack of moduleIds currently being built.
        var requireStack = [];
        // Map of module ID -> index into requireStack of modules currently being built.
        var inProgressModules = {};

        function build(module) {
          var factory = module.factory;
          module.exports = {};
          delete module.factory;
          factory(require, module.exports, module);
          return module.exports;
        }

        require = function(id) {
          if(!modules[id]) {
            throw "module " + id + " not found";
          } else if(id in inProgressModules) {
            var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;
            throw "Cycle in require graph: " + cycle;
          }
          if(modules[id].factory) {
            try {
              inProgressModules[id] = requireStack.length;
              requireStack.push(id);
              return build(modules[id]);
            } finally {
              delete inProgressModules[id];
              requireStack.pop();
            }
          }
          return modules[id].exports;
        };

        define = function(id, factory) {
          if(modules[id]) {
            throw "module " + id + " already defined";
          }

          modules[id] = {
            id: id,
            factory: factory
          };
        };

        define.remove = function(id) {
          delete modules[id];
        };

        define.moduleMap = modules;
      })();

      //Export for use in node
      if(typeof module === "object" && typeof require === "function") {
        module.exports.require = require;
        module.exports.define = define;
      }

      // file: lib/cordova.js
      define("cordova", function(require, exports, module) {


        var channel = require('cordova/channel');

        /**
         * Listen for DOMContentLoaded and notify our channel subscribers.
         */
        document.addEventListener('DOMContentLoaded', function() {
          channel.onDOMContentLoaded.fire();
        }, false);
        if(document.readyState == 'complete' || document.readyState == 'interactive') {
          channel.onDOMContentLoaded.fire();
        }

        /**
         * Intercept calls to addEventListener + removeEventListener and handle deviceready,
         * resume, and pause events.
         */
        var m_document_addEventListener = document.addEventListener;
        var m_document_removeEventListener = document.removeEventListener;
        var m_window_addEventListener = window.addEventListener;
        var m_window_removeEventListener = window.removeEventListener;

        /**
         * Houses custom event handlers to intercept on document + window event listeners.
         */
        var documentEventHandlers = {},
          windowEventHandlers = {};

        document.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if(typeof documentEventHandlers[e] != 'undefined') {
            documentEventHandlers[e].subscribe(handler);
          } else {
            m_document_addEventListener.call(document, evt, handler, capture);
          }
        };

        window.addEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          if(typeof windowEventHandlers[e] != 'undefined') {
            windowEventHandlers[e].subscribe(handler);
          } else {
            m_window_addEventListener.call(window, evt, handler, capture);
          }
        };

        document.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if(typeof documentEventHandlers[e] != "undefined") {
            documentEventHandlers[e].unsubscribe(handler);
          } else {
            m_document_removeEventListener.call(document, evt, handler, capture);
          }
        };

        window.removeEventListener = function(evt, handler, capture) {
          var e = evt.toLowerCase();
          // If unsubscribing from an event that is handled by a plugin
          if(typeof windowEventHandlers[e] != "undefined") {
            windowEventHandlers[e].unsubscribe(handler);
          } else {
            m_window_removeEventListener.call(window, evt, handler, capture);
          }
        };

        function createEvent(type, data) {
          var event = document.createEvent('Events');
          event.initEvent(type, false, false);
          if(data) {
            for(var i in data) {
              if(data.hasOwnProperty(i)) {
                event[i] = data[i];
              }
            }
          }
          return event;
        }

        if(typeof window.console === "undefined") {
          window.console = {
            log: function() {}
          };
        }

        var cordova = {
          define: define,
          require: require,
          /**
           * Methods to add/remove your own addEventListener hijacking on document + window.
           */
          addWindowEventHandler: function(event) {
            return(windowEventHandlers[event] = channel.create(event));
          },
          addStickyDocumentEventHandler: function(event) {
            return(documentEventHandlers[event] = channel.createSticky(event));
          },
          addDocumentEventHandler: function(event) {
            return(documentEventHandlers[event] = channel.create(event));
          },
          removeWindowEventHandler: function(event) {
            delete windowEventHandlers[event];
          },
          removeDocumentEventHandler: function(event) {
            delete documentEventHandlers[event];
          },
          /**
           * Retrieve original event handlers that were replaced by Cordova
           *
           * @return object
           */
          getOriginalHandlers: function() {
            return {
              'document': { 'addEventListener': m_document_addEventListener, 'removeEventListener': m_document_removeEventListener },
              'window': { 'addEventListener': m_window_addEventListener, 'removeEventListener': m_window_removeEventListener }
            };
          },
          /**
           * Method to fire event from native code
           * bNoDetach is required for events which cause an exception which needs to be caught in native code
           */
          fireDocumentEvent: function(type, data, bNoDetach) {
            var evt = createEvent(type, data);
            if(typeof documentEventHandlers[type] != 'undefined') {
              if(bNoDetach) {
                documentEventHandlers[type].fire(evt);
              } else {
                setTimeout(function() {
                  documentEventHandlers[type].fire(evt);
                }, 0);
              }
            } else {
              document.dispatchEvent(evt);
            }
          },
          fireWindowEvent: function(type, data) {
            var evt = createEvent(type, data);
            if(typeof windowEventHandlers[type] != 'undefined') {
              setTimeout(function() {
                windowEventHandlers[type].fire(evt);
              }, 0);
            } else {
              window.dispatchEvent(evt);
            }
          },

          /**
           * Plugin callback mechanism.
           */
          // Randomize the starting callbackId to avoid collisions after refreshing or navigating.
          // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.
          callbackId: Math.floor(Math.random() * 2000000000),
          callbacks: {},
          callbackStatus: {
            NO_RESULT: 0,
            OK: 1,
            CLASS_NOT_FOUND_EXCEPTION: 2,
            ILLEGAL_ACCESS_EXCEPTION: 3,
            INSTANTIATION_EXCEPTION: 4,
            MALFORMED_URL_EXCEPTION: 5,
            IO_EXCEPTION: 6,
            INVALID_ACTION: 7,
            JSON_EXCEPTION: 8,
            ERROR: 9
          },

          /**
           * Called by native code when returning successful result from an action.
           */
          callbackSuccess: function(callbackId, args) {
            try {
              cordova.callbackFromNative(callbackId, true, args.status, args.message, args.keepCallback);
            } catch(e) {
              console.log("Error in error callback: " + callbackId + " = " + e);
            }
          },

          /**
           * Called by native code when returning error result from an action.
           */
          callbackError: function(callbackId, args) {
            // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.
            // Derive success from status.
            try {
              cordova.callbackFromNative(callbackId, false, args.status, args.message, args.keepCallback);
            } catch(e) {
              console.log("Error in error callback: " + callbackId + " = " + e);
            }
          },

          /**
           * Called by native code when returning the result from an action.
           */
          callbackFromNative: function(callbackId, success, status, message, keepCallback) {
            var callback = cordova.callbacks[callbackId];
            if(callback) {
              if(success && status == cordova.callbackStatus.OK) {
                callback.success && callback.success(message);
              } else if(!success) {
                callback.fail && callback.fail(message);
              }

              // Clear callback if not expecting any more results
              if(!keepCallback) {
                delete cordova.callbacks[callbackId];
              }
            }
          },
          addConstructor: function(func) {
            channel.onCordovaReady.subscribe(function() {
              try {
                func();
              } catch(e) {
                console.log("Failed to run constructor: " + e);
              }
            });
          }
        };

        // Register pause, resume and deviceready channels as events on document.
        channel.onPause = cordova.addDocumentEventHandler('pause');
        channel.onResume = cordova.addDocumentEventHandler('resume');
        channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

        module.exports = cordova;

      });

      // file: lib/common/argscheck.js
      define("cordova/argscheck", function(require, exports, module) {

        var exec = require('cordova/exec');
        var utils = require('cordova/utils');

        var moduleExports = module.exports;

        var typeMap = {
          'A': 'Array',
          'D': 'Date',
          'N': 'Number',
          'S': 'String',
          'F': 'Function',
          'O': 'Object'
        };

        function extractParamName(callee, argIndex) {
          return(/.*?\((.*?)\)/).exec(callee)[1].split(', ')[argIndex];
        }

        function checkArgs(spec, functionName, args, opt_callee) {
          if(!moduleExports.enableChecks) {
            return;
          }
          var errMsg = null;
          var typeName;
          for(var i = 0; i < spec.length; ++i) {
            var c = spec.charAt(i),
              cUpper = c.toUpperCase(),
              arg = args[i];
            // Asterix means allow anything.
            if(c == '*') {
              continue;
            }
            typeName = utils.typeName(arg);
            if((arg === null || arg === undefined) && c == cUpper) {
              continue;
            }
            if(typeName != typeMap[cUpper]) {
              errMsg = 'Expected ' + typeMap[cUpper];
              break;
            }
          }
          if(errMsg) {
            errMsg += ', but got ' + typeName + '.';
            errMsg = 'Wrong type for parameter "' + extractParamName(opt_callee || args.callee, i) + '" of ' + functionName + ': ' + errMsg;
            // Don't log when running jake test.
            if(typeof jasmine == 'undefined') {
              console.error(errMsg);
            }
            throw TypeError(errMsg);
          }
        }

        function getValue(value, defaultValue) {
          return value === undefined ? defaultValue : value;
        }

        moduleExports.checkArgs = checkArgs;
        moduleExports.getValue = getValue;
        moduleExports.enableChecks = true;


      });

      // file: lib/common/builder.js
      define("cordova/builder", function(require, exports, module) {

        var utils = require('cordova/utils');

        function each(objects, func, context) {
          for(var prop in objects) {
            if(objects.hasOwnProperty(prop)) {
              func.apply(context, [objects[prop], prop]);
            }
          }
        }

        function clobber(obj, key, value) {
          obj[key] = value;
          // Getters can only be overridden by getters.
          if(obj[key] !== value) {
            utils.defineGetter(obj, key, function() {
              return value;
            });
          }
        }

        function assignOrWrapInDeprecateGetter(obj, key, value, message) {
          if(message) {
            utils.defineGetter(obj, key, function() {
              console.log(message);
              delete obj[key];
              clobber(obj, key, value);
              return value;
            });
          } else {
            clobber(obj, key, value);
          }
        }

        function include(parent, objects, clobber, merge) {
          each(objects, function(obj, key) {
            try {
              var result = obj.path ? require(obj.path) : {};

              if(clobber) {
                // Clobber if it doesn't exist.
                if(typeof parent[key] === 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else if(typeof obj.path !== 'undefined') {
                  // If merging, merge properties onto parent, otherwise, clobber.
                  if(merge) {
                    recursiveMerge(parent[key], result);
                  } else {
                    assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                  }
                }
                result = parent[key];
              } else {
                // Overwrite if not currently defined.
                if(typeof parent[key] == 'undefined') {
                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                } else {
                  // Set result to what already exists, so we can build children into it if they exist.
                  result = parent[key];
                }
              }

              if(obj.children) {
                include(result, obj.children, clobber, merge);
              }
            } catch(e) {
              utils.alert('Exception building cordova JS globals: ' + e + ' for key "' + key + '"');
            }
          });
        }

        /**
         * Merge properties from one object onto another recursively.  Properties from
         * the src object will overwrite existing target property.
         *
         * @param target Object to merge properties into.
         * @param src Object to merge properties from.
         */
        function recursiveMerge(target, src) {
          for(var prop in src) {
            if(src.hasOwnProperty(prop)) {
              if(target.prototype && target.prototype.constructor === target) {
                // If the target object is a constructor override off prototype.
                clobber(target.prototype, prop, src[prop]);
              } else {
                if(typeof src[prop] === 'object' && typeof target[prop] === 'object') {
                  recursiveMerge(target[prop], src[prop]);
                } else {
                  clobber(target, prop, src[prop]);
                }
              }
            }
          }
        }

        module.exports = {
          buildIntoButDoNotClobber: function(objects, target) {
            include(target, objects, false, false);
          },
          buildIntoAndClobber: function(objects, target) {
            include(target, objects, true, false);
          },
          buildIntoAndMerge: function(objects, target) {
            include(target, objects, true, true);
          },
          recursiveMerge: recursiveMerge,
          assignOrWrapInDeprecateGetter: assignOrWrapInDeprecateGetter
        };

      });

      // file: lib/common/channel.js
      define("cordova/channel", function(require, exports, module) {

        var utils = require('cordova/utils'),
          nextGuid = 1;

        /**
         * Custom pub-sub "channel" that can have functions subscribed to it
         * This object is used to define and control firing of events for
         * cordova initialization, as well as for custom events thereafter.
         *
         * The order of events during page load and Cordova startup is as follows:
         *
         * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.
         * onNativeReady*              Internal event that indicates the Cordova native side is ready.
         * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.
         * onCordovaInfoReady*         Internal event fired when device properties are available.
         * onCordovaConnectionReady*   Internal event fired when the connection property has been set.
         * onDeviceReady*              User event fired to indicate that Cordova is ready
         * onResume                    User event fired to indicate a start/resume lifecycle event
         * onPause                     User event fired to indicate a pause lifecycle event
         * onDestroy*                  Internal event fired when app is being destroyed (User should use window.onunload event, not this one).
         *
         * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.
         * All listeners that subscribe after the event is fired will be executed right away.
         *
         * The only Cordova events that user code should register for are:
         *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript
         *      pause                 App has moved to background
         *      resume                App has returned to foreground
         *
         * Listeners can be registered as:
         *      document.addEventListener("deviceready", myDeviceReadyListener, false);
         *      document.addEventListener("resume", myResumeListener, false);
         *      document.addEventListener("pause", myPauseListener, false);
         *
         * The DOM lifecycle events should be used for saving and restoring state
         *      window.onload
         *      window.onunload
         *
         */

        /**
         * Channel
         * @constructor
         * @param type  String the channel name
         */
        var Channel = function(type, sticky) {
            this.type = type;
            // Map of guid -> function.
            this.handlers = {};
            // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
            this.state = sticky ? 1 : 0;
            // Used in sticky mode to remember args passed to fire().
            this.fireArgs = null;
            // Used by onHasSubscribersChange to know if there are any listeners.
            this.numHandlers = 0;
            // Function that is called when the first listener is subscribed, or when
            // the last listener is unsubscribed.
            this.onHasSubscribersChange = null;
          },
          channel = {
            /**
             * Calls the provided function only after all of the channels specified
             * have been fired. All channels must be sticky channels.
             */
            join: function(h, c) {
              var len = c.length,
                i = len,
                f = function() {
                  if(!(--i)) h();
                };
              for(var j = 0; j < len; j++) {
                if(c[j].state === 0) {
                  throw Error('Can only use join with sticky channels.');
                }
                c[j].subscribe(f);
              }
              if(!len) h();
            },
            create: function(type) {
              return channel[type] = new Channel(type, false);
            },
            createSticky: function(type) {
              return channel[type] = new Channel(type, true);
            },

            /**
             * cordova Channels that must fire before "deviceready" is fired.
             */
            deviceReadyChannelsArray: [],
            deviceReadyChannelsMap: {},

            /**
             * Indicate that a feature needs to be initialized before it is ready to be used.
             * This holds up Cordova's "deviceready" event until the feature has been initialized
             * and Cordova.initComplete(feature) is called.
             *
             * @param feature {String}     The unique feature name
             */
            waitForInitialization: function(feature) {
              if(feature) {
                var c = channel[feature] || this.createSticky(feature);
                this.deviceReadyChannelsMap[feature] = c;
                this.deviceReadyChannelsArray.push(c);
              }
            },

            /**
             * Indicate that initialization code has completed and the feature is ready to be used.
             *
             * @param feature {String}     The unique feature name
             */
            initializationComplete: function(feature) {
              var c = this.deviceReadyChannelsMap[feature];
              if(c) {
                c.fire();
              }
            }
          };

        function forceFunction(f) {
          if(typeof f != 'function') throw "Function required as first argument!";
        }

        /**
         * Subscribes the given function to the channel. Any time that
         * Channel.fire is called so too will the function.
         * Optionally specify an execution context for the function
         * and a guid that can be used to stop subscribing to the channel.
         * Returns the guid.
         */
        Channel.prototype.subscribe = function(f, c) {
          // need a function to call
          forceFunction(f);
          if(this.state == 2) {
            f.apply(c || this, this.fireArgs);
            return;
          }

          var func = f,
            guid = f.observer_guid;
          if(typeof c == "object") { func = utils.close(c, f); }

          if(!guid) {
            // first time any channel has seen this subscriber
            guid = '' + nextGuid++;
          }
          func.observer_guid = guid;
          f.observer_guid = guid;

          // Don't add the same handler more than once.
          if(!this.handlers[guid]) {
            this.handlers[guid] = func;
            this.numHandlers++;
            if(this.numHandlers == 1) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Unsubscribes the function with the given guid from the channel.
         */
        Channel.prototype.unsubscribe = function(f) {
          // need a function to unsubscribe
          forceFunction(f);

          var guid = f.observer_guid,
            handler = this.handlers[guid];
          if(handler) {
            delete this.handlers[guid];
            this.numHandlers--;
            if(this.numHandlers === 0) {
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };

        /**
         * Calls all functions subscribed to this channel.
         */
        Channel.prototype.fire = function(e) {
          var fail = false,
            fireArgs = Array.prototype.slice.call(arguments);
          // Apply stickiness.
          if(this.state == 1) {
            this.state = 2;
            this.fireArgs = fireArgs;
          }
          if(this.numHandlers) {
            // Copy the values first so that it is safe to modify it from within
            // callbacks.
            var toCall = [];
            for(var item in this.handlers) {
              toCall.push(this.handlers[item]);
            }
            for(var i = 0; i < toCall.length; ++i) {
              toCall[i].apply(this, fireArgs);
            }
            if(this.state == 2 && this.numHandlers) {
              this.numHandlers = 0;
              this.handlers = {};
              this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
          }
        };


        // defining them here so they are ready super fast!
        // DOM event that is received when the web page is loaded and parsed.
        channel.createSticky('onDOMContentLoaded');

        // Event to indicate the Cordova native side is ready.
        channel.createSticky('onNativeReady');

        // Event to indicate that all Cordova JavaScript objects have been created
        // and it's time to run plugin constructors.
        channel.createSticky('onCordovaReady');

        // Event to indicate that device properties are available
        channel.createSticky('onCordovaInfoReady');

        // Event to indicate that the connection property has been set.
        channel.createSticky('onCordovaConnectionReady');

        // Event to indicate that Cordova is ready
        channel.createSticky('onDeviceReady');

        // Event to indicate a resume lifecycle event
        channel.create('onResume');

        // Event to indicate a pause lifecycle event
        channel.create('onPause');

        // Event to indicate a destroy lifecycle event
        channel.createSticky('onDestroy');

        // Channels that must fire before "deviceready" is fired.
        channel.waitForInitialization('onCordovaReady');
        channel.waitForInitialization('onCordovaConnectionReady');

        module.exports = channel;

      });

      // file: lib/common/commandProxy.js
      define("cordova/commandProxy", function(require, exports, module) {


        // internal map of proxy function
        var CommandProxyMap = {};

        module.exports = {

          // example: cordova.commandProxy.add("Accelerometer",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);
          add: function(id, proxyObj) {
            console.log("adding proxy for " + id);
            CommandProxyMap[id] = proxyObj;
            return proxyObj;
          },

          // cordova.commandProxy.remove("Accelerometer");
          remove: function(id) {
            var proxy = CommandProxyMap[id];
            delete CommandProxyMap[id];
            CommandProxyMap[id] = null;
            return proxy;
          },

          get: function(service, action) {
            return(CommandProxyMap[service] ? CommandProxyMap[service][action] : null);
          }
        };
      });

      // file: lib/common/common.js
      define("cordova/common", function(require, exports, module) {

        module.exports = {
          defaults: {
            cordova: {
              path: 'cordova',
              children: {
                exec: {
                  path: 'cordova/exec'
                },
                logger: {
                  path: 'cordova/plugin/logger'
                }
              }
            },
            Cordova: {
              children: {
                exec: {
                  path: 'cordova/exec'
                }
              }
            },
            open: {
              path: 'cordova/plugin/InAppBrowser'
            },
            navigator: {
              children: {
                notification: {
                  path: 'cordova/plugin/notification'
                },
                accelerometer: {
                  path: 'cordova/plugin/accelerometer'
                },
                battery: {
                  path: 'cordova/plugin/battery'
                },
                camera: {
                  path: 'cordova/plugin/Camera'
                },
                compass: {
                  path: 'cordova/plugin/compass'
                },
                contacts: {
                  path: 'cordova/plugin/contacts'
                },
                device: {
                  children: {
                    capture: {
                      path: 'cordova/plugin/capture'
                    }
                  }
                },
                geolocation: {
                  path: 'cordova/plugin/geolocation'
                },
                globalization: {
                  path: 'cordova/plugin/globalization'
                },
                network: {
                  children: {
                    connection: {
                      path: 'cordova/plugin/network',
                      deprecated: 'navigator.network.connection is deprecated. Use navigator.connection instead.'
                    }
                  }
                },
                splashscreen: {
                  path: 'cordova/plugin/splashscreen'
                }
              }
            },
            Acceleration: {
              path: 'cordova/plugin/Acceleration'
            },
            Camera: {
              path: 'cordova/plugin/CameraConstants'
            },
            CameraPopoverOptions: {
              path: 'cordova/plugin/CameraPopoverOptions'
            },
            CaptureError: {
              path: 'cordova/plugin/CaptureError'
            },
            CaptureAudioOptions: {
              path: 'cordova/plugin/CaptureAudioOptions'
            },
            CaptureImageOptions: {
              path: 'cordova/plugin/CaptureImageOptions'
            },
            CaptureVideoOptions: {
              path: 'cordova/plugin/CaptureVideoOptions'
            },
            CompassHeading: {
              path: 'cordova/plugin/CompassHeading'
            },
            CompassError: {
              path: 'cordova/plugin/CompassError'
            },
            ConfigurationData: {
              path: 'cordova/plugin/ConfigurationData'
            },
            Connection: {
              path: 'cordova/plugin/Connection'
            },
            Contact: {
              path: 'cordova/plugin/Contact'
            },
            ContactAddress: {
              path: 'cordova/plugin/ContactAddress'
            },
            ContactError: {
              path: 'cordova/plugin/ContactError'
            },
            ContactField: {
              path: 'cordova/plugin/ContactField'
            },
            ContactFindOptions: {
              path: 'cordova/plugin/ContactFindOptions'
            },
            ContactName: {
              path: 'cordova/plugin/ContactName'
            },
            ContactOrganization: {
              path: 'cordova/plugin/ContactOrganization'
            },
            Coordinates: {
              path: 'cordova/plugin/Coordinates'
            },
            device: {
              path: 'cordova/plugin/device'
            },
            GlobalizationError: {
              path: 'cordova/plugin/GlobalizationError'
            },
            Media: {
              path: 'cordova/plugin/Media'
            },
            MediaError: {
              path: 'cordova/plugin/MediaError'
            },
            MediaFile: {
              path: 'cordova/plugin/MediaFile'
            },
            MediaFileData: {
              path: 'cordova/plugin/MediaFileData'
            },
            Position: {
              path: 'cordova/plugin/Position'
            },
            PositionError: {
              path: 'cordova/plugin/PositionError'
            },
            ProgressEvent: {
              path: 'cordova/plugin/ProgressEvent'
            }
          },
          clobbers: {
            navigator: {
              children: {
                connection: {
                  path: 'cordova/plugin/network'
                }
              }
            }
          }
        };

      });

      // file: lib/android/exec.js
      define("cordova/exec", function(require, exports, module) {

        /**
         * Execute a cordova command.  It is up to the native side whether this action
         * is synchronous or asynchronous.  The native side can return:
         *      Synchronous: PluginResult object as a JSON string
         *      Asynchronous: Empty string ""
         * If async, the native side will cordova.callbackSuccess or cordova.callbackError,
         * depending upon the result of the action.
         *
         * @param {Function} success    The success callback
         * @param {Function} fail       The fail callback
         * @param {String} service      The name of the service to use
         * @param {String} action       Action to be run in cordova
         * @param {String[]} [args]     Zero or more arguments to pass to the method
         */
        var cordova = require('cordova'),
          nativeApiProvider = require('cordova/plugin/android/nativeapiprovider'),
          utils = require('cordova/utils'),
          jsToNativeModes = {
            PROMPT: 0,
            JS_OBJECT: 1,
            // This mode is currently for benchmarking purposes only. It must be enabled
            // on the native side through the ENABLE_LOCATION_CHANGE_EXEC_MODE
            // constant within CordovaWebViewClient.java before it will work.
            LOCATION_CHANGE: 2
          },
          nativeToJsModes = {
            // Polls for messages using the JS->Native bridge.
            POLLING: 0,
            // For LOAD_URL to be viable, it would need to have a work-around for
            // the bug where the soft-keyboard gets dismissed when a message is sent.
            LOAD_URL: 1,
            // For the ONLINE_EVENT to be viable, it would need to intercept all event
            // listeners (both through addEventListener and window.ononline) as well
            // as set the navigator property itself.
            ONLINE_EVENT: 2,
            // Uses reflection to access private APIs of the WebView that can send JS
            // to be executed.
            // Requires Android 3.2.4 or above.
            PRIVATE_API: 3
          },
          jsToNativeBridgeMode, // Set lazily.
          nativeToJsBridgeMode = nativeToJsModes.ONLINE_EVENT,
          pollEnabled = false,
          messagesFromNative = [];

        function androidExec(success, fail, service, action, args) {
          // Set default bridge modes if they have not already been set.
          // By default, we use the failsafe, since addJavascriptInterface breaks too often
          if(jsToNativeBridgeMode === undefined) {
            androidExec.setJsToNativeBridgeMode(jsToNativeModes.JS_OBJECT);
          }

          // Process any ArrayBuffers in the args into a string.
          for(var i = 0; i < args.length; i++) {
            if(utils.typeName(args[i]) == 'ArrayBuffer') {
              args[i] = window.btoa(String.fromCharCode.apply(null, new Uint8Array(args[i])));
            }
          }

          var callbackId = service + cordova.callbackId++,
            argsJson = JSON.stringify(args),
            returnValue;

          // TODO: Returning the payload of a synchronous call was deprecated in 2.2.0.
          // Remove it after 6 months.
          function captureReturnValue(value) {
            returnValue = value;
            success && success(value);
          }

          cordova.callbacks[callbackId] = { success: captureReturnValue, fail: fail };

          if(jsToNativeBridgeMode == jsToNativeModes.LOCATION_CHANGE) {
            window.location = 'http://cdv_exec/' + service + '#' + action + '#' + callbackId + '#' + argsJson;
          } else {
            var messages = nativeApiProvider.get().exec(service, action, callbackId, argsJson);
            androidExec.processMessages(messages);
          }
          if(cordova.callbacks[callbackId]) {
            if(success || fail) {
              cordova.callbacks[callbackId].success = success;
            } else {
              delete cordova.callbacks[callbackId];
            }
          }
          return returnValue;
        }

        function pollOnce() {
          var msg = nativeApiProvider.get().retrieveJsMessages();
          androidExec.processMessages(msg);
        }

        function pollingTimerFunc() {
          if(pollEnabled) {
            pollOnce();
            setTimeout(pollingTimerFunc, 50);
          }
        }

        function hookOnlineApis() {
          function proxyEvent(e) {
            cordova.fireWindowEvent(e.type);
          }
          // The network module takes care of firing online and offline events.
          // It currently fires them only on document though, so we bridge them
          // to window here (while first listening for exec()-releated online/offline
          // events).
          window.addEventListener('online', pollOnce, false);
          window.addEventListener('offline', pollOnce, false);
          cordova.addWindowEventHandler('online');
          cordova.addWindowEventHandler('offline');
          document.addEventListener('online', proxyEvent, false);
          document.addEventListener('offline', proxyEvent, false);
        }

        hookOnlineApis();

        androidExec.jsToNativeModes = jsToNativeModes;
        androidExec.nativeToJsModes = nativeToJsModes;

        androidExec.setJsToNativeBridgeMode = function(mode) {
          if(mode == jsToNativeModes.JS_OBJECT && !window._cordovaNative) {
            console.log('Falling back on PROMPT mode since _cordovaNative is missing.');
            mode = jsToNativeModes.PROMPT;
          }
          nativeApiProvider.setPreferPrompt(mode == jsToNativeModes.PROMPT);
          jsToNativeBridgeMode = mode;
        };

        androidExec.setNativeToJsBridgeMode = function(mode) {
          if(mode == nativeToJsBridgeMode) {
            return;
          }
          if(nativeToJsBridgeMode == nativeToJsModes.POLLING) {
            pollEnabled = false;
          }

          nativeToJsBridgeMode = mode;
          // Tell the native side to switch modes.
          nativeApiProvider.get().setNativeToJsBridgeMode(mode);

          if(mode == nativeToJsModes.POLLING) {
            pollEnabled = true;
            setTimeout(pollingTimerFunc, 1);
          }
        };

        // Processes a single message, as encoded by NativeToJsMessageQueue.java.
        function processMessage(message) {
          try {
            var firstChar = message.charAt(0);
            if(firstChar == 'J') {
              eval(message.slice(1));
            } else if(firstChar == 'S' || firstChar == 'F') {
              var success = firstChar == 'S';
              var keepCallback = message.charAt(1) == '1';
              var spaceIdx = message.indexOf(' ', 2);
              var status = +message.slice(2, spaceIdx);
              var nextSpaceIdx = message.indexOf(' ', spaceIdx + 1);
              var callbackId = message.slice(spaceIdx + 1, nextSpaceIdx);
              var payloadKind = message.charAt(nextSpaceIdx + 1);
              var payload;
              if(payloadKind == 's') {
                payload = message.slice(nextSpaceIdx + 2);
              } else if(payloadKind == 't') {
                payload = true;
              } else if(payloadKind == 'f') {
                payload = false;
              } else if(payloadKind == 'N') {
                payload = null;
              } else if(payloadKind == 'n') {
                payload = +message.slice(nextSpaceIdx + 2);
              } else if(payloadKind == 'A') {
                var data = message.slice(nextSpaceIdx + 2);
                var bytes = window.atob(data);
                var arraybuffer = new Uint8Array(bytes.length);
                for(var i = 0; i < bytes.length; i++) {
                  arraybuffer[i] = bytes.charCodeAt(i);
                }
                payload = arraybuffer.buffer;
              } else {
                payload = JSON.parse(message.slice(nextSpaceIdx + 1));
              }
              cordova.callbackFromNative(callbackId, success, status, payload, keepCallback);
            } else {
              console.log("processMessage failed: invalid message:" + message);
            }
          } catch(e) {
            console.log("processMessage failed: Message: " + message);
            console.log("processMessage failed: Error: " + e);
            console.log("processMessage failed: Stack: " + e.stack);
          }
        }

        // This is called from the NativeToJsMessageQueue.java.
        androidExec.processMessages = function(messages) {
          if(messages) {
            messagesFromNative.push(messages);
            while(messagesFromNative.length) {
              messages = messagesFromNative.shift();
              // The Java side can send a * message to indicate that it
              // still has messages waiting to be retrieved.
              // TODO(agrieve): This is currently disabled on the Java side
              // since it breaks returning the result in exec of synchronous
              // plugins. Once we remove this ability, we can remove this comment.
              if(messages == '*') {
                window.setTimeout(pollOnce, 0);
                continue;
              }

              var spaceIdx = messages.indexOf(' ');
              var msgLen = +messages.slice(0, spaceIdx);
              var message = messages.substr(spaceIdx + 1, msgLen);
              messages = messages.slice(spaceIdx + msgLen + 1);
              // Put the remaining messages back into queue in case an exec()
              // is made by the callback.
              if(messages) {
                messagesFromNative.unshift(messages);
              }

              if(message) {
                processMessage(message);
              }
            }
          }
        };

        module.exports = androidExec;

      });

      // file: lib/common/modulemapper.js
      define("cordova/modulemapper", function(require, exports, module) {

        var builder = require('cordova/builder'),
          moduleMap = define.moduleMap,
          symbolList,
          deprecationMap;

        exports.reset = function() {
          symbolList = [];
          deprecationMap = {};
        };

        function addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {
          if(!(moduleName in moduleMap)) {
            throw new Error('Module ' + moduleName + ' does not exist.');
          }
          symbolList.push(strategy, moduleName, symbolPath);
          if(opt_deprecationMessage) {
            deprecationMap[symbolPath] = opt_deprecationMessage;
          }
        }

        // Note: Android 2.3 does have Function.bind().
        exports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('c', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('m', moduleName, symbolPath, opt_deprecationMessage);
        };

        exports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {
          addEntry('d', moduleName, symbolPath, opt_deprecationMessage);
        };

        function prepareNamespace(symbolPath, context) {
          if(!symbolPath) {
            return context;
          }
          var parts = symbolPath.split('.');
          var cur = context;
          for(var i = 0, part; part = parts[i]; ++i) {
            cur[part] = cur[part] || {};
          }
          return cur[parts[i - 1]];
        }

        exports.mapModules = function(context) {
          var origSymbols = {};
          context.CDV_origSymbols = origSymbols;
          for(var i = 0, len = symbolList.length; i < len; i += 3) {
            var strategy = symbolList[i];
            var moduleName = symbolList[i + 1];
            var symbolPath = symbolList[i + 2];
            var lastDot = symbolPath.lastIndexOf('.');
            var namespace = symbolPath.substr(0, lastDot);
            var lastName = symbolPath.substr(lastDot + 1);

            var module = require(moduleName);
            var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;
            var parentObj = prepareNamespace(namespace, context);
            var target = parentObj[lastName];

            if(strategy == 'm' && target) {
              builder.recursiveMerge(target, module);
            } else if((strategy == 'd' && !target) || (strategy != 'd')) {
              if(target) {
                origSymbols[symbolPath] = target;
              }
              builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);
            }
          }
        };

        exports.getOriginalSymbol = function(context, symbolPath) {
          var origSymbols = context.CDV_origSymbols;
          if(origSymbols && (symbolPath in origSymbols)) {
            return origSymbols[symbolPath];
          }
          var parts = symbolPath.split('.');
          var obj = context;
          for(var i = 0; i < parts.length; ++i) {
            obj = obj && obj[parts[i]];
          }
          return obj;
        };

        exports.loadMatchingModules = function(matchingRegExp) {
          for(var k in moduleMap) {
            if(matchingRegExp.exec(k)) {
              require(k);
            }
          }
        };

        exports.reset();


      });

      // file: lib/android/platform.js
      define("cordova/platform", function(require, exports, module) {

        module.exports = {
          id: "android",
          initialize: function() {
            var channel = require("cordova/channel"),
              cordova = require('cordova'),
              exec = require('cordova/exec'),
              modulemapper = require('cordova/modulemapper');

            modulemapper.loadMatchingModules(/cordova.*\/symbols$/);
            modulemapper.mapModules(window);

            // Inject a listener for the backbutton on the document.
            var backButtonChannel = cordova.addDocumentEventHandler('backbutton');
            backButtonChannel.onHasSubscribersChange = function() {
              // If we just attached the first handler or detached the last handler,
              // let native know we need to override the back button.
              exec(null, null, "App", "overrideBackbutton", [this.numHandlers == 1]);
            };

            // Add hardware MENU and SEARCH button handlers
            cordova.addDocumentEventHandler('menubutton');
            cordova.addDocumentEventHandler('searchbutton');

            // Figure out if we need to shim-in localStorage and WebSQL
            // support from the native side.
            var storage = require('cordova/plugin/android/storage');

            // First patch WebSQL if necessary
            if(typeof window.openDatabase == 'undefined') {
              // Not defined, create an openDatabase function for all to use!
              window.openDatabase = storage.openDatabase;
            } else {
              // Defined, but some Android devices will throw a SECURITY_ERR -
              // so we wrap the whole thing in a try-catch and shim in our own
              // if the device has Android bug 16175.
              var originalOpenDatabase = window.openDatabase;
              window.openDatabase = function(name, version, desc, size) {
                var db = null;
                try {
                  db = originalOpenDatabase(name, version, desc, size);
                } catch(ex) {
                  if(ex.code === 18) {
                    db = null;
                  } else {
                    throw ex;
                  }
                }

                if(db === null) {
                  return storage.openDatabase(name, version, desc, size);
                } else {
                  return db;
                }

              };
            }

            // Patch localStorage if necessary
            if(typeof window.localStorage == 'undefined' || window.localStorage === null) {
              window.localStorage = new storage.CupcakeLocalStorage();
            }

            // Let native code know we are all done on the JS side.
            // Native code will then un-hide the WebView.
            channel.join(function() {
              exec(null, null, "App", "show", []);
            }, [channel.onCordovaReady]);
          },
          clobbers: {
            navigator: {
              children: {
                app: {
                  path: "cordova/plugin/android/app"
                }
              }
            },
            File: { // exists natively on Android WebView, override
              path: "cordova/plugin/File"
            },
            FileReader: { // exists natively on Android WebView, override
              path: "cordova/plugin/FileReader"
            },
            FileError: { //exists natively on Android WebView on Android 4.x
              path: "cordova/plugin/FileError"
            },
            MediaError: { // exists natively on Android WebView on Android 4.x
              path: "cordova/plugin/MediaError"
            },
            open: {
              path: "cordova/plugin/InAppBrowser"
            }
          },
          merges: {
            device: {
              path: 'cordova/plugin/android/device'
            },
            navigator: {
              children: {
                notification: {
                  path: 'cordova/plugin/android/notification'
                }
              }
            }
          }
        };

      });

      // file: lib/common/plugin/Acceleration.js
      define("cordova/plugin/Acceleration", function(require, exports, module) {

        var Acceleration = function(x, y, z, timestamp) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.timestamp = timestamp || (new Date()).getTime();
        };

        module.exports = Acceleration;

      });

      // file: lib/common/plugin/Camera.js
      define("cordova/plugin/Camera", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          exec = require('cordova/exec'),
          Camera = require('cordova/plugin/CameraConstants');

        var cameraExport = {};

        // Tack on the Camera Constants to the base camera plugin.
        for(var key in Camera) {
          cameraExport[key] = Camera[key];
        }

        /**
         * Gets a picture from source defined by "options.sourceType", and returns the
         * image as defined by the "options.destinationType" option.

         * The defaults are sourceType=CAMERA and destinationType=FILE_URI.
         *
         * @param {Function} successCallback
         * @param {Function} errorCallback
         * @param {Object} options
         */
        cameraExport.getPicture = function(successCallback, errorCallback, options) {
          argscheck.checkArgs('fFO', 'Camera.getPicture', arguments);
          options = options || {};
          var getValue = argscheck.getValue;

          var quality = getValue(options.quality, 50);
          var destinationType = getValue(options.destinationType, Camera.DestinationType.FILE_URI);
          var sourceType = getValue(options.sourceType, Camera.PictureSourceType.CAMERA);
          var targetWidth = getValue(options.targetWidth, -1);
          var targetHeight = getValue(options.targetHeight, -1);
          var encodingType = getValue(options.encodingType, Camera.EncodingType.JPEG);
          var mediaType = getValue(options.mediaType, Camera.MediaType.PICTURE);
          var allowEdit = !!options.allowEdit;
          var correctOrientation = !!options.correctOrientation;
          var saveToPhotoAlbum = !!options.saveToPhotoAlbum;
          var popoverOptions = getValue(options.popoverOptions, null);

          var args = [quality, destinationType, sourceType, targetWidth, targetHeight, encodingType,
            mediaType, allowEdit, correctOrientation, saveToPhotoAlbum, popoverOptions
          ];

          exec(successCallback, errorCallback, "Camera", "takePicture", args);
        };

        cameraExport.cleanup = function(successCallback, errorCallback) {
          exec(successCallback, errorCallback, "Camera", "cleanup", []);
        };

        module.exports = cameraExport;

      });

      // file: lib/common/plugin/CameraConstants.js
      define("cordova/plugin/CameraConstants", function(require, exports, module) {

        module.exports = {
          DestinationType: {
            DATA_URL: 0, // Return base64 encoded string
            FILE_URI: 1, // Return file uri (content://media/external/images/media/2 for Android)
            NATIVE_URI: 2 // Return native uri (eg. asset-library://... for iOS)
          },
          EncodingType: {
            JPEG: 0, // Return JPEG encoded image
            PNG: 1 // Return PNG encoded image
          },
          MediaType: {
            PICTURE: 0, // allow selection of still pictures only. DEFAULT. Will return format specified via DestinationType
            VIDEO: 1, // allow selection of video only, ONLY RETURNS URL
            ALLMEDIA: 2 // allow selection from all media types
          },
          PictureSourceType: {
            PHOTOLIBRARY: 0, // Choose image from picture library (same as SAVEDPHOTOALBUM for Android)
            CAMERA: 1, // Take picture from camera
            SAVEDPHOTOALBUM: 2 // Choose image from picture library (same as PHOTOLIBRARY for Android)
          },
          PopoverArrowDirection: {
            ARROW_UP: 1, // matches iOS UIPopoverArrowDirection constants to specify arrow location on popover
            ARROW_DOWN: 2,
            ARROW_LEFT: 4,
            ARROW_RIGHT: 8,
            ARROW_ANY: 15
          }
        };

      });

      // file: lib/common/plugin/CameraPopoverOptions.js
      define("cordova/plugin/CameraPopoverOptions", function(require, exports, module) {

        var Camera = require('cordova/plugin/CameraConstants');

        /**
         * Encapsulates options for iOS Popover image picker
         */
        var CameraPopoverOptions = function(x, y, width, height, arrowDir) {
          // information of rectangle that popover should be anchored to
          this.x = x || 0;
          this.y = y || 32;
          this.width = width || 320;
          this.height = height || 480;
          // The direction of the popover arrow
          this.arrowDir = arrowDir || Camera.PopoverArrowDirection.ARROW_ANY;
        };

        module.exports = CameraPopoverOptions;

      });

      // file: lib/common/plugin/CaptureAudioOptions.js
      define("cordova/plugin/CaptureAudioOptions", function(require, exports, module) {

        /**
         * Encapsulates all audio capture operation configuration options.
         */
        var CaptureAudioOptions = function() {
          // Upper limit of sound clips user can record. Value must be equal or greater than 1.
          this.limit = 1;
          // Maximum duration of a single sound clip in seconds.
          this.duration = 0;
          // The selected audio mode. Must match with one of the elements in supportedAudioModes array.
          this.mode = null;
        };

        module.exports = CaptureAudioOptions;

      });

      // file: lib/common/plugin/CaptureError.js
      define("cordova/plugin/CaptureError", function(require, exports, module) {

        /**
         * The CaptureError interface encapsulates all errors in the Capture API.
         */
        var CaptureError = function(c) {
          this.code = c || null;
        };

        // Camera or microphone failed to capture image or sound.
        CaptureError.CAPTURE_INTERNAL_ERR = 0;
        // Camera application or audio capture application is currently serving other capture request.
        CaptureError.CAPTURE_APPLICATION_BUSY = 1;
        // Invalid use of the API (e.g. limit parameter has value less than one).
        CaptureError.CAPTURE_INVALID_ARGUMENT = 2;
        // User exited camera application or audio capture application before capturing anything.
        CaptureError.CAPTURE_NO_MEDIA_FILES = 3;
        // The requested capture operation is not supported.
        CaptureError.CAPTURE_NOT_SUPPORTED = 20;

        module.exports = CaptureError;

      });

      // file: lib/common/plugin/CaptureImageOptions.js
      define("cordova/plugin/CaptureImageOptions", function(require, exports, module) {

        /**
         * Encapsulates all image capture operation configuration options.
         */
        var CaptureImageOptions = function() {
          // Upper limit of images user can take. Value must be equal or greater than 1.
          this.limit = 1;
          // The selected image mode. Must match with one of the elements in supportedImageModes array.
          this.mode = null;
        };

        module.exports = CaptureImageOptions;

      });

      // file: lib/common/plugin/CaptureVideoOptions.js
      define("cordova/plugin/CaptureVideoOptions", function(require, exports, module) {

        /**
         * Encapsulates all video capture operation configuration options.
         */
        var CaptureVideoOptions = function() {
          // Upper limit of videos user can record. Value must be equal or greater than 1.
          this.limit = 1;
          // Maximum duration of a single video clip in seconds.
          this.duration = 0;
          // The selected video mode. Must match with one of the elements in supportedVideoModes array.
          this.mode = null;
        };

        module.exports = CaptureVideoOptions;

      });

      // file: lib/common/plugin/CompassError.js
      define("cordova/plugin/CompassError", function(require, exports, module) {

        /**
         *  CompassError.
         *  An error code assigned by an implementation when an error has occurred
         * @constructor
         */
        var CompassError = function(err) {
          this.code = (err !== undefined ? err : null);
        };

        CompassError.COMPASS_INTERNAL_ERR = 0;
        CompassError.COMPASS_NOT_SUPPORTED = 20;

        module.exports = CompassError;

      });

      // file: lib/common/plugin/CompassHeading.js
      define("cordova/plugin/CompassHeading", function(require, exports, module) {

        var CompassHeading = function(magneticHeading, trueHeading, headingAccuracy, timestamp) {
          this.magneticHeading = magneticHeading || null;
          this.trueHeading = trueHeading || null;
          this.headingAccuracy = headingAccuracy || null;
          this.timestamp = timestamp || new Date().getTime();
        };

        module.exports = CompassHeading;

      });

      // file: lib/common/plugin/ConfigurationData.js
      define("cordova/plugin/ConfigurationData", function(require, exports, module) {

        /**
         * Encapsulates a set of parameters that the capture device supports.
         */
        function ConfigurationData() {
          // The ASCII-encoded string in lower case representing the media type.
          this.type = null;
          // The height attribute represents height of the image or video in pixels.
          // In the case of a sound clip this attribute has value 0.
          this.height = 0;
          // The width attribute represents width of the image or video in pixels.
          // In the case of a sound clip this attribute has value 0
          this.width = 0;
        }

        module.exports = ConfigurationData;

      });

      // file: lib/common/plugin/Connection.js
      define("cordova/plugin/Connection", function(require, exports, module) {

        /**
         * Network status
         */
        module.exports = {
          UNKNOWN: "unknown",
          ETHERNET: "ethernet",
          WIFI: "wifi",
          CELL_2G: "2g",
          CELL_3G: "3g",
          CELL_4G: "4g",
          NONE: "none"
        };

      });

      // file: lib/common/plugin/Contact.js
      define("cordova/plugin/Contact", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          exec = require('cordova/exec'),
          ContactError = require('cordova/plugin/ContactError'),
          utils = require('cordova/utils');

        /**
         * Converts primitives into Complex Object
         * Currently only used for Date fields
         */
        function convertIn(contact) {
          var value = contact.birthday;
          try {
            contact.birthday = new Date(parseFloat(value));
          } catch(exception) {
            console.log("Cordova Contact convertIn error: exception creating date.");
          }
          return contact;
        }

        /**
         * Converts Complex objects into primitives
         * Only conversion at present is for Dates.
         **/

        function convertOut(contact) {
          var value = contact.birthday;
          if(value !== null) {
            // try to make it a Date object if it is not already
            if(!utils.isDate(value)) {
              try {
                value = new Date(value);
              } catch(exception) {
                value = null;
              }
            }
            if(utils.isDate(value)) {
              value = value.valueOf(); // convert to milliseconds
            }
            contact.birthday = value;
          }
          return contact;
        }

        /**
         * Contains information about a single contact.
         * @constructor
         * @param {DOMString} id unique identifier
         * @param {DOMString} displayName
         * @param {ContactName} name
         * @param {DOMString} nickname
         * @param {Array.<ContactField>} phoneNumbers array of phone numbers
         * @param {Array.<ContactField>} emails array of email addresses
         * @param {Array.<ContactAddress>} addresses array of addresses
         * @param {Array.<ContactField>} ims instant messaging user ids
         * @param {Array.<ContactOrganization>} organizations
         * @param {DOMString} birthday contact's birthday
         * @param {DOMString} note user notes about contact
         * @param {Array.<ContactField>} photos
         * @param {Array.<ContactField>} categories
         * @param {Array.<ContactField>} urls contact's web sites
         */
        var Contact = function(id, displayName, name, nickname, phoneNumbers, emails, addresses,
          ims, organizations, birthday, note, photos, categories, urls) {
          this.id = id || null;
          this.rawId = null;
          this.displayName = displayName || null;
          this.name = name || null; // ContactName
          this.nickname = nickname || null;
          this.phoneNumbers = phoneNumbers || null; // ContactField[]
          this.emails = emails || null; // ContactField[]
          this.addresses = addresses || null; // ContactAddress[]
          this.ims = ims || null; // ContactField[]
          this.organizations = organizations || null; // ContactOrganization[]
          this.birthday = birthday || null;
          this.note = note || null;
          this.photos = photos || null; // ContactField[]
          this.categories = categories || null; // ContactField[]
          this.urls = urls || null; // ContactField[]
        };

        /**
         * Removes contact from device storage.
         * @param successCB success callback
         * @param errorCB error callback
         */
        Contact.prototype.remove = function(successCB, errorCB) {
          argscheck.checkArgs('FF', 'Contact.remove', arguments);
          var fail = errorCB && function(code) {
            errorCB(new ContactError(code));
          };
          if(this.id === null) {
            fail(ContactError.UNKNOWN_ERROR);
          } else {
            exec(successCB, fail, "Contacts", "remove", [this.id]);
          }
        };

        /**
         * Creates a deep copy of this Contact.
         * With the contact ID set to null.
         * @return copy of this Contact
         */
        Contact.prototype.clone = function() {
          var clonedContact = utils.clone(this);
          clonedContact.id = null;
          clonedContact.rawId = null;

          function nullIds(arr) {
            if(arr) {
              for(var i = 0; i < arr.length; ++i) {
                arr[i].id = null;
              }
            }
          }

          // Loop through and clear out any id's in phones, emails, etc.
          nullIds(clonedContact.phoneNumbers);
          nullIds(clonedContact.emails);
          nullIds(clonedContact.addresses);
          nullIds(clonedContact.ims);
          nullIds(clonedContact.organizations);
          nullIds(clonedContact.categories);
          nullIds(clonedContact.photos);
          nullIds(clonedContact.urls);
          return clonedContact;
        };

        /**
         * Persists contact to device storage.
         * @param successCB success callback
         * @param errorCB error callback
         */
        Contact.prototype.save = function(successCB, errorCB) {
          argscheck.checkArgs('FFO', 'Contact.save', arguments);
          var fail = errorCB && function(code) {
            errorCB(new ContactError(code));
          };
          var success = function(result) {
            if(result) {
              if(successCB) {
                var fullContact = require('cordova/plugin/contacts').create(result);
                successCB(convertIn(fullContact));
              }
            } else {
              // no Entry object returned
              fail(ContactError.UNKNOWN_ERROR);
            }
          };
          var dupContact = convertOut(utils.clone(this));
          exec(success, fail, "Contacts", "save", [dupContact]);
        };


        module.exports = Contact;

      });

      // file: lib/common/plugin/ContactAddress.js
      define("cordova/plugin/ContactAddress", function(require, exports, module) {

        /**
         * Contact address.
         * @constructor
         * @param {DOMString} id unique identifier, should only be set by native code
         * @param formatted // NOTE: not a W3C standard
         * @param streetAddress
         * @param locality
         * @param region
         * @param postalCode
         * @param country
         */

        var ContactAddress = function(pref, type, formatted, streetAddress, locality, region, postalCode, country) {
          this.id = null;
          this.pref = (typeof pref != 'undefined' ? pref : false);
          this.type = type || null;
          this.formatted = formatted || null;
          this.streetAddress = streetAddress || null;
          this.locality = locality || null;
          this.region = region || null;
          this.postalCode = postalCode || null;
          this.country = country || null;
        };

        module.exports = ContactAddress;

      });

      // file: lib/common/plugin/ContactError.js
      define("cordova/plugin/ContactError", function(require, exports, module) {

        /**
         *  ContactError.
         *  An error code assigned by an implementation when an error has occurred
         * @constructor
         */
        var ContactError = function(err) {
          this.code = (typeof err != 'undefined' ? err : null);
        };

        /**
         * Error codes
         */
        ContactError.UNKNOWN_ERROR = 0;
        ContactError.INVALID_ARGUMENT_ERROR = 1;
        ContactError.TIMEOUT_ERROR = 2;
        ContactError.PENDING_OPERATION_ERROR = 3;
        ContactError.IO_ERROR = 4;
        ContactError.NOT_SUPPORTED_ERROR = 5;
        ContactError.PERMISSION_DENIED_ERROR = 20;

        module.exports = ContactError;

      });

      // file: lib/common/plugin/ContactField.js
      define("cordova/plugin/ContactField", function(require, exports, module) {

        /**
         * Generic contact field.
         * @constructor
         * @param {DOMString} id unique identifier, should only be set by native code // NOTE: not a W3C standard
         * @param type
         * @param value
         * @param pref
         */
        var ContactField = function(type, value, pref) {
          this.id = null;
          this.type = (type && type.toString()) || null;
          this.value = (value && value.toString()) || null;
          this.pref = (typeof pref != 'undefined' ? pref : false);
        };

        module.exports = ContactField;

      });

      // file: lib/common/plugin/ContactFindOptions.js
      define("cordova/plugin/ContactFindOptions", function(require, exports, module) {

        /**
         * ContactFindOptions.
         * @constructor
         * @param filter used to match contacts against
         * @param multiple boolean used to determine if more than one contact should be returned
         */

        var ContactFindOptions = function(filter, multiple) {
          this.filter = filter || '';
          this.multiple = (typeof multiple != 'undefined' ? multiple : false);
        };

        module.exports = ContactFindOptions;

      });

      // file: lib/common/plugin/ContactName.js
      define("cordova/plugin/ContactName", function(require, exports, module) {

        /**
         * Contact name.
         * @constructor
         * @param formatted // NOTE: not part of W3C standard
         * @param familyName
         * @param givenName
         * @param middle
         * @param prefix
         * @param suffix
         */
        var ContactName = function(formatted, familyName, givenName, middle, prefix, suffix) {
          this.formatted = formatted || null;
          this.familyName = familyName || null;
          this.givenName = givenName || null;
          this.middleName = middle || null;
          this.honorificPrefix = prefix || null;
          this.honorificSuffix = suffix || null;
        };

        module.exports = ContactName;

      });

      // file: lib/common/plugin/ContactOrganization.js
      define("cordova/plugin/ContactOrganization", function(require, exports, module) {

        /**
         * Contact organization.
         * @constructor
         * @param {DOMString} id unique identifier, should only be set by native code // NOTE: not a W3C standard
         * @param name
         * @param dept
         * @param title
         * @param startDate
         * @param endDate
         * @param location
         * @param desc
         */

        var ContactOrganization = function(pref, type, name, dept, title) {
          this.id = null;
          this.pref = (typeof pref != 'undefined' ? pref : false);
          this.type = type || null;
          this.name = name || null;
          this.department = dept || null;
          this.title = title || null;
        };

        module.exports = ContactOrganization;

      });

      // file: lib/common/plugin/Coordinates.js
      define("cordova/plugin/Coordinates", function(require, exports, module) {

        /**
         * This class contains position information.
         * @param {Object} lat
         * @param {Object} lng
         * @param {Object} alt
         * @param {Object} acc
         * @param {Object} head
         * @param {Object} vel
         * @param {Object} altacc
         * @constructor
         */
        var Coordinates = function(lat, lng, alt, acc, head, vel, altacc) {
          /**
           * The latitude of the position.
           */
          this.latitude = lat;
          /**
           * The longitude of the position,
           */
          this.longitude = lng;
          /**
           * The accuracy of the position.
           */
          this.accuracy = acc;
          /**
           * The altitude of the position.
           */
          this.altitude = (alt !== undefined ? alt : null);
          /**
           * The direction the device is moving at the position.
           */
          this.heading = (head !== undefined ? head : null);
          /**
           * The velocity with which the device is moving at the position.
           */
          this.speed = (vel !== undefined ? vel : null);

          if(this.speed === 0 || this.speed === null) {
            this.heading = NaN;
          }

          /**
           * The altitude accuracy of the position.
           */
          this.altitudeAccuracy = (altacc !== undefined) ? altacc : null;
        };

        module.exports = Coordinates;

      });

      // file: lib/common/plugin/DirectoryEntry.js
      define("cordova/plugin/DirectoryEntry", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec'),
          Entry = require('cordova/plugin/Entry'),
          FileError = require('cordova/plugin/FileError'),
          DirectoryReader = require('cordova/plugin/DirectoryReader');

        /**
         * An interface representing a directory on the file system.
         *
         * {boolean} isFile always false (readonly)
         * {boolean} isDirectory always true (readonly)
         * {DOMString} name of the directory, excluding the path leading to it (readonly)
         * {DOMString} fullPath the absolute full path to the directory (readonly)
         * TODO: implement this!!! {FileSystem} filesystem on which the directory resides (readonly)
         */
        var DirectoryEntry = function(name, fullPath) {
          DirectoryEntry.__super__.constructor.call(this, false, true, name, fullPath);
        };

        utils.extend(DirectoryEntry, Entry);

        /**
         * Creates a new DirectoryReader to read entries from this directory
         */
        DirectoryEntry.prototype.createReader = function() {
          return new DirectoryReader(this.fullPath);
        };

        /**
         * Creates or looks up a directory
         *
         * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a directory
         * @param {Flags} options to create or exclusively create the directory
         * @param {Function} successCallback is called with the new entry
         * @param {Function} errorCallback is called with a FileError
         */
        DirectoryEntry.prototype.getDirectory = function(path, options, successCallback, errorCallback) {
          argscheck.checkArgs('sOFF', 'DirectoryEntry.getDirectory', arguments);
          var win = successCallback && function(result) {
            var entry = new DirectoryEntry(result.name, result.fullPath);
            successCallback(entry);
          };
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };
          exec(win, fail, "File", "getDirectory", [this.fullPath, path, options]);
        };

        /**
         * Deletes a directory and all of it's contents
         *
         * @param {Function} successCallback is called with no parameters
         * @param {Function} errorCallback is called with a FileError
         */
        DirectoryEntry.prototype.removeRecursively = function(successCallback, errorCallback) {
          argscheck.checkArgs('FF', 'DirectoryEntry.removeRecursively', arguments);
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };
          exec(successCallback, fail, "File", "removeRecursively", [this.fullPath]);
        };

        /**
         * Creates or looks up a file
         *
         * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a file
         * @param {Flags} options to create or exclusively create the file
         * @param {Function} successCallback is called with the new entry
         * @param {Function} errorCallback is called with a FileError
         */
        DirectoryEntry.prototype.getFile = function(path, options, successCallback, errorCallback) {
          argscheck.checkArgs('sOFF', 'DirectoryEntry.getFile', arguments);
          var win = successCallback && function(result) {
            var FileEntry = require('cordova/plugin/FileEntry');
            var entry = new FileEntry(result.name, result.fullPath);
            successCallback(entry);
          };
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };
          exec(win, fail, "File", "getFile", [this.fullPath, path, options]);
        };

        module.exports = DirectoryEntry;

      });

      // file: lib/common/plugin/DirectoryReader.js
      define("cordova/plugin/DirectoryReader", function(require, exports, module) {

        var exec = require('cordova/exec'),
          FileError = require('cordova/plugin/FileError');

        /**
         * An interface that lists the files and directories in a directory.
         */
        function DirectoryReader(path) {
          this.path = path || null;
        }

        /**
         * Returns a list of entries from a directory.
         *
         * @param {Function} successCallback is called with a list of entries
         * @param {Function} errorCallback is called with a FileError
         */
        DirectoryReader.prototype.readEntries = function(successCallback, errorCallback) {
          var win = typeof successCallback !== 'function' ? null : function(result) {
            var retVal = [];
            for(var i = 0; i < result.length; i++) {
              var entry = null;
              if(result[i].isDirectory) {
                entry = new(require('cordova/plugin/DirectoryEntry'))();
              } else if(result[i].isFile) {
                entry = new(require('cordova/plugin/FileEntry'))();
              }
              entry.isDirectory = result[i].isDirectory;
              entry.isFile = result[i].isFile;
              entry.name = result[i].name;
              entry.fullPath = result[i].fullPath;
              retVal.push(entry);
            }
            successCallback(retVal);
          };
          var fail = typeof errorCallback !== 'function' ? null : function(code) {
            errorCallback(new FileError(code));
          };
          exec(win, fail, "File", "readEntries", [this.path]);
        };

        module.exports = DirectoryReader;

      });

      // file: lib/common/plugin/Entry.js
      define("cordova/plugin/Entry", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          exec = require('cordova/exec'),
          FileError = require('cordova/plugin/FileError'),
          Metadata = require('cordova/plugin/Metadata');

        /**
         * Represents a file or directory on the local file system.
         *
         * @param isFile
         *            {boolean} true if Entry is a file (readonly)
         * @param isDirectory
         *            {boolean} true if Entry is a directory (readonly)
         * @param name
         *            {DOMString} name of the file or directory, excluding the path
         *            leading to it (readonly)
         * @param fullPath
         *            {DOMString} the absolute full path to the file or directory
         *            (readonly)
         */
        function Entry(isFile, isDirectory, name, fullPath, fileSystem) {
          this.isFile = !!isFile;
          this.isDirectory = !!isDirectory;
          this.name = name || '';
          this.fullPath = fullPath || '';
          this.filesystem = fileSystem || null;
        }

        /**
         * Look up the metadata of the entry.
         *
         * @param successCallback
         *            {Function} is called with a Metadata object
         * @param errorCallback
         *            {Function} is called with a FileError
         */
        Entry.prototype.getMetadata = function(successCallback, errorCallback) {
          argscheck.checkArgs('FF', 'Entry.getMetadata', arguments);
          var success = successCallback && function(lastModified) {
            var metadata = new Metadata(lastModified);
            successCallback(metadata);
          };
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };

          exec(success, fail, "File", "getMetadata", [this.fullPath]);
        };

        /**
         * Set the metadata of the entry.
         *
         * @param successCallback
         *            {Function} is called with a Metadata object
         * @param errorCallback
         *            {Function} is called with a FileError
         * @param metadataObject
         *            {Object} keys and values to set
         */
        Entry.prototype.setMetadata = function(successCallback, errorCallback, metadataObject) {
          argscheck.checkArgs('FFO', 'Entry.setMetadata', arguments);
          exec(successCallback, errorCallback, "File", "setMetadata", [this.fullPath, metadataObject]);
        };

        /**
         * Move a file or directory to a new location.
         *
         * @param parent
         *            {DirectoryEntry} the directory to which to move this entry
         * @param newName
         *            {DOMString} new name of the entry, defaults to the current name
         * @param successCallback
         *            {Function} called with the new DirectoryEntry object
         * @param errorCallback
         *            {Function} called with a FileError
         */
        Entry.prototype.moveTo = function(parent, newName, successCallback, errorCallback) {
          argscheck.checkArgs('oSFF', 'Entry.moveTo', arguments);
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };
          // source path
          var srcPath = this.fullPath,
            // entry name
            name = newName || this.name,
            success = function(entry) {
              if(entry) {
                if(successCallback) {
                  // create appropriate Entry object
                  var result = (entry.isDirectory) ? new(require('cordova/plugin/DirectoryEntry'))(entry.name, entry.fullPath) : new(require('cordova/plugin/FileEntry'))(entry.name, entry.fullPath);
                  successCallback(result);
                }
              } else {
                // no Entry object returned
                fail && fail(FileError.NOT_FOUND_ERR);
              }
            };

          // copy
          exec(success, fail, "File", "moveTo", [srcPath, parent.fullPath, name]);
        };

        /**
         * Copy a directory to a different location.
         *
         * @param parent
         *            {DirectoryEntry} the directory to which to copy the entry
         * @param newName
         *            {DOMString} new name of the entry, defaults to the current name
         * @param successCallback
         *            {Function} called with the new Entry object
         * @param errorCallback
         *            {Function} called with a FileError
         */
        Entry.prototype.copyTo = function(parent, newName, successCallback, errorCallback) {
          argscheck.checkArgs('oSFF', 'Entry.copyTo', arguments);
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };

          // source path
          var srcPath = this.fullPath,
            // entry name
            name = newName || this.name,
            // success callback
            success = function(entry) {
              if(entry) {
                if(successCallback) {
                  // create appropriate Entry object
                  var result = (entry.isDirectory) ? new(require('cordova/plugin/DirectoryEntry'))(entry.name, entry.fullPath) : new(require('cordova/plugin/FileEntry'))(entry.name, entry.fullPath);
                  successCallback(result);
                }
              } else {
                // no Entry object returned
                fail && fail(FileError.NOT_FOUND_ERR);
              }
            };

          // copy
          exec(success, fail, "File", "copyTo", [srcPath, parent.fullPath, name]);
        };

        /**
         * Return a URL that can be used to identify this entry.
         */
        Entry.prototype.toURL = function() {
          // fullPath attribute contains the full URL
          return this.fullPath;
        };

        /**
         * Returns a URI that can be used to identify this entry.
         *
         * @param {DOMString} mimeType for a FileEntry, the mime type to be used to interpret the file, when loaded through this URI.
         * @return uri
         */
        Entry.prototype.toURI = function(mimeType) {
          console.log("DEPRECATED: Update your code to use 'toURL'");
          // fullPath attribute contains the full URI
          return this.toURL();
        };

        /**
         * Remove a file or directory. It is an error to attempt to delete a
         * directory that is not empty. It is an error to attempt to delete a
         * root directory of a file system.
         *
         * @param successCallback {Function} called with no parameters
         * @param errorCallback {Function} called with a FileError
         */
        Entry.prototype.remove = function(successCallback, errorCallback) {
          argscheck.checkArgs('FF', 'Entry.remove', arguments);
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };
          exec(successCallback, fail, "File", "remove", [this.fullPath]);
        };

        /**
         * Look up the parent DirectoryEntry of this entry.
         *
         * @param successCallback {Function} called with the parent DirectoryEntry object
         * @param errorCallback {Function} called with a FileError
         */
        Entry.prototype.getParent = function(successCallback, errorCallback) {
          argscheck.checkArgs('FF', 'Entry.getParent', arguments);
          var win = successCallback && function(result) {
            var DirectoryEntry = require('cordova/plugin/DirectoryEntry');
            var entry = new DirectoryEntry(result.name, result.fullPath);
            successCallback(entry);
          };
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };
          exec(win, fail, "File", "getParent", [this.fullPath]);
        };

        module.exports = Entry;

      });

      // file: lib/common/plugin/File.js
      define("cordova/plugin/File", function(require, exports, module) {

        /**
         * Constructor.
         * name {DOMString} name of the file, without path information
         * fullPath {DOMString} the full path of the file, including the name
         * type {DOMString} mime type
         * lastModifiedDate {Date} last modified date
         * size {Number} size of the file in bytes
         */

        var File = function(name, fullPath, type, lastModifiedDate, size) {
          this.name = name || '';
          this.fullPath = fullPath || null;
          this.type = type || null;
          this.lastModifiedDate = lastModifiedDate || null;
          this.size = size || 0;

          // These store the absolute start and end for slicing the file.
          this.start = 0;
          this.end = this.size;
        };

        /**
         * Returns a "slice" of the file. Since Cordova Files don't contain the actual
         * content, this really returns a File with adjusted start and end.
         * Slices of slices are supported.
         * start {Number} The index at which to start the slice (inclusive).
         * end {Number} The index at which to end the slice (exclusive).
         */
        File.prototype.slice = function(start, end) {
          var size = this.end - this.start;
          var newStart = 0;
          var newEnd = size;
          if(arguments.length) {
            if(start < 0) {
              newStart = Math.max(size + start, 0);
            } else {
              newStart = Math.min(size, start);
            }
          }

          if(arguments.length >= 2) {
            if(end < 0) {
              newEnd = Math.max(size + end, 0);
            } else {
              newEnd = Math.min(end, size);
            }
          }

          var newFile = new File(this.name, this.fullPath, this.type, this.lastModifiedData, this.size);
          newFile.start = this.start + newStart;
          newFile.end = this.start + newEnd;
          return newFile;
        };


        module.exports = File;

      });

      // file: lib/common/plugin/FileEntry.js
      define("cordova/plugin/FileEntry", function(require, exports, module) {

        var utils = require('cordova/utils'),
          exec = require('cordova/exec'),
          Entry = require('cordova/plugin/Entry'),
          FileWriter = require('cordova/plugin/FileWriter'),
          File = require('cordova/plugin/File'),
          FileError = require('cordova/plugin/FileError');

        /**
         * An interface representing a file on the file system.
         *
         * {boolean} isFile always true (readonly)
         * {boolean} isDirectory always false (readonly)
         * {DOMString} name of the file, excluding the path leading to it (readonly)
         * {DOMString} fullPath the absolute full path to the file (readonly)
         * {FileSystem} filesystem on which the file resides (readonly)
         */
        var FileEntry = function(name, fullPath) {
          FileEntry.__super__.constructor.apply(this, [true, false, name, fullPath]);
        };

        utils.extend(FileEntry, Entry);

        /**
         * Creates a new FileWriter associated with the file that this FileEntry represents.
         *
         * @param {Function} successCallback is called with the new FileWriter
         * @param {Function} errorCallback is called with a FileError
         */
        FileEntry.prototype.createWriter = function(successCallback, errorCallback) {
          this.file(function(filePointer) {
            var writer = new FileWriter(filePointer);

            if(writer.fileName === null || writer.fileName === "") {
              errorCallback && errorCallback(new FileError(FileError.INVALID_STATE_ERR));
            } else {
              successCallback && successCallback(writer);
            }
          }, errorCallback);
        };

        /**
         * Returns a File that represents the current state of the file that this FileEntry represents.
         *
         * @param {Function} successCallback is called with the new File object
         * @param {Function} errorCallback is called with a FileError
         */
        FileEntry.prototype.file = function(successCallback, errorCallback) {
          var win = successCallback && function(f) {
            var file = new File(f.name, f.fullPath, f.type, f.lastModifiedDate, f.size);
            successCallback(file);
          };
          var fail = errorCallback && function(code) {
            errorCallback(new FileError(code));
          };
          exec(win, fail, "File", "getFileMetadata", [this.fullPath]);
        };


        module.exports = FileEntry;

      });

      // file: lib/common/plugin/FileError.js
      define("cordova/plugin/FileError", function(require, exports, module) {

        /**
         * FileError
         */
        function FileError(error) {
          this.code = error || null;
        }

        // File error codes
        // Found in DOMException
        FileError.NOT_FOUND_ERR = 1;
        FileError.SECURITY_ERR = 2;
        FileError.ABORT_ERR = 3;

        // Added by File API specification
        FileError.NOT_READABLE_ERR = 4;
        FileError.ENCODING_ERR = 5;
        FileError.NO_MODIFICATION_ALLOWED_ERR = 6;
        FileError.INVALID_STATE_ERR = 7;
        FileError.SYNTAX_ERR = 8;
        FileError.INVALID_MODIFICATION_ERR = 9;
        FileError.QUOTA_EXCEEDED_ERR = 10;
        FileError.TYPE_MISMATCH_ERR = 11;
        FileError.PATH_EXISTS_ERR = 12;

        module.exports = FileError;

      });

      // file: lib/common/plugin/FileReader.js
      define("cordova/plugin/FileReader", function(require, exports, module) {

        var exec = require('cordova/exec'),
          modulemapper = require('cordova/modulemapper'),
          utils = require('cordova/utils'),
          File = require('cordova/plugin/File'),
          FileError = require('cordova/plugin/FileError'),
          ProgressEvent = require('cordova/plugin/ProgressEvent'),
          origFileReader = modulemapper.getOriginalSymbol(this, 'FileReader');

        /**
         * This class reads the mobile device file system.
         *
         * For Android:
         *      The root directory is the root of the file system.
         *      To read from the SD card, the file name is "sdcard/my_file.txt"
         * @constructor
         */
        var FileReader = function() {
          this._readyState = 0;
          this._error = null;
          this._result = null;
          this._fileName = '';
          this._realReader = origFileReader ? new origFileReader() : {};
        };

        // States
        FileReader.EMPTY = 0;
        FileReader.LOADING = 1;
        FileReader.DONE = 2;

        utils.defineGetter(FileReader.prototype, 'readyState', function() {
          return this._fileName ? this._readyState : this._realReader.readyState;
        });

        utils.defineGetter(FileReader.prototype, 'error', function() {
          return this._fileName ? this._error : this._realReader.error;
        });

        utils.defineGetter(FileReader.prototype, 'result', function() {
          return this._fileName ? this._result : this._realReader.result;
        });

        function defineEvent(eventName) {
          utils.defineGetterSetter(FileReader.prototype, eventName, function() {
            return this._realReader[eventName] || null;
          }, function(value) {
            this._realReader[eventName] = value;
          });
        }
        defineEvent('onloadstart'); // When the read starts.
        defineEvent('onprogress'); // While reading (and decoding) file or fileBlob data, and reporting partial file data (progress.loaded/progress.total)
        defineEvent('onload'); // When the read has successfully completed.
        defineEvent('onerror'); // When the read has failed (see errors).
        defineEvent('onloadend'); // When the request has completed (either in success or failure).
        defineEvent('onabort'); // When the read has been aborted. For instance, by invoking the abort() method.

        function initRead(reader, file) {
          // Already loading something
          if(reader.readyState == FileReader.LOADING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
          }

          reader._result = null;
          reader._error = null;
          reader._readyState = FileReader.LOADING;

          if(typeof file == 'string') {
            // Deprecated in Cordova 2.4.
            console.warning('Using a string argument with FileReader.readAs functions is deprecated.');
            reader._fileName = file;
          } else if(typeof file.fullPath == 'string') {
            reader._fileName = file.fullPath;
          } else {
            reader._fileName = '';
            return true;
          }

          reader.onloadstart && reader.onloadstart(new ProgressEvent("loadstart", { target: reader }));
        }

        /**
         * Abort reading file.
         */
        FileReader.prototype.abort = function() {
          if(origFileReader && !this._fileName) {
            return this._realReader.abort();
          }
          this._result = null;

          if(this._readyState == FileReader.DONE || this._readyState == FileReader.EMPTY) {
            return;
          }

          this._readyState = FileReader.DONE;

          // If abort callback
          if(typeof this.onabort === 'function') {
            this.onabort(new ProgressEvent('abort', { target: this }));
          }
          // If load end callback
          if(typeof this.onloadend === 'function') {
            this.onloadend(new ProgressEvent('loadend', { target: this }));
          }
        };

        /**
         * Read text file.
         *
         * @param file          {File} File object containing file properties
         * @param encoding      [Optional] (see http://www.iana.org/assignments/character-sets)
         */
        FileReader.prototype.readAsText = function(file, encoding) {
          if(initRead(this, file)) {
            return this._realReader.readAsText(file, encoding);
          }

          // Default encoding is UTF-8
          var enc = encoding ? encoding : "UTF-8";
          var me = this;
          var execArgs = [this._fileName, enc];

          // Maybe add slice parameters.
          if(file.end < file.size) {
            execArgs.push(file.start, file.end);
          } else if(file.start > 0) {
            execArgs.push(file.start);
          }

          // Read file
          exec(
            // Success callback
            function(r) {
              // If DONE (cancelled), then don't do anything
              if(me._readyState === FileReader.DONE) {
                return;
              }

              // Save result
              me._result = r;

              // If onload callback
              if(typeof me.onload === "function") {
                me.onload(new ProgressEvent("load", { target: me }));
              }

              // DONE state
              me._readyState = FileReader.DONE;

              // If onloadend callback
              if(typeof me.onloadend === "function") {
                me.onloadend(new ProgressEvent("loadend", { target: me }));
              }
            },
            // Error callback
            function(e) {
              // If DONE (cancelled), then don't do anything
              if(me._readyState === FileReader.DONE) {
                return;
              }

              // DONE state
              me._readyState = FileReader.DONE;

              // null result
              me._result = null;

              // Save error
              me._error = new FileError(e);

              // If onerror callback
              if(typeof me.onerror === "function") {
                me.onerror(new ProgressEvent("error", { target: me }));
              }

              // If onloadend callback
              if(typeof me.onloadend === "function") {
                me.onloadend(new ProgressEvent("loadend", { target: me }));
              }
            }, "File", "readAsText", execArgs);
        };


        /**
         * Read file and return data as a base64 encoded data url.
         * A data url is of the form:
         *      data:[<mediatype>][;base64],<data>
         *
         * @param file          {File} File object containing file properties
         */
        FileReader.prototype.readAsDataURL = function(file) {
          if(initRead(this, file)) {
            return this._realReader.readAsDataURL(file);
          }

          var me = this;
          var execArgs = [this._fileName];

          // Maybe add slice parameters.
          if(file.end < file.size) {
            execArgs.push(file.start, file.end);
          } else if(file.start > 0) {
            execArgs.push(file.start);
          }

          // Read file
          exec(
            // Success callback
            function(r) {
              // If DONE (cancelled), then don't do anything
              if(me._readyState === FileReader.DONE) {
                return;
              }

              // DONE state
              me._readyState = FileReader.DONE;

              // Save result
              me._result = r;

              // If onload callback
              if(typeof me.onload === "function") {
                me.onload(new ProgressEvent("load", { target: me }));
              }

              // If onloadend callback
              if(typeof me.onloadend === "function") {
                me.onloadend(new ProgressEvent("loadend", { target: me }));
              }
            },
            // Error callback
            function(e) {
              // If DONE (cancelled), then don't do anything
              if(me._readyState === FileReader.DONE) {
                return;
              }

              // DONE state
              me._readyState = FileReader.DONE;

              me._result = null;

              // Save error
              me._error = new FileError(e);

              // If onerror callback
              if(typeof me.onerror === "function") {
                me.onerror(new ProgressEvent("error", { target: me }));
              }

              // If onloadend callback
              if(typeof me.onloadend === "function") {
                me.onloadend(new ProgressEvent("loadend", { target: me }));
              }
            }, "File", "readAsDataURL", execArgs);
        };

        /**
         * Read file and return data as a binary data.
         *
         * @param file          {File} File object containing file properties
         */
        FileReader.prototype.readAsBinaryString = function(file) {
          if(initRead(this, file)) {
            return this._realReader.readAsBinaryString(file);
          }
          // TODO - Can't return binary data to browser.
          console.log('method "readAsBinaryString" is not supported at this time.');
          this.abort();
        };

        /**
         * Read file and return data as a binary data.
         *
         * @param file          {File} File object containing file properties
         */
        FileReader.prototype.readAsArrayBuffer = function(file) {
          if(initRead(this, file)) {
            return this._realReader.readAsArrayBuffer(file);
          }
          // TODO - Can't return binary data to browser.
          console.log('This method is not supported at this time.');
          this.abort();
        };

        module.exports = FileReader;

      });

      // file: lib/common/plugin/FileSystem.js
      define("cordova/plugin/FileSystem", function(require, exports, module) {

        var DirectoryEntry = require('cordova/plugin/DirectoryEntry');

        /**
         * An interface representing a file system
         *
         * @constructor
         * {DOMString} name the unique name of the file system (readonly)
         * {DirectoryEntry} root directory of the file system (readonly)
         */
        var FileSystem = function(name, root) {
          this.name = name || null;
          if(root) {
            this.root = new DirectoryEntry(root.name, root.fullPath);
          }
        };

        module.exports = FileSystem;

      });

      // file: lib/common/plugin/FileTransfer.js
      define("cordova/plugin/FileTransfer", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          exec = require('cordova/exec'),
          FileTransferError = require('cordova/plugin/FileTransferError'),
          ProgressEvent = require('cordova/plugin/ProgressEvent');

        function newProgressEvent(result) {
          var pe = new ProgressEvent();
          pe.lengthComputable = result.lengthComputable;
          pe.loaded = result.loaded;
          pe.total = result.total;
          return pe;
        }

        var idCounter = 0;

        /**
         * FileTransfer uploads a file to a remote server.
         * @constructor
         */
        var FileTransfer = function() {
          this._id = ++idCounter;
          this.onprogress = null; // optional callback
        };

        /**
         * Given an absolute file path, uploads a file on the device to a remote server
         * using a multipart HTTP request.
         * @param filePath {String}           Full path of the file on the device
         * @param server {String}             URL of the server to receive the file
         * @param successCallback (Function}  Callback to be invoked when upload has completed
         * @param errorCallback {Function}    Callback to be invoked upon error
         * @param options {FileUploadOptions} Optional parameters such as file name and mimetype
         * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false
         */
        FileTransfer.prototype.upload = function(filePath, server, successCallback, errorCallback, options, trustAllHosts) {
          argscheck.checkArgs('ssFFO*', 'FileTransfer.upload', arguments);
          // check for options
          var fileKey = null;
          var fileName = null;
          var mimeType = null;
          var params = null;
          var chunkedMode = true;
          var headers = null;
          if(options) {
            fileKey = options.fileKey;
            fileName = options.fileName;
            mimeType = options.mimeType;
            headers = options.headers;
            if(options.chunkedMode !== null || typeof options.chunkedMode != "undefined") {
              chunkedMode = options.chunkedMode;
            }
            if(options.params) {
              params = options.params;
            } else {
              params = {};
            }
          }

          var fail = errorCallback && function(e) {
            var error = new FileTransferError(e.code, e.source, e.target, e.http_status);
            errorCallback(error);
          };

          var self = this;
          var win = function(result) {
            if(typeof result.lengthComputable != "undefined") {
              if(self.onprogress) {
                self.onprogress(newProgressEvent(result));
              }
            } else {
              successCallback && successCallback(result);
            }
          };
          exec(win, fail, 'FileTransfer', 'upload', [filePath, server, fileKey, fileName, mimeType, params, trustAllHosts, chunkedMode, headers, this._id]);
        };

        /**
         * Downloads a file form a given URL and saves it to the specified directory.
         * @param source {String}          URL of the server to receive the file
         * @param target {String}         Full path of the file on the device
         * @param successCallback (Function}  Callback to be invoked when upload has completed
         * @param errorCallback {Function}    Callback to be invoked upon error
         * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false
         */
        FileTransfer.prototype.download = function(source, target, successCallback, errorCallback, trustAllHosts) {
          argscheck.checkArgs('ssFF*', 'FileTransfer.download', arguments);
          var self = this;
          var win = function(result) {
            if(typeof result.lengthComputable != "undefined") {
              if(self.onprogress) {
                return self.onprogress(newProgressEvent(result));
              }
            } else if(successCallback) {
              var entry = null;
              if(result.isDirectory) {
                entry = new(require('cordova/plugin/DirectoryEntry'))();
              } else if(result.isFile) {
                entry = new(require('cordova/plugin/FileEntry'))();
              }
              entry.isDirectory = result.isDirectory;
              entry.isFile = result.isFile;
              entry.name = result.name;
              entry.fullPath = result.fullPath;
              successCallback(entry);
            }
          };

          var fail = errorCallback && function(e) {
            var error = new FileTransferError(e.code, e.source, e.target, e.http_status);
            errorCallback(error);
          };

          exec(win, fail, 'FileTransfer', 'download', [source, target, trustAllHosts, this._id]);
        };

        /**
         * Aborts the ongoing file transfer on this object
         * @param successCallback {Function}  Callback to be invoked upon success
         * @param errorCallback {Function}    Callback to be invoked upon error
         */
        FileTransfer.prototype.abort = function(successCallback, errorCallback) {
          exec(successCallback, errorCallback, 'FileTransfer', 'abort', [this._id]);
        };

        module.exports = FileTransfer;

      });

      // file: lib/common/plugin/FileTransferError.js
      define("cordova/plugin/FileTransferError", function(require, exports, module) {

        /**
         * FileTransferError
         * @constructor
         */
        var FileTransferError = function(code, source, target, status) {
          this.code = code || null;
          this.source = source || null;
          this.target = target || null;
          this.http_status = status || null;
        };

        FileTransferError.FILE_NOT_FOUND_ERR = 1;
        FileTransferError.INVALID_URL_ERR = 2;
        FileTransferError.CONNECTION_ERR = 3;
        FileTransferError.ABORT_ERR = 4;

        module.exports = FileTransferError;

      });

      // file: lib/common/plugin/FileUploadOptions.js
      define("cordova/plugin/FileUploadOptions", function(require, exports, module) {

        /**
         * Options to customize the HTTP request used to upload files.
         * @constructor
         * @param fileKey {String}   Name of file request parameter.
         * @param fileName {String}  Filename to be used by the server. Defaults to image.jpg.
         * @param mimeType {String}  Mimetype of the uploaded file. Defaults to image/jpeg.
         * @param params {Object}    Object with key: value params to send to the server.
         * @param headers {Object}   Keys are header names, values are header values. Multiple
         *                           headers of the same name are not supported.
         */
        var FileUploadOptions = function(fileKey, fileName, mimeType, params, headers) {
          this.fileKey = fileKey || null;
          this.fileName = fileName || null;
          this.mimeType = mimeType || null;
          this.params = params || null;
          this.headers = headers || null;
        };

        module.exports = FileUploadOptions;

      });

      // file: lib/common/plugin/FileUploadResult.js
      define("cordova/plugin/FileUploadResult", function(require, exports, module) {

        /**
         * FileUploadResult
         * @constructor
         */
        var FileUploadResult = function() {
          this.bytesSent = 0;
          this.responseCode = null;
          this.response = null;
        };

        module.exports = FileUploadResult;

      });

      // file: lib/common/plugin/FileWriter.js
      define("cordova/plugin/FileWriter", function(require, exports, module) {

        var exec = require('cordova/exec'),
          FileError = require('cordova/plugin/FileError'),
          ProgressEvent = require('cordova/plugin/ProgressEvent');

        /**
         * This class writes to the mobile device file system.
         *
         * For Android:
         *      The root directory is the root of the file system.
         *      To write to the SD card, the file name is "sdcard/my_file.txt"
         *
         * @constructor
         * @param file {File} File object containing file properties
         * @param append if true write to the end of the file, otherwise overwrite the file
         */
        var FileWriter = function(file) {
          this.fileName = "";
          this.length = 0;
          if(file) {
            this.fileName = file.fullPath || file;
            this.length = file.size || 0;
          }
          // default is to write at the beginning of the file
          this.position = 0;

          this.readyState = 0; // EMPTY

          this.result = null;

          // Error
          this.error = null;

          // Event handlers
          this.onwritestart = null; // When writing starts
          this.onprogress = null; // While writing the file, and reporting partial file data
          this.onwrite = null; // When the write has successfully completed.
          this.onwriteend = null; // When the request has completed (either in success or failure).
          this.onabort = null; // When the write has been aborted. For instance, by invoking the abort() method.
          this.onerror = null; // When the write has failed (see errors).
        };

        // States
        FileWriter.INIT = 0;
        FileWriter.WRITING = 1;
        FileWriter.DONE = 2;

        /**
         * Abort writing file.
         */
        FileWriter.prototype.abort = function() {
          // check for invalid state
          if(this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) {
            throw new FileError(FileError.INVALID_STATE_ERR);
          }

          // set error
          this.error = new FileError(FileError.ABORT_ERR);

          this.readyState = FileWriter.DONE;

          // If abort callback
          if(typeof this.onabort === "function") {
            this.onabort(new ProgressEvent("abort", { "target": this }));
          }

          // If write end callback
          if(typeof this.onwriteend === "function") {
            this.onwriteend(new ProgressEvent("writeend", { "target": this }));
          }
        };

        /**
         * Writes data to the file
         *
         * @param text to be written
         */
        FileWriter.prototype.write = function(text) {
          // Throw an exception if we are already writing a file
          if(this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
          }

          // WRITING state
          this.readyState = FileWriter.WRITING;

          var me = this;

          // If onwritestart callback
          if(typeof me.onwritestart === "function") {
            me.onwritestart(new ProgressEvent("writestart", { "target": me }));
          }

          // Write file
          exec(
            // Success callback
            function(r) {
              // If DONE (cancelled), then don't do anything
              if(me.readyState === FileWriter.DONE) {
                return;
              }

              // position always increases by bytes written because file would be extended
              me.position += r;
              // The length of the file is now where we are done writing.

              me.length = me.position;

              // DONE state
              me.readyState = FileWriter.DONE;

              // If onwrite callback
              if(typeof me.onwrite === "function") {
                me.onwrite(new ProgressEvent("write", { "target": me }));
              }

              // If onwriteend callback
              if(typeof me.onwriteend === "function") {
                me.onwriteend(new ProgressEvent("writeend", { "target": me }));
              }
            },
            // Error callback
            function(e) {
              // If DONE (cancelled), then don't do anything
              if(me.readyState === FileWriter.DONE) {
                return;
              }

              // DONE state
              me.readyState = FileWriter.DONE;

              // Save error
              me.error = new FileError(e);

              // If onerror callback
              if(typeof me.onerror === "function") {
                me.onerror(new ProgressEvent("error", { "target": me }));
              }

              // If onwriteend callback
              if(typeof me.onwriteend === "function") {
                me.onwriteend(new ProgressEvent("writeend", { "target": me }));
              }
            }, "File", "write", [this.fileName, text, this.position]);
        };

        /**
         * Moves the file pointer to the location specified.
         *
         * If the offset is a negative number the position of the file
         * pointer is rewound.  If the offset is greater than the file
         * size the position is set to the end of the file.
         *
         * @param offset is the location to move the file pointer to.
         */
        FileWriter.prototype.seek = function(offset) {
          // Throw an exception if we are already writing a file
          if(this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
          }

          if(!offset && offset !== 0) {
            return;
          }

          // See back from end of file.
          if(offset < 0) {
            this.position = Math.max(offset + this.length, 0);
          }
          // Offset is bigger than file size so set position
          // to the end of the file.
          else if(offset > this.length) {
            this.position = this.length;
          }
          // Offset is between 0 and file size so set the position
          // to start writing.
          else {
            this.position = offset;
          }
        };

        /**
         * Truncates the file to the size specified.
         *
         * @param size to chop the file at.
         */
        FileWriter.prototype.truncate = function(size) {
          // Throw an exception if we are already writing a file
          if(this.readyState === FileWriter.WRITING) {
            throw new FileError(FileError.INVALID_STATE_ERR);
          }

          // WRITING state
          this.readyState = FileWriter.WRITING;

          var me = this;

          // If onwritestart callback
          if(typeof me.onwritestart === "function") {
            me.onwritestart(new ProgressEvent("writestart", { "target": this }));
          }

          // Write file
          exec(
            // Success callback
            function(r) {
              // If DONE (cancelled), then don't do anything
              if(me.readyState === FileWriter.DONE) {
                return;
              }

              // DONE state
              me.readyState = FileWriter.DONE;

              // Update the length of the file
              me.length = r;
              me.position = Math.min(me.position, r);

              // If onwrite callback
              if(typeof me.onwrite === "function") {
                me.onwrite(new ProgressEvent("write", { "target": me }));
              }

              // If onwriteend callback
              if(typeof me.onwriteend === "function") {
                me.onwriteend(new ProgressEvent("writeend", { "target": me }));
              }
            },
            // Error callback
            function(e) {
              // If DONE (cancelled), then don't do anything
              if(me.readyState === FileWriter.DONE) {
                return;
              }

              // DONE state
              me.readyState = FileWriter.DONE;

              // Save error
              me.error = new FileError(e);

              // If onerror callback
              if(typeof me.onerror === "function") {
                me.onerror(new ProgressEvent("error", { "target": me }));
              }

              // If onwriteend callback
              if(typeof me.onwriteend === "function") {
                me.onwriteend(new ProgressEvent("writeend", { "target": me }));
              }
            }, "File", "truncate", [this.fileName, size]);
        };

        module.exports = FileWriter;

      });

      // file: lib/common/plugin/Flags.js
      define("cordova/plugin/Flags", function(require, exports, module) {

        /**
         * Supplies arguments to methods that lookup or create files and directories.
         *
         * @param create
         *            {boolean} file or directory if it doesn't exist
         * @param exclusive
         *            {boolean} used with create; if true the command will fail if
         *            target path exists
         */
        function Flags(create, exclusive) {
          this.create = create || false;
          this.exclusive = exclusive || false;
        }

        module.exports = Flags;

      });

      // file: lib/common/plugin/GlobalizationError.js
      define("cordova/plugin/GlobalizationError", function(require, exports, module) {


        /**
         * Globalization error object
         *
         * @constructor
         * @param code
         * @param message
         */
        var GlobalizationError = function(code, message) {
          this.code = code || null;
          this.message = message || '';
        };

        // Globalization error codes
        GlobalizationError.UNKNOWN_ERROR = 0;
        GlobalizationError.FORMATTING_ERROR = 1;
        GlobalizationError.PARSING_ERROR = 2;
        GlobalizationError.PATTERN_ERROR = 3;

        module.exports = GlobalizationError;

      });

      // file: lib/common/plugin/InAppBrowser.js
      define("cordova/plugin/InAppBrowser", function(require, exports, module) {

        var exec = require('cordova/exec');
        var channel = require('cordova/channel');

        function InAppBrowser() {
          this.channels = {
            'loadstart': channel.create('loadstart'),
            'loadstop': channel.create('loadstop'),
            'exit': channel.create('exit')
          };
        }

        InAppBrowser.prototype = {
          _eventHandler: function(event) {
            if(event.type in this.channels) {
              this.channels[event.type].fire(event);
            }
          },
          close: function(eventname) {
            exec(null, null, "InAppBrowser", "close", []);
          },
          addEventListener: function(eventname, f) {
            if(eventname in this.channels) {
              this.channels[eventname].subscribe(f);
            }
          },
          removeEventListener: function(eventname, f) {
            if(eventname in this.channels) {
              this.channels[eventname].unsubscribe(f);
            }
          }
        };

        module.exports = function(strUrl, strWindowName, strWindowFeatures) {
          var iab = new InAppBrowser();
          var cb = function(eventname) {
            iab._eventHandler(eventname);
          };
          exec(cb, null, "InAppBrowser", "open", [strUrl, strWindowName, strWindowFeatures]);
          return iab;
        };

        //Export the original open so it can be used if needed
        module.exports._orig = window.open;

      });

      // file: lib/common/plugin/LocalFileSystem.js
      define("cordova/plugin/LocalFileSystem", function(require, exports, module) {

        var exec = require('cordova/exec');

        /**
         * Represents a local file system.
         */
        var LocalFileSystem = function() {

        };

        LocalFileSystem.TEMPORARY = 0; //temporary, with no guarantee of persistence
        LocalFileSystem.PERSISTENT = 1; //persistent

        module.exports = LocalFileSystem;

      });

      // file: lib/common/plugin/Media.js
      define("cordova/plugin/Media", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec');

        var mediaObjects = {};

        /**
         * This class provides access to the device media, interfaces to both sound and video
         *
         * @constructor
         * @param src                   The file name or url to play
         * @param successCallback       The callback to be called when the file is done playing or recording.
         *                                  successCallback()
         * @param errorCallback         The callback to be called if there is an error.
         *                                  errorCallback(int errorCode) - OPTIONAL
         * @param statusCallback        The callback to be called when media status has changed.
         *                                  statusCallback(int statusCode) - OPTIONAL
         */
        var Media = function(src, successCallback, errorCallback, statusCallback) {
          argscheck.checkArgs('SFFF', 'Media', arguments);
          this.id = utils.createUUID();
          mediaObjects[this.id] = this;
          this.src = src;
          this.successCallback = successCallback;
          this.errorCallback = errorCallback;
          this.statusCallback = statusCallback;
          this._duration = -1;
          this._position = -1;
          exec(null, this.errorCallback, "Media", "create", [this.id, this.src]);
        };

        // Media messages
        Media.MEDIA_STATE = 1;
        Media.MEDIA_DURATION = 2;
        Media.MEDIA_POSITION = 3;
        Media.MEDIA_ERROR = 9;

        // Media states
        Media.MEDIA_NONE = 0;
        Media.MEDIA_STARTING = 1;
        Media.MEDIA_RUNNING = 2;
        Media.MEDIA_PAUSED = 3;
        Media.MEDIA_STOPPED = 4;
        Media.MEDIA_MSG = ["None", "Starting", "Running", "Paused", "Stopped"];

        // "static" function to return existing objs.
        Media.get = function(id) {
          return mediaObjects[id];
        };

        /**
         * Start or resume playing audio file.
         */
        Media.prototype.play = function(options) {
          exec(null, null, "Media", "startPlayingAudio", [this.id, this.src, options]);
        };

        /**
         * Stop playing audio file.
         */
        Media.prototype.stop = function() {
          var me = this;
          exec(function() {
            me._position = 0;
          }, this.errorCallback, "Media", "stopPlayingAudio", [this.id]);
        };

        /**
         * Seek or jump to a new time in the track..
         */
        Media.prototype.seekTo = function(milliseconds) {
          var me = this;
          exec(function(p) {
            me._position = p;
          }, this.errorCallback, "Media", "seekToAudio", [this.id, milliseconds]);
        };

        /**
         * Pause playing audio file.
         */
        Media.prototype.pause = function() {
          exec(null, this.errorCallback, "Media", "pausePlayingAudio", [this.id]);
        };

        /**
         * Get duration of an audio file.
         * The duration is only set for audio that is playing, paused or stopped.
         *
         * @return      duration or -1 if not known.
         */
        Media.prototype.getDuration = function() {
          return this._duration;
        };

        /**
         * Get position of audio.
         */
        Media.prototype.getCurrentPosition = function(success, fail) {
          var me = this;
          exec(function(p) {
            me._position = p;
            success(p);
          }, fail, "Media", "getCurrentPositionAudio", [this.id]);
        };

        /**
         * Start recording audio file.
         */
        Media.prototype.startRecord = function() {
          exec(null, this.errorCallback, "Media", "startRecordingAudio", [this.id, this.src]);
        };

        /**
         * Stop recording audio file.
         */
        Media.prototype.stopRecord = function() {
          exec(null, this.errorCallback, "Media", "stopRecordingAudio", [this.id]);
        };

        /**
         * Release the resources.
         */
        Media.prototype.release = function() {
          exec(null, this.errorCallback, "Media", "release", [this.id]);
        };

        /**
         * Adjust the volume.
         */
        Media.prototype.setVolume = function(volume) {
          exec(null, null, "Media", "setVolume", [this.id, volume]);
        };

        /**
         * Audio has status update.
         * PRIVATE
         *
         * @param id            The media object id (string)
         * @param msgType       The 'type' of update this is
         * @param value         Use of value is determined by the msgType
         */
        Media.onStatus = function(id, msgType, value) {

          var media = mediaObjects[id];

          if(media) {
            switch(msgType) {
              case Media.MEDIA_STATE:
                media.statusCallback && media.statusCallback(value);
                if(value == Media.MEDIA_STOPPED) {
                  media.successCallback && media.successCallback();
                }
                break;
              case Media.MEDIA_DURATION:
                media._duration = value;
                break;
              case Media.MEDIA_ERROR:
                media.errorCallback && media.errorCallback(value);
                break;
              case Media.MEDIA_POSITION:
                media._position = Number(value);
                break;
              default:
                console.error && console.error("Unhandled Media.onStatus :: " + msgType);
                break;
            }
          } else {
            console.error && console.error("Received Media.onStatus callback for unknown media :: " + id);
          }

        };

        module.exports = Media;

      });

      // file: lib/common/plugin/MediaError.js
      define("cordova/plugin/MediaError", function(require, exports, module) {

        /**
         * This class contains information about any Media errors.
         */
        /*
         According to :: http://dev.w3.org/html5/spec-author-view/video.html#mediaerror
         We should never be creating these objects, we should just implement the interface
         which has 1 property for an instance, 'code'

         instead of doing :
            errorCallbackFunction( new MediaError(3,'msg') );
        we should simply use a literal :
            errorCallbackFunction( {'code':3} );
         */

        var _MediaError = window.MediaError;


        if(!_MediaError) {
          window.MediaError = _MediaError = function(code, msg) {
            this.code = (typeof code != 'undefined') ? code : null;
            this.message = msg || ""; // message is NON-standard! do not use!
          };
        }

        _MediaError.MEDIA_ERR_NONE_ACTIVE = _MediaError.MEDIA_ERR_NONE_ACTIVE || 0;
        _MediaError.MEDIA_ERR_ABORTED = _MediaError.MEDIA_ERR_ABORTED || 1;
        _MediaError.MEDIA_ERR_NETWORK = _MediaError.MEDIA_ERR_NETWORK || 2;
        _MediaError.MEDIA_ERR_DECODE = _MediaError.MEDIA_ERR_DECODE || 3;
        _MediaError.MEDIA_ERR_NONE_SUPPORTED = _MediaError.MEDIA_ERR_NONE_SUPPORTED || 4;
        // TODO: MediaError.MEDIA_ERR_NONE_SUPPORTED is legacy, the W3 spec now defines it as below.
        // as defined by http://dev.w3.org/html5/spec-author-view/video.html#error-codes
        _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = _MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED || 4;

        module.exports = _MediaError;

      });

      // file: lib/common/plugin/MediaFile.js
      define("cordova/plugin/MediaFile", function(require, exports, module) {

        var utils = require('cordova/utils'),
          exec = require('cordova/exec'),
          File = require('cordova/plugin/File'),
          CaptureError = require('cordova/plugin/CaptureError');
        /**
         * Represents a single file.
         *
         * name {DOMString} name of the file, without path information
         * fullPath {DOMString} the full path of the file, including the name
         * type {DOMString} mime type
         * lastModifiedDate {Date} last modified date
         * size {Number} size of the file in bytes
         */
        var MediaFile = function(name, fullPath, type, lastModifiedDate, size) {
          MediaFile.__super__.constructor.apply(this, arguments);
        };

        utils.extend(MediaFile, File);

        /**
         * Request capture format data for a specific file and type
         *
         * @param {Function} successCB
         * @param {Function} errorCB
         */
        MediaFile.prototype.getFormatData = function(successCallback, errorCallback) {
          if(typeof this.fullPath === "undefined" || this.fullPath === null) {
            errorCallback(new CaptureError(CaptureError.CAPTURE_INVALID_ARGUMENT));
          } else {
            exec(successCallback, errorCallback, "Capture", "getFormatData", [this.fullPath, this.type]);
          }
        };

        module.exports = MediaFile;

      });

      // file: lib/common/plugin/MediaFileData.js
      define("cordova/plugin/MediaFileData", function(require, exports, module) {

        /**
         * MediaFileData encapsulates format information of a media file.
         *
         * @param {DOMString} codecs
         * @param {long} bitrate
         * @param {long} height
         * @param {long} width
         * @param {float} duration
         */
        var MediaFileData = function(codecs, bitrate, height, width, duration) {
          this.codecs = codecs || null;
          this.bitrate = bitrate || 0;
          this.height = height || 0;
          this.width = width || 0;
          this.duration = duration || 0;
        };

        module.exports = MediaFileData;

      });

      // file: lib/common/plugin/Metadata.js
      define("cordova/plugin/Metadata", function(require, exports, module) {

        /**
         * Information about the state of the file or directory
         *
         * {Date} modificationTime (readonly)
         */
        var Metadata = function(time) {
          this.modificationTime = (typeof time != 'undefined' ? new Date(time) : null);
        };

        module.exports = Metadata;

      });

      // file: lib/common/plugin/Position.js
      define("cordova/plugin/Position", function(require, exports, module) {

        var Coordinates = require('cordova/plugin/Coordinates');

        var Position = function(coords, timestamp) {
          if(coords) {
            this.coords = new Coordinates(coords.latitude, coords.longitude, coords.altitude, coords.accuracy, coords.heading, coords.velocity, coords.altitudeAccuracy);
          } else {
            this.coords = new Coordinates();
          }
          this.timestamp = (timestamp !== undefined) ? timestamp : new Date();
        };

        module.exports = Position;

      });

      // file: lib/common/plugin/PositionError.js
      define("cordova/plugin/PositionError", function(require, exports, module) {

        /**
         * Position error object
         *
         * @constructor
         * @param code
         * @param message
         */
        var PositionError = function(code, message) {
          this.code = code || null;
          this.message = message || '';
        };

        PositionError.PERMISSION_DENIED = 1;
        PositionError.POSITION_UNAVAILABLE = 2;
        PositionError.TIMEOUT = 3;

        module.exports = PositionError;

      });

      // file: lib/common/plugin/ProgressEvent.js
      define("cordova/plugin/ProgressEvent", function(require, exports, module) {

        // If ProgressEvent exists in global context, use it already, otherwise use our own polyfill
        // Feature test: See if we can instantiate a native ProgressEvent;
        // if so, use that approach,
        // otherwise fill-in with our own implementation.
        //
        // NOTE: right now we always fill in with our own. Down the road would be nice if we can use whatever is native in the webview.
        var ProgressEvent = (function() {
          /*
          var createEvent = function(data) {
              var event = document.createEvent('Events');
              event.initEvent('ProgressEvent', false, false);
              if (data) {
                  for (var i in data) {
                      if (data.hasOwnProperty(i)) {
                          event[i] = data[i];
                      }
                  }
                  if (data.target) {
                      // TODO: cannot call <some_custom_object>.dispatchEvent
                      // need to first figure out how to implement EventTarget
                  }
              }
              return event;
          };
          try {
              var ev = createEvent({type:"abort",target:document});
              return function ProgressEvent(type, data) {
                  data.type = type;
                  return createEvent(data);
              };
          } catch(e){
          */
          return function ProgressEvent(type, dict) {
            this.type = type;
            this.bubbles = false;
            this.cancelBubble = false;
            this.cancelable = false;
            this.lengthComputable = false;
            this.loaded = dict && dict.loaded ? dict.loaded : 0;
            this.total = dict && dict.total ? dict.total : 0;
            this.target = dict && dict.target ? dict.target : null;
          };
          //}
        })();

        module.exports = ProgressEvent;

      });

      // file: lib/common/plugin/accelerometer.js
      define("cordova/plugin/accelerometer", function(require, exports, module) {

        /**
         * This class provides access to device accelerometer data.
         * @constructor
         */
        var argscheck = require('cordova/argscheck'),
          utils = require("cordova/utils"),
          exec = require("cordova/exec"),
          Acceleration = require('cordova/plugin/Acceleration');

        // Is the accel sensor running?
        var running = false;

        // Keeps reference to watchAcceleration calls.
        var timers = {};

        // Array of listeners; used to keep track of when we should call start and stop.
        var listeners = [];

        // Last returned acceleration object from native
        var accel = null;

        // Tells native to start.
        function start() {
          exec(function(a) {
            var tempListeners = listeners.slice(0);
            accel = new Acceleration(a.x, a.y, a.z, a.timestamp);
            for(var i = 0, l = tempListeners.length; i < l; i++) {
              tempListeners[i].win(accel);
            }
          }, function(e) {
            var tempListeners = listeners.slice(0);
            for(var i = 0, l = tempListeners.length; i < l; i++) {
              tempListeners[i].fail(e);
            }
          }, "Accelerometer", "start", []);
          running = true;
        }

        // Tells native to stop.
        function stop() {
          exec(null, null, "Accelerometer", "stop", []);
          running = false;
        }

        // Adds a callback pair to the listeners array
        function createCallbackPair(win, fail) {
          return { win: win, fail: fail };
        }

        // Removes a win/fail listener pair from the listeners array
        function removeListeners(l) {
          var idx = listeners.indexOf(l);
          if(idx > -1) {
            listeners.splice(idx, 1);
            if(listeners.length === 0) {
              stop();
            }
          }
        }

        var accelerometer = {
          /**
           * Asynchronously acquires the current acceleration.
           *
           * @param {Function} successCallback    The function to call when the acceleration data is available
           * @param {Function} errorCallback      The function to call when there is an error getting the acceleration data. (OPTIONAL)
           * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL)
           */
          getCurrentAcceleration: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'accelerometer.getCurrentAcceleration', arguments);

            var p;
            var win = function(a) {
              removeListeners(p);
              successCallback(a);
            };
            var fail = function(e) {
              removeListeners(p);
              errorCallback && errorCallback(e);
            };

            p = createCallbackPair(win, fail);
            listeners.push(p);

            if(!running) {
              start();
            }
          },

          /**
           * Asynchronously acquires the acceleration repeatedly at a given interval.
           *
           * @param {Function} successCallback    The function to call each time the acceleration data is available
           * @param {Function} errorCallback      The function to call when there is an error getting the acceleration data. (OPTIONAL)
           * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL)
           * @return String                       The watch id that must be passed to #clearWatch to stop watching.
           */
          watchAcceleration: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'accelerometer.watchAcceleration', arguments);
            // Default interval (10 sec)
            var frequency = (options && options.frequency && typeof options.frequency == 'number') ? options.frequency : 10000;

            // Keep reference to watch id, and report accel readings as often as defined in frequency
            var id = utils.createUUID();

            var p = createCallbackPair(function() {}, function(e) {
              removeListeners(p);
              errorCallback && errorCallback(e);
            });
            listeners.push(p);

            timers[id] = {
              timer: window.setInterval(function() {
                if(accel) {
                  successCallback(accel);
                }
              }, frequency),
              listeners: p
            };

            if(running) {
              // If we're already running then immediately invoke the success callback
              // but only if we have retrieved a value, sample code does not check for null ...
              if(accel) {
                successCallback(accel);
              }
            } else {
              start();
            }

            return id;
          },

          /**
           * Clears the specified accelerometer watch.
           *
           * @param {String} id       The id of the watch returned from #watchAcceleration.
           */
          clearWatch: function(id) {
            // Stop javascript timer & remove from timer list
            if(id && timers[id]) {
              window.clearInterval(timers[id].timer);
              removeListeners(timers[id].listeners);
              delete timers[id];
            }
          }
        };

        module.exports = accelerometer;

      });

      // file: lib/android/plugin/android/app.js
      define("cordova/plugin/android/app", function(require, exports, module) {

        var exec = require('cordova/exec');

        module.exports = {
          /**
           * Clear the resource cache.
           */
          clearCache: function() {
            exec(null, null, "App", "clearCache", []);
          },

          /**
           * Load the url into the webview or into new browser instance.
           *
           * @param url           The URL to load
           * @param props         Properties that can be passed in to the activity:
           *      wait: int                           => wait msec before loading URL
           *      loadingDialog: "Title,Message"      => display a native loading dialog
           *      loadUrlTimeoutValue: int            => time in msec to wait before triggering a timeout error
           *      clearHistory: boolean              => clear webview history (default=false)
           *      openExternal: boolean              => open in a new browser (default=false)
           *
           * Example:
           *      navigator.app.loadUrl("http://server/myapp/index.html", {wait:2000, loadingDialog:"Wait,Loading App", loadUrlTimeoutValue: 60000});
           */
          loadUrl: function(url, props) {
            exec(null, null, "App", "loadUrl", [url, props]);
          },

          /**
           * Cancel loadUrl that is waiting to be loaded.
           */
          cancelLoadUrl: function() {
            exec(null, null, "App", "cancelLoadUrl", []);
          },

          /**
           * Clear web history in this web view.
           * Instead of BACK button loading the previous web page, it will exit the app.
           */
          clearHistory: function() {
            exec(null, null, "App", "clearHistory", []);
          },

          /**
           * Go to previous page displayed.
           * This is the same as pressing the backbutton on Android device.
           */
          backHistory: function() {
            exec(null, null, "App", "backHistory", []);
          },

          /**
           * Override the default behavior of the Android back button.
           * If overridden, when the back button is pressed, the "backKeyDown" JavaScript event will be fired.
           *
           * Note: The user should not have to call this method.  Instead, when the user
           *       registers for the "backbutton" event, this is automatically done.
           *
           * @param override        T=override, F=cancel override
           */
          overrideBackbutton: function(override) {
            exec(null, null, "App", "overrideBackbutton", [override]);
          },

          /**
           * Exit and terminate the application.
           */
          exitApp: function() {
            return exec(null, null, "App", "exitApp", []);
          }
        };

      });

      // file: lib/android/plugin/android/device.js
      define("cordova/plugin/android/device", function(require, exports, module) {

        var channel = require('cordova/channel'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec'),
          app = require('cordova/plugin/android/app');

        module.exports = {
          /*
           * DEPRECATED
           * This is only for Android.
           *
           * You must explicitly override the back button.
           */
          overrideBackButton: function() {
            console.log("Device.overrideBackButton() is deprecated.  Use App.overrideBackbutton(true).");
            app.overrideBackbutton(true);
          },

          /*
           * DEPRECATED
           * This is only for Android.
           *
           * This resets the back button to the default behavior
           */
          resetBackButton: function() {
            console.log("Device.resetBackButton() is deprecated.  Use App.overrideBackbutton(false).");
            app.overrideBackbutton(false);
          },

          /*
           * DEPRECATED
           * This is only for Android.
           *
           * This terminates the activity!
           */
          exitApp: function() {
            console.log("Device.exitApp() is deprecated.  Use App.exitApp().");
            app.exitApp();
          }
        };

      });

      // file: lib/android/plugin/android/nativeapiprovider.js
      define("cordova/plugin/android/nativeapiprovider", function(require, exports, module) {

        var nativeApi = this._cordovaNative || require('cordova/plugin/android/promptbasednativeapi');
        var currentApi = nativeApi;

        module.exports = {
          get: function() { return currentApi; },
          setPreferPrompt: function(value) {
            currentApi = value ? require('cordova/plugin/android/promptbasednativeapi') : nativeApi;
          },
          // Used only by tests.
          set: function(value) {
            currentApi = value;
          }
        };

      });

      // file: lib/android/plugin/android/notification.js
      define("cordova/plugin/android/notification", function(require, exports, module) {

        var exec = require('cordova/exec');

        /**
         * Provides Android enhanced notification API.
         */
        module.exports = {
          activityStart: function(title, message) {
            // If title and message not specified then mimic Android behavior of
            // using default strings.
            if(typeof title === "undefined" && typeof message == "undefined") {
              title = "Busy";
              message = 'Please wait...';
            }

            exec(null, null, 'Notification', 'activityStart', [title, message]);
          },

          /**
           * Close an activity dialog
           */
          activityStop: function() {
            exec(null, null, 'Notification', 'activityStop', []);
          },

          /**
           * Display a progress dialog with progress bar that goes from 0 to 100.
           *
           * @param {String}
           *            title Title of the progress dialog.
           * @param {String}
           *            message Message to display in the dialog.
           */
          progressStart: function(title, message) {
            exec(null, null, 'Notification', 'progressStart', [title, message]);
          },

          /**
           * Close the progress dialog.
           */
          progressStop: function() {
            exec(null, null, 'Notification', 'progressStop', []);
          },

          /**
           * Set the progress dialog value.
           *
           * @param {Number}
           *            value 0-100
           */
          progressValue: function(value) {
            exec(null, null, 'Notification', 'progressValue', [value]);
          }
        };

      });

      // file: lib/android/plugin/android/promptbasednativeapi.js
      define("cordova/plugin/android/promptbasednativeapi", function(require, exports, module) {

        module.exports = {
          exec: function(service, action, callbackId, argsJson) {
            return prompt(argsJson, 'gap:' + JSON.stringify([service, action, callbackId]));
          },
          setNativeToJsBridgeMode: function(value) {
            prompt(value, 'gap_bridge_mode:');
          },
          retrieveJsMessages: function() {
            return prompt('', 'gap_poll:');
          }
        };

      });

      // file: lib/android/plugin/android/storage.js
      define("cordova/plugin/android/storage", function(require, exports, module) {

        var utils = require('cordova/utils'),
          exec = require('cordova/exec'),
          channel = require('cordova/channel');

        var queryQueue = {};

        /**
         * SQL result set object
         * PRIVATE METHOD
         * @constructor
         */
        var DroidDB_Rows = function() {
          this.resultSet = []; // results array
          this.length = 0; // number of rows
        };

        /**
         * Get item from SQL result set
         *
         * @param row           The row number to return
         * @return              The row object
         */
        DroidDB_Rows.prototype.item = function(row) {
          return this.resultSet[row];
        };

        /**
         * SQL result set that is returned to user.
         * PRIVATE METHOD
         * @constructor
         */
        var DroidDB_Result = function() {
          this.rows = new DroidDB_Rows();
        };

        /**
         * Callback from native code when query is complete.
         * PRIVATE METHOD
         *
         * @param id   Query id
         */
        function completeQuery(id, data) {
          var query = queryQueue[id];
          if(query) {
            try {
              delete queryQueue[id];

              // Get transaction
              var tx = query.tx;

              // If transaction hasn't failed
              // Note: We ignore all query results if previous query
              //       in the same transaction failed.
              if(tx && tx.queryList[id]) {

                // Save query results
                var r = new DroidDB_Result();
                r.rows.resultSet = data;
                r.rows.length = data.length;
                try {
                  if(typeof query.successCallback === 'function') {
                    query.successCallback(query.tx, r);
                  }
                } catch(ex) {
                  console.log("executeSql error calling user success callback: " + ex);
                }

                tx.queryComplete(id);
              }
            } catch(e) {
              console.log("executeSql error: " + e);
            }
          }
        }

        /**
         * Callback from native code when query fails
         * PRIVATE METHOD
         *
         * @param reason            Error message
         * @param id                Query id
         */
        function failQuery(reason, id) {
          var query = queryQueue[id];
          if(query) {
            try {
              delete queryQueue[id];

              // Get transaction
              var tx = query.tx;

              // If transaction hasn't failed
              // Note: We ignore all query results if previous query
              //       in the same transaction failed.
              if(tx && tx.queryList[id]) {
                tx.queryList = {};

                try {
                  if(typeof query.errorCallback === 'function') {
                    query.errorCallback(query.tx, reason);
                  }
                } catch(ex) {
                  console.log("executeSql error calling user error callback: " + ex);
                }

                tx.queryFailed(id, reason);
              }

            } catch(e) {
              console.log("executeSql error: " + e);
            }
          }
        }

        /**
         * SQL query object
         * PRIVATE METHOD
         *
         * @constructor
         * @param tx                The transaction object that this query belongs to
         */
        var DroidDB_Query = function(tx) {

          // Set the id of the query
          this.id = utils.createUUID();

          // Add this query to the queue
          queryQueue[this.id] = this;

          // Init result
          this.resultSet = [];

          // Set transaction that this query belongs to
          this.tx = tx;

          // Add this query to transaction list
          this.tx.queryList[this.id] = this;

          // Callbacks
          this.successCallback = null;
          this.errorCallback = null;

        };

        /**
         * Transaction object
         * PRIVATE METHOD
         * @constructor
         */
        var DroidDB_Tx = function() {

          // Set the id of the transaction
          this.id = utils.createUUID();

          // Callbacks
          this.successCallback = null;
          this.errorCallback = null;

          // Query list
          this.queryList = {};
        };

        /**
         * Mark query in transaction as complete.
         * If all queries are complete, call the user's transaction success callback.
         *
         * @param id                Query id
         */
        DroidDB_Tx.prototype.queryComplete = function(id) {
          delete this.queryList[id];

          // If no more outstanding queries, then fire transaction success
          if(this.successCallback) {
            var count = 0;
            var i;
            for(i in this.queryList) {
              if(this.queryList.hasOwnProperty(i)) {
                count++;
              }
            }
            if(count === 0) {
              try {
                this.successCallback();
              } catch(e) {
                console.log("Transaction error calling user success callback: " + e);
              }
            }
          }
        };

        /**
         * Mark query in transaction as failed.
         *
         * @param id                Query id
         * @param reason            Error message
         */
        DroidDB_Tx.prototype.queryFailed = function(id, reason) {

          // The sql queries in this transaction have already been run, since
          // we really don't have a real transaction implemented in native code.
          // However, the user callbacks for the remaining sql queries in transaction
          // will not be called.
          this.queryList = {};

          if(this.errorCallback) {
            try {
              this.errorCallback(reason);
            } catch(e) {
              console.log("Transaction error calling user error callback: " + e);
            }
          }
        };

        /**
         * Execute SQL statement
         *
         * @param sql                   SQL statement to execute
         * @param params                Statement parameters
         * @param successCallback       Success callback
         * @param errorCallback         Error callback
         */
        DroidDB_Tx.prototype.executeSql = function(sql, params, successCallback, errorCallback) {

          // Init params array
          if(typeof params === 'undefined') {
            params = [];
          }

          // Create query and add to queue
          var query = new DroidDB_Query(this);
          queryQueue[query.id] = query;

          // Save callbacks
          query.successCallback = successCallback;
          query.errorCallback = errorCallback;

          // Call native code
          exec(null, null, "Storage", "executeSql", [sql, params, query.id]);
        };

        var DatabaseShell = function() {};

        /**
         * Start a transaction.
         * Does not support rollback in event of failure.
         *
         * @param process {Function}            The transaction function
         * @param successCallback {Function}
         * @param errorCallback {Function}
         */
        DatabaseShell.prototype.transaction = function(process, errorCallback, successCallback) {
          var tx = new DroidDB_Tx();
          tx.successCallback = successCallback;
          tx.errorCallback = errorCallback;
          try {
            process(tx);
          } catch(e) {
            console.log("Transaction error: " + e);
            if(tx.errorCallback) {
              try {
                tx.errorCallback(e);
              } catch(ex) {
                console.log("Transaction error calling user error callback: " + e);
              }
            }
          }
        };

        /**
         * Open database
         *
         * @param name              Database name
         * @param version           Database version
         * @param display_name      Database display name
         * @param size              Database size in bytes
         * @return                  Database object
         */
        var DroidDB_openDatabase = function(name, version, display_name, size) {
          exec(null, null, "Storage", "openDatabase", [name, version, display_name, size]);
          var db = new DatabaseShell();
          return db;
        };

        /**
         * For browsers with no localStorage we emulate it with SQLite. Follows the w3c api.
         * TODO: Do similar for sessionStorage.
         * @constructor
         */
        var CupcakeLocalStorage = function() {
          channel.waitForInitialization("cupcakeStorage");

          try {

            this.db = openDatabase('localStorage', '1.0', 'localStorage', 2621440);
            var storage = {};
            this.length = 0;

            function setLength(length) {
              this.length = length;
              localStorage.length = length;
            }
            this.db.transaction(
              function(transaction) {
                var i;
                transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                transaction.executeSql('SELECT * FROM storage', [], function(tx, result) {
                  for(var i = 0; i < result.rows.length; i++) {
                    storage[result.rows.item(i).id] = result.rows.item(i).body;
                  }
                  setLength(result.rows.length);
                  channel.initializationComplete("cupcakeStorage");
                });

              },
              function(err) {
                utils.alert(err.message);
              }
            );
            this.setItem = function(key, val) {
              if(typeof(storage[key]) == 'undefined') {
                this.length++;
              }
              storage[key] = val;
              this.db.transaction(
                function(transaction) {
                  transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                  transaction.executeSql('REPLACE INTO storage (id, body) values(?,?)', [key, val]);
                }
              );
            };
            this.getItem = function(key) {
              return storage[key];
            };
            this.removeItem = function(key) {
              delete storage[key];
              this.length--;
              this.db.transaction(
                function(transaction) {
                  transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                  transaction.executeSql('DELETE FROM storage where id=?', [key]);
                }
              );
            };
            this.clear = function() {
              storage = {};
              this.length = 0;
              this.db.transaction(
                function(transaction) {
                  transaction.executeSql('CREATE TABLE IF NOT EXISTS storage (id NVARCHAR(40) PRIMARY KEY, body NVARCHAR(255))');
                  transaction.executeSql('DELETE FROM storage', []);
                }
              );
            };
            this.key = function(index) {
              var i = 0;
              for(var j in storage) {
                if(i == index) {
                  return j;
                } else {
                  i++;
                }
              }
              return null;
            };

          } catch(e) {
            utils.alert("Database error " + e + ".");
            return;
          }
        };

        module.exports = {
          openDatabase: DroidDB_openDatabase,
          CupcakeLocalStorage: CupcakeLocalStorage,
          failQuery: failQuery,
          completeQuery: completeQuery
        };

      });

      // file: lib/common/plugin/battery.js
      define("cordova/plugin/battery", function(require, exports, module) {

        /**
         * This class contains information about the current battery status.
         * @constructor
         */
        var cordova = require('cordova'),
          exec = require('cordova/exec');

        function handlers() {
          return battery.channels.batterystatus.numHandlers +
            battery.channels.batterylow.numHandlers +
            battery.channels.batterycritical.numHandlers;
        }

        var Battery = function() {
          this._level = null;
          this._isPlugged = null;
          // Create new event handlers on the window (returns a channel instance)
          this.channels = {
            batterystatus: cordova.addWindowEventHandler("batterystatus"),
            batterylow: cordova.addWindowEventHandler("batterylow"),
            batterycritical: cordova.addWindowEventHandler("batterycritical")
          };
          for(var key in this.channels) {
            this.channels[key].onHasSubscribersChange = Battery.onHasSubscribersChange;
          }
        };
        /**
         * Event handlers for when callbacks get registered for the battery.
         * Keep track of how many handlers we have so we can start and stop the native battery listener
         * appropriately (and hopefully save on battery life!).
         */
        Battery.onHasSubscribersChange = function() {
          // If we just registered the first handler, make sure native listener is started.
          if(this.numHandlers === 1 && handlers() === 1) {
            exec(battery._status, battery._error, "Battery", "start", []);
          } else if(handlers() === 0) {
            exec(null, null, "Battery", "stop", []);
          }
        };

        /**
         * Callback for battery status
         *
         * @param {Object} info            keys: level, isPlugged
         */
        Battery.prototype._status = function(info) {
          if(info) {
            var me = battery;
            var level = info.level;
            if(me._level !== level || me._isPlugged !== info.isPlugged) {
              // Fire batterystatus event
              cordova.fireWindowEvent("batterystatus", info);

              // Fire low battery event
              if(level === 20 || level === 5) {
                if(level === 20) {
                  cordova.fireWindowEvent("batterylow", info);
                } else {
                  cordova.fireWindowEvent("batterycritical", info);
                }
              }
            }
            me._level = level;
            me._isPlugged = info.isPlugged;
          }
        };

        /**
         * Error callback for battery start
         */
        Battery.prototype._error = function(e) {
          console.log("Error initializing Battery: " + e);
        };

        var battery = new Battery();

        module.exports = battery;

      });

      // file: lib/common/plugin/capture.js
      define("cordova/plugin/capture", function(require, exports, module) {

        var exec = require('cordova/exec'),
          MediaFile = require('cordova/plugin/MediaFile');

        /**
         * Launches a capture of different types.
         *
         * @param (DOMString} type
         * @param {Function} successCB
         * @param {Function} errorCB
         * @param {CaptureVideoOptions} options
         */
        function _capture(type, successCallback, errorCallback, options) {
          var win = function(pluginResult) {
            var mediaFiles = [];
            var i;
            for(i = 0; i < pluginResult.length; i++) {
              var mediaFile = new MediaFile();
              mediaFile.name = pluginResult[i].name;
              mediaFile.fullPath = pluginResult[i].fullPath;
              mediaFile.type = pluginResult[i].type;
              mediaFile.lastModifiedDate = pluginResult[i].lastModifiedDate;
              mediaFile.size = pluginResult[i].size;
              mediaFiles.push(mediaFile);
            }
            successCallback(mediaFiles);
          };
          exec(win, errorCallback, "Capture", type, [options]);
        }
        /**
         * The Capture interface exposes an interface to the camera and microphone of the hosting device.
         */
        function Capture() {
          this.supportedAudioModes = [];
          this.supportedImageModes = [];
          this.supportedVideoModes = [];
        }

        /**
         * Launch audio recorder application for recording audio clip(s).
         *
         * @param {Function} successCB
         * @param {Function} errorCB
         * @param {CaptureAudioOptions} options
         */
        Capture.prototype.captureAudio = function(successCallback, errorCallback, options) {
          _capture("captureAudio", successCallback, errorCallback, options);
        };

        /**
         * Launch camera application for taking image(s).
         *
         * @param {Function} successCB
         * @param {Function} errorCB
         * @param {CaptureImageOptions} options
         */
        Capture.prototype.captureImage = function(successCallback, errorCallback, options) {
          _capture("captureImage", successCallback, errorCallback, options);
        };

        /**
         * Launch device camera application for recording video(s).
         *
         * @param {Function} successCB
         * @param {Function} errorCB
         * @param {CaptureVideoOptions} options
         */
        Capture.prototype.captureVideo = function(successCallback, errorCallback, options) {
          _capture("captureVideo", successCallback, errorCallback, options);
        };


        module.exports = new Capture();

      });

      // file: lib/common/plugin/compass.js
      define("cordova/plugin/compass", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          exec = require('cordova/exec'),
          utils = require('cordova/utils'),
          CompassHeading = require('cordova/plugin/CompassHeading'),
          CompassError = require('cordova/plugin/CompassError'),
          timers = {},
          compass = {
            /**
             * Asynchronously acquires the current heading.
             * @param {Function} successCallback The function to call when the heading
             * data is available
             * @param {Function} errorCallback The function to call when there is an error
             * getting the heading data.
             * @param {CompassOptions} options The options for getting the heading data (not used).
             */
            getCurrentHeading: function(successCallback, errorCallback, options) {
              argscheck.checkArgs('fFO', 'compass.getCurrentHeading', arguments);

              var win = function(result) {
                var ch = new CompassHeading(result.magneticHeading, result.trueHeading, result.headingAccuracy, result.timestamp);
                successCallback(ch);
              };
              var fail = errorCallback && function(code) {
                var ce = new CompassError(code);
                errorCallback(ce);
              };

              // Get heading
              exec(win, fail, "Compass", "getHeading", [options]);
            },

            /**
             * Asynchronously acquires the heading repeatedly at a given interval.
             * @param {Function} successCallback The function to call each time the heading
             * data is available
             * @param {Function} errorCallback The function to call when there is an error
             * getting the heading data.
             * @param {HeadingOptions} options The options for getting the heading data
             * such as timeout and the frequency of the watch. For iOS, filter parameter
             * specifies to watch via a distance filter rather than time.
             */
            watchHeading: function(successCallback, errorCallback, options) {
              argscheck.checkArgs('fFO', 'compass.watchHeading', arguments);
              // Default interval (100 msec)
              var frequency = (options !== undefined && options.frequency !== undefined) ? options.frequency : 100;
              var filter = (options !== undefined && options.filter !== undefined) ? options.filter : 0;

              var id = utils.createUUID();
              if(filter > 0) {
                // is an iOS request for watch by filter, no timer needed
                timers[id] = "iOS";
                compass.getCurrentHeading(successCallback, errorCallback, options);
              } else {
                // Start watch timer to get headings
                timers[id] = window.setInterval(function() {
                  compass.getCurrentHeading(successCallback, errorCallback);
                }, frequency);
              }

              return id;
            },

            /**
             * Clears the specified heading watch.
             * @param {String} watchId The ID of the watch returned from #watchHeading.
             */
            clearWatch: function(id) {
              // Stop javascript timer & remove from timer list
              if(id && timers[id]) {
                if(timers[id] != "iOS") {
                  clearInterval(timers[id]);
                } else {
                  // is iOS watch by filter so call into device to stop
                  exec(null, null, "Compass", "stopHeading", []);
                }
                delete timers[id];
              }
            }
          };

        module.exports = compass;

      });

      // file: lib/common/plugin/console-via-logger.js
      define("cordova/plugin/console-via-logger", function(require, exports, module) {

        //------------------------------------------------------------------------------

        var logger = require("cordova/plugin/logger");
        var utils = require("cordova/utils");

        //------------------------------------------------------------------------------
        // object that we're exporting
        //------------------------------------------------------------------------------
        var console = module.exports;

        //------------------------------------------------------------------------------
        // copy of the original console object
        //------------------------------------------------------------------------------
        var WinConsole = window.console;

        //------------------------------------------------------------------------------
        // whether to use the logger
        //------------------------------------------------------------------------------
        var UseLogger = false;

        //------------------------------------------------------------------------------
        // Timers
        //------------------------------------------------------------------------------
        var Timers = {};

        //------------------------------------------------------------------------------
        // used for unimplemented methods
        //------------------------------------------------------------------------------
        function noop() {}

        //------------------------------------------------------------------------------
        // used for unimplemented methods
        //------------------------------------------------------------------------------
        console.useLogger = function(value) {
          if(arguments.length) UseLogger = !!value;

          if(UseLogger) {
            if(logger.useConsole()) {
              throw new Error("console and logger are too intertwingly");
            }
          }

          return UseLogger;
        };

        //------------------------------------------------------------------------------
        console.log = function() {
          if(logger.useConsole()) return;
          logger.log.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.error = function() {
          if(logger.useConsole()) return;
          logger.error.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.warn = function() {
          if(logger.useConsole()) return;
          logger.warn.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.info = function() {
          if(logger.useConsole()) return;
          logger.info.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.debug = function() {
          if(logger.useConsole()) return;
          logger.debug.apply(logger, [].slice.call(arguments));
        };

        //------------------------------------------------------------------------------
        console.assert = function(expression) {
          if(expression) return;

          var message = utils.vformat(arguments[1], [].slice.call(arguments, 2));
          console.log("ASSERT: " + message);
        };

        //------------------------------------------------------------------------------
        console.clear = function() {};

        //------------------------------------------------------------------------------
        console.dir = function(object) {
          console.log("%o", object);
        };

        //------------------------------------------------------------------------------
        console.dirxml = function(node) {
          console.log(node.innerHTML);
        };

        //------------------------------------------------------------------------------
        console.trace = noop;

        //------------------------------------------------------------------------------
        console.group = console.log;

        //------------------------------------------------------------------------------
        console.groupCollapsed = console.log;

        //------------------------------------------------------------------------------
        console.groupEnd = noop;

        //------------------------------------------------------------------------------
        console.time = function(name) {
          Timers[name] = new Date().valueOf();
        };

        //------------------------------------------------------------------------------
        console.timeEnd = function(name) {
          var timeStart = Timers[name];
          if(!timeStart) {
            console.warn("unknown timer: " + name);
            return;
          }

          var timeElapsed = new Date().valueOf() - timeStart;
          console.log(name + ": " + timeElapsed + "ms");
        };

        //------------------------------------------------------------------------------
        console.timeStamp = noop;

        //------------------------------------------------------------------------------
        console.profile = noop;

        //------------------------------------------------------------------------------
        console.profileEnd = noop;

        //------------------------------------------------------------------------------
        console.count = noop;

        //------------------------------------------------------------------------------
        console.exception = console.log;

        //------------------------------------------------------------------------------
        console.table = function(data, columns) {
          console.log("%o", data);
        };

        //------------------------------------------------------------------------------
        // return a new function that calls both functions passed as args
        //------------------------------------------------------------------------------
        function wrappedOrigCall(orgFunc, newFunc) {
          return function() {
            var args = [].slice.call(arguments);
            try { orgFunc.apply(WinConsole, args); } catch(e) {}
            try { newFunc.apply(console, args); } catch(e) {}
          };
        }

        //------------------------------------------------------------------------------
        // For every function that exists in the original console object, that
        // also exists in the new console object, wrap the new console method
        // with one that calls both
        //------------------------------------------------------------------------------
        for(var key in console) {
          if(typeof WinConsole[key] == "function") {
            console[key] = wrappedOrigCall(WinConsole[key], console[key]);
          }
        }

      });

      // file: lib/common/plugin/contacts.js
      define("cordova/plugin/contacts", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          exec = require('cordova/exec'),
          ContactError = require('cordova/plugin/ContactError'),
          utils = require('cordova/utils'),
          Contact = require('cordova/plugin/Contact');

        /**
         * Represents a group of Contacts.
         * @constructor
         */
        var contacts = {
          /**
           * Returns an array of Contacts matching the search criteria.
           * @param fields that should be searched
           * @param successCB success callback
           * @param errorCB error callback
           * @param {ContactFindOptions} options that can be applied to contact searching
           * @return array of Contacts matching search criteria
           */
          find: function(fields, successCB, errorCB, options) {
            argscheck.checkArgs('afFO', 'contacts.find', arguments);
            if(!fields.length) {
              errorCB && errorCB(new ContactError(ContactError.INVALID_ARGUMENT_ERROR));
            } else {
              var win = function(result) {
                var cs = [];
                for(var i = 0, l = result.length; i < l; i++) {
                  cs.push(contacts.create(result[i]));
                }
                successCB(cs);
              };
              exec(win, errorCB, "Contacts", "search", [fields, options]);
            }
          },

          /**
           * This function creates a new contact, but it does not persist the contact
           * to device storage. To persist the contact to device storage, invoke
           * contact.save().
           * @param properties an object whose properties will be examined to create a new Contact
           * @returns new Contact object
           */
          create: function(properties) {
            argscheck.checkArgs('O', 'contacts.create', arguments);
            var contact = new Contact();
            for(var i in properties) {
              if(typeof contact[i] !== 'undefined' && properties.hasOwnProperty(i)) {
                contact[i] = properties[i];
              }
            }
            return contact;
          }
        };

        module.exports = contacts;

      });

      // file: lib/common/plugin/device.js
      define("cordova/plugin/device", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          channel = require('cordova/channel'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec');

        // Tell cordova channel to wait on the CordovaInfoReady event
        channel.waitForInitialization('onCordovaInfoReady');

        /**
         * This represents the mobile device, and provides properties for inspecting the model, version, UUID of the
         * phone, etc.
         * @constructor
         */
        function Device() {
          this.available = false;
          this.platform = null;
          this.version = null;
          this.name = null;
          this.uuid = null;
          this.cordova = null;
          this.model = null;

          var me = this;

          channel.onCordovaReady.subscribe(function() {
            me.getInfo(function(info) {
              me.available = true;
              me.platform = info.platform;
              me.version = info.version;
              me.name = info.name;
              me.uuid = info.uuid;
              me.cordova = info.cordova;
              me.model = info.model;
              channel.onCordovaInfoReady.fire();
            }, function(e) {
              me.available = false;
              utils.alert("[ERROR] Error initializing Cordova: " + e);
            });
          });
        }

        /**
         * Get device info
         *
         * @param {Function} successCallback The function to call when the heading data is available
         * @param {Function} errorCallback The function to call when there is an error getting the heading data. (OPTIONAL)
         */
        Device.prototype.getInfo = function(successCallback, errorCallback) {
          argscheck.checkArgs('fF', 'Device.getInfo', arguments);
          exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);
        };

        module.exports = new Device();

      });

      // file: lib/common/plugin/echo.js
      define("cordova/plugin/echo", function(require, exports, module) {

        var exec = require('cordova/exec');

        /**
         * Sends the given message through exec() to the Echo plugin, which sends it back to the successCallback.
         * @param successCallback  invoked with a FileSystem object
         * @param errorCallback  invoked if error occurs retrieving file system
         * @param message  The string to be echoed.
         * @param forceAsync  Whether to force an async return value (for testing native->js bridge).
         */
        module.exports = function(successCallback, errorCallback, message, forceAsync) {
          var action = forceAsync ? 'echoAsync' : 'echo';
          if(!forceAsync && message.constructor == ArrayBuffer) {
            action = 'echoArrayBuffer';
          }
          exec(successCallback, errorCallback, "Echo", action, [message]);
        };


      });

      // file: lib/android/plugin/file/symbols.js
      define("cordova/plugin/file/symbols", function(require, exports, module) {


        var modulemapper = require('cordova/modulemapper'),
          symbolshelper = require('cordova/plugin/file/symbolshelper');

        symbolshelper(modulemapper.clobbers);

      });

      // file: lib/common/plugin/file/symbolshelper.js
      define("cordova/plugin/file/symbolshelper", function(require, exports, module) {

        module.exports = function(exportFunc) {
          exportFunc('cordova/plugin/DirectoryEntry', 'DirectoryEntry');
          exportFunc('cordova/plugin/DirectoryReader', 'DirectoryReader');
          exportFunc('cordova/plugin/Entry', 'Entry');
          exportFunc('cordova/plugin/File', 'File');
          exportFunc('cordova/plugin/FileEntry', 'FileEntry');
          exportFunc('cordova/plugin/FileError', 'FileError');
          exportFunc('cordova/plugin/FileReader', 'FileReader');
          exportFunc('cordova/plugin/FileSystem', 'FileSystem');
          exportFunc('cordova/plugin/FileTransfer', 'FileTransfer');
          exportFunc('cordova/plugin/FileTransferError', 'FileTransferError');
          exportFunc('cordova/plugin/FileUploadOptions', 'FileUploadOptions');
          exportFunc('cordova/plugin/FileUploadResult', 'FileUploadResult');
          exportFunc('cordova/plugin/FileWriter', 'FileWriter');
          exportFunc('cordova/plugin/Flags', 'Flags');
          exportFunc('cordova/plugin/LocalFileSystem', 'LocalFileSystem');
          exportFunc('cordova/plugin/Metadata', 'Metadata');
          exportFunc('cordova/plugin/requestFileSystem', 'requestFileSystem');
          exportFunc('cordova/plugin/resolveLocalFileSystemURI', 'resolveLocalFileSystemURI');
        };

      });

      // file: lib/common/plugin/geolocation.js
      define("cordova/plugin/geolocation", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          utils = require('cordova/utils'),
          exec = require('cordova/exec'),
          PositionError = require('cordova/plugin/PositionError'),
          Position = require('cordova/plugin/Position');

        var timers = {}; // list of timers in use

        // Returns default params, overrides if provided with values
        function parseParameters(options) {
          var opt = {
            maximumAge: 0,
            enableHighAccuracy: false,
            timeout: Infinity
          };

          if(options) {
            if(options.maximumAge !== undefined && !isNaN(options.maximumAge) && options.maximumAge > 0) {
              opt.maximumAge = options.maximumAge;
            }
            if(options.enableHighAccuracy !== undefined) {
              opt.enableHighAccuracy = options.enableHighAccuracy;
            }
            if(options.timeout !== undefined && !isNaN(options.timeout)) {
              if(options.timeout < 0) {
                opt.timeout = 0;
              } else {
                opt.timeout = options.timeout;
              }
            }
          }

          return opt;
        }

        // Returns a timeout failure, closed over a specified timeout value and error callback.
        function createTimeout(errorCallback, timeout) {
          var t = setTimeout(function() {
            clearTimeout(t);
            t = null;
            errorCallback({
              code: PositionError.TIMEOUT,
              message: "Position retrieval timed out."
            });
          }, timeout);
          return t;
        }

        var geolocation = {
          lastPosition: null, // reference to last known (cached) position returned
          /**
           * Asynchronously acquires the current position.
           *
           * @param {Function} successCallback    The function to call when the position data is available
           * @param {Function} errorCallback      The function to call when there is an error getting the heading position. (OPTIONAL)
           * @param {PositionOptions} options     The options for getting the position data. (OPTIONAL)
           */
          getCurrentPosition: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);
            options = parseParameters(options);

            // Timer var that will fire an error callback if no position is retrieved from native
            // before the "timeout" param provided expires
            var timeoutTimer = { timer: null };

            var win = function(p) {
              clearTimeout(timeoutTimer.timer);
              if(!(timeoutTimer.timer)) {
                // Timeout already happened, or native fired error callback for
                // this geo request.
                // Don't continue with success callback.
                return;
              }
              var pos = new Position({
                  latitude: p.latitude,
                  longitude: p.longitude,
                  altitude: p.altitude,
                  accuracy: p.accuracy,
                  heading: p.heading,
                  velocity: p.velocity,
                  altitudeAccuracy: p.altitudeAccuracy
                },
                (p.timestamp === undefined ? new Date() : ((p.timestamp instanceof Date) ? p.timestamp : new Date(p.timestamp)))
              );
              geolocation.lastPosition = pos;
              successCallback(pos);
            };
            var fail = function(e) {
              clearTimeout(timeoutTimer.timer);
              timeoutTimer.timer = null;
              var err = new PositionError(e.code, e.message);
              if(errorCallback) {
                errorCallback(err);
              }
            };

            // Check our cached position, if its timestamp difference with current time is less than the maximumAge, then just
            // fire the success callback with the cached position.
            if(geolocation.lastPosition && options.maximumAge && (((new Date()).getTime() - geolocation.lastPosition.timestamp.getTime()) <= options.maximumAge)) {
              successCallback(geolocation.lastPosition);
              // If the cached position check failed and the timeout was set to 0, error out with a TIMEOUT error object.
            } else if(options.timeout === 0) {
              fail({
                code: PositionError.TIMEOUT,
                message: "timeout value in PositionOptions set to 0 and no cached Position object available, or cached Position object's age exceeds provided PositionOptions' maximumAge parameter."
              });
              // Otherwise we have to call into native to retrieve a position.
            } else {
              if(options.timeout !== Infinity) {
                // If the timeout value was not set to Infinity (default), then
                // set up a timeout function that will fire the error callback
                // if no successful position was retrieved before timeout expired.
                timeoutTimer.timer = createTimeout(fail, options.timeout);
              } else {
                // This is here so the check in the win function doesn't mess stuff up
                // may seem weird but this guarantees timeoutTimer is
                // always truthy before we call into native
                timeoutTimer.timer = true;
              }
              exec(win, fail, "Geolocation", "getLocation", [options.enableHighAccuracy, options.maximumAge]);
            }
            return timeoutTimer;
          },
          /**
           * Asynchronously watches the geolocation for changes to geolocation.  When a change occurs,
           * the successCallback is called with the new location.
           *
           * @param {Function} successCallback    The function to call each time the location data is available
           * @param {Function} errorCallback      The function to call when there is an error getting the location data. (OPTIONAL)
           * @param {PositionOptions} options     The options for getting the location data such as frequency. (OPTIONAL)
           * @return String                       The watch id that must be passed to #clearWatch to stop watching.
           */
          watchPosition: function(successCallback, errorCallback, options) {
            argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);
            options = parseParameters(options);

            var id = utils.createUUID();

            // Tell device to get a position ASAP, and also retrieve a reference to the timeout timer generated in getCurrentPosition
            timers[id] = geolocation.getCurrentPosition(successCallback, errorCallback, options);

            var fail = function(e) {
              clearTimeout(timers[id].timer);
              var err = new PositionError(e.code, e.message);
              if(errorCallback) {
                errorCallback(err);
              }
            };

            var win = function(p) {
              clearTimeout(timers[id].timer);
              if(options.timeout !== Infinity) {
                timers[id].timer = createTimeout(fail, options.timeout);
              }
              var pos = new Position({
                  latitude: p.latitude,
                  longitude: p.longitude,
                  altitude: p.altitude,
                  accuracy: p.accuracy,
                  heading: p.heading,
                  velocity: p.velocity,
                  altitudeAccuracy: p.altitudeAccuracy
                },
                (p.timestamp === undefined ? new Date() : ((p.timestamp instanceof Date) ? p.timestamp : new Date(p.timestamp)))
              );
              geolocation.lastPosition = pos;
              successCallback(pos);
            };

            exec(win, fail, "Geolocation", "addWatch", [id, options.enableHighAccuracy]);

            return id;
          },
          /**
           * Clears the specified heading watch.
           *
           * @param {String} id       The ID of the watch returned from #watchPosition
           */
          clearWatch: function(id) {
            if(id && timers[id] !== undefined) {
              clearTimeout(timers[id].timer);
              timers[id].timer = false;
              exec(null, null, "Geolocation", "clearWatch", [id]);
            }
          }
        };

        module.exports = geolocation;

      });

      // file: lib/common/plugin/globalization.js
      define("cordova/plugin/globalization", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          exec = require('cordova/exec'),
          GlobalizationError = require('cordova/plugin/GlobalizationError');

        var globalization = {

          /**
           * Returns the string identifier for the client's current language.
           * It returns the language identifier string to the successCB callback with a
           * properties object as a parameter. If there is an error getting the language,
           * then the errorCB callback is invoked.
           *
           * @param {Function} successCB
           * @param {Function} errorCB
           *
           * @return Object.value {String}: The language identifier
           *
           * @error GlobalizationError.UNKNOWN_ERROR
           *
           * Example
           *    globalization.getPreferredLanguage(function (language) {alert('language:' + language.value + '\n');},
           *                                function () {});
           */
          getPreferredLanguage: function(successCB, failureCB) {
            argscheck.checkArgs('fF', 'Globalization.getPreferredLanguage', arguments);
            exec(successCB, failureCB, "Globalization", "getPreferredLanguage", []);
          },

          /**
           * Returns the string identifier for the client's current locale setting.
           * It returns the locale identifier string to the successCB callback with a
           * properties object as a parameter. If there is an error getting the locale,
           * then the errorCB callback is invoked.
           *
           * @param {Function} successCB
           * @param {Function} errorCB
           *
           * @return Object.value {String}: The locale identifier
           *
           * @error GlobalizationError.UNKNOWN_ERROR
           *
           * Example
           *    globalization.getLocaleName(function (locale) {alert('locale:' + locale.value + '\n');},
           *                                function () {});
           */
          getLocaleName: function(successCB, failureCB) {
            argscheck.checkArgs('fF', 'Globalization.getLocaleName', arguments);
            exec(successCB, failureCB, "Globalization", "getLocaleName", []);
          },


          /**
           * Returns a date formatted as a string according to the client's user preferences and
           * calendar using the time zone of the client. It returns the formatted date string to the
           * successCB callback with a properties object as a parameter. If there is an error
           * formatting the date, then the errorCB callback is invoked.
           *
           * The defaults are: formatLenght="short" and selector="date and time"
           *
           * @param {Date} date
           * @param {Function} successCB
           * @param {Function} errorCB
           * @param {Object} options {optional}
           *            formatLength {String}: 'short', 'medium', 'long', or 'full'
           *            selector {String}: 'date', 'time', or 'date and time'
           *
           * @return Object.value {String}: The localized date string
           *
           * @error GlobalizationError.FORMATTING_ERROR
           *
           * Example
           *    globalization.dateToString(new Date(),
           *                function (date) {alert('date:' + date.value + '\n');},
           *                function (errorCode) {alert(errorCode);},
           *                {formatLength:'short'});
           */
          dateToString: function(date, successCB, failureCB, options) {
            argscheck.checkArgs('dfFO', 'Globalization.dateToString', arguments);
            var dateValue = date.valueOf();
            exec(successCB, failureCB, "Globalization", "dateToString", [{ "date": dateValue, "options": options }]);
          },


          /**
           * Parses a date formatted as a string according to the client's user
           * preferences and calendar using the time zone of the client and returns
           * the corresponding date object. It returns the date to the successCB
           * callback with a properties object as a parameter. If there is an error
           * parsing the date string, then the errorCB callback is invoked.
           *
           * The defaults are: formatLength="short" and selector="date and time"
           *
           * @param {String} dateString
           * @param {Function} successCB
           * @param {Function} errorCB
           * @param {Object} options {optional}
           *            formatLength {String}: 'short', 'medium', 'long', or 'full'
           *            selector {String}: 'date', 'time', or 'date and time'
           *
           * @return    Object.year {Number}: The four digit year
           *            Object.month {Number}: The month from (0 - 11)
           *            Object.day {Number}: The day from (1 - 31)
           *            Object.hour {Number}: The hour from (0 - 23)
           *            Object.minute {Number}: The minute from (0 - 59)
           *            Object.second {Number}: The second from (0 - 59)
           *            Object.millisecond {Number}: The milliseconds (from 0 - 999),
           *                                        not available on all platforms
           *
           * @error GlobalizationError.PARSING_ERROR
           *
           * Example
           *    globalization.stringToDate('4/11/2011',
           *                function (date) { alert('Month:' + date.month + '\n' +
           *                    'Day:' + date.day + '\n' +
           *                    'Year:' + date.year + '\n');},
           *                function (errorCode) {alert(errorCode);},
           *                {selector:'date'});
           */
          stringToDate: function(dateString, successCB, failureCB, options) {
            argscheck.checkArgs('sfFO', 'Globalization.stringToDate', arguments);
            exec(successCB, failureCB, "Globalization", "stringToDate", [{ "dateString": dateString, "options": options }]);
          },


          /**
           * Returns a pattern string for formatting and parsing dates according to the client's
           * user preferences. It returns the pattern to the successCB callback with a
           * properties object as a parameter. If there is an error obtaining the pattern,
           * then the errorCB callback is invoked.
           *
           * The defaults are: formatLength="short" and selector="date and time"
           *
           * @param {Function} successCB
           * @param {Function} errorCB
           * @param {Object} options {optional}
           *            formatLength {String}: 'short', 'medium', 'long', or 'full'
           *            selector {String}: 'date', 'time', or 'date and time'
           *
           * @return    Object.pattern {String}: The date and time pattern for formatting and parsing dates.
           *                                    The patterns follow Unicode Technical Standard #35
           *                                    http://unicode.org/reports/tr35/tr35-4.html
           *            Object.timezone {String}: The abbreviated name of the time zone on the client
           *            Object.utc_offset {Number}: The current difference in seconds between the client's
           *                                        time zone and coordinated universal time.
           *            Object.dst_offset {Number}: The current daylight saving time offset in seconds
           *                                        between the client's non-daylight saving's time zone
           *                                        and the client's daylight saving's time zone.
           *
           * @error GlobalizationError.PATTERN_ERROR
           *
           * Example
           *    globalization.getDatePattern(
           *                function (date) {alert('pattern:' + date.pattern + '\n');},
           *                function () {},
           *                {formatLength:'short'});
           */
          getDatePattern: function(successCB, failureCB, options) {
            argscheck.checkArgs('fFO', 'Globalization.getDatePattern', arguments);
            exec(successCB, failureCB, "Globalization", "getDatePattern", [{ "options": options }]);
          },


          /**
           * Returns an array of either the names of the months or days of the week
           * according to the client's user preferences and calendar. It returns the array of names to the
           * successCB callback with a properties object as a parameter. If there is an error obtaining the
           * names, then the errorCB callback is invoked.
           *
           * The defaults are: type="wide" and item="months"
           *
           * @param {Function} successCB
           * @param {Function} errorCB
           * @param {Object} options {optional}
           *            type {String}: 'narrow' or 'wide'
           *            item {String}: 'months', or 'days'
           *
           * @return Object.value {Array{String}}: The array of names starting from either
           *                                        the first month in the year or the
           *                                        first day of the week.
           * @error GlobalizationError.UNKNOWN_ERROR
           *
           * Example
           *    globalization.getDateNames(function (names) {
           *        for(var i = 0; i < names.value.length; i++) {
           *            alert('Month:' + names.value[i] + '\n');}},
           *        function () {});
           */
          getDateNames: function(successCB, failureCB, options) {
            argscheck.checkArgs('fFO', 'Globalization.getDateNames', arguments);
            exec(successCB, failureCB, "Globalization", "getDateNames", [{ "options": options }]);
          },

          /**
           * Returns whether daylight savings time is in effect for a given date using the client's
           * time zone and calendar. It returns whether or not daylight savings time is in effect
           * to the successCB callback with a properties object as a parameter. If there is an error
           * reading the date, then the errorCB callback is invoked.
           *
           * @param {Date} date
           * @param {Function} successCB
           * @param {Function} errorCB
           *
           * @return Object.dst {Boolean}: The value "true" indicates that daylight savings time is
           *                                in effect for the given date and "false" indicate that it is not.
           *
           * @error GlobalizationError.UNKNOWN_ERROR
           *
           * Example
           *    globalization.isDayLightSavingsTime(new Date(),
           *                function (date) {alert('dst:' + date.dst + '\n');}
           *                function () {});
           */
          isDayLightSavingsTime: function(date, successCB, failureCB) {
            argscheck.checkArgs('dfF', 'Globalization.isDayLightSavingsTime', arguments);
            var dateValue = date.valueOf();
            exec(successCB, failureCB, "Globalization", "isDayLightSavingsTime", [{ "date": dateValue }]);
          },

          /**
           * Returns the first day of the week according to the client's user preferences and calendar.
           * The days of the week are numbered starting from 1 where 1 is considered to be Sunday.
           * It returns the day to the successCB callback with a properties object as a parameter.
           * If there is an error obtaining the pattern, then the errorCB callback is invoked.
           *
           * @param {Function} successCB
           * @param {Function} errorCB
           *
           * @return Object.value {Number}: The number of the first day of the week.
           *
           * @error GlobalizationError.UNKNOWN_ERROR
           *
           * Example
           *    globalization.getFirstDayOfWeek(function (day)
           *                { alert('Day:' + day.value + '\n');},
           *                function () {});
           */
          getFirstDayOfWeek: function(successCB, failureCB) {
            argscheck.checkArgs('fF', 'Globalization.getFirstDayOfWeek', arguments);
            exec(successCB, failureCB, "Globalization", "getFirstDayOfWeek", []);
          },


          /**
           * Returns a number formatted as a string according to the client's user preferences.
           * It returns the formatted number string to the successCB callback with a properties object as a
           * parameter. If there is an error formatting the number, then the errorCB callback is invoked.
           *
           * The defaults are: type="decimal"
           *
           * @param {Number} number
           * @param {Function} successCB
           * @param {Function} errorCB
           * @param {Object} options {optional}
           *            type {String}: 'decimal', "percent", or 'currency'
           *
           * @return Object.value {String}: The formatted number string.
           *
           * @error GlobalizationError.FORMATTING_ERROR
           *
           * Example
           *    globalization.numberToString(3.25,
           *                function (number) {alert('number:' + number.value + '\n');},
           *                function () {},
           *                {type:'decimal'});
           */
          numberToString: function(number, successCB, failureCB, options) {
            argscheck.checkArgs('nfFO', 'Globalization.numberToString', arguments);
            exec(successCB, failureCB, "Globalization", "numberToString", [{ "number": number, "options": options }]);
          },

          /**
           * Parses a number formatted as a string according to the client's user preferences and
           * returns the corresponding number. It returns the number to the successCB callback with a
           * properties object as a parameter. If there is an error parsing the number string, then
           * the errorCB callback is invoked.
           *
           * The defaults are: type="decimal"
           *
           * @param {String} numberString
           * @param {Function} successCB
           * @param {Function} errorCB
           * @param {Object} options {optional}
           *            type {String}: 'decimal', "percent", or 'currency'
           *
           * @return Object.value {Number}: The parsed number.
           *
           * @error GlobalizationError.PARSING_ERROR
           *
           * Example
           *    globalization.stringToNumber('1234.56',
           *                function (number) {alert('Number:' + number.value + '\n');},
           *                function () { alert('Error parsing number');});
           */
          stringToNumber: function(numberString, successCB, failureCB, options) {
            argscheck.checkArgs('sfFO', 'Globalization.stringToNumber', arguments);
            exec(successCB, failureCB, "Globalization", "stringToNumber", [{ "numberString": numberString, "options": options }]);
          },

          /**
           * Returns a pattern string for formatting and parsing numbers according to the client's user
           * preferences. It returns the pattern to the successCB callback with a properties object as a
           * parameter. If there is an error obtaining the pattern, then the errorCB callback is invoked.
           *
           * The defaults are: type="decimal"
           *
           * @param {Function} successCB
           * @param {Function} errorCB
           * @param {Object} options {optional}
           *            type {String}: 'decimal', "percent", or 'currency'
           *
           * @return    Object.pattern {String}: The number pattern for formatting and parsing numbers.
           *                                    The patterns follow Unicode Technical Standard #35.
           *                                    http://unicode.org/reports/tr35/tr35-4.html
           *            Object.symbol {String}: The symbol to be used when formatting and parsing
           *                                    e.g., percent or currency symbol.
           *            Object.fraction {Number}: The number of fractional digits to use when parsing and
           *                                    formatting numbers.
           *            Object.rounding {Number}: The rounding increment to use when parsing and formatting.
           *            Object.positive {String}: The symbol to use for positive numbers when parsing and formatting.
           *            Object.negative: {String}: The symbol to use for negative numbers when parsing and formatting.
           *            Object.decimal: {String}: The decimal symbol to use for parsing and formatting.
           *            Object.grouping: {String}: The grouping symbol to use for parsing and formatting.
           *
           * @error GlobalizationError.PATTERN_ERROR
           *
           * Example
           *    globalization.getNumberPattern(
           *                function (pattern) {alert('Pattern:' + pattern.pattern + '\n');},
           *                function () {});
           */
          getNumberPattern: function(successCB, failureCB, options) {
            argscheck.checkArgs('fFO', 'Globalization.getNumberPattern', arguments);
            exec(successCB, failureCB, "Globalization", "getNumberPattern", [{ "options": options }]);
          },

          /**
           * Returns a pattern string for formatting and parsing currency values according to the client's
           * user preferences and ISO 4217 currency code. It returns the pattern to the successCB callback with a
           * properties object as a parameter. If there is an error obtaining the pattern, then the errorCB
           * callback is invoked.
           *
           * @param {String} currencyCode
           * @param {Function} successCB
           * @param {Function} errorCB
           *
           * @return    Object.pattern {String}: The currency pattern for formatting and parsing currency values.
           *                                    The patterns follow Unicode Technical Standard #35
           *                                    http://unicode.org/reports/tr35/tr35-4.html
           *            Object.code {String}: The ISO 4217 currency code for the pattern.
           *            Object.fraction {Number}: The number of fractional digits to use when parsing and
           *                                    formatting currency.
           *            Object.rounding {Number}: The rounding increment to use when parsing and formatting.
           *            Object.decimal: {String}: The decimal symbol to use for parsing and formatting.
           *            Object.grouping: {String}: The grouping symbol to use for parsing and formatting.
           *
           * @error GlobalizationError.FORMATTING_ERROR
           *
           * Example
           *    globalization.getCurrencyPattern('EUR',
           *                function (currency) {alert('Pattern:' + currency.pattern + '\n');}
           *                function () {});
           */
          getCurrencyPattern: function(currencyCode, successCB, failureCB) {
            argscheck.checkArgs('sfF', 'Globalization.getCurrencyPattern', arguments);
            exec(successCB, failureCB, "Globalization", "getCurrencyPattern", [{ "currencyCode": currencyCode }]);
          }

        };

        module.exports = globalization;

      });

      // file: lib/common/plugin/logger.js
      define("cordova/plugin/logger", function(require, exports, module) {

        //------------------------------------------------------------------------------
        // The logger module exports the following properties/functions:
        //
        // LOG                          - constant for the level LOG
        // ERROR                        - constant for the level ERROR
        // WARN                         - constant for the level WARN
        // INFO                         - constant for the level INFO
        // DEBUG                        - constant for the level DEBUG
        // logLevel()                   - returns current log level
        // logLevel(value)              - sets and returns a new log level
        // useConsole()                 - returns whether logger is using console
        // useConsole(value)            - sets and returns whether logger is using console
        // log(message,...)             - logs a message at level LOG
        // error(message,...)           - logs a message at level ERROR
        // warn(message,...)            - logs a message at level WARN
        // info(message,...)            - logs a message at level INFO
        // debug(message,...)           - logs a message at level DEBUG
        // logLevel(level,message,...)  - logs a message specified level
        //
        //------------------------------------------------------------------------------

        var logger = exports;

        var exec = require('cordova/exec');
        var utils = require('cordova/utils');

        var UseConsole = true;
        var Queued = [];
        var DeviceReady = false;
        var CurrentLevel;

        /**
         * Logging levels
         */

        var Levels = [
          "LOG",
          "ERROR",
          "WARN",
          "INFO",
          "DEBUG"
        ];

        /*
         * add the logging levels to the logger object and
         * to a separate levelsMap object for testing
         */

        var LevelsMap = {};
        for(var i = 0; i < Levels.length; i++) {
          var level = Levels[i];
          LevelsMap[level] = i;
          logger[level] = level;
        }

        CurrentLevel = LevelsMap.WARN;

        /**
         * Getter/Setter for the logging level
         *
         * Returns the current logging level.
         *
         * When a value is passed, sets the logging level to that value.
         * The values should be one of the following constants:
         *    logger.LOG
         *    logger.ERROR
         *    logger.WARN
         *    logger.INFO
         *    logger.DEBUG
         *
         * The value used determines which messages get printed.  The logging
         * values above are in order, and only messages logged at the logging
         * level or above will actually be displayed to the user.  E.g., the
         * default level is WARN, so only messages logged with LOG, ERROR, or
         * WARN will be displayed; INFO and DEBUG messages will be ignored.
         */
        logger.level = function(value) {
          if(arguments.length) {
            if(LevelsMap[value] === null) {
              throw new Error("invalid logging level: " + value);
            }
            CurrentLevel = LevelsMap[value];
          }

          return Levels[CurrentLevel];
        };

        /**
         * Getter/Setter for the useConsole functionality
         *
         * When useConsole is true, the logger will log via the
         * browser 'console' object.  Otherwise, it will use the
         * native Logger plugin.
         */
        logger.useConsole = function(value) {
          if(arguments.length) UseConsole = !!value;

          if(UseConsole) {
            if(typeof console == "undefined") {
              throw new Error("global console object is not defined");
            }

            if(typeof console.log != "function") {
              throw new Error("global console object does not have a log function");
            }

            if(typeof console.useLogger == "function") {
              if(console.useLogger()) {
                throw new Error("console and logger are too intertwingly");
              }
            }
          }

          return UseConsole;
        };

        /**
         * Logs a message at the LOG level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.log = function(message) { logWithArgs("LOG", arguments); };

        /**
         * Logs a message at the ERROR level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.error = function(message) { logWithArgs("ERROR", arguments); };

        /**
         * Logs a message at the WARN level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.warn = function(message) { logWithArgs("WARN", arguments); };

        /**
         * Logs a message at the INFO level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.info = function(message) { logWithArgs("INFO", arguments); };

        /**
         * Logs a message at the DEBUG level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.debug = function(message) { logWithArgs("DEBUG", arguments); };

        // log at the specified level with args
        function logWithArgs(level, args) {
          args = [level].concat([].slice.call(args));
          logger.logLevel.apply(logger, args);
        }

        /**
         * Logs a message at the specified level.
         *
         * Parameters passed after message are used applied to
         * the message with utils.format()
         */
        logger.logLevel = function(level, message /* , ... */ ) {
          // format the message with the parameters
          var formatArgs = [].slice.call(arguments, 2);
          message = utils.vformat(message, formatArgs);

          if(LevelsMap[level] === null) {
            throw new Error("invalid logging level: " + level);
          }

          if(LevelsMap[level] > CurrentLevel) return;

          // queue the message if not yet at deviceready
          if(!DeviceReady && !UseConsole) {
            Queued.push([level, message]);
            return;
          }

          // if not using the console, use the native logger
          if(!UseConsole) {
            exec(null, null, "Logger", "logLevel", [level, message]);
            return;
          }

          // make sure console is not using logger
          if(console.__usingCordovaLogger) {
            throw new Error("console and logger are too intertwingly");
          }

          // log to the console
          switch(level) {
            case logger.LOG:
              console.log(message);
              break;
            case logger.ERROR:
              console.log("ERROR: " + message);
              break;
            case logger.WARN:
              console.log("WARN: " + message);
              break;
            case logger.INFO:
              console.log("INFO: " + message);
              break;
            case logger.DEBUG:
              console.log("DEBUG: " + message);
              break;
          }
        };

        // when deviceready fires, log queued messages
        logger.__onDeviceReady = function() {
          if(DeviceReady) return;

          DeviceReady = true;

          for(var i = 0; i < Queued.length; i++) {
            var messageArgs = Queued[i];
            logger.logLevel(messageArgs[0], messageArgs[1]);
          }

          Queued = null;
        };

        // add a deviceready event to log queued messages
        document.addEventListener("deviceready", logger.__onDeviceReady, false);

      });

      // file: lib/common/plugin/network.js
      define("cordova/plugin/network", function(require, exports, module) {

        var exec = require('cordova/exec'),
          cordova = require('cordova'),
          channel = require('cordova/channel'),
          utils = require('cordova/utils');

        // Link the onLine property with the Cordova-supplied network info.
        // This works because we clobber the naviagtor object with our own
        // object in bootstrap.js.
        if(typeof navigator != 'undefined') {
          utils.defineGetter(navigator, 'onLine', function() {
            return this.connection.type != 'none';
          });
        }

        function NetworkConnection() {
          this.type = 'unknown';
        }

        /**
         * Get connection info
         *
         * @param {Function} successCallback The function to call when the Connection data is available
         * @param {Function} errorCallback The function to call when there is an error getting the Connection data. (OPTIONAL)
         */
        NetworkConnection.prototype.getInfo = function(successCallback, errorCallback) {
          exec(successCallback, errorCallback, "NetworkStatus", "getConnectionInfo", []);
        };

        var me = new NetworkConnection();
        var timerId = null;
        var timeout = 500;

        channel.onCordovaReady.subscribe(function() {
          me.getInfo(function(info) {
              me.type = info;
              if(info === "none") {
                // set a timer if still offline at the end of timer send the offline event
                timerId = setTimeout(function() {
                  cordova.fireDocumentEvent("offline");
                  timerId = null;
                }, timeout);
              } else {
                // If there is a current offline event pending clear it
                if(timerId !== null) {
                  clearTimeout(timerId);
                  timerId = null;
                }
                cordova.fireDocumentEvent("online");
              }

              // should only fire this once
              if(channel.onCordovaConnectionReady.state !== 2) {
                channel.onCordovaConnectionReady.fire();
              }
            },
            function(e) {
              // If we can't get the network info we should still tell Cordova
              // to fire the deviceready event.
              if(channel.onCordovaConnectionReady.state !== 2) {
                channel.onCordovaConnectionReady.fire();
              }
              console.log("Error initializing Network Connection: " + e);
            });
        });

        module.exports = me;

      });

      // file: lib/common/plugin/notification.js
      define("cordova/plugin/notification", function(require, exports, module) {

        var exec = require('cordova/exec');

        /**
         * Provides access to notifications on the device.
         */

        module.exports = {

          /**
           * Open a native alert dialog, with a customizable title and button text.
           *
           * @param {String} message              Message to print in the body of the alert
           * @param {Function} completeCallback   The callback that is called when user clicks on a button.
           * @param {String} title                Title of the alert dialog (default: Alert)
           * @param {String} buttonLabel          Label of the close button (default: OK)
           */
          alert: function(message, completeCallback, title, buttonLabel) {
            var _title = (title || "Alert");
            var _buttonLabel = (buttonLabel || "OK");
            exec(completeCallback, null, "Notification", "alert", [message, _title, _buttonLabel]);
          },

          /**
           * Open a native confirm dialog, with a customizable title and button text.
           * The result that the user selects is returned to the result callback.
           *
           * @param {String} message              Message to print in the body of the alert
           * @param {Function} resultCallback     The callback that is called when user clicks on a button.
           * @param {String} title                Title of the alert dialog (default: Confirm)
           * @param {String} buttonLabels         Comma separated list of the labels of the buttons (default: 'OK,Cancel')
           */
          confirm: function(message, resultCallback, title, buttonLabels) {
            var _title = (title || "Confirm");
            var _buttonLabels = (buttonLabels || "OK,Cancel");
            exec(resultCallback, null, "Notification", "confirm", [message, _title, _buttonLabels]);
          },

          /**
           * Causes the device to vibrate.
           *
           * @param {Integer} mills       The number of milliseconds to vibrate for.
           */
          vibrate: function(mills) {
            exec(null, null, "Notification", "vibrate", [mills]);
          },

          /**
           * Causes the device to beep.
           * On Android, the default notification ringtone is played "count" times.
           *
           * @param {Integer} count       The number of beeps.
           */
          beep: function(count) {
            exec(null, null, "Notification", "beep", [count]);
          }
        };

      });

      // file: lib/common/plugin/requestFileSystem.js
      define("cordova/plugin/requestFileSystem", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          FileError = require('cordova/plugin/FileError'),
          FileSystem = require('cordova/plugin/FileSystem'),
          exec = require('cordova/exec');

        /**
         * Request a file system in which to store application data.
         * @param type  local file system type
         * @param size  indicates how much storage space, in bytes, the application expects to need
         * @param successCallback  invoked with a FileSystem object
         * @param errorCallback  invoked if error occurs retrieving file system
         */
        var requestFileSystem = function(type, size, successCallback, errorCallback) {
          argscheck.checkArgs('nnFF', 'requestFileSystem', arguments);
          var fail = function(code) {
            errorCallback && errorCallback(new FileError(code));
          };

          if(type < 0 || type > 3) {
            fail(FileError.SYNTAX_ERR);
          } else {
            // if successful, return a FileSystem object
            var success = function(file_system) {
              if(file_system) {
                if(successCallback) {
                  // grab the name and root from the file system object
                  var result = new FileSystem(file_system.name, file_system.root);
                  successCallback(result);
                }
              } else {
                // no FileSystem object returned
                fail(FileError.NOT_FOUND_ERR);
              }
            };
            exec(success, fail, "File", "requestFileSystem", [type, size]);
          }
        };

        module.exports = requestFileSystem;

      });

      // file: lib/common/plugin/resolveLocalFileSystemURI.js
      define("cordova/plugin/resolveLocalFileSystemURI", function(require, exports, module) {

        var argscheck = require('cordova/argscheck'),
          DirectoryEntry = require('cordova/plugin/DirectoryEntry'),
          FileEntry = require('cordova/plugin/FileEntry'),
          FileError = require('cordova/plugin/FileError'),
          exec = require('cordova/exec');

        /**
         * Look up file system Entry referred to by local URI.
         * @param {DOMString} uri  URI referring to a local file or directory
         * @param successCallback  invoked with Entry object corresponding to URI
         * @param errorCallback    invoked if error occurs retrieving file system entry
         */
        module.exports = function(uri, successCallback, errorCallback) {
          argscheck.checkArgs('sFF', 'resolveLocalFileSystemURI', arguments);
          // error callback
          var fail = function(error) {
            errorCallback && errorCallback(new FileError(error));
          };
          // sanity check for 'not:valid:filename'
          if(!uri || uri.split(":").length > 2) {
            setTimeout(function() {
              fail(FileError.ENCODING_ERR);
            }, 0);
            return;
          }
          // if successful, return either a file or directory entry
          var success = function(entry) {
            var result;
            if(entry) {
              if(successCallback) {
                // create appropriate Entry object
                result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath) : new FileEntry(entry.name, entry.fullPath);
                successCallback(result);
              }
            } else {
              // no Entry object returned
              fail(FileError.NOT_FOUND_ERR);
            }
          };

          exec(success, fail, "File", "resolveLocalFileSystemURI", [uri]);
        };

      });

      // file: lib/common/plugin/splashscreen.js
      define("cordova/plugin/splashscreen", function(require, exports, module) {

        var exec = require('cordova/exec');

        var splashscreen = {
          show: function() {
            exec(null, null, "SplashScreen", "show", []);
          },
          hide: function() {
            exec(null, null, "SplashScreen", "hide", []);
          }
        };

        module.exports = splashscreen;

      });

      // file: lib/common/utils.js
      define("cordova/utils", function(require, exports, module) {

        var utils = exports;

        /**
         * Defines a property getter / setter for obj[key].
         */
        utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {
          if(Object.defineProperty) {
            var desc = {
              get: getFunc,
              configurable: true
            };
            if(opt_setFunc) {
              desc.set = opt_setFunc;
            }
            Object.defineProperty(obj, key, desc);
          } else {
            obj.__defineGetter__(key, getFunc);
            if(opt_setFunc) {
              obj.__defineSetter__(key, opt_setFunc);
            }
          }
        };

        /**
         * Defines a property getter for obj[key].
         */
        utils.defineGetter = utils.defineGetterSetter;

        utils.arrayIndexOf = function(a, item) {
          if(a.indexOf) {
            return a.indexOf(item);
          }
          var len = a.length;
          for(var i = 0; i < len; ++i) {
            if(a[i] == item) {
              return i;
            }
          }
          return -1;
        };

        /**
         * Returns whether the item was found in the array.
         */
        utils.arrayRemove = function(a, item) {
          var index = utils.arrayIndexOf(a, item);
          if(index != -1) {
            a.splice(index, 1);
          }
          return index != -1;
        };

        utils.typeName = function(val) {
          return Object.prototype.toString.call(val).slice(8, -1);
        };

        /**
         * Returns an indication of whether the argument is an array or not
         */
        utils.isArray = function(a) {
          return utils.typeName(a) == 'Array';
        };

        /**
         * Returns an indication of whether the argument is a Date or not
         */
        utils.isDate = function(d) {
          return utils.typeName(d) == 'Date';
        };

        /**
         * Does a deep clone of the object.
         */
        utils.clone = function(obj) {
          if(!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {
            return obj;
          }

          var retVal, i;

          if(utils.isArray(obj)) {
            retVal = [];
            for(i = 0; i < obj.length; ++i) {
              retVal.push(utils.clone(obj[i]));
            }
            return retVal;
          }

          retVal = {};
          for(i in obj) {
            if(!(i in retVal) || retVal[i] != obj[i]) {
              retVal[i] = utils.clone(obj[i]);
            }
          }
          return retVal;
        };

        /**
         * Returns a wrapped version of the function
         */
        utils.close = function(context, func, params) {
          if(typeof params == 'undefined') {
            return function() {
              return func.apply(context, arguments);
            };
          } else {
            return function() {
              return func.apply(context, params);
            };
          }
        };

        /**
         * Create a UUID
         */
        utils.createUUID = function() {
          return UUIDcreatePart(4) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(6);
        };

        /**
         * Extends a child object from a parent object using classical inheritance
         * pattern.
         */
        utils.extend = (function() {
          // proxy used to establish prototype chain
          var F = function() {};
          // extend Child from Parent
          return function(Child, Parent) {
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.__super__ = Parent.prototype;
            Child.prototype.constructor = Child;
          };
        }());

        /**
         * Alerts a message in any available way: alert or console.log.
         */
        utils.alert = function(msg) {
          if(window.alert) {
            window.alert(msg);
          } else if(console && console.log) {
            console.log(msg);
          }
        };

        /**
         * Formats a string and arguments following it ala sprintf()
         *
         * see utils.vformat() for more information
         */
        utils.format = function(formatString /* ,... */ ) {
          var args = [].slice.call(arguments, 1);
          return utils.vformat(formatString, args);
        };

        /**
         * Formats a string and arguments following it ala vsprintf()
         *
         * format chars:
         *   %j - format arg as JSON
         *   %o - format arg as JSON
         *   %c - format arg as ''
         *   %% - replace with '%'
         * any other char following % will format it's
         * arg via toString().
         *
         * for rationale, see FireBug's Console API:
         *    http://getfirebug.com/wiki/index.php/Console_API
         */
        utils.vformat = function(formatString, args) {
          if(formatString === null || formatString === undefined) return "";
          if(arguments.length == 1) return formatString.toString();
          if(typeof formatString != "string") return formatString.toString();

          var pattern = /(.*?)%(.)(.*)/;
          var rest = formatString;
          var result = [];

          while(args.length) {
            var arg = args.shift();
            var match = pattern.exec(rest);

            if(!match) break;

            rest = match[3];

            result.push(match[1]);

            if(match[2] == '%') {
              result.push('%');
              args.unshift(arg);
              continue;
            }

            result.push(formatted(arg, match[2]));
          }

          result.push(rest);

          return result.join('');
        };

        //------------------------------------------------------------------------------
        function UUIDcreatePart(length) {
          var uuidpart = "";
          for(var i = 0; i < length; i++) {
            var uuidchar = parseInt((Math.random() * 256), 10).toString(16);
            if(uuidchar.length == 1) {
              uuidchar = "0" + uuidchar;
            }
            uuidpart += uuidchar;
          }
          return uuidpart;
        }

        //------------------------------------------------------------------------------
        function formatted(object, formatChar) {

          try {
            switch(formatChar) {
              case 'j':
              case 'o':
                return JSON.stringify(object);
              case 'c':
                return '';
            }
          } catch(e) {
            return "error JSON.stringify()ing argument: " + e;
          }

          if((object === null) || (object === undefined)) {
            return Object.prototype.toString.call(object);
          }

          return object.toString();
        }

      });


      window.cordova = require('cordova');

      // file: lib/scripts/bootstrap.js

      (function(context) {
        // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
        // We replace it so that properties that can't be clobbered can instead be overridden.
        if(context.navigator) {
          var CordovaNavigator = function() {};
          CordovaNavigator.prototype = context.navigator;
          context.navigator = new CordovaNavigator();
        }

        var channel = require("cordova/channel"),
          _self = {
            boot: function() {
              /**
               * Create all cordova objects once page has fully loaded and native side is ready.
               */
              channel.join(function() {
                var builder = require('cordova/builder'),
                  base = require('cordova/common'),
                  platform = require('cordova/platform');

                // Drop the common globals into the window object, but be nice and don't overwrite anything.
                builder.buildIntoButDoNotClobber(base.defaults, context);
                builder.buildIntoAndClobber(base.clobbers, context);
                builder.buildIntoAndMerge(base.merges, context);

                builder.buildIntoButDoNotClobber(platform.defaults, context);
                builder.buildIntoAndClobber(platform.clobbers, context);
                builder.buildIntoAndMerge(platform.merges, context);

                // Call the platform-specific initialization
                platform.initialize();

                // Fire event to notify that all objects are created
                channel.onCordovaReady.fire();

                // Fire onDeviceReady event once all constructors have run and
                // cordova info has been received from native side.
                channel.join(function() {
                  require('cordova').fireDocumentEvent('deviceready');
                }, channel.deviceReadyChannelsArray);

              }, [channel.onDOMContentLoaded, channel.onNativeReady]);
            }
          };

        // boot up once native side is ready
        channel.onNativeReady.subscribe(_self.boot);

        // _nativeReady is global variable that the native side can set
        // to signify that the native code is ready. It is a global since
        // it may be called before any cordova JS is ready.
        if(window._nativeReady) {
          channel.onNativeReady.fire();
        }

      }(window));


    })();
    var PhoneGap = cordova;

  }
}
/**
 * 录音插件
 * @type {Object}
 */
Xut.Plugin.Recorder = {
  // 开始录音
  startRecord: function(id, successCallback, errorCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Recorder.startRecord(id, successCallback, errorCallback);
    } else {
      return cordova.exec(successCallback, errorCallback, "XXTRecord", "startRecord", [id])
    }
  },
  // 结束录音
  stopRecord: function(successCallback, errorCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Recorder.stopRecord();
    } else {
      return cordova.exec(successCallback, errorCallback, "XXTRecord", "stopRecord", [])
    }
  },
  // 开始播放
  startPlay: function(id, successCallback, errorCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Recorder.startPlay(id, successCallback, errorCallback);
    } else {
      return cordova.exec(successCallback, errorCallback, "XXTRecord", "startPlay", [id])
    }
  },
  // 结束播放
  stopPlay: function(id, successCallback, errorCallback) {
    if (GLOBALIFRAME) {
      return GLOBALCONTEXT.Recorder.stopPlay(id);
    } else {
      return cordova.exec(successCallback, errorCallback, "XXTRecord", "stopPlay", [id])
    }
  }
}

/**
 *     readAssetsFilePlugin.js
 *     readAssetsFilePlugin PhoneGap plugin (Android)
 *
 *     Created by Tanxiangjiang on 05/21/2013.
 */
Xut.Plugin.ReadAssetsFile = {

  readAssetsFileAction: function(path, successCallback, failureCallback) {
    if(GLOBALIFRAME) {
      //客户端插件调用
      if(CLIENTCONFIGT) {
        return GLOBALCONTEXT.Xut.Plugin.ReadAssetsFile.readAssetsFileAction(path, successCallback, failureCallback)
      }
      //读库
      return GLOBALCONTEXT.ReadAssetsFile.readAssetsFileAction(path, successCallback, failureCallback);
    } else {
      //正常模式
      return cordova.exec(
        successCallback,
        failureCallback,
        'ReadAssetsFile',
        'readAssetsFileAction', [path]);
    }
  }

};
/**
 * Constructor
 */
Xut.Plugin.XXTEbookInit = {

  /**
   * Play the passed in text as synthasized speech
   *
   * @param {DOMString} text
   * @param {Object} successCallback
   * @param {Object} errorCallback
   */
  update: function(text, successCallback, errorCallback) {
    return cordova.exec(successCallback, errorCallback, "XxtebookInit", "update", [text]);
  },

  /**
   * Starts up the XXTEbookInit Service
   * @param {string} databaseName
   * @param {Object} successCallback
   * @param {Object} errorCallback
   */
  startup: function(databaseName, successCallback, errorCallback) {
    if(GLOBALIFRAME) {
      return successCallback();
    } else {
      return cordova.exec(successCallback, errorCallback, "XxtebookInit", "startup", [databaseName]);
    }
  },

  /**
   * Finds out if the language is currently supported by the XXTEbookInit service.
   *
   * @param {DOMSting} lang
   * @param {Object} successCallback
   * @param {Object} errorCallback
   */
  getInfo: function(text, successCallback, errorCallback) {
    return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getInfo", [text]);
  },

  /**
   * Finds out the current language of the XXTEbookInit service.
   *
   * @param {Object} successCallback
   * @param {Object} errorCallback
   */
  getChapter: function(chapterId, successCallback, errorCallback) {
    return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getChapter", [chapterId]);
  },



  getPercent: function(successCallback, errorCallback) {
    return cordova.exec(successCallback, errorCallback, "XxtebookInit", "getPercent", []);
  }

};
/*
 * PhoneGap is available under *either* the terms of the modified BSD license *or* the
 * MIT License (2008). See http://opensource.org/licenses/alphabetical for full text.
 *
 * Copyright (c) 2005-2010, Nitobi Software Inc.
 * Copyright (c) 2011, IBM Corporation
 */

Xut.Plugin.WebView = {
  open: function(url, left, top, height, width, mode) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.WebView.open(url, left, top, height, width, mode);
    } else {
      return cordova.exec(null, null, "WebView", "open", [url, left, top, height, width, mode]);
    }
  },
  close: function() {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.WebView.close();
    } else {
      return cordova.exec(null, null, "WebView", "close", []);
    }
  },
  flag: function(successCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.WebView.flag(successCallback);
    } else {
      return cordova.exec(successCallback, null, "WebView", "flag", []);
    }
  }
};
Xut.Plugin.VideoPlayer = {
  play: function(successCallback, errorCallback, videoname, type, left, top, height, width) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.VideoPlayer.play(successCallback, errorCallback, videoname, 0, left, top, height, width);
    } else {
      if(navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
        var config = {
          paramA: videoname, //传入地址
          paramB: type, //传入类型 0-本地 1-网络
          paramC: left, //上下左右表示视频的位置
          paramD: top,
          paramE: height,
          paramF: width
        };
        return cordova.exec(successCallback, errorCallback, 'VideoPlayer', 'play', [config]);
      } else {
        var param = new Array();
        param[0] = videoname;
        param[1] = type;
        param[2] = left;
        param[3] = top;
        param[4] = height;
        param[5] = width;
        return cordova.exec(successCallback, errorCallback, "VideoPlayer", "play", param);


      }
    }
  },

  close: function(successCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.VideoPlayer.close(successCallback);
    } else {
      return cordova.exec(successCallback, null, "VideoPlayer", "close", []);
    }
  },

  flag: function(successCallback) {
    if(GLOBALIFRAME) {
      return GLOBALIFRAME.VideoPlayer.flag(successCallback);
    } else {
      return cordova.exec(successCallback, null, "VideoPlayer", "flag", []);
    }
  },

  errorFlag: function(successCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.VideoPlayer.errorFlag(successCallback);
    } else {
      return cordova.exec(successCallback, null, 'VideoPlayer', 'errorFlag', []);
    }
  },

  pauseFlag: function(successCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.VideoPlayer.pauseFlag(successCallback);
    } else {
      return cordova.exec(successCallback, null, 'VideoPlayer', 'pauseFlag', []);
    }
  },

  windowFlag: function(successCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.VideoPlayer.windowFlag(successCallback);
    } else {
      return cordova.exec(successCallback, null, "VideoPlayer", "windowFlag", []);
    }
  },

  init: function(successCallback, infilename, outfilename) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.VideoPlayer.init(successCallback, infilename, outfilename);
    } else {
      return cordova.exec(successCallback, null, 'VideoPlayer', 'init', [infilename, outfilename]);
    }
  }
};
/**
 *     AppToAppPlugin.js
 *     AppToApp PhoneGap plugin (Android)
 *
 *     Created by Tanxiangjiang on 06/11/2012.
 */
Xut.Plugin.OpenApp = {

  openAppAction: function(appName, successCallback, failureCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.OpenApp.openAppAction(appName, successCallback, failureCallback);
    } else {
      return cordova.exec(
        successCallback,
        failureCallback,
        'OpenApp',
        'openAppAction', [appName]);
    }
  }

};
/**
 *  tabletPlugin.js
 *  tablet PhoneGap plugin (Android)
 *
 *  Created by Tanxiangjiang on 06/16/2012
 */
Xut.Plugin.Tablet = {

  paintPath: function(successCallback, failureCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.paintPath(successCallback, failureCallback);
    } else {
      return cordova.exec(
        successCallback,
        failureCallback,
        'Tablet',
        'paintPath', []);
    }
  },

  openAction: function(path, filename, BitmapWidth, BitmapHeight, left, top, height, weight, successCallback, failureCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.openAction(path, filename, BitmapWidth, BitmapHeight, left, top, height, weight, successCallback, failureCallback);
    } else {
      return cordova.exec(successCallback,
        failureCallback,
        'Tablet',
        'openAction', [path, filename, BitmapWidth, BitmapHeight, left, top, height, weight]);
    }
  },

  closeAction: function(successCallback, failureCallback) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.Tablet.closeAction(successCallback, failureCallback);
    } else {
      return cordova.exec(successCallback,
        failureCallback,
        'Tablet',
        'closeAction', []);
    }
  }

};
/**
 * 	aptestPlugin.js
 * 	aptestPlugin PhoneGap plugin (IOS)
 *
 * 	Created by YangQingming on 2013-07-01.
 * 	appInfo  1:hide ; 0:show
 */
Xut.Plugin.statusbarPlugin = {
  setStatus: function(successfullCallback, failedCallback, appInfo) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.XXT.plugins.statusbarPlugin.setStatus(successfullCallback, failedCallback, appInfo);
    } else {
      return cordova.exec(successfullCallback, failedCallback, 'statusbarSet', 'set', [appInfo]);
    }
  }
};
/**
 *  iap.js
 *  iap PhoneGap plugin (IOS)
 *
 *  Created by YangQingming on 2013-07-01.
 **/

Xut.Plugin.iapPlugin = {
  restore: function(successfullCallback, failedCallback, appInfo) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.iapPlugin.restore(successfullCallback, failedCallback, appInfo);
    } else {
      return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'restoreGood', [appInfo]);
    }
  },

  buyGood: function(successfullCallback, failedCallback, appInfo) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.iapPlugin.buyGood(successfullCallback, failedCallback, appInfo);
    } else {
      return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'buyIAP', [appInfo]);
    }
  },

  selectInfo: function(successfullCallback, failedCallback, appInfo) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.iapPlugin.selectInfo(successfullCallback, failedCallback, appInfo);
    } else {
      return cordova.exec(successfullCallback, failedCallback, 'IAPPlguin', 'selectInfo', [appInfo]);
    }
  }
};
/**
 *  AppStoreLink.js
 *  AppStoreLink PhoneGap plugin (IOS)
 *
 *  Created by HuXi on 2014-05-29.
 **/

Xut.Plugin.appStoreLinkPlugin = {
  callProductView: function(successfullCallback, failedCallback, appId) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.appStoreLinkPlugin.callProductView(successfullCallback, failedCallback, appId);
    } else {
      return cordova.exec(successfullCallback, failedCallback, "AppStoreLink", "callProductView", [appId]);
    }
  }
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

Xut.Plugin.DownloadPlugin = {

  download: function(successfullCallback, failedCallback, json) {
    return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'download', [json]);
  },

  pause: function(successfullCallback, failedCallback, url) {
    return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'pause', [url]);
  },

  downloadContinue: function(successfullCallback, failedCallback, json) {
    return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'downloadContinue', [json]);
  },

  back: function(successfullCallback, failedCallback) {
    return cordova.exec(successfullCallback, failedCallback, 'DownloadPlugin', 'back', []);
  }
}
//txt文本插件
Xut.Plugin.bookManagerPlugins = {
  getAppOpenWay: function(successfullCallback, failedCallback) {
    return cordova.exec(successfullCallback, failedCallback, 'XxtebookManager', 'getAppOpenWay', []);
  },
  pause: function(successfullCallback, failedCallback) {

    return cordova.exec(successfullCallback, failedCallback, 'XxtebookManager', 'pause', []);
  }
}
/**
 * 	unzipPlugin.js
 * 	Unzip PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 18/6/2013.
 */

Xut.Plugin.UnzipPlugin = {
  storageAction: function(json, successCallback, failureCallback) {
    return cordova.exec(successCallback, failureCallback, 'UnzipPlugin', 'storageAction', [json]);
  }
}
/**
 * 	readPlugin.js
 * 	Read PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 18/6/2013.
 */

Xut.Plugin.ReadPlugin = {
  loadAction: function(id, type, successCallback, failureCallback) {
    return cordova.exec(successCallback, failureCallback, 'ReadPlugin', 'loadAction', [id, type]);
  }
};
/**
 * 	deletePlugin.js
 * 	delete PhoneGap plugin (Android)
 *
 * 	Created by Tanxiangjiang on 4/8/2013.
 *  Last-Modified  11:03 4/8/2013
 */
Xut.Plugin.DeletePlugin = {
  deleteAction: function(successCallback, failureCallback, id) {
    if(GLOBALIFRAME) {
      return GLOBALCONTEXT.DeletePlugin.deleteAction(directory, successCallback, failureCallback);
    } else {
      return cordova.exec(successCallback, failureCallback, 'DeletePlugin', 'deleteAction', [id]);
    }
  }
}
/*!
 * VERSION: 0.14.8
 * DATE: 2016-07-18
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Requires TweenLite and CSSPlugin version 1.17.0 or later (TweenMax contains both TweenLite and CSSPlugin). ThrowPropsPlugin is required for momentum-based continuation of movement after the mouse/touch is released (ThrowPropsPlugin is a membership benefit of Club GreenSock - http://greensock.com/club/).
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {

  "use strict";

  _gsScope._gsDefine("utils.Draggable", ["events.EventDispatcher", "TweenLite", "plugins.CSSPlugin"], function(EventDispatcher, TweenLite, CSSPlugin) {

    var _tempVarsXY = { css: {} }, //speed optimization - we reuse the same vars object for x/y TweenLite.set() calls to minimize garbage collection tasks and improve performance.
      _tempVarsX = { css: {} },
      _tempVarsY = { css: {} },
      _tempVarsRotation = { css: {} },
      _globals = _gsScope._gsDefine.globals,
      _tempEvent = {}, //for populating with pageX/pageY in old versions of IE
      _doc = document,
      _docElement = _doc.documentElement || {},
      _createElement = function(type) {
        return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
      },
      _tempDiv = _createElement("div"),
      _emptyArray = [],
      _emptyFunc = function() { return false; },
      _RAD2DEG = 180 / Math.PI,
      _max = 999999999999999,
      _getTime = Date.now || function() { return new Date().getTime(); },
      _isOldIE = !!(!_doc.addEventListener && _doc.all),
      _placeholderDiv = _doc.createElement("div"),
      _renderQueue = [],
      _lookup = {}, //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
      _lookupCount = 0,
      _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
      _dragCount = 0, //total number of elements currently being dragged
      _prefix,
      _isMultiTouching,
      _isAndroid = (navigator.userAgent.toLowerCase().indexOf("android") !== -1), //Android handles touch events in an odd way and it's virtually impossible to "feature test" so we resort to UA sniffing
      _lastDragTime = 0,
      _temp1 = {}, // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.
      _windowProxy = {}, //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.
      _slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
        if(typeof(a) === "string") {
          a = TweenLite.selector(a);
        }
        if(!a || a.nodeType) { //if it's not an array, wrap it in one.
          return [a];
        }
        var b = [],
          l = a.length,
          i;
        for(i = 0; i !== l; b.push(a[i++]));
        return b;
      },
      _copy = function(obj) {
        var copy = {},
          p;
        for(p in obj) {
          copy[p] = obj[p];
        }
        return copy;
      },
      ThrowPropsPlugin,

      _renderQueueTick = function() {
        var i = _renderQueue.length;
        while(--i > -1) {
          _renderQueue[i]();
        }
      },
      _addToRenderQueue = function(func) {
        _renderQueue.push(func);
        if(_renderQueue.length === 1) {
          TweenLite.ticker.addEventListener("tick", _renderQueueTick, this, false, 1);
        }
      },
      _removeFromRenderQueue = function(func) {
        var i = _renderQueue.length;
        while(--i > -1) {
          if(_renderQueue[i] === func) {
            _renderQueue.splice(i, 1);
          }
        }
        TweenLite.to(_renderQueueTimeout, 0, { overwrite: "all", delay: 15, onComplete: _renderQueueTimeout }); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
      },
      _renderQueueTimeout = function() {
        if(!_renderQueue.length) {
          TweenLite.ticker.removeEventListener("tick", _renderQueueTick);
        }
      },

      _extend = function(obj, defaults) {
        var p;
        for(p in defaults) {
          if(obj[p] === undefined) {
            obj[p] = defaults[p];
          }
        }
        return obj;
      },
      _getDocScrollTop = function() {
        return(window.pageYOffset != null) ? window.pageYOffset : (_doc.scrollTop != null) ? _doc.scrollTop : _docElement.scrollTop || _doc.body.scrollTop || 0;
      },
      _getDocScrollLeft = function() {
        return(window.pageXOffset != null) ? window.pageXOffset : (_doc.scrollLeft != null) ? _doc.scrollLeft : _docElement.scrollLeft || _doc.body.scrollLeft || 0;
      },
      _addScrollListener = function(e, callback) {
        _addListener(e, "scroll", callback);
        if(!_isRoot(e.parentNode)) {
          _addScrollListener(e.parentNode, callback);
        }
      },
      _removeScrollListener = function(e, callback) {
        _removeListener(e, "scroll", callback);
        if(!_isRoot(e.parentNode)) {
          _removeScrollListener(e.parentNode, callback);
        }
      },
      _isRoot = function(e) {
        return !!(!e || e === _docElement || e === _doc || e === _doc.body || e === window || !e.nodeType || !e.parentNode);
      },
      _getMaxScroll = function(element, axis) {
        var dim = (axis === "x") ? "Width" : "Height",
          scroll = "scroll" + dim,
          client = "client" + dim,
          body = _doc.body;
        return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], body[scroll]) - (window["inner" + dim] || _docElement[client] || body[client]) : element[scroll] - element[client]);
      },
      _recordMaxScrolls = function(e) { //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
        var isRoot = _isRoot(e),
          x = _getMaxScroll(e, "x"),
          y = _getMaxScroll(e, "y");
        if(isRoot) {
          e = _windowProxy;
        } else {
          _recordMaxScrolls(e.parentNode);
        }
        e._gsMaxScrollX = x;
        e._gsMaxScrollY = y;
        e._gsScrollX = e.scrollLeft || 0;
        e._gsScrollY = e.scrollTop || 0;
      },

      //just used for IE8 and earlier to normalize events and populate pageX/pageY
      _populateIEEvent = function(e, preventDefault) {
        e = e || window.event;
        _tempEvent.pageX = e.clientX + _doc.body.scrollLeft + _docElement.scrollLeft;
        _tempEvent.pageY = e.clientY + _doc.body.scrollTop + _docElement.scrollTop;
        if(preventDefault) {
          e.returnValue = false;
        }
        return _tempEvent;
      },

      //grabs the first element it finds (and we include the window as an element), so if it's selector text, it'll feed that value to TweenLite.selector, if it's a jQuery object or some other selector engine's result, it'll grab the first one, and same for an array. If the value doesn't contain a DOM element, it'll just return null.
      _unwrapElement = function(value) {
        if(!value) {
          return value;
        }
        if(typeof(value) === "string") {
          value = TweenLite.selector(value);
        }
        if(value.length && value !== window && value[0] && value[0].style && !value.nodeType) {
          value = value[0];
        }
        return(value === window || (value.nodeType && value.style)) ? value : null;
      },

      _checkPrefix = function(e, p) {
        var s = e.style,
          capped, i, a;
        if(s[p] === undefined) {
          a = ["O", "Moz", "ms", "Ms", "Webkit"];
          i = 5;
          capped = p.charAt(0).toUpperCase() + p.substr(1);
          while(--i > -1 && s[a[i] + capped] === undefined) {}
          if(i < 0) {
            return "";
          }
          _prefix = (i === 3) ? "ms" : a[i];
          p = _prefix + capped;
        }
        return p;
      },

      _setStyle = function(e, p, value) {
        var s = e.style;
        if(!s) {
          return;
        }
        if(s[p] === undefined) {
          p = _checkPrefix(e, p);
        }
        if(value == null) {
          if(s.removeProperty) {
            s.removeProperty(p.replace(/([A-Z])/g, "-$1").toLowerCase());
          } else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
            s.removeAttribute(p);
          }
        } else if(s[p] !== undefined) {
          s[p] = value;
        }
      },

      _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : _emptyFunc,
      _horizExp = /(?:Left|Right|Width)/i,
      _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
      _convertToPixels = function(t, p, v, sfx, recurse) {
        if(sfx === "px" || !sfx) { return v; }
        if(sfx === "auto" || !v) { return 0; }
        var horiz = _horizExp.test(p),
          node = t,
          style = _tempDiv.style,
          neg = (v < 0),
          pix;
        if(neg) {
          v = -v;
        }
        if(sfx === "%" && p.indexOf("border") !== -1) {
          pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
        } else {
          style.cssText = "border:0 solid red;position:" + _getStyle(t, "position", true) + ";line-height:0;";
          if(sfx === "%" || !node.appendChild) {
            node = t.parentNode || _doc.body;
            style[(horiz ? "width" : "height")] = v + sfx;
          } else {
            style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
          }
          node.appendChild(_tempDiv);
          pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
          node.removeChild(_tempDiv);
          if(pix === 0 && !recurse) {
            pix = _convertToPixels(t, p, v, sfx, true);
          }
        }
        return neg ? -pix : pix;
      },
      _calculateOffset = function(t, p) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
        if(_getStyle(t, "position", true) !== "absolute") { return 0; }
        var dim = ((p === "left") ? "Left" : "Top"),
          v = _getStyle(t, "margin" + dim, true);
        return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), (v + "").replace(_suffixExp, "")) || 0);
      },

      _getStyle = function(element, prop, keepUnits) {
        var rv = (element._gsTransform || {})[prop],
          cs;
        if(rv || rv === 0) {
          return rv;
        } else if(element.style[prop]) {
          rv = element.style[prop];
        } else if((cs = _getComputedStyle(element))) {
          rv = cs.getPropertyValue(prop.replace(/([A-Z])/g, "-$1").toLowerCase());
          rv = (rv || cs.length) ? rv : cs[prop]; //Opera behaves VERY strangely - length is usually 0 and cs[prop] is the only way to get accurate results EXCEPT when checking for -o-transform which only works with cs.getPropertyValue()!
        } else if(element.currentStyle) {
          rv = element.currentStyle[prop];
        }
        if(rv === "auto" && (prop === "top" || prop === "left")) {
          rv = _calculateOffset(element, prop);
        }
        return keepUnits ? rv : parseFloat(rv) || 0;
      },

      _dispatchEvent = function(instance, type, callbackName) {
        var vars = instance.vars,
          callback = vars[callbackName],
          listeners = instance._listeners[type];
        if(typeof(callback) === "function") {
          callback.apply(vars[callbackName + "Scope"] || vars.callbackScope || instance, vars[callbackName + "Params"] || [instance.pointerEvent]);
        }
        if(listeners) {
          instance.dispatchEvent(type);
        }
      },
      _getBounds = function(obj, context) { //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
        var e = _unwrapElement(obj),
          top, left, offset;
        if(!e) {
          if(obj.left !== undefined) {
            offset = _getOffsetTransformOrigin(context); //the bounds should be relative to the origin
            return { left: obj.left - offset.x, top: obj.top - offset.y, width: obj.width, height: obj.height };
          }
          left = obj.min || obj.minX || obj.minRotation || 0;
          top = obj.min || obj.minY || 0;
          return { left: left, top: top, width: (obj.max || obj.maxX || obj.maxRotation || 0) - left, height: (obj.max || obj.maxY || 0) - top };
        }
        return _getElementBounds(e, context);
      },

      _svgBorderFactor,
      _svgBorderScales,
      _svgScrollOffset,
      _hasBorderBug,
      _hasReparentBug, //some browsers, like Chrome 49, alter the offsetTop/offsetLeft/offsetParent of elements when a non-identity transform is applied.
      _setEnvironmentVariables = function() { //some browsers factor the border into the SVG coordinate space, some don't (like Firefox). Some apply transforms to them, some don't. We feature-detect here so we know how to handle the border(s). We can't do this immediately - we must wait for the document.body to exist.
        if(!_doc.createElementNS) {
          _svgBorderFactor = 0;
          _svgBorderScales = false;
          return;
        }
        var div = _createElement("div"),
          svg = _doc.createElementNS("http://www.w3.org/2000/svg", "svg"),
          wrapper = _createElement("div"),
          style = div.style,
          parent = _doc.body || _docElement,
          matrix, e1, point, oldValue;
        if(_doc.body && _transformProp) {
          style.position = "absolute";
          parent.appendChild(wrapper);
          wrapper.appendChild(div);
          oldValue = div.offsetParent;
          wrapper.style[_transformProp] = "rotate(1deg)";
          _hasReparentBug = (div.offsetParent === oldValue);
          wrapper.style.position = "absolute";
          style.height = "10px";
          oldValue = div.offsetTop;
          wrapper.style.border = "5px solid red";
          _hasBorderBug = (oldValue !== div.offsetTop); //some browsers, like Firefox 38, cause the offsetTop/Left to be affected by a parent's border.
          parent.removeChild(wrapper);
        }
        style = svg.style;
        svg.setAttributeNS(null, "width", "400px");
        svg.setAttributeNS(null, "height", "400px");
        svg.setAttributeNS(null, "viewBox", "0 0 400 400");
        style.display = "block";
        style.boxSizing = "border-box";
        style.border = "0px solid red";
        style.transform = "none";
        // in some browsers (like certain flavors of Android), the getScreenCTM() matrix is contaminated by the scroll position. We can run some logic here to detect that condition, but we ended up not needing this because we found another workaround using getBoundingClientRect().
        div.style.cssText = "width:100px;height:100px;overflow:scroll;-ms-overflow-style:none;";
        parent.appendChild(div);
        div.appendChild(svg);
        point = svg.createSVGPoint().matrixTransform(svg.getScreenCTM());
        e1 = point.y;
        div.scrollTop = 100;
        point.x = point.y = 0;
        point = point.matrixTransform(svg.getScreenCTM());
        _svgScrollOffset = (e1 - point.y < 100.1) ? 0 : e1 - point.y - 150;
        div.removeChild(svg);
        parent.removeChild(div);
        // -- end _svgScrollOffset calculation.
        parent.appendChild(svg);
        matrix = svg.getScreenCTM();
        e1 = matrix.e;
        style.border = "50px solid red";
        matrix = svg.getScreenCTM();
        if(e1 === 0 && matrix.e === 0 && matrix.f === 0 && matrix.a === 1) { //Opera has a bunch of bugs - it doesn't adjust the x/y of the matrix, nor does it scale when box-sizing is border-box but it does so elsewhere; to get the correct behavior we set _svgBorderScales to true.
          _svgBorderFactor = 1;
          _svgBorderScales = true;
        } else {
          _svgBorderFactor = (e1 !== matrix.e) ? 1 : 0;
          _svgBorderScales = (matrix.a !== 1);
        }
        parent.removeChild(svg);
      },

      _supports3D = (_checkPrefix(_tempDiv, "perspective") !== ""),

      // start matrix and point conversion methods...
      _transformOriginProp = _checkPrefix(_tempDiv, "transformOrigin").replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
      _transformProp = _checkPrefix(_tempDiv, "transform"),
      _transformPropCSS = _transformProp.replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
      _point1 = {}, //we reuse _point1 and _point2 objects inside matrix and point conversion methods to conserve memory and minimize garbage collection tasks.
      _point2 = {},
      _SVGElement = window.SVGElement,
      _isSVG = function(e) {
        return !!(_SVGElement && typeof(e.getBBox) === "function" && e.getCTM && (!e.parentNode || (e.parentNode.getBBox && e.parentNode.getCTM)));
      },
      _isIE10orBelow = (((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(navigator.userAgent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(navigator.userAgent)) && parseFloat(RegExp.$1) < 11), //Ideally we'd avoid user agent sniffing, but there doesn't seem to be a way to feature-detect and sense a border-related bug that only affects IE10 and IE9.
      _tempTransforms = [],
      _tempElements = [],
      _getSVGOffsets = function(e) { //SVG elements don't always report offsetTop/offsetLeft/offsetParent at all (I'm looking at you, Firefox 29 and Android), so we have to do some work to manufacture those values. You can pass any SVG element and it'll spit back an object with offsetTop, offsetLeft, offsetParent, scaleX, and scaleY properties. We need the scaleX and scaleY to handle the way SVG can resize itself based on the container.
        if(!e.getBoundingClientRect || !e.parentNode || !_transformProp) {
          return { offsetTop: 0, offsetLeft: 0, scaleX: 1, scaleY: 1, offsetParent: _docElement };
        }
        if(Draggable.cacheSVGData !== false && e._gsCache && e._gsCache.lastUpdate === TweenLite.ticker.frame) { //performance optimization. Assume that if the offsets are requested again on the same tick, we can just feed back the values we already calculated (no need to keep recalculating until another tick elapses).
          return e._gsCache;
        }
        var curElement = e,
          cache = _cache(e),
          eRect, parentRect, offsetParent, cs, m, i, point1, point2, borderWidth, borderHeight, width, height;
        cache.lastUpdate = TweenLite.ticker.frame;
        if(e.getBBox && !cache.isSVGRoot) { //if it's a nested/child SVG element, we must find the parent SVG canvas and measure the offset from there.
          curElement = e.parentNode;
          eRect = e.getBBox();
          while(curElement && (curElement.nodeName + "").toLowerCase() !== "svg") {
            curElement = curElement.parentNode;
          }
          cs = _getSVGOffsets(curElement);
          cache.offsetTop = eRect.y * cs.scaleY;
          cache.offsetLeft = eRect.x * cs.scaleX;
          cache.scaleX = cs.scaleX;
          cache.scaleY = cs.scaleY;
          cache.offsetParent = curElement || _docElement;
          return cache;
        }
        //only root SVG elements continue here...
        offsetParent = cache.offsetParent;
        if(offsetParent === _doc.body) {
          offsetParent = _docElement; //avoids problems with margins/padding on the body
        }
        //walk up the ancestors and record any non-identity transforms (and reset them to "none") until we reach the offsetParent. We must do this so that the getBoundingClientRect() is accurate for measuring the offsetTop/offsetLeft. We'll revert the values later...
        _tempElements.length = _tempTransforms.length = 0;
        while(curElement) {
          m = _getStyle(curElement, _transformProp, true);
          if(m !== "matrix(1, 0, 0, 1, 0, 0)" && m !== "none" && m !== "translate3d(0px, 0px, 0px)") {
            _tempElements.push(curElement);
            _tempTransforms.push(curElement.style[_transformProp]);
            curElement.style[_transformProp] = "none";
          }
          if(curElement === offsetParent) {
            break;
          }
          curElement = curElement.parentNode;
        }
        parentRect = offsetParent.getBoundingClientRect();
        m = e.getScreenCTM();
        point2 = e.createSVGPoint();
        point1 = point2.matrixTransform(m);
        point2.x = point2.y = 10;
        point2 = point2.matrixTransform(m);
        cache.scaleX = (point2.x - point1.x) / 10;
        cache.scaleY = (point2.y - point1.y) / 10;
        if(_svgBorderFactor === undefined) {
          _setEnvironmentVariables();
        }
        if(cache.borderBox && !_svgBorderScales && e.getAttribute("width")) { //some browsers (like Safari) don't properly scale the matrix to accommodate the border when box-sizing is border-box, so we must calculate it here...
          cs = _getComputedStyle(e) || {};
          borderWidth = (parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth)) || 0;
          borderHeight = (parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth)) || 0;
          width = parseFloat(cs.width) || 0;
          height = parseFloat(cs.height) || 0;
          cache.scaleX *= (width - borderWidth) / width;
          cache.scaleY *= (height - borderHeight) / height;
        }
        if(_svgScrollOffset) { //some browsers (like Chrome for Android) have bugs in the way getScreenCTM() is reported (it doesn't factor in scroll position), so we must revert to a more expensive technique for calculating offsetTop/Left.
          eRect = e.getBoundingClientRect();
          cache.offsetLeft = eRect.left - parentRect.left;
          cache.offsetTop = eRect.top - parentRect.top;
        } else {
          cache.offsetLeft = point1.x - parentRect.left;
          cache.offsetTop = point1.y - parentRect.top;
        }
        cache.offsetParent = offsetParent;
        i = _tempElements.length;
        while(--i > -1) {
          _tempElements[i].style[_transformProp] = _tempTransforms[i];
        }
        return cache;
      },
      _getOffsetTransformOrigin = function(e, decoratee) { //returns the x/y position of the transformOrigin of the element, in its own local coordinate system (pixels), offset from the top left corner.
        decoratee = decoratee || {};
        if(!e || e === _docElement || !e.parentNode || e === window) {
          return { x: 0, y: 0 };
        }
        var cs = _getComputedStyle(e),
          v = (_transformOriginProp && cs) ? cs.getPropertyValue(_transformOriginProp) : "50% 50%",
          a = v.split(" "),
          x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
          y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];
        if(y === "center" || y == null) {
          y = "50%";
        }
        if(x === "center" || isNaN(parseFloat(x))) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
          x = "50%";
        }
        if(e.getBBox && _isSVG(e)) { //SVG elements must be handled in a special way because their origins are calculated from the top left.
          if(!e._gsTransform) {
            TweenLite.set(e, { x: "+=0", overwrite: false }); //forces creation of the _gsTransform where we store all the transform components including xOrigin and yOrigin for SVG elements, as of GSAP 1.15.0 which also takes care of calculating the origin from the upper left corner of the SVG canvas.
            if(e._gsTransform.xOrigin === undefined) {
              console.log("Draggable requires at least GSAP 1.17.0");
            }
          }
          v = e.getBBox();
          decoratee.x = (e._gsTransform.xOrigin - v.x);
          decoratee.y = (e._gsTransform.yOrigin - v.y);
        } else {
          if(e.getBBox && (x + y).indexOf("%") !== -1) { //Firefox doesn't report offsetWidth/height on <svg> elements.
            e = e.getBBox();
            e = { offsetWidth: e.width, offsetHeight: e.height };
          }
          decoratee.x = ((x.indexOf("%") !== -1) ? e.offsetWidth * parseFloat(x) / 100 : parseFloat(x));
          decoratee.y = ((y.indexOf("%") !== -1) ? e.offsetHeight * parseFloat(y) / 100 : parseFloat(y));

        }
        return decoratee;
      },
      _cache = function(e) { //computes some important values and stores them in a _gsCache object attached to the element itself so that we can optimize performance
        if(Draggable.cacheSVGData !== false && e._gsCache && e._gsCache.lastUpdate === TweenLite.ticker.frame) { //performance optimization. Assume that if the offsets are requested again on the same tick, we can just feed back the values we already calculated (no need to keep recalculating until another tick elapses).
          return e._gsCache;
        }
        var cache = e._gsCache = e._gsCache || {},
          cs = _getComputedStyle(e),
          isSVG = (e.getBBox && _isSVG(e)),
          isSVGRoot = ((e.nodeName + "").toLowerCase() === "svg"),
          curSVG;
        cache.isSVG = isSVG;
        cache.isSVGRoot = isSVGRoot;
        cache.borderBox = (cs.boxSizing === "border-box");
        cache.computedStyle = cs;
        if(isSVGRoot) { //some browsers don't report parentNode on SVG elements.
          curSVG = e.parentNode || _docElement;
          curSVG.insertBefore(_tempDiv, e);
          cache.offsetParent = _tempDiv.offsetParent || _docElement; //in some cases, Firefox still reports offsetParent as null.
          curSVG.removeChild(_tempDiv);
        } else if(isSVG) {
          curSVG = e.parentNode;
          while(curSVG && (curSVG.nodeName + "").toLowerCase() !== "svg") { //offsetParent is always the SVG canvas for SVG elements.
            curSVG = curSVG.parentNode;
          }
          cache.offsetParent = curSVG;
        } else {
          cache.offsetParent = e.offsetParent;
        }
        return cache;
      },
      _getOffset2DMatrix = function(e, offsetOrigin, parentOffsetOrigin, zeroOrigin) {
        if(e === window || !e || !e.style || !e.parentNode) {
          return [1, 0, 0, 1, 0, 0];
        }
        var cache = e._gsCache || _cache(e),
          parent = e.parentNode,
          parentCache = parent._gsCache || _cache(parent),
          cs = cache.computedStyle,
          parentOffsetParent = cache.isSVG ? parentCache.offsetParent : parent.offsetParent,
          m, isRoot, offsets, rect, t, sx, sy, offsetX, offsetY, parentRect, borderTop, borderLeft, borderTranslateX, borderTranslateY;
        m = (cache.isSVG && (e.style[_transformProp] + "").indexOf("matrix") !== -1) ? e.style[_transformProp] : cs ? cs.getPropertyValue(_transformPropCSS) : e.currentStyle ? e.currentStyle[_transformProp] : "1,0,0,1,0,0"; //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values

        if(e.getBBox && (e.getAttribute("transform") + "").indexOf("matrix") !== -1) { //SVG can store transform data in its "transform" attribute instead of the CSS, so look for that here (only accept matrix()).
          m = e.getAttribute("transform");
        }
        m = (m + "").match(/(?:\-|\.|\b)(\d|\.|e\-)+/g) || [1, 0, 0, 1, 0, 0];
        if(m.length > 6) {
          m = [m[0], m[1], m[4], m[5], m[12], m[13]];
        }
        if(zeroOrigin) {
          m[4] = m[5] = 0;
        } else if(cache.isSVG && (t = e._gsTransform) && (t.xOrigin || t.yOrigin)) {
          //SVGs handle origin very differently. Factor in GSAP's handling of origin values here:
          m[0] = parseFloat(m[0]);
          m[1] = parseFloat(m[1]);
          m[2] = parseFloat(m[2]);
          m[3] = parseFloat(m[3]);
          m[4] = parseFloat(m[4]) - (t.xOrigin - (t.xOrigin * m[0] + t.yOrigin * m[2]));
          m[5] = parseFloat(m[5]) - (t.yOrigin - (t.xOrigin * m[1] + t.yOrigin * m[3]));
        }
        if(offsetOrigin) {
          if(_svgBorderFactor === undefined) {
            _setEnvironmentVariables();
          }
          offsets = (cache.isSVG || cache.isSVGRoot) ? _getSVGOffsets(e) : e;
          if(cache.isSVG) { //don't just rely on "instanceof _SVGElement" because if the SVG is embedded via an object tag, it won't work (SVGElement is mapped to a different object))
            rect = e.getBBox();
            parentRect = (parentCache.isSVGRoot) ? { x: 0, y: 0 } : parent.getBBox();
            offsets = { offsetLeft: rect.x - parentRect.x, offsetTop: rect.y - parentRect.y, offsetParent: cache.offsetParent };
          } else if(cache.isSVGRoot) {
            borderTop = parseInt(cs.borderTopWidth, 10) || 0;
            borderLeft = parseInt(cs.borderLeftWidth, 10) || 0;
            borderTranslateX = ((m[0] - _svgBorderFactor) * borderLeft + m[2] * borderTop);
            borderTranslateY = (m[1] * borderLeft + (m[3] - _svgBorderFactor) * borderTop);

            sx = offsetOrigin.x;
            sy = offsetOrigin.y;
            offsetX = (sx - (sx * m[0] + sy * m[2])); //accommodate the SVG root's transforms when the origin isn't in the top left.
            offsetY = (sy - (sx * m[1] + sy * m[3]));

            m[4] = parseFloat(m[4]) + offsetX;
            m[5] = parseFloat(m[5]) + offsetY;
            offsetOrigin.x -= offsetX;
            offsetOrigin.y -= offsetY;
            sx = offsets.scaleX;
            sy = offsets.scaleY;
            offsetOrigin.x *= sx;
            offsetOrigin.y *= sy;
            m[0] *= sx;
            m[1] *= sy;
            m[2] *= sx;
            m[3] *= sy;

            if(!_isIE10orBelow) {
              offsetOrigin.x += borderTranslateX;
              offsetOrigin.y += borderTranslateY;
            }
          } else if(!_hasBorderBug && e.offsetParent) {
            offsetOrigin.x += parseInt(_getStyle(e.offsetParent, "borderLeftWidth"), 10) || 0;
            offsetOrigin.y += parseInt(_getStyle(e.offsetParent, "borderTopWidth"), 10) || 0;
          }
          isRoot = (parent === _docElement || parent === _doc.body);
          m[4] = Number(m[4]) + offsetOrigin.x + (offsets.offsetLeft || 0) - parentOffsetOrigin.x - (isRoot ? 0 : parent.scrollLeft || 0);
          m[5] = Number(m[5]) + offsetOrigin.y + (offsets.offsetTop || 0) - parentOffsetOrigin.y - (isRoot ? 0 : parent.scrollTop || 0);
          if(parent && _getStyle(e, "position", cs) === "fixed") { //fixed position elements should factor in the scroll position of the document.
            m[4] += _getDocScrollLeft();
            m[5] += _getDocScrollTop();
          }
          if(parent && parent !== _docElement && parentOffsetParent === offsets.offsetParent && !parentCache.isSVG && (!_hasReparentBug || _getOffset2DMatrix(parent).join("") === "100100")) {
            offsets = (parentCache.isSVGRoot) ? _getSVGOffsets(parent) : parent;
            m[4] -= offsets.offsetLeft || 0;
            m[5] -= offsets.offsetTop || 0;
            if(!_hasBorderBug && parentCache.offsetParent && !cache.isSVG && !cache.isSVGRoot) {
              m[4] -= parseInt(_getStyle(parentCache.offsetParent, "borderLeftWidth"), 10) || 0;
              m[5] -= parseInt(_getStyle(parentCache.offsetParent, "borderTopWidth"), 10) || 0;
            }
          }
        }
        return m;
      },
      _getConcatenatedMatrix = function(e, invert) {
        if(!e || e === window || !e.parentNode) {
          return [1, 0, 0, 1, 0, 0];
        }
        //note: we keep reusing _point1 and _point2 in order to minimize memory usage and garbage collection chores.
        var originOffset = _getOffsetTransformOrigin(e, _point1),
          parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, _point2),
          m = _getOffset2DMatrix(e, originOffset, parentOriginOffset),
          a, b, c, d, tx, ty, m2, determinant;
        while((e = e.parentNode) && e.parentNode && e !== _docElement) {
          originOffset = parentOriginOffset;
          parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, (originOffset === _point1) ? _point2 : _point1);
          m2 = _getOffset2DMatrix(e, originOffset, parentOriginOffset);
          a = m[0];
          b = m[1];
          c = m[2];
          d = m[3];
          tx = m[4];
          ty = m[5];
          m[0] = a * m2[0] + b * m2[2];
          m[1] = a * m2[1] + b * m2[3];
          m[2] = c * m2[0] + d * m2[2];
          m[3] = c * m2[1] + d * m2[3];
          m[4] = tx * m2[0] + ty * m2[2] + m2[4];
          m[5] = tx * m2[1] + ty * m2[3] + m2[5];
        }
        if(invert) {
          a = m[0];
          b = m[1];
          c = m[2];
          d = m[3];
          tx = m[4];
          ty = m[5];
          determinant = (a * d - b * c);
          m[0] = d / determinant;
          m[1] = -b / determinant;
          m[2] = -c / determinant;
          m[3] = a / determinant;
          m[4] = (c * ty - d * tx) / determinant;
          m[5] = -(a * ty - b * tx) / determinant;
        }
        return m;
      },
      _localToGlobal = function(e, p, fromTopLeft, decoratee, zeroOrigin) {
        e = _unwrapElement(e);
        var m = _getConcatenatedMatrix(e, false, zeroOrigin),
          x = p.x,
          y = p.y;
        if(fromTopLeft) {
          _getOffsetTransformOrigin(e, p);
          x -= p.x;
          y -= p.y;
        }
        decoratee = (decoratee === true) ? p : decoratee || {};
        decoratee.x = x * m[0] + y * m[2] + m[4];
        decoratee.y = x * m[1] + y * m[3] + m[5];
        return decoratee;
      },
      _localizePoint = function(p, localToGlobal, globalToLocal) {
        var x = p.x * localToGlobal[0] + p.y * localToGlobal[2] + localToGlobal[4],
          y = p.x * localToGlobal[1] + p.y * localToGlobal[3] + localToGlobal[5];
        p.x = x * globalToLocal[0] + y * globalToLocal[2] + globalToLocal[4];
        p.y = x * globalToLocal[1] + y * globalToLocal[3] + globalToLocal[5];
        return p;
      },

      _getElementBounds = function(e, context, fromTopLeft) {
        if(!(e = _unwrapElement(e))) {
          return null;
        }
        context = _unwrapElement(context);
        var isSVG = (e.getBBox && _isSVG(e)),
          origin, left, right, top, bottom, mLocalToGlobal, mGlobalToLocal, p1, p2, p3, p4, bbox, width, height, cache, borderLeft, borderTop, viewBox, viewBoxX, viewBoxY, computedDimensions, cs;
        if(e === window) {
          top = _getDocScrollTop();
          left = _getDocScrollLeft();
          right = left + (_docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0);
          bottom = top + (((e.innerHeight || 0) - 20 < _docElement.clientHeight) ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.
        } else if(context === undefined || context === window) {
          return e.getBoundingClientRect();
        } else {
          origin = _getOffsetTransformOrigin(e);
          left = -origin.x;
          top = -origin.y;
          if(isSVG) {
            bbox = e.getBBox();
            width = bbox.width;
            height = bbox.height;
          } else if((e.nodeName + "").toLowerCase() !== "svg" && e.offsetWidth) { //Chrome dropped support for "offsetWidth" on SVG elements
            width = e.offsetWidth;
            height = e.offsetHeight;
          } else {
            computedDimensions = _getComputedStyle(e);
            width = parseFloat(computedDimensions.width);
            height = parseFloat(computedDimensions.height);
          }
          right = left + width;
          bottom = top + height;
          if(e.nodeName.toLowerCase() === "svg" && !_isOldIE) { //root SVG elements are a special beast because they have 2 types of scaling - transforms on themselves as well as the stretching of the SVG canvas itself based on the outer size and the viewBox. If, for example, the SVG's viewbox is "0 0 100 100" but the CSS is set to width:200px; height:200px, that'd make it appear at 2x scale even though the element itself has no CSS transforms but the offsetWidth/offsetHeight are based on that css, not the viewBox so we need to adjust them accordingly.
            cache = _getSVGOffsets(e);
            cs = cache.computedStyle || {};
            viewBox = (e.getAttribute("viewBox") || "0 0").split(" ");
            viewBoxX = parseFloat(viewBox[0]);
            viewBoxY = parseFloat(viewBox[1]);
            borderLeft = parseFloat(cs.borderLeftWidth) || 0;
            borderTop = parseFloat(cs.borderTopWidth) || 0;
            right -= width - ((width - borderLeft) / cache.scaleX) - viewBoxX;
            bottom -= height - ((height - borderTop) / cache.scaleY) - viewBoxY;
            left -= borderLeft / cache.scaleX - viewBoxX;
            top -= borderTop / cache.scaleY - viewBoxY;
            if(computedDimensions) { //when we had to use computed styles, factor in the border now.
              right += (parseFloat(cs.borderRightWidth) + borderLeft) / cache.scaleX;
              bottom += (borderTop + parseFloat(cs.borderBottomWidth)) / cache.scaleY;
            }
          }
        }
        if(e === context) {
          return { left: left, top: top, width: right - left, height: bottom - top };
        }
        mLocalToGlobal = _getConcatenatedMatrix(e);
        mGlobalToLocal = _getConcatenatedMatrix(context, true);
        p1 = _localizePoint({ x: left, y: top }, mLocalToGlobal, mGlobalToLocal);
        p2 = _localizePoint({ x: right, y: top }, mLocalToGlobal, mGlobalToLocal);
        p3 = _localizePoint({ x: right, y: bottom }, mLocalToGlobal, mGlobalToLocal);
        p4 = _localizePoint({ x: left, y: bottom }, mLocalToGlobal, mGlobalToLocal);
        left = Math.min(p1.x, p2.x, p3.x, p4.x);
        top = Math.min(p1.y, p2.y, p3.y, p4.y);
        _temp1.x = _temp1.y = 0;
        if(fromTopLeft) {
          _getOffsetTransformOrigin(context, _temp1);
        }
        return { left: left + _temp1.x, top: top + _temp1.y, width: Math.max(p1.x, p2.x, p3.x, p4.x) - left, height: Math.max(p1.y, p2.y, p3.y, p4.y) - top };
      },
      // end matrix and point conversion methods



      _isArrayLike = function(e) {
        return(e && e.length && e[0] && ((e[0].nodeType && e[0].style && !e.nodeType) || (e[0].length && e[0][0]))) ? true : false; //could be an array of jQuery objects too, so accommodate that.
      },

      _flattenArray = function(a) {
        var result = [],
          l = a.length,
          i, e, j;
        for(i = 0; i < l; i++) {
          e = a[i];
          if(_isArrayLike(e)) {
            j = e.length;
            for(j = 0; j < e.length; j++) {
              result.push(e[j]);
            }
          } else if(e && e.length !== 0) {
            result.push(e);
          }
        }
        return result;
      },

      _isTouchDevice = (("ontouchstart" in _docElement) && ("orientation" in window)),
      _touchEventLookup = (function(types) { //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
        var standard = types.split(","),
          converted = ((_tempDiv.onpointerdown !== undefined) ? "pointerdown,pointermove,pointerup,pointercancel" : (_tempDiv.onmspointerdown !== undefined) ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
          obj = {},
          i = 8;
        while(--i > -1) {
          obj[standard[i]] = converted[i];
          obj[converted[i]] = standard[i];
        }
        return obj;
      }("touchstart,touchmove,touchend,touchcancel")),

      _addListener = function(element, type, func, capture) {
        if(element.addEventListener) {
          element.addEventListener(_touchEventLookup[type] || type, func, capture);
        } else if(element.attachEvent) {
          element.attachEvent("on" + type, func);
        }
      },

      _removeListener = function(element, type, func) {
        if(element.removeEventListener) {
          element.removeEventListener(_touchEventLookup[type] || type, func);
        } else if(element.detachEvent) {
          element.detachEvent("on" + type, func);
        }
      },

      _hasTouchID = function(list, ID) {
        var i = list.length;
        while(--i > -1) {
          if(list[i].identifier === ID) {
            return true;
          }
        }
        return false;
      },

      _onMultiTouchDocumentEnd = function(e) {
        _isMultiTouching = (e.touches && _dragCount < e.touches.length);
        _removeListener(e.target, "touchend", _onMultiTouchDocumentEnd);
      },

      _onMultiTouchDocument = function(e) {
        _isMultiTouching = (e.touches && _dragCount < e.touches.length);
        _addListener(e.target, "touchend", _onMultiTouchDocumentEnd);
      },

      _parseThrowProps = function(draggable, snap, max, min, factor, forceZeroVelocity) {
        var vars = {},
          a, i, l;
        if(snap) {
          if(factor !== 1 && snap instanceof Array) { //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
            vars.end = a = [];
            l = snap.length;
            for(i = 0; i < l; i++) {
              a[i] = snap[i] * factor;
            }
            max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.
            min -= 1.1;
          } else if(typeof(snap) === "function") {
            vars.end = function(value) {
              return snap.call(draggable, value) * factor; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
            };
          } else {
            vars.end = snap;
          }
        }
        if(max || max === 0) {
          vars.max = max;
        }
        if(min || min === 0) {
          vars.min = min;
        }
        if(forceZeroVelocity) {
          vars.velocity = 0;
        }
        return vars;
      },

      _isClickable = function(e) { //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
        var data;
        return(!e || !e.getAttribute || e.nodeName === "BODY") ? false : ((data = e.getAttribute("data-clickable")) === "true" || (data !== "false" && (e.onclick || _clickableTagExp.test(e.nodeName + "") || e.getAttribute("contentEditable") === "true"))) ? true : _isClickable(e.parentNode);
      },

      _setSelectable = function(elements, selectable) {
        var i = elements.length,
          e;
        while(--i > -1) {
          e = elements[i];
          e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;
          _setStyle(e, "userSelect", (selectable ? "text" : "none"));
        }
      },

      _addPaddingBR,
      _addPaddingLeft = (function() { //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
        var div = _doc.createElement("div"),
          child = _doc.createElement("div"),
          childStyle = child.style,
          parent = _doc.body || _tempDiv,
          val;
        childStyle.display = "inline-block";
        childStyle.position = "relative";
        div.style.cssText = child.innerHTML = "width:90px; height:40px; padding:10px; overflow:auto; visibility: hidden";
        div.appendChild(child);
        parent.appendChild(div);
        _addPaddingBR = (child.offsetHeight + 18 > div.scrollHeight); //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.
        childStyle.width = "100%";
        if(!_transformProp) {
          childStyle.paddingRight = "500px";
          val = div.scrollLeft = div.scrollWidth - div.clientWidth;
          childStyle.left = "-90px";
          val = (val !== div.scrollLeft);
        }
        parent.removeChild(div);
        return val;
      }()),




      //The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
      ScrollProxy = function(element, vars) {
        element = _unwrapElement(element);
        vars = vars || {};
        var content = _doc.createElement("div"),
          style = content.style,
          node = element.firstChild,
          offsetTop = 0,
          offsetLeft = 0,
          prevTop = element.scrollTop,
          prevLeft = element.scrollLeft,
          scrollWidth = element.scrollWidth,
          scrollHeight = element.scrollHeight,
          extraPadRight = 0,
          maxLeft = 0,
          maxTop = 0,
          elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;

        if(_supports3D && vars.force3D !== false) {
          transformStart = "translate3d(";
          transformEnd = "px,0px)";
        } else if(_transformProp) {
          transformStart = "translate(";
          transformEnd = "px)";
        }

        this.scrollTop = function(value, force) {
          if(!arguments.length) {
            return -this.top();
          }
          this.top(-value, force);
        };

        this.scrollLeft = function(value, force) {
          if(!arguments.length) {
            return -this.left();
          }
          this.left(-value, force);
        };

        this.left = function(value, force) {
          if(!arguments.length) {
            return -(element.scrollLeft + offsetLeft);
          }
          var dif = element.scrollLeft - prevLeft,
            oldOffset = offsetLeft;
          if((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
            prevLeft = element.scrollLeft;
            TweenLite.killTweensOf(this, true, { left: 1, scrollLeft: 1 });
            this.left(-prevLeft);
            if(vars.onKill) {
              vars.onKill();
            }
            return;
          }
          value = -value; //invert because scrolling works in the opposite direction
          if(value < 0) {
            offsetLeft = (value - 0.5) | 0;
            value = 0;
          } else if(value > maxLeft) {
            offsetLeft = (value - maxLeft) | 0;
            value = maxLeft;
          } else {
            offsetLeft = 0;
          }
          if(offsetLeft || oldOffset) {
            if(transformStart) {
              if(!this._suspendTransforms) {
                style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
              }
            } else {
              style.left = -offsetLeft + "px";
            }
            if(_addPaddingLeft && offsetLeft + extraPadRight >= 0) {
              style.paddingRight = offsetLeft + extraPadRight + "px";
            }
          }
          element.scrollLeft = value | 0;
          prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjsut the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
        };

        this.top = function(value, force) {
          if(!arguments.length) {
            return -(element.scrollTop + offsetTop);
          }
          var dif = element.scrollTop - prevTop,
            oldOffset = offsetTop;
          if((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
            prevTop = element.scrollTop;
            TweenLite.killTweensOf(this, true, { top: 1, scrollTop: 1 });
            this.top(-prevTop);
            if(vars.onKill) {
              vars.onKill();
            }
            return;
          }
          value = -value; //invert because scrolling works in the opposite direction
          if(value < 0) {
            offsetTop = (value - 0.5) | 0;
            value = 0;
          } else if(value > maxTop) {
            offsetTop = (value - maxTop) | 0;
            value = maxTop;
          } else {
            offsetTop = 0;
          }
          if(offsetTop || oldOffset) {
            if(transformStart) {
              if(!this._suspendTransforms) {
                style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
              }
            } else {
              style.top = -offsetTop + "px";
            }
          }
          element.scrollTop = value | 0;
          prevTop = element.scrollTop;
        };

        this.maxScrollTop = function() {
          return maxTop;
        };

        this.maxScrollLeft = function() {
          return maxLeft;
        };

        this.disable = function() {
          node = content.firstChild;
          while(node) {
            nextNode = node.nextSibling;
            element.appendChild(node);
            node = nextNode;
          }
          if(element === content.parentNode) { //in case disable() is called when it's already disabled.
            element.removeChild(content);
          }
        };

        this.enable = function() {
          node = element.firstChild;
          if(node === content) {
            return;
          }
          while(node) {
            nextNode = node.nextSibling;
            content.appendChild(node);
            node = nextNode;
          }
          element.appendChild(content);
          this.calibrate();
        };

        this.calibrate = function(force) {
          var widthMatches = (element.clientWidth === elementWidth),
            x, y;
          prevTop = element.scrollTop;
          prevLeft = element.scrollLeft;
          if(widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
            return; //no need to recalculate things if the width and height haven't changed.
          }
          if(offsetTop || offsetLeft) {
            x = this.left();
            y = this.top();
            this.left(-element.scrollLeft);
            this.top(-element.scrollTop);
          }
          //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)
          if(!widthMatches || force) {
            style.display = "block";
            style.width = "auto";
            style.paddingRight = "0px";
            extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
            //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.
            if(extraPadRight) {
              extraPadRight += _getStyle(element, "paddingLeft") + (_addPaddingBR ? _getStyle(element, "paddingRight") : 0);
            }
          }
          style.display = "inline-block";
          style.position = "relative";
          style.overflow = "visible";
          style.verticalAlign = "top";
          style.width = "100%";
          style.paddingRight = extraPadRight + "px";
          //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error
          if(_addPaddingBR) {
            style.paddingBottom = _getStyle(element, "paddingBottom", true);
          }
          if(_isOldIE) {
            style.zoom = "1";
          }
          elementWidth = element.clientWidth;
          elementHeight = element.clientHeight;
          scrollWidth = element.scrollWidth;
          scrollHeight = element.scrollHeight;
          maxLeft = element.scrollWidth - elementWidth;
          maxTop = element.scrollHeight - elementHeight;
          contentHeight = content.offsetHeight;
          style.display = "block";
          if(x || y) {
            this.left(x);
            this.top(y);
          }
        };

        this.content = content;
        this.element = element;
        this._suspendTransforms = false;
        this.enable();
      },





      Draggable = function(target, vars) {
        EventDispatcher.call(this, target);
        target = _unwrapElement(target); //in case the target is a selector object or selector text
        if(!ThrowPropsPlugin) {
          ThrowPropsPlugin = _globals.com.greensock.plugins.ThrowPropsPlugin;
        }
        this.vars = vars = _copy(vars || {});
        this.target = target;
        this.x = this.y = this.rotation = 0;
        this.dragResistance = parseFloat(vars.dragResistance) || 0;
        this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
        this.lockAxis = vars.lockAxis;
        this.autoScroll = vars.autoScroll || 0;
        this.lockedAxis = null;
        this.allowEventDefault = !!vars.allowEventDefault;
        var type = (vars.type || (_isOldIE ? "top,left" : "x,y")).toLowerCase(),
          xyMode = (type.indexOf("x") !== -1 || type.indexOf("y") !== -1),
          rotationMode = (type.indexOf("rotation") !== -1),
          xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
          yProp = xyMode ? "y" : "top",
          allowX = (type.indexOf("x") !== -1 || type.indexOf("left") !== -1 || type === "scroll"),
          allowY = (type.indexOf("y") !== -1 || type.indexOf("top") !== -1 || type === "scroll"),
          minimumMovement = vars.minimumMovement || 2,
          self = this,
          triggers = _slice(vars.trigger || vars.handle || target),
          killProps = {},
          dragEndTime = 0,
          checkAutoScrollBounds = false,
          isClickable = vars.clickableTest || _isClickable,
          clickTime = 0,
          enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, maxX, minX, maxY, minY, tempVars, cssVars, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, isClicking, touchEventTarget, matrix, interrupted, startScrollTop, startScrollLeft, applyObj, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch,
          //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
          render = function(suppressEvents) {
            if(self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
              var e = target,
                autoScrollFactor = self.autoScroll * 15, //multiplying by 15 just gives us a better "feel" speed-wise.
                parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;
              checkAutoScrollBounds = false;
              _windowProxy.scrollTop = ((window.pageYOffset != null) ? window.pageYOffset : (_docElement.scrollTop != null) ? _docElement.scrollTop : _doc.body.scrollTop);
              _windowProxy.scrollLeft = ((window.pageXOffset != null) ? window.pageXOffset : (_docElement.scrollLeft != null) ? _docElement.scrollLeft : _doc.body.scrollLeft);
              pointerX = self.pointerX - _windowProxy.scrollLeft;
              pointerY = self.pointerY - _windowProxy.scrollTop;
              while(e && !isRoot) { //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
                isRoot = _isRoot(e.parentNode);
                parent = isRoot ? _windowProxy : e.parentNode;
                rect = isRoot ? { bottom: Math.max(_docElement.clientHeight, window.innerHeight || 0), right: Math.max(_docElement.clientWidth, window.innerWidth || 0), left: 0, top: 0 } : parent.getBoundingClientRect();
                changeX = changeY = 0;
                if(allowY) {
                  gap = parent._gsMaxScrollY - parent.scrollTop;
                  if(gap < 0) {
                    changeY = gap;
                  } else if(pointerY > rect.bottom - 40 && gap) {
                    checkAutoScrollBounds = true;
                    changeY = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.bottom - pointerY)) / 40)) | 0);
                  } else if(pointerY < rect.top + 40 && parent.scrollTop) {
                    checkAutoScrollBounds = true;
                    changeY = -Math.min(parent.scrollTop, (autoScrollFactor * (1 - Math.max(0, (pointerY - rect.top)) / 40)) | 0);
                  }
                  if(changeY) {
                    parent.scrollTop += changeY;
                  }
                }
                if(allowX) {
                  gap = parent._gsMaxScrollX - parent.scrollLeft;
                  if(gap < 0) {
                    changeX = gap;
                  } else if(pointerX > rect.right - 40 && gap) {
                    checkAutoScrollBounds = true;
                    changeX = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.right - pointerX)) / 40)) | 0);
                  } else if(pointerX < rect.left + 40 && parent.scrollLeft) {
                    checkAutoScrollBounds = true;
                    changeX = -Math.min(parent.scrollLeft, (autoScrollFactor * (1 - Math.max(0, (pointerX - rect.left)) / 40)) | 0);
                  }
                  if(changeX) {
                    parent.scrollLeft += changeX;
                  }
                }

                if(isRoot && (changeX || changeY)) {
                  window.scrollTo(parent.scrollLeft, parent.scrollTop);
                  setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
                }
                e = parent;
              }
            }
            if(dirty) {
              var x = self.x,
                y = self.y,
                min = 0.000001;
              if(x < min && x > -min) { //browsers don't handle super small decimals well.
                x = 0;
              }
              if(y < min && y > -min) {
                y = 0;
              }
              if(rotationMode) {
                applyObj.data.rotation = self.rotation = x;
                applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
              } else {
                if(scrollProxy) {
                  if(allowY) {
                    scrollProxy.top(y);
                  }
                  if(allowX) {
                    scrollProxy.left(x);
                  }
                } else if(xyMode) {
                  if(allowY) {
                    applyObj.data.y = y;
                  }
                  if(allowX) {
                    applyObj.data.x = x;
                  }
                  applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
                } else {
                  if(allowY) {
                    target.style.top = y + "px";
                  }
                  if(allowX) {
                    target.style.left = x + "px";
                  }
                }
              }
              if(hasDragCallback && !suppressEvents && !isDispatching) {
                isDispatching = true; //in case onDrag has an update() call (avoid endless loop)
                _dispatchEvent(self, "drag", "onDrag");
                isDispatching = false;
              }
            }
            dirty = false;
          },

          //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the ThrowPropsPlugin tween in an onUpdate to ensure things are synced and snapped.
          syncXY = function(skipOnUpdate, skipSnap) {
            var x = self.x,
              y = self.y,
              snappedValue;
            if(!target._gsTransform && (xyMode || rotationMode)) { //just in case the _gsTransform got wiped, like if the user called clearProps on the transform or something (very rare), doing an x tween forces a re-parsing of the transforms and population of the _gsTransform.
              TweenLite.set(target, { x: "+=0", overwrite: false });
            }
            if(xyMode) {
              self.y = target._gsTransform.y;
              self.x = target._gsTransform.x;
            } else if(rotationMode) {
              self.x = self.rotation = target._gsTransform.rotation;
            } else if(scrollProxy) {
              self.y = scrollProxy.top();
              self.x = scrollProxy.left();
            } else {
              self.y = parseInt(target.style.top, 10) || 0;
              self.x = parseInt(target.style.left, 10) || 0;
            }
            if((snapX || snapY) && !skipSnap) {
              if(snapX) {
                snappedValue = snapX(self.x);
                if(snappedValue !== self.x) {
                  self.x = snappedValue;
                  if(rotationMode) {
                    self.rotation = snappedValue;
                  }
                  dirty = true;
                }
              }
              if(snapY) {
                snappedValue = snapY(self.y);
                if(snappedValue !== self.y) {
                  self.y = snappedValue;
                }
                dirty = true;
              }
            }
            if(dirty) {
              render(true);
            }
            if(!skipOnUpdate) {
              _dispatchEvent(self, "throwupdate", "onThrowUpdate");
            }
          },

          calculateBounds = function() {
            var bounds, targetBounds, snap, snapIsRaw;
            hasBounds = false;
            if(scrollProxy) {
              scrollProxy.calibrate();
              self.minX = minX = -scrollProxy.maxScrollLeft();
              self.minY = minY = -scrollProxy.maxScrollTop();
              self.maxX = maxX = self.maxY = maxY = 0;
              hasBounds = true;
            } else if(!!vars.bounds) {
              bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}
              if(rotationMode) {
                self.minX = minX = bounds.left;
                self.maxX = maxX = bounds.left + bounds.width;
                self.minY = minY = self.maxY = maxY = 0;
              } else if(vars.bounds.maxX !== undefined || vars.bounds.maxY !== undefined) {
                bounds = vars.bounds;
                self.minX = minX = bounds.minX;
                self.minY = minY = bounds.minY;
                self.maxX = maxX = bounds.maxX;
                self.maxY = maxY = bounds.maxY;
              } else {
                targetBounds = _getBounds(target, target.parentNode);
                self.minX = minX = _getStyle(target, xProp) + bounds.left - targetBounds.left;
                self.minY = minY = _getStyle(target, yProp) + bounds.top - targetBounds.top;
                self.maxX = maxX = minX + (bounds.width - targetBounds.width);
                self.maxY = maxY = minY + (bounds.height - targetBounds.height);
              }
              if(minX > maxX) {
                self.minX = maxX;
                self.maxX = maxX = minX;
                minX = self.minX;
              }
              if(minY > maxY) {
                self.minY = maxY;
                self.maxY = maxY = minY;
                minY = self.minY;
              }
              if(rotationMode) {
                self.minRotation = minX;
                self.maxRotation = maxX;
              }
              hasBounds = true;
            }
            if(vars.liveSnap) {
              snap = (vars.liveSnap === true) ? (vars.snap || {}) : vars.liveSnap;
              snapIsRaw = (snap instanceof Array || typeof(snap) === "function");
              if(rotationMode) {
                snapX = buildSnapFunc((snapIsRaw ? snap : snap.rotation), minX, maxX, 1);
                snapY = null;
              } else {
                if(allowX) {
                  snapX = buildSnapFunc((snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft), minX, maxX, scrollProxy ? -1 : 1);
                }
                if(allowY) {
                  snapY = buildSnapFunc((snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop), minY, maxY, scrollProxy ? -1 : 1);
                }
              }
            }

          },

          onThrowComplete = function() {
            self.isThrowing = false;
            _dispatchEvent(self, "throwcomplete", "onThrowComplete");
          },
          onThrowOverwrite = function() {
            self.isThrowing = false;
          },

          animate = function(throwProps, forceZeroVelocity) {
            var snap, snapIsRaw, tween, overshootTolerance;
            if(throwProps && ThrowPropsPlugin) {
              if(throwProps === true) {
                snap = vars.snap || {};
                snapIsRaw = (snap instanceof Array || typeof(snap) === "function");
                throwProps = { resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1) };
                if(rotationMode) {
                  throwProps.rotation = _parseThrowProps(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
                } else {
                  if(allowX) {
                    throwProps[xProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "x"));
                  }
                  if(allowY) {
                    throwProps[yProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "y"));
                  }
                }
              }
              self.isThrowing = true;
              overshootTolerance = (!isNaN(vars.overshootTolerance)) ? vars.overshootTolerance : (vars.edgeResistance === 1) ? 0 : (1 - self.edgeResistance) + 0.2;
              self.tween = tween = ThrowPropsPlugin.to(scrollProxy || target, { throwProps: throwProps, ease: (vars.ease || _globals.Power3.easeOut), onComplete: onThrowComplete, onOverwrite: onThrowOverwrite, onUpdate: (vars.fastMode ? _dispatchEvent : syncXY), onUpdateParams: (vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : _emptyArray) }, (isNaN(vars.maxDuration) ? 2 : vars.maxDuration), (!isNaN(vars.minDuration) ? vars.minDuration : (overshootTolerance === 0) ? 0 : 0.5), overshootTolerance);
              if(!vars.fastMode) {
                //to populate the end values, we just scrub the tween to the end, record the values, and then jump back to the beginning.
                if(scrollProxy) {
                  scrollProxy._suspendTransforms = true; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
                }
                tween.render(tween.duration(), true, true);
                syncXY(true, true);
                self.endX = self.x;
                self.endY = self.y;
                if(rotationMode) {
                  self.endRotation = self.x;
                }
                tween.play(0);
                syncXY(true, true);
                if(scrollProxy) {
                  scrollProxy._suspendTransforms = false;
                }
              }
            } else if(hasBounds) {
              self.applyBounds();
            }
          },

          updateMatrix = function(shiftStart) {
            var start = matrix || [1, 0, 0, 1, 0, 0],
              a, b, c, d, tx, ty, determinant, pointerX, pointerY;
            matrix = _getConcatenatedMatrix(target.parentNode, true);
            if(shiftStart && self.isPressed && start.join(",") !== matrix.join(",")) { //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.
              a = start[0];
              b = start[1];
              c = start[2];
              d = start[3];
              tx = start[4];
              ty = start[5];
              determinant = (a * d - b * c);
              pointerX = startPointerX * (d / determinant) + startPointerY * (-c / determinant) + ((c * ty - d * tx) / determinant);
              pointerY = startPointerX * (-b / determinant) + startPointerY * (a / determinant) + (-(a * ty - b * tx) / determinant);
              startPointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
              startPointerX = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
            }
            if(!matrix[1] && !matrix[2] && matrix[0] == 1 && matrix[3] == 1 && matrix[4] == 0 && matrix[5] == 0) { //if there are no transforms, we can optimize performance by not factoring in the matrix
              matrix = null;
            }

          },

          recordStartPositions = function() {
            var edgeTolerance = 1 - self.edgeResistance;
            updateMatrix(false);
            if(matrix) {
              startPointerX = self.pointerX * matrix[0] + self.pointerY * matrix[2] + matrix[4]; //translate to local coordinate system
              startPointerY = self.pointerX * matrix[1] + self.pointerY * matrix[3] + matrix[5];
            }
            if(dirty) {
              setPointerPosition(self.pointerX, self.pointerY);
              render(true);
            }
            if(scrollProxy) {
              calculateBounds();
              startElementY = scrollProxy.top();
              startElementX = scrollProxy.left();
            } else {
              //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
              if(isTweening()) {
                syncXY(true, true);
                calculateBounds();
              } else {
                self.applyBounds();
              }
              if(rotationMode) {
                rotationOrigin = _localToGlobal(target, { x: 0, y: 0 });
                syncXY(true, true);
                startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)
                startElementY = self.y = Math.atan2(rotationOrigin.y - self.pointerY, self.pointerX - rotationOrigin.x) * _RAD2DEG;
              } else {
                startScrollTop = target.parentNode ? target.parentNode.scrollTop || 0 : 0;
                startScrollLeft = target.parentNode ? target.parentNode.scrollLeft || 0 : 0;
                startElementY = _getStyle(target, yProp); //record the starting top and left values so that we can just add the mouse's movement to them later.
                startElementX = _getStyle(target, xProp);
              }
            }
            if(hasBounds && edgeTolerance) {
              if(startElementX > maxX) {
                startElementX = maxX + (startElementX - maxX) / edgeTolerance;
              } else if(startElementX < minX) {
                startElementX = minX - (minX - startElementX) / edgeTolerance;
              }
              if(!rotationMode) {
                if(startElementY > maxY) {
                  startElementY = maxY + (startElementY - maxY) / edgeTolerance;
                } else if(startElementY < minY) {
                  startElementY = minY - (minY - startElementY) / edgeTolerance;
                }
              }
            }
          },

          isTweening = function() {
            return(self.tween && self.tween.isActive());
          },

          removePlaceholder = function() {
            if(_placeholderDiv.parentNode && !isTweening() && !self.isDragging) { //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.
              _placeholderDiv.parentNode.removeChild(_placeholderDiv);
            }
          },

          buildSnapFunc = function(snap, min, max, factor) {
            if(typeof(snap) === "function") {
              return function(n) {
                var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)
                return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : (n < min) ? min + (n - min) * edgeTolerance : n)) * factor;
              };
            }
            if(snap instanceof Array) {
              return function(n) {
                var i = snap.length,
                  closest = 0,
                  absDif = _max,
                  val, dif;
                while(--i > -1) {
                  val = snap[i];
                  dif = val - n;
                  if(dif < 0) {
                    dif = -dif;
                  }
                  if(dif < absDif && val >= min && val <= max) {
                    closest = i;
                    absDif = dif;
                  }
                }
                return snap[closest];
              };
            }
            return isNaN(snap) ? function(n) { return n; } : function() { return snap * factor; };
          },

          //called when the mouse is pressed (or touch starts)
          onPress = function(e) {
            var i;
            if(!enabled || self.isPressed || !e || ((e.type === "mousedown" || e.type === "pointerdown") && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type])) { //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.
              return;
            }
            interrupted = isTweening();
            self.pointerEvent = e;
            if(_touchEventLookup[e.type]) { //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
              touchEventTarget = (e.type.indexOf("touch") !== -1) ? (e.currentTarget || e.target) : _doc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".
              _addListener(touchEventTarget, "touchend", onRelease);
              _addListener(touchEventTarget, "touchmove", onMove);
              _addListener(touchEventTarget, "touchcancel", onRelease);
              _addListener(_doc, "touchstart", _onMultiTouchDocument);
            } else {
              touchEventTarget = null;
              _addListener(_doc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.
            }
            touchDragAxis = null;
            _addListener(_doc, "mouseup", onRelease);
            if(e && e.target) {
              _addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"
            }
            isClicking = (isClickable.call(self, e.target) && !vars.dragClickables);
            if(isClicking) {
              _addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.
              _dispatchEvent(self, "press", "onPress");
              _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)
              return;
            }
            allowNativeTouchScrolling = (!touchEventTarget || allowX === allowY || scrollProxy || self.vars.allowNativeTouchScrolling === false) ? false : allowX ? "y" : "x";
            if(_isOldIE) {
              e = _populateIEEvent(e, true);
            } else if(!allowNativeTouchScrolling && !self.allowEventDefault) {
              e.preventDefault();
              if(e.preventManipulation) {
                e.preventManipulation(); //for some Microsoft browsers
              }
            }
            if(e.changedTouches) { //touch events store the data slightly differently
              e = touch = e.changedTouches[0];
              touchID = e.identifier;
            } else if(e.pointerId) {
              touchID = e.pointerId; //for some Microsoft browsers
            } else {
              touch = touchID = null;
            }
            _dragCount++;
            _addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)
            startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove
            startPointerX = self.pointerX = e.pageX;
            if(allowNativeTouchScrolling || self.autoScroll) {
              _recordMaxScrolls(target.parentNode);
            }
            if(target.parentNode && (scrollProxy || (self.autoScroll && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode)) && !target.getBBox) { //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
              _placeholderDiv.style.width = (target.parentNode.scrollWidth) + "px";
              target.parentNode.appendChild(_placeholderDiv);
            }
            recordStartPositions();
            if(self.tween) {
              self.tween.kill();
            }
            self.isThrowing = false;
            TweenLite.killTweensOf(scrollProxy || target, true, killProps); //in case the user tries to drag it before the last tween is done.
            if(scrollProxy) {
              TweenLite.killTweensOf(target, true, { scrollTo: 1 }); //just in case the original target's scroll position is being tweened somewhere else.
            }
            self.tween = self.lockedAxis = null;
            if(vars.zIndexBoost || (!rotationMode && !scrollProxy && vars.zIndexBoost !== false)) {
              target.style.zIndex = Draggable.zIndex++;
            }
            self.isPressed = true;
            hasDragCallback = !!(vars.onDrag || self._listeners.drag);
            if(!rotationMode) {
              i = triggers.length;
              while(--i > -1) {
                _setStyle(triggers[i], "cursor", vars.cursor || "move");
              }
            }
            _dispatchEvent(self, "press", "onPress");
          },

          //called every time the mouse/touch moves
          onMove = function(e) {
            var originalEvent = e,
              touches, pointerX, pointerY, i;
            if(!enabled || _isMultiTouching || !self.isPressed || !e) {
              return;
            }
            self.pointerEvent = e;
            touches = e.changedTouches;
            if(touches) { //touch events store the data slightly differently
              e = touches[0];
              if(e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
                i = touches.length;
                while(--i > -1 && (e = touches[i]).identifier !== touchID) {}
                if(i < 0) {
                  return;
                }
              }
            } else if(e.pointerId && touchID && e.pointerId !== touchID) { //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
              return;
            }
            if(_isOldIE) {
              e = _populateIEEvent(e, true);
            } else {
              if(touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) { //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).
                pointerX = e.pageX;
                pointerY = e.pageY;
                if(matrix) {
                  i = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
                  pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
                  pointerX = i;
                }
                touchDragAxis = (Math.abs(pointerX - startPointerX) > Math.abs(pointerY - startPointerY) && allowX) ? "x" : "y";
                if(self.vars.lockAxisOnTouchScroll !== false) {
                  self.lockedAxis = (touchDragAxis === "x") ? "y" : "x";
                  if(typeof(self.vars.onLockAxis) === "function") {
                    self.vars.onLockAxis.call(self, originalEvent);
                  }
                }
                if(_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
                  onRelease(originalEvent);
                  return;
                }
              }
              if(!self.allowEventDefault && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling !== touchDragAxis)) && originalEvent.cancelable !== false) {
                originalEvent.preventDefault();
                if(originalEvent.preventManipulation) { //for some Microsoft browsers
                  originalEvent.preventManipulation();
                }
              }
            }
            if(self.autoScroll) {
              checkAutoScrollBounds = true;
            }
            setPointerPosition(e.pageX, e.pageY);
          },

          setPointerPosition = function(pointerX, pointerY) {
            var dragTolerance = 1 - self.dragResistance,
              edgeTolerance = 1 - self.edgeResistance,
              xChange, yChange, x, y, dif, temp;

            self.pointerX = pointerX;
            self.pointerY = pointerY;

            if(rotationMode) {
              y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
              dif = self.y - y;
              self.y = y;
              if(dif > 180) {
                startElementY -= 360;
              } else if(dif < -180) {
                startElementY += 360;
              }
              x = startElementX + (startElementY - y) * dragTolerance;

            } else {
              if(matrix) {
                temp = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
                pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
                pointerX = temp;
              }
              yChange = (pointerY - startPointerY);
              xChange = (pointerX - startPointerX);
              if(yChange < minimumMovement && yChange > -minimumMovement) {
                yChange = 0;
              }
              if(xChange < minimumMovement && xChange > -minimumMovement) {
                xChange = 0;
              }
              if((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
                temp = self.lockedAxis;
                if(!temp) {
                  self.lockedAxis = temp = (allowX && Math.abs(xChange) > Math.abs(yChange)) ? "y" : allowY ? "x" : null;
                  if(temp && typeof(self.vars.onLockAxis) === "function") {
                    self.vars.onLockAxis.call(self, self.pointerEvent);
                  }
                }
                if(temp === "y") {
                  yChange = 0;
                } else if(temp === "x") {
                  xChange = 0;
                }
              }
              x = startElementX + xChange * dragTolerance;
              y = startElementY + yChange * dragTolerance;
            }

            if(snapX || snapY) {
              if(snapX) {
                x = snapX(x);
              }
              if(snapY) {
                y = snapY(y);
              }
            } else if(hasBounds) {
              if(x > maxX) {
                x = maxX + (x - maxX) * edgeTolerance;
              } else if(x < minX) {
                x = minX + (x - minX) * edgeTolerance;
              }
              if(!rotationMode) {
                if(y > maxY) {
                  y = maxY + (y - maxY) * edgeTolerance;
                } else if(y < minY) {
                  y = minY + (y - minY) * edgeTolerance;
                }
              }
            }
            if(!rotationMode) {
              x = Math.round(x); //helps work around an issue with some Win Touch devices
              y = Math.round(y);
            }
            if(self.x !== x || (self.y !== y && !rotationMode)) {
              if(rotationMode) {
                self.endRotation = self.x = self.endX = x;
              } else {
                if(allowY) {
                  self.y = self.endY = y;
                }
                if(allowX) {
                  self.x = self.endX = x;
                }
              }
              dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
              if(!self.isDragging && self.isPressed) {
                self.isDragging = true;
                _dispatchEvent(self, "dragstart", "onDragStart");
              }
            }
          },

          //called when the mouse/touch is released
          onRelease = function(e, force) {
            if(!enabled || !self.isPressed || (e && touchID != null && !force && ((e.pointerId && e.pointerId !== touchID) || (e.changedTouches && !_hasTouchID(e.changedTouches, touchID))))) { //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
              return;
            }
            self.isPressed = false;
            var originalEvent = e,
              wasDragging = self.isDragging,
              placeholderDelayedCall = TweenLite.delayedCall(0.001, removePlaceholder),
              touches, i, syntheticEvent, eventTarget, syntheticClick;
            if(touchEventTarget) {
              _removeListener(touchEventTarget, "touchend", onRelease);
              _removeListener(touchEventTarget, "touchmove", onMove);
              _removeListener(touchEventTarget, "touchcancel", onRelease);
              _removeListener(_doc, "touchstart", _onMultiTouchDocument);
            } else {
              _removeListener(_doc, "mousemove", onMove);
            }
            _removeListener(_doc, "mouseup", onRelease);
            if(e && e.target) {
              _removeListener(e.target, "mouseup", onRelease);
            }
            dirty = false;
            if(isClicking) {
              if(e) {
                _removeListener(e.target, "change", onRelease);
              }
              _setSelectable(triggers, false);
              _dispatchEvent(self, "release", "onRelease");
              _dispatchEvent(self, "click", "onClick");
              isClicking = false;
              return;
            }
            _removeFromRenderQueue(render);
            if(!rotationMode) {
              i = triggers.length;
              while(--i > -1) {
                _setStyle(triggers[i], "cursor", vars.cursor || "move");
              }
            }
            if(wasDragging) {
              dragEndTime = _lastDragTime = _getTime();
              self.isDragging = false;
            }
            _dragCount--;
            if(e) {
              if(_isOldIE) {
                e = _populateIEEvent(e, false);
              }
              touches = e.changedTouches;
              if(touches) { //touch events store the data slightly differently
                e = touches[0];
                if(e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
                  i = touches.length;
                  while(--i > -1 && (e = touches[i]).identifier !== touchID) {}
                  if(i < 0) {
                    return;
                  }
                }
              }
              self.pointerEvent = originalEvent;
              self.pointerX = e.pageX;
              self.pointerY = e.pageY;
            }
            if(originalEvent && !wasDragging) {
              if(interrupted && (vars.snap || vars.bounds)) { //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
                animate(vars.throwProps);
              }
              _dispatchEvent(self, "release", "onRelease");
              if(!_isAndroid || originalEvent.type !== "touchmove") { //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a "click".
                _dispatchEvent(self, "click", "onClick");
                eventTarget = originalEvent.target || originalEvent.srcElement || target; //old IE uses srcElement
                clickTime = _getTime();
                syntheticClick = function() { // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
                  if(clickTime !== clickDispatch && self.enabled() && !self.isPressed) {
                    if(eventTarget.click) { //some browsers (like mobile Safari) don't properly trigger the click event
                      eventTarget.click();
                    } else if(_doc.createEvent) {
                      syntheticEvent = _doc.createEvent("MouseEvents");
                      syntheticEvent.initMouseEvent("click", true, true, window, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
                      eventTarget.dispatchEvent(syntheticEvent);
                    }
                  }
                };
                if(!_isAndroid) { //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.
                  TweenLite.delayedCall(0.00001, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click.
                }
              }
            } else {
              animate(vars.throwProps); //will skip if throwProps isn't defined or ThrowPropsPlugin isn't loaded.
              if(!_isOldIE && !self.allowEventDefault && originalEvent && (vars.dragClickables || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling === touchDragAxis)) && originalEvent.cancelable !== false) {
                originalEvent.preventDefault();
                if(originalEvent.preventManipulation) {
                  originalEvent.preventManipulation(); //for some Microsoft browsers
                }
              }
              _dispatchEvent(self, "release", "onRelease");
            }
            if(isTweening()) {
              placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets
            }
            if(wasDragging) {
              _dispatchEvent(self, "dragend", "onDragEnd");
            }
            return true;
          },

          updateScroll = function(e) {
            if(e && self.isDragging) {
              var parent = e.target || e.srcElement || target.parentNode,
                deltaX = parent.scrollLeft - parent._gsScrollX,
                deltaY = parent.scrollTop - parent._gsScrollY;
              if(deltaX || deltaY) {
                if(matrix) {
                  startPointerX -= deltaX * matrix[0] + deltaY * matrix[2];
                  startPointerY -= deltaY * matrix[3] + deltaX * matrix[1];
                } else {
                  startPointerX -= deltaX;
                  startPointerY -= deltaY;
                }
                parent._gsScrollX += deltaX;
                parent._gsScrollY += deltaY;
                setPointerPosition(self.pointerX, self.pointerY);
              }
            }
          },

          onClick = function(e) { //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.
            var time = _getTime(),
              recentlyClicked = (time - clickTime < 40),
              recentlyDragged = (time - dragEndTime < 40),
              alreadyDispatched = (recentlyClicked && clickDispatch === clickTime),
              isModern = !!e.preventDefault,
              alreadyDispatchedTrusted = (recentlyClicked && trustedClickDispatch === clickTime),
              trusted = e.isTrusted || (e.isTrusted == null && recentlyClicked && alreadyDispatched); //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?
            if(isModern && (alreadyDispatched || (recentlyDragged && self.vars.suppressClickOnDrag !== false))) {
              e.stopImmediatePropagation();
            }
            if(recentlyClicked && (!alreadyDispatched || (trusted !== alreadyDispatchedTrusted))) { //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)
              if(trusted && alreadyDispatched) {
                trustedClickDispatch = clickTime;
              }
              clickDispatch = clickTime;
              return;
            }
            if(self.isPressed || recentlyDragged || recentlyClicked) {
              if(!isModern) {
                e.returnValue = false;
              } else if(!trusted || !e.detail || !recentlyClicked) {
                e.preventDefault();
                if(e.preventManipulation) {
                  e.preventManipulation(); //for some Microsoft browsers
                }
              }
            }
          };

        old = Draggable.get(this.target);
        if(old) {
          old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)
        }

        //give the user access to start/stop dragging...
        this.startDrag = function(e) {
          onPress(e);
          if(!self.isDragging) {
            self.isDragging = true;
            _dispatchEvent(self, "dragstart", "onDragStart");
          }
        };
        this.drag = onMove;
        this.endDrag = function(e) {
          onRelease(e, true);
        };
        this.timeSinceDrag = function() {
          return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
        };
        this.hitTest = function(target, threshold) {
          return Draggable.hitTest(self.target, target, threshold);
        };

        this.getDirection = function(from, diagonalThreshold) { //from can be "start" (default), "velocity", or an element
          var mode = (from === "velocity" && ThrowPropsPlugin) ? from : (typeof(from) === "object" && !rotationMode) ? "element" : "start",
            xChange, yChange, ratio, direction, r1, r2;
          if(mode === "element") {
            r1 = _parseRect(self.target);
            r2 = _parseRect(from);
          }
          xChange = (mode === "start") ? self.x - startElementX : (mode === "velocity") ? ThrowPropsPlugin.getVelocity(this.target, xProp) : (r1.left + r1.width / 2) - (r2.left + r2.width / 2);
          if(rotationMode) {
            return xChange < 0 ? "counter-clockwise" : "clockwise";
          } else {
            diagonalThreshold = diagonalThreshold || 2;
            yChange = (mode === "start") ? self.y - startElementY : (mode === "velocity") ? ThrowPropsPlugin.getVelocity(this.target, yProp) : (r1.top + r1.height / 2) - (r2.top + r2.height / 2);
            ratio = Math.abs(xChange / yChange);
            direction = (ratio < 1 / diagonalThreshold) ? "" : (xChange < 0) ? "left" : "right";
            if(ratio < diagonalThreshold) {
              if(direction !== "") {
                direction += "-";
              }
              direction += (yChange < 0) ? "up" : "down";
            }
          }
          return direction;
        };


        this.applyBounds = function(newBounds) {
          var x, y, forceZeroVelocity, e, parent, isRoot;
          if(newBounds && vars.bounds !== newBounds) {
            vars.bounds = newBounds;
            return self.update(true);
          }
          syncXY(true);
          calculateBounds();
          if(hasBounds) {
            x = self.x;
            y = self.y;
            if(x > maxX) {
              x = maxX;
            } else if(x < minX) {
              x = minX;
            }
            if(y > maxY) {
              y = maxY;
            } else if(y < minY) {
              y = minY;
            }
            if(self.x !== x || self.y !== y) {
              forceZeroVelocity = true;
              self.x = self.endX = x;
              if(rotationMode) {
                self.endRotation = x;
              } else {
                self.y = self.endY = y;
              }
              dirty = true;
              render(true);
              if(self.autoScroll && !self.isDragging) {
                _recordMaxScrolls(target.parentNode);
                e = target;
                _windowProxy.scrollTop = ((window.pageYOffset != null) ? window.pageYOffset : (_docElement.scrollTop != null) ? _docElement.scrollTop : _doc.body.scrollTop);
                _windowProxy.scrollLeft = ((window.pageXOffset != null) ? window.pageXOffset : (_docElement.scrollLeft != null) ? _docElement.scrollLeft : _doc.body.scrollLeft);
                while(e && !isRoot) { //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.
                  isRoot = _isRoot(e.parentNode);
                  parent = isRoot ? _windowProxy : e.parentNode;
                  if(allowY && parent.scrollTop > parent._gsMaxScrollY) {
                    parent.scrollTop = parent._gsMaxScrollY;
                  }
                  if(allowX && parent.scrollLeft > parent._gsMaxScrollX) {
                    parent.scrollLeft = parent._gsMaxScrollX;
                  }
                  e = parent;
                }
              }
            }
            if(self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
              animate(vars.throwProps, forceZeroVelocity);
            }
          }
          return self;
        };

        this.update = function(applyBounds, sticky, ignoreExternalChanges) {
          var x = self.x,
            y = self.y;
          updateMatrix(!sticky);
          if(applyBounds) {
            self.applyBounds();
          } else {
            if(dirty && ignoreExternalChanges) {
              render(true);
            }
            syncXY(true);
          }
          if(sticky) {
            setPointerPosition(self.pointerX, self.pointerY);
            if(dirty) {
              render(true);
            }
          }
          if(self.isPressed && !sticky && ((allowX && Math.abs(x - self.x) > 0.01) || (allowY && (Math.abs(y - self.y) > 0.01 && !rotationMode)))) {
            recordStartPositions();
          }
          if(self.autoScroll) {
            _recordMaxScrolls(target.parentNode);
            checkAutoScrollBounds = self.isDragging;
            render(true);
          }
          if(self.autoScroll) { //in case reparenting occurred.
            _removeScrollListener(target, updateScroll);
            _addScrollListener(target, updateScroll);
          }
          return self;
        };

        this.enable = function(type) {
          var id, i, trigger;
          if(type !== "soft") {
            i = triggers.length;
            while(--i > -1) {
              trigger = triggers[i];
              _addListener(trigger, "mousedown", onPress);
              _addListener(trigger, "touchstart", onPress);
              _addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.
              if(!rotationMode) {
                _setStyle(trigger, "cursor", vars.cursor || "move");
              }
              _setStyle(trigger, "touchCallout", "none");
              _setStyle(trigger, "touchAction", (allowX === allowY || scrollProxy) ? "none" : allowX ? "pan-y" : "pan-x");
            }
            _setSelectable(triggers, false);
          }
          _addScrollListener(target, updateScroll);
          enabled = true;
          if(ThrowPropsPlugin && type !== "soft") {
            ThrowPropsPlugin.track(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
          }
          if(scrollProxy) {
            scrollProxy.enable();
          }
          target._gsDragID = id = "d" + (_lookupCount++);
          _lookup[id] = this;
          if(scrollProxy) {
            scrollProxy.element._gsDragID = id;
          }
          TweenLite.set(target, { x: "+=0", overwrite: false }); //simply ensures that there's a _gsTransform on the element.
          applyObj = {
            t: target,
            data: _isOldIE ? cssVars : target._gsTransform,
            tween: {},
            setRatio: (_isOldIE ? function() { TweenLite.set(target, tempVars); } : CSSPlugin._internals.setTransformRatio || CSSPlugin._internals.set3DTransformRatio)
          };
          recordStartPositions();
          self.update(true);
          return self;
        };

        this.disable = function(type) {
          var dragging = self.isDragging,
            i, trigger;
          if(!rotationMode) {
            i = triggers.length;
            while(--i > -1) {
              _setStyle(triggers[i], "cursor", null);
            }
          }
          if(type !== "soft") {
            i = triggers.length;
            while(--i > -1) {
              trigger = triggers[i];
              _setStyle(trigger, "touchCallout", null);
              _setStyle(trigger, "touchAction", null);
              _removeListener(trigger, "mousedown", onPress);
              _removeListener(trigger, "touchstart", onPress);
              _removeListener(trigger, "click", onClick);
            }
            _setSelectable(triggers, true);
            if(touchEventTarget) {
              _removeListener(touchEventTarget, "touchcancel", onRelease);
              _removeListener(touchEventTarget, "touchend", onRelease);
              _removeListener(touchEventTarget, "touchmove", onMove);
            }
            _removeListener(_doc, "mouseup", onRelease);
            _removeListener(_doc, "mousemove", onMove);
          }
          _removeScrollListener(target, updateScroll);
          enabled = false;
          if(ThrowPropsPlugin && type !== "soft") {
            ThrowPropsPlugin.untrack(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
          }
          if(scrollProxy) {
            scrollProxy.disable();
          }
          _removeFromRenderQueue(render);
          self.isDragging = self.isPressed = isClicking = false;
          if(dragging) {
            _dispatchEvent(self, "dragend", "onDragEnd");
          }
          return self;
        };

        this.enabled = function(value, type) {
          return arguments.length ? (value ? self.enable(type) : self.disable(type)) : enabled;
        };

        this.kill = function() {
          self.isThrowing = false;
          TweenLite.killTweensOf(scrollProxy || target, true, killProps);
          self.disable();
          delete _lookup[target._gsDragID];
          return self;
        };

        if(type.indexOf("scroll") !== -1) {
          scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({
            onKill: function() { //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
              if(self.isPressed) {
                onRelease(null);
              }
            }
          }, vars));
          //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)
          target.style.overflowY = (allowY && !_isTouchDevice) ? "auto" : "hidden";
          target.style.overflowX = (allowX && !_isTouchDevice) ? "auto" : "hidden";
          target = scrollProxy.content;
        }

        if(vars.force3D !== false) {
          TweenLite.set(target, { force3D: true }); //improve performance by forcing a GPU layer when possible
        }
        if(rotationMode) {
          killProps.rotation = 1;
        } else {
          if(allowX) {
            killProps[xProp] = 1;
          }
          if(allowY) {
            killProps[yProp] = 1;
          }
        }
        if(rotationMode) {
          tempVars = _tempVarsRotation;
          cssVars = tempVars.css;
          tempVars.overwrite = false;
        } else if(xyMode) {
          tempVars = (allowX && allowY) ? _tempVarsXY : allowX ? _tempVarsX : _tempVarsY;
          cssVars = tempVars.css;
          tempVars.overwrite = false;
        }

        this.enable();
      },
      p = Draggable.prototype = new EventDispatcher();

    p.constructor = Draggable;
    p.pointerX = p.pointerY = 0;
    p.isDragging = p.isPressed = false;
    Draggable.version = "0.14.8";
    Draggable.zIndex = 1000;

    _addListener(_doc, "touchcancel", function() {
      //some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.
    });
    _addListener(_doc, "contextmenu", function(e) {
      var p;
      for(p in _lookup) {
        if(_lookup[p].isPressed) {
          _lookup[p].endDrag();
        }
      }
    });

    Draggable.create = function(targets, vars) {
      if(typeof(targets) === "string") {
        targets = TweenLite.selector(targets);
      }
      var a = (!targets || targets.length === 0) ? [] : _isArrayLike(targets) ? _flattenArray(targets) : [targets],
        i = a.length;
      while(--i > -1) {
        a[i] = new Draggable(a[i], vars);
      }
      return a;
    };

    Draggable.get = function(target) {
      return _lookup[(_unwrapElement(target) || {})._gsDragID];
    };

    Draggable.timeSinceDrag = function() {
      return(_getTime() - _lastDragTime) / 1000;
    };

    var _tempRect = {}, //reuse to reduce garbage collection tasks
      _oldIERect = function(e) { //IE8 doesn't support getBoundingClientRect(), so we use this as a backup.
        var top = 0,
          left = 0,
          width, height;
        e = _unwrapElement(e);
        width = e.offsetWidth;
        height = e.offsetHeight;
        while(e) {
          top += e.offsetTop;
          left += e.offsetLeft;
          e = e.offsetParent;
        }
        return { top: top, left: left, width: width, height: height };
      },
      _parseRect = function(e, undefined) { //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
        if(e === window) {
          _tempRect.left = _tempRect.top = 0;
          _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0;
          _tempRect.height = _tempRect.bottom = ((e.innerHeight || 0) - 20 < _docElement.clientHeight) ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0;
          return _tempRect;
        }
        var r = (e.pageX !== undefined) ? { left: e.pageX - _getDocScrollLeft(), top: e.pageY - _getDocScrollTop(), right: e.pageX - _getDocScrollLeft() + 1, bottom: e.pageY - _getDocScrollTop() + 1 } : (!e.nodeType && e.left !== undefined && e.top !== undefined) ? e : _isOldIE ? _oldIERect(e) : _unwrapElement(e).getBoundingClientRect();
        if(r.right === undefined && r.width !== undefined) {
          r.right = r.left + r.width;
          r.bottom = r.top + r.height;
        } else if(r.width === undefined) { //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.
          r = { width: r.right - r.left, height: r.bottom - r.top, right: r.right, left: r.left, bottom: r.bottom, top: r.top };
        }
        return r;
      };

    Draggable.hitTest = function(obj1, obj2, threshold) {
      if(obj1 === obj2) {
        return false;
      }
      var r1 = _parseRect(obj1),
        r2 = _parseRect(obj2),
        isOutside = (r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top),
        overlap, area, isRatio;
      if(isOutside || !threshold) {
        return !isOutside;
      }
      isRatio = ((threshold + "").indexOf("%") !== -1);
      threshold = parseFloat(threshold) || 0;
      overlap = { left: Math.max(r1.left, r2.left), top: Math.max(r1.top, r2.top) };
      overlap.width = Math.min(r1.right, r2.right) - overlap.left;
      overlap.height = Math.min(r1.bottom, r2.bottom) - overlap.top;
      if(overlap.width < 0 || overlap.height < 0) {
        return false;
      }
      if(isRatio) {
        threshold *= 0.01;
        area = overlap.width * overlap.height;
        return(area >= r1.width * r1.height * threshold || area >= r2.width * r2.height * threshold);
      }
      return(overlap.width > threshold && overlap.height > threshold);
    };

    _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;";

    return Draggable;

  }, true);


});
if(_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
  "use strict";
  var getGlobal = function() {
    return(_gsScope.GreenSockGlobals || _gsScope)[name];
  };
  if(typeof(define) === "function" && define.amd) { //AMD
    define(["TweenLite", "CSSPlugin"], getGlobal);
  } else if(typeof(module) !== "undefined" && module.exports) { //node
    require("../TweenLite.js");
    require("../plugins/CSSPlugin.js");
    module.exports = getGlobal();
  }
}("Draggable"));
/*!
 * VERSION: 1.19.0
 * DATE: 2016-07-14
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {

  "use strict";

  _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

    var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
        var b = [],
          l = a.length,
          i;
        for(i = 0; i !== l; b.push(a[i++]));
        return b;
      },
      _applyCycle = function(vars, targets, i) {
        var alt = vars.cycle,
          p, val;
        for(p in alt) {
          val = alt[p];
          vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
        }
        delete vars.cycle;
      },
      TweenMax = function(target, duration, vars) {
        TweenLite.call(this, target, duration, vars);
        this._cycle = 0;
        this._yoyo = (this.vars.yoyo === true);
        this._repeat = this.vars.repeat || 0;
        this._repeatDelay = this.vars.repeatDelay || 0;
        this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
        this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
      },
      _tinyNum = 0.0000000001,
      TweenLiteInternals = TweenLite._internals,
      _isSelector = TweenLiteInternals.isSelector,
      _isArray = TweenLiteInternals.isArray,
      p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
      _blankArray = [];

    TweenMax.version = "1.19.0";
    p.constructor = TweenMax;
    p.kill()._gc = false;
    TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
    TweenMax.getTweensOf = TweenLite.getTweensOf;
    TweenMax.lagSmoothing = TweenLite.lagSmoothing;
    TweenMax.ticker = TweenLite.ticker;
    TweenMax.render = TweenLite.render;

    p.invalidate = function() {
      this._yoyo = (this.vars.yoyo === true);
      this._repeat = this.vars.repeat || 0;
      this._repeatDelay = this.vars.repeatDelay || 0;
      this._uncache(true);
      return TweenLite.prototype.invalidate.call(this);
    };

    p.updateTo = function(vars, resetDuration) {
      var curRatio = this.ratio,
        immediate = this.vars.immediateRender || vars.immediateRender,
        p;
      if(resetDuration && this._startTime < this._timeline._time) {
        this._startTime = this._timeline._time;
        this._uncache(false);
        if(this._gc) {
          this._enabled(true, false);
        } else {
          this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
        }
      }
      for(p in vars) {
        this.vars[p] = vars[p];
      }
      if(this._initted || immediate) {
        if(resetDuration) {
          this._initted = false;
          if(immediate) {
            this.render(0, true, true);
          }
        } else {
          if(this._gc) {
            this._enabled(true, false);
          }
          if(this._notifyPluginsOfEnabled && this._firstPT) {
            TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
          }
          if(this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
            var prevTime = this._totalTime;
            this.render(0, true, false);
            this._initted = false;
            this.render(prevTime, true, false);
          } else {
            this._initted = false;
            this._init();
            if(this._time > 0 || immediate) {
              var inv = 1 / (1 - curRatio),
                pt = this._firstPT,
                endValue;
              while(pt) {
                endValue = pt.s + pt.c;
                pt.c *= inv;
                pt.s = endValue - pt.c;
                pt = pt._next;
              }
            }
          }
        }
      }
      return this;
    };

    p.render = function(time, suppressEvents, force) {
      if(!this._initted)
        if(this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
          this.invalidate();
        }
      var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
        prevTime = this._time,
        prevTotalTime = this._totalTime,
        prevCycle = this._cycle,
        duration = this._duration,
        prevRawPrevTime = this._rawPrevTime,
        isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime;
      if(time >= totalDur - 0.0000001) { //to work around occasional floating point math artifacts.
        this._totalTime = totalDur;
        this._cycle = this._repeat;
        if(this._yoyo && (this._cycle & 1) !== 0) {
          this._time = 0;
          this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
        } else {
          this._time = duration;
          this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
        }
        if(!this._reversed) {
          isComplete = true;
          callback = "onComplete";
          force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
        }
        if(duration === 0)
          if(this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
            if(this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
              time = 0;
            }
            if(prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause"))
              if(prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
                force = true;
                if(prevRawPrevTime > _tinyNum) {
                  callback = "onReverseComplete";
                }
              }
            this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
          }

      } else if(time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
        this._totalTime = this._time = this._cycle = 0;
        this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
        if(prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
          callback = "onReverseComplete";
          isComplete = this._reversed;
        }
        if(time < 0) {
          this._active = false;
          if(duration === 0)
            if(this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
              if(prevRawPrevTime >= 0) {
                force = true;
              }
              this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
            }
        }
        if(!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
          force = true;
        }
      } else {
        this._totalTime = this._time = time;
        if(this._repeat !== 0) {
          cycleDuration = duration + this._repeatDelay;
          this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
          if(this._cycle !== 0)
            if(this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
              this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
            }
          this._time = this._totalTime - (this._cycle * cycleDuration);
          if(this._yoyo)
            if((this._cycle & 1) !== 0) {
              this._time = duration - this._time;
            }
          if(this._time > duration) {
            this._time = duration;
          } else if(this._time < 0) {
            this._time = 0;
          }
        }

        if(this._easeType) {
          r = this._time / duration;
          type = this._easeType;
          pow = this._easePower;
          if(type === 1 || (type === 3 && r >= 0.5)) {
            r = 1 - r;
          }
          if(type === 3) {
            r *= 2;
          }
          if(pow === 1) {
            r *= r;
          } else if(pow === 2) {
            r *= r * r;
          } else if(pow === 3) {
            r *= r * r * r;
          } else if(pow === 4) {
            r *= r * r * r * r;
          }

          if(type === 1) {
            this.ratio = 1 - r;
          } else if(type === 2) {
            this.ratio = r;
          } else if(this._time / duration < 0.5) {
            this.ratio = r / 2;
          } else {
            this.ratio = 1 - (r / 2);
          }

        } else {
          this.ratio = this._ease.getRatio(this._time / duration);
        }

      }

      if(prevTime === this._time && !force && prevCycle === this._cycle) {
        if(prevTotalTime !== this._totalTime)
          if(this._onUpdate)
            if(!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
              this._callback("onUpdate");
            }
        return;
      } else if(!this._initted) {
        this._init();
        if(!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
          return;
        } else if(!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
          this._time = prevTime;
          this._totalTime = prevTotalTime;
          this._rawPrevTime = prevRawPrevTime;
          this._cycle = prevCycle;
          TweenLiteInternals.lazyTweens.push(this);
          this._lazy = [time, suppressEvents];
          return;
        }
        //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
        if(this._time && !isComplete) {
          this.ratio = this._ease.getRatio(this._time / duration);
        } else if(isComplete && this._ease._calcEnd) {
          this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
        }
      }
      if(this._lazy !== false) {
        this._lazy = false;
      }

      if(!this._active)
        if(!this._paused && this._time !== prevTime && time >= 0) {
          this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
        }
      if(prevTotalTime === 0) {
        if(this._initted === 2 && time > 0) {
          //this.invalidate();
          this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
        }
        if(this._startAt) {
          if(time >= 0) {
            this._startAt.render(time, suppressEvents, force);
          } else if(!callback) {
            callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
          }
        }
        if(this.vars.onStart)
          if(this._totalTime !== 0 || duration === 0)
            if(!suppressEvents) {
              this._callback("onStart");
            }
      }

      pt = this._firstPT;
      while(pt) {
        if(pt.f) {
          pt.t[pt.p](pt.c * this.ratio + pt.s);
        } else {
          pt.t[pt.p] = pt.c * this.ratio + pt.s;
        }
        pt = pt._next;
      }

      if(this._onUpdate) {
        if(time < 0)
          if(this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
            this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
          }
        if(!suppressEvents)
          if(this._totalTime !== prevTotalTime || callback) {
            this._callback("onUpdate");
          }
      }
      if(this._cycle !== prevCycle)
        if(!suppressEvents)
          if(!this._gc)
            if(this.vars.onRepeat) {
              this._callback("onRepeat");
            }
      if(callback)
        if(!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
          if(time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
            this._startAt.render(time, suppressEvents, force);
          }
          if(isComplete) {
            if(this._timeline.autoRemoveChildren) {
              this._enabled(false, false);
            }
            this._active = false;
          }
          if(!suppressEvents && this.vars[callback]) {
            this._callback(callback);
          }
          if(duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
            this._rawPrevTime = 0;
          }
        }
    };

    //---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------

    TweenMax.to = function(target, duration, vars) {
      return new TweenMax(target, duration, vars);
    };

    TweenMax.from = function(target, duration, vars) {
      vars.runBackwards = true;
      vars.immediateRender = (vars.immediateRender != false);
      return new TweenMax(target, duration, vars);
    };

    TweenMax.fromTo = function(target, duration, fromVars, toVars) {
      toVars.startAt = fromVars;
      toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
      return new TweenMax(target, duration, toVars);
    };

    TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      stagger = stagger || 0;
      var delay = 0,
        a = [],
        finalComplete = function() {
          if(vars.onComplete) {
            vars.onComplete.apply(vars.onCompleteScope || this, arguments);
          }
          onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
        },
        cycle = vars.cycle,
        fromCycle = (vars.startAt && vars.startAt.cycle),
        l, copy, i, p;
      if(!_isArray(targets)) {
        if(typeof(targets) === "string") {
          targets = TweenLite.selector(targets) || targets;
        }
        if(_isSelector(targets)) {
          targets = _slice(targets);
        }
      }
      targets = targets || [];
      if(stagger < 0) {
        targets = _slice(targets);
        targets.reverse();
        stagger *= -1;
      }
      l = targets.length - 1;
      for(i = 0; i <= l; i++) {
        copy = {};
        for(p in vars) {
          copy[p] = vars[p];
        }
        if(cycle) {
          _applyCycle(copy, targets, i);
          if(copy.duration != null) {
            duration = copy.duration;
            delete copy.duration;
          }
        }
        if(fromCycle) {
          fromCycle = copy.startAt = {};
          for(p in vars.startAt) {
            fromCycle[p] = vars.startAt[p];
          }
          _applyCycle(copy.startAt, targets, i);
        }
        copy.delay = delay + (copy.delay || 0);
        if(i === l && onCompleteAll) {
          copy.onComplete = finalComplete;
        }
        a[i] = new TweenMax(targets[i], duration, copy);
        delay += stagger;
      }
      return a;
    };

    TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      vars.runBackwards = true;
      vars.immediateRender = (vars.immediateRender != false);
      return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };

    TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      toVars.startAt = fromVars;
      toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
      return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };

    TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
      return new TweenMax(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, useFrames: useFrames, overwrite: 0 });
    };

    TweenMax.set = function(target, vars) {
      return new TweenMax(target, 0, vars);
    };

    TweenMax.isTweening = function(target) {
      return(TweenLite.getTweensOf(target, true).length > 0);
    };

    var _getChildrenOf = function(timeline, includeTimelines) {
        var a = [],
          cnt = 0,
          tween = timeline._first;
        while(tween) {
          if(tween instanceof TweenLite) {
            a[cnt++] = tween;
          } else {
            if(includeTimelines) {
              a[cnt++] = tween;
            }
            a = a.concat(_getChildrenOf(tween, includeTimelines));
            cnt = a.length;
          }
          tween = tween._next;
        }
        return a;
      },
      getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
        return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
      };

    TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
      if(tweens == null) {
        tweens = true;
      }
      if(delayedCalls == null) {
        delayedCalls = true;
      }
      var a = getAllTweens((timelines != false)),
        l = a.length,
        allTrue = (tweens && delayedCalls && timelines),
        isDC, tween, i;
      for(i = 0; i < l; i++) {
        tween = a[i];
        if(allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
          if(complete) {
            tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
          } else {
            tween._enabled(false, false);
          }
        }
      }
    };

    TweenMax.killChildTweensOf = function(parent, complete) {
      if(parent == null) {
        return;
      }
      var tl = TweenLiteInternals.tweenLookup,
        a, curParent, p, i, l;
      if(typeof(parent) === "string") {
        parent = TweenLite.selector(parent) || parent;
      }
      if(_isSelector(parent)) {
        parent = _slice(parent);
      }
      if(_isArray(parent)) {
        i = parent.length;
        while(--i > -1) {
          TweenMax.killChildTweensOf(parent[i], complete);
        }
        return;
      }
      a = [];
      for(p in tl) {
        curParent = tl[p].target.parentNode;
        while(curParent) {
          if(curParent === parent) {
            a = a.concat(tl[p].tweens);
          }
          curParent = curParent.parentNode;
        }
      }
      l = a.length;
      for(i = 0; i < l; i++) {
        if(complete) {
          a[i].totalTime(a[i].totalDuration());
        }
        a[i]._enabled(false, false);
      }
    };

    var _changePause = function(pause, tweens, delayedCalls, timelines) {
      tweens = (tweens !== false);
      delayedCalls = (delayedCalls !== false);
      timelines = (timelines !== false);
      var a = getAllTweens(timelines),
        allTrue = (tweens && delayedCalls && timelines),
        i = a.length,
        isDC, tween;
      while(--i > -1) {
        tween = a[i];
        if(allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
          tween.paused(pause);
        }
      }
    };

    TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
      _changePause(true, tweens, delayedCalls, timelines);
    };

    TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
      _changePause(false, tweens, delayedCalls, timelines);
    };

    TweenMax.globalTimeScale = function(value) {
      var tl = Animation._rootTimeline,
        t = TweenLite.ticker.time;
      if(!arguments.length) {
        return tl._timeScale;
      }
      value = value || _tinyNum; //can't allow zero because it'll throw the math off
      tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
      tl = Animation._rootFramesTimeline;
      t = TweenLite.ticker.frame;
      tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
      tl._timeScale = Animation._rootTimeline._timeScale = value;
      return value;
    };


    //---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------

    p.progress = function(value, suppressEvents) {
      return(!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
    };

    p.totalProgress = function(value, suppressEvents) {
      return(!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
    };

    p.time = function(value, suppressEvents) {
      if(!arguments.length) {
        return this._time;
      }
      if(this._dirty) {
        this.totalDuration();
      }
      if(value > this._duration) {
        value = this._duration;
      }
      if(this._yoyo && (this._cycle & 1) !== 0) {
        value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
      } else if(this._repeat !== 0) {
        value += this._cycle * (this._duration + this._repeatDelay);
      }
      return this.totalTime(value, suppressEvents);
    };

    p.duration = function(value) {
      if(!arguments.length) {
        return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
      }
      return Animation.prototype.duration.call(this, value);
    };

    p.totalDuration = function(value) {
      if(!arguments.length) {
        if(this._dirty) {
          //instead of Infinity, we use 999999999999 so that we can accommodate reverses
          this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
          this._dirty = false;
        }
        return this._totalDuration;
      }
      return(this._repeat === -1) ? this : this.duration((value - (this._repeat * this._repeatDelay)) / (this._repeat + 1));
    };

    p.repeat = function(value) {
      if(!arguments.length) {
        return this._repeat;
      }
      this._repeat = value;
      return this._uncache(true);
    };

    p.repeatDelay = function(value) {
      if(!arguments.length) {
        return this._repeatDelay;
      }
      this._repeatDelay = value;
      return this._uncache(true);
    };

    p.yoyo = function(value) {
      if(!arguments.length) {
        return this._yoyo;
      }
      this._yoyo = value;
      return this;
    };


    return TweenMax;

  }, true);








  /*
   * ----------------------------------------------------------------
   * TimelineLite
   * ----------------------------------------------------------------
   */
  _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

    var TimelineLite = function(vars) {
        SimpleTimeline.call(this, vars);
        this._labels = {};
        this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
        this.smoothChildTiming = (this.vars.smoothChildTiming === true);
        this._sortChildren = true;
        this._onUpdate = this.vars.onUpdate;
        var v = this.vars,
          val, p;
        for(p in v) {
          val = v[p];
          if(_isArray(val))
            if(val.join("").indexOf("{self}") !== -1) {
              v[p] = this._swapSelfInParams(val);
            }
        }
        if(_isArray(v.tweens)) {
          this.add(v.tweens, 0, v.align, v.stagger);
        }
      },
      _tinyNum = 0.0000000001,
      TweenLiteInternals = TweenLite._internals,
      _internals = TimelineLite._internals = {},
      _isSelector = TweenLiteInternals.isSelector,
      _isArray = TweenLiteInternals.isArray,
      _lazyTweens = TweenLiteInternals.lazyTweens,
      _lazyRender = TweenLiteInternals.lazyRender,
      _globals = _gsScope._gsDefine.globals,
      _copy = function(vars) {
        var copy = {},
          p;
        for(p in vars) {
          copy[p] = vars[p];
        }
        return copy;
      },
      _applyCycle = function(vars, targets, i) {
        var alt = vars.cycle,
          p, val;
        for(p in alt) {
          val = alt[p];
          vars[p] = (typeof(val) === "function") ? val.call(targets[i], i) : val[i % val.length];
        }
        delete vars.cycle;
      },
      _pauseCallback = _internals.pauseCallback = function() {},
      _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
        var b = [],
          l = a.length,
          i;
        for(i = 0; i !== l; b.push(a[i++]));
        return b;
      },
      p = TimelineLite.prototype = new SimpleTimeline();

    TimelineLite.version = "1.19.0";
    p.constructor = TimelineLite;
    p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

    /* might use later...
    //translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
    function localToGlobal(time, animation) {
    	while (animation) {
    		time = (time / animation._timeScale) + animation._startTime;
    		animation = animation.timeline;
    	}
    	return time;
    }

    //translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
    function globalToLocal(time, animation) {
    	var scale = 1;
    	time -= localToGlobal(0, animation);
    	while (animation) {
    		scale *= animation._timeScale;
    		animation = animation.timeline;
    	}
    	return time * scale;
    }
    */

    p.to = function(target, duration, vars, position) {
      var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
      return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
    };

    p.from = function(target, duration, vars, position) {
      return this.add(((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
    };

    p.fromTo = function(target, duration, fromVars, toVars, position) {
      var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
      return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
    };

    p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      var tl = new TimelineLite({ onComplete: onCompleteAll, onCompleteParams: onCompleteAllParams, callbackScope: onCompleteAllScope, smoothChildTiming: this.smoothChildTiming }),
        cycle = vars.cycle,
        copy, i;
      if(typeof(targets) === "string") {
        targets = TweenLite.selector(targets) || targets;
      }
      targets = targets || [];
      if(_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
        targets = _slice(targets);
      }
      stagger = stagger || 0;
      if(stagger < 0) {
        targets = _slice(targets);
        targets.reverse();
        stagger *= -1;
      }
      for(i = 0; i < targets.length; i++) {
        copy = _copy(vars);
        if(copy.startAt) {
          copy.startAt = _copy(copy.startAt);
          if(copy.startAt.cycle) {
            _applyCycle(copy.startAt, targets, i);
          }
        }
        if(cycle) {
          _applyCycle(copy, targets, i);
          if(copy.duration != null) {
            duration = copy.duration;
            delete copy.duration;
          }
        }
        tl.to(targets[i], duration, copy, i * stagger);
      }
      return this.add(tl, position);
    };

    p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      vars.immediateRender = (vars.immediateRender != false);
      vars.runBackwards = true;
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };

    p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      toVars.startAt = fromVars;
      toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };

    p.call = function(callback, params, scope, position) {
      return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
    };

    p.set = function(target, vars, position) {
      position = this._parseTimeOrLabel(position, 0, true);
      if(vars.immediateRender == null) {
        vars.immediateRender = (position === this._time && !this._paused);
      }
      return this.add(new TweenLite(target, 0, vars), position);
    };

    TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
      vars = vars || {};
      if(vars.smoothChildTiming == null) {
        vars.smoothChildTiming = true;
      }
      var tl = new TimelineLite(vars),
        root = tl._timeline,
        tween, next;
      if(ignoreDelayedCalls == null) {
        ignoreDelayedCalls = true;
      }
      root._remove(tl, true);
      tl._startTime = 0;
      tl._rawPrevTime = tl._time = tl._totalTime = root._time;
      tween = root._first;
      while(tween) {
        next = tween._next;
        if(!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
          tl.add(tween, tween._startTime - tween._delay);
        }
        tween = next;
      }
      root.add(tl, 0);
      return tl;
    };

    p.add = function(value, position, align, stagger) {
      var curTime, l, i, child, tl, beforeRawTime;
      if(typeof(position) !== "number") {
        position = this._parseTimeOrLabel(position, 0, true, value);
      }
      if(!(value instanceof Animation)) {
        if((value instanceof Array) || (value && value.push && _isArray(value))) {
          align = align || "normal";
          stagger = stagger || 0;
          curTime = position;
          l = value.length;
          for(i = 0; i < l; i++) {
            if(_isArray(child = value[i])) {
              child = new TimelineLite({ tweens: child });
            }
            this.add(child, curTime);
            if(typeof(child) !== "string" && typeof(child) !== "function") {
              if(align === "sequence") {
                curTime = child._startTime + (child.totalDuration() / child._timeScale);
              } else if(align === "start") {
                child._startTime -= child.delay();
              }
            }
            curTime += stagger;
          }
          return this._uncache(true);
        } else if(typeof(value) === "string") {
          return this.addLabel(value, position);
        } else if(typeof(value) === "function") {
          value = TweenLite.delayedCall(0, value);
        } else {
          throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
        }
      }

      SimpleTimeline.prototype.add.call(this, value, position);

      //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
      if(this._gc || this._time === this._duration)
        if(!this._paused)
          if(this._duration < this.duration()) {
            //in case any of the ancestors had completed but should now be enabled...
            tl = this;
            beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
            while(tl._timeline) {
              if(beforeRawTime && tl._timeline.smoothChildTiming) {
                tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
              } else if(tl._gc) {
                tl._enabled(true, false);
              }
              tl = tl._timeline;
            }
          }

      return this;
    };

    p.remove = function(value) {
      if(value instanceof Animation) {
        this._remove(value, false);
        var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
        value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
        return this;
      } else if(value instanceof Array || (value && value.push && _isArray(value))) {
        var i = value.length;
        while(--i > -1) {
          this.remove(value[i]);
        }
        return this;
      } else if(typeof(value) === "string") {
        return this.removeLabel(value);
      }
      return this.kill(null, value);
    };

    p._remove = function(tween, skipDisable) {
      SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
      var last = this._last;
      if(!last) {
        this._time = this._totalTime = this._duration = this._totalDuration = 0;
      } else if(this._time > last._startTime + last._totalDuration / last._timeScale) {
        this._time = this.duration();
        this._totalTime = this._totalDuration;
      }
      return this;
    };

    p.append = function(value, offsetOrLabel) {
      return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
    };

    p.insert = p.insertMultiple = function(value, position, align, stagger) {
      return this.add(value, position || 0, align, stagger);
    };

    p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
      return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
    };

    p.addLabel = function(label, position) {
      this._labels[label] = this._parseTimeOrLabel(position);
      return this;
    };

    p.addPause = function(position, callback, params, scope) {
      var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
      t.vars.onComplete = t.vars.onReverseComplete = callback;
      t.data = "isPause";
      this._hasPause = true;
      return this.add(t, position);
    };

    p.removeLabel = function(label) {
      delete this._labels[label];
      return this;
    };

    p.getLabelTime = function(label) {
      return(this._labels[label] != null) ? this._labels[label] : -1;
    };

    p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
      var i;
      //if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
      if(ignore instanceof Animation && ignore.timeline === this) {
        this.remove(ignore);
      } else if(ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
        i = ignore.length;
        while(--i > -1) {
          if(ignore[i] instanceof Animation && ignore[i].timeline === this) {
            this.remove(ignore[i]);
          }
        }
      }
      if(typeof(offsetOrLabel) === "string") {
        return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
      }
      offsetOrLabel = offsetOrLabel || 0;
      if(typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
        i = timeOrLabel.indexOf("=");
        if(i === -1) {
          if(this._labels[timeOrLabel] == null) {
            return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
          }
          return this._labels[timeOrLabel] + offsetOrLabel;
        }
        offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
        timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
      } else if(timeOrLabel == null) {
        timeOrLabel = this.duration();
      }
      return Number(timeOrLabel) + offsetOrLabel;
    };

    p.seek = function(position, suppressEvents) {
      return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
    };

    p.stop = function() {
      return this.paused(true);
    };

    p.gotoAndPlay = function(position, suppressEvents) {
      return this.play(position, suppressEvents);
    };

    p.gotoAndStop = function(position, suppressEvents) {
      return this.pause(position, suppressEvents);
    };

    p.render = function(time, suppressEvents, force) {
      if(this._gc) {
        this._enabled(true, false);
      }
      var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
        prevTime = this._time,
        prevStart = this._startTime,
        prevTimeScale = this._timeScale,
        prevPaused = this._paused,
        tween, isComplete, next, callback, internalForce, pauseTween, curTime;
      if(time >= totalDur - 0.0000001) { //to work around occasional floating point math artifacts.
        this._totalTime = this._time = totalDur;
        if(!this._reversed)
          if(!this._hasPausedChild()) {
            isComplete = true;
            callback = "onComplete";
            internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
            if(this._duration === 0)
              if((time <= 0 && time >= -0.0000001) || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum)
                if(this._rawPrevTime !== time && this._first) {
                  internalForce = true;
                  if(this._rawPrevTime > _tinyNum) {
                    callback = "onReverseComplete";
                  }
                }
          }
        this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

      } else if(time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
        this._totalTime = this._time = 0;
        if(prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
          callback = "onReverseComplete";
          isComplete = this._reversed;
        }
        if(time < 0) {
          this._active = false;
          if(this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
            internalForce = isComplete = true;
            callback = "onReverseComplete";
          } else if(this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
            internalForce = true;
          }
          this._rawPrevTime = time;
        } else {
          this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
          if(time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
            tween = this._first;
            while(tween && tween._startTime === 0) {
              if(!tween._duration) {
                isComplete = false;
              }
              tween = tween._next;
            }
          }
          time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
          if(!this._initted) {
            internalForce = true;
          }
        }

      } else {

        if(this._hasPause && !this._forcingPlayhead && !suppressEvents) {
          if(time >= prevTime) {
            tween = this._first;
            while(tween && tween._startTime <= time && !pauseTween) {
              if(!tween._duration)
                if(tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                  pauseTween = tween;
                }
              tween = tween._next;
            }
          } else {
            tween = this._last;
            while(tween && tween._startTime >= time && !pauseTween) {
              if(!tween._duration)
                if(tween.data === "isPause" && tween._rawPrevTime > 0) {
                  pauseTween = tween;
                }
              tween = tween._prev;
            }
          }
          if(pauseTween) {
            this._time = time = pauseTween._startTime;
            this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
          }
        }

        this._totalTime = this._time = this._rawPrevTime = time;
      }
      if((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
        return;
      } else if(!this._initted) {
        this._initted = true;
      }

      if(!this._active)
        if(!this._paused && this._time !== prevTime && time > 0) {
          this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
        }

      if(prevTime === 0)
        if(this.vars.onStart)
          if(this._time !== 0 || !this._duration)
            if(!suppressEvents) {
              this._callback("onStart");
            }

      curTime = this._time;
      if(curTime >= prevTime) {
        tween = this._first;
        while(tween) {
          next = tween._next; //record it here because the value could change after rendering...
          if(curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
            break;
          } else if(tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
            if(pauseTween === tween) {
              this.pause();
            }
            if(!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
            }
          }
          tween = next;
        }
      } else {
        tween = this._last;
        while(tween) {
          next = tween._prev; //record it here because the value could change after rendering...
          if(curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
            break;
          } else if(tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
            if(pauseTween === tween) {
              pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
              while(pauseTween && pauseTween.endTime() > this._time) {
                pauseTween.render((pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
                pauseTween = pauseTween._prev;
              }
              pauseTween = null;
              this.pause();
            }
            if(!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
            }
          }
          tween = next;
        }
      }

      if(this._onUpdate)
        if(!suppressEvents) {
          if(_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
            _lazyRender();
          }
          this._callback("onUpdate");
        }

      if(callback)
        if(!this._gc)
          if(prevStart === this._startTime || prevTimeScale !== this._timeScale)
            if(this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
              if(isComplete) {
                if(_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
                  _lazyRender();
                }
                if(this._timeline.autoRemoveChildren) {
                  this._enabled(false, false);
                }
                this._active = false;
              }
              if(!suppressEvents && this.vars[callback]) {
                this._callback(callback);
              }
            }
    };

    p._hasPausedChild = function() {
      var tween = this._first;
      while(tween) {
        if(tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
          return true;
        }
        tween = tween._next;
      }
      return false;
    };

    p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
      ignoreBeforeTime = ignoreBeforeTime || -9999999999;
      var a = [],
        tween = this._first,
        cnt = 0;
      while(tween) {
        if(tween._startTime < ignoreBeforeTime) {
          //do nothing
        } else if(tween instanceof TweenLite) {
          if(tweens !== false) {
            a[cnt++] = tween;
          }
        } else {
          if(timelines !== false) {
            a[cnt++] = tween;
          }
          if(nested !== false) {
            a = a.concat(tween.getChildren(true, tweens, timelines));
            cnt = a.length;
          }
        }
        tween = tween._next;
      }
      return a;
    };

    p.getTweensOf = function(target, nested) {
      var disabled = this._gc,
        a = [],
        cnt = 0,
        tweens, i;
      if(disabled) {
        this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
      }
      tweens = TweenLite.getTweensOf(target);
      i = tweens.length;
      while(--i > -1) {
        if(tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
          a[cnt++] = tweens[i];
        }
      }
      if(disabled) {
        this._enabled(false, true);
      }
      return a;
    };

    p.recent = function() {
      return this._recent;
    };

    p._contains = function(tween) {
      var tl = tween.timeline;
      while(tl) {
        if(tl === this) {
          return true;
        }
        tl = tl.timeline;
      }
      return false;
    };

    p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
      ignoreBeforeTime = ignoreBeforeTime || 0;
      var tween = this._first,
        labels = this._labels,
        p;
      while(tween) {
        if(tween._startTime >= ignoreBeforeTime) {
          tween._startTime += amount;
        }
        tween = tween._next;
      }
      if(adjustLabels) {
        for(p in labels) {
          if(labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return this._uncache(true);
    };

    p._kill = function(vars, target) {
      if(!vars && !target) {
        return this._enabled(false, false);
      }
      var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
        i = tweens.length,
        changed = false;
      while(--i > -1) {
        if(tweens[i]._kill(vars, target)) {
          changed = true;
        }
      }
      return changed;
    };

    p.clear = function(labels) {
      var tweens = this.getChildren(false, true, true),
        i = tweens.length;
      this._time = this._totalTime = 0;
      while(--i > -1) {
        tweens[i]._enabled(false, false);
      }
      if(labels !== false) {
        this._labels = {};
      }
      return this._uncache(true);
    };

    p.invalidate = function() {
      var tween = this._first;
      while(tween) {
        tween.invalidate();
        tween = tween._next;
      }
      return Animation.prototype.invalidate.call(this);;
    };

    p._enabled = function(enabled, ignoreTimeline) {
      if(enabled === this._gc) {
        var tween = this._first;
        while(tween) {
          tween._enabled(enabled, true);
          tween = tween._next;
        }
      }
      return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
    };

    p.totalTime = function(time, suppressEvents, uncapped) {
      this._forcingPlayhead = true;
      var val = Animation.prototype.totalTime.apply(this, arguments);
      this._forcingPlayhead = false;
      return val;
    };

    p.duration = function(value) {
      if(!arguments.length) {
        if(this._dirty) {
          this.totalDuration(); //just triggers recalculation
        }
        return this._duration;
      }
      if(this.duration() !== 0 && value !== 0) {
        this.timeScale(this._duration / value);
      }
      return this;
    };

    p.totalDuration = function(value) {
      if(!arguments.length) {
        if(this._dirty) {
          var max = 0,
            tween = this._last,
            prevStart = 999999999999,
            prev, end;
          while(tween) {
            prev = tween._prev; //record it here in case the tween changes position in the sequence...
            if(tween._dirty) {
              tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
            }
            if(tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
              this.add(tween, tween._startTime - tween._delay);
            } else {
              prevStart = tween._startTime;
            }
            if(tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
              max -= tween._startTime;
              if(this._timeline.smoothChildTiming) {
                this._startTime += tween._startTime / this._timeScale;
              }
              this.shiftChildren(-tween._startTime, false, -9999999999);
              prevStart = 0;
            }
            end = tween._startTime + (tween._totalDuration / tween._timeScale);
            if(end > max) {
              max = end;
            }
            tween = prev;
          }
          this._duration = this._totalDuration = max;
          this._dirty = false;
        }
        return this._totalDuration;
      }
      return(value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
    };

    p.paused = function(value) {
      if(!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
        var tween = this._first,
          time = this._time;
        while(tween) {
          if(tween._startTime === time && tween.data === "isPause") {
            tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
          }
          tween = tween._next;
        }
      }
      return Animation.prototype.paused.apply(this, arguments);
    };

    p.usesFrames = function() {
      var tl = this._timeline;
      while(tl._timeline) {
        tl = tl._timeline;
      }
      return(tl === Animation._rootFramesTimeline);
    };

    p.rawTime = function() {
      return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
    };

    return TimelineLite;

  }, true);













  /*
   * ----------------------------------------------------------------
   * TimelineMax
   * ----------------------------------------------------------------
   */
  _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(TimelineLite, TweenLite, Ease) {

    var TimelineMax = function(vars) {
        TimelineLite.call(this, vars);
        this._repeat = this.vars.repeat || 0;
        this._repeatDelay = this.vars.repeatDelay || 0;
        this._cycle = 0;
        this._yoyo = (this.vars.yoyo === true);
        this._dirty = true;
      },
      _tinyNum = 0.0000000001,
      TweenLiteInternals = TweenLite._internals,
      _lazyTweens = TweenLiteInternals.lazyTweens,
      _lazyRender = TweenLiteInternals.lazyRender,
      _globals = _gsScope._gsDefine.globals,
      _easeNone = new Ease(null, null, 1, 0),
      p = TimelineMax.prototype = new TimelineLite();

    p.constructor = TimelineMax;
    p.kill()._gc = false;
    TimelineMax.version = "1.19.0";

    p.invalidate = function() {
      this._yoyo = (this.vars.yoyo === true);
      this._repeat = this.vars.repeat || 0;
      this._repeatDelay = this.vars.repeatDelay || 0;
      this._uncache(true);
      return TimelineLite.prototype.invalidate.call(this);
    };

    p.addCallback = function(callback, position, params, scope) {
      return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
    };

    p.removeCallback = function(callback, position) {
      if(callback) {
        if(position == null) {
          this._kill(null, callback);
        } else {
          var a = this.getTweensOf(callback, false),
            i = a.length,
            time = this._parseTimeOrLabel(position);
          while(--i > -1) {
            if(a[i]._startTime === time) {
              a[i]._enabled(false, false);
            }
          }
        }
      }
      return this;
    };

    p.removePause = function(position) {
      return this.removeCallback(TimelineLite._internals.pauseCallback, position);
    };

    p.tweenTo = function(position, vars) {
      vars = vars || {};
      var copy = { ease: _easeNone, useFrames: this.usesFrames(), immediateRender: false },
        Engine = (vars.repeat && _globals.TweenMax) || TweenLite,
        duration, p, t;
      for(p in vars) {
        copy[p] = vars[p];
      }
      copy.time = this._parseTimeOrLabel(position);
      duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
      t = new Engine(this, duration, copy);
      copy.onStart = function() {
        t.target.paused(true);
        if(t.vars.time !== t.target.time() && duration === t.duration()) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
          t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale);
        }
        if(vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
          t._callback("onStart");
        }
      };
      return t;
    };

    p.tweenFromTo = function(fromPosition, toPosition, vars) {
      vars = vars || {};
      fromPosition = this._parseTimeOrLabel(fromPosition);
      vars.startAt = { onComplete: this.seek, onCompleteParams: [fromPosition], callbackScope: this };
      vars.immediateRender = (vars.immediateRender !== false);
      var t = this.tweenTo(toPosition, vars);
      return t.duration((Math.abs(t.vars.time - fromPosition) / this._timeScale) || 0.001);
    };

    p.render = function(time, suppressEvents, force) {
      if(this._gc) {
        this._enabled(true, false);
      }
      var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
        dur = this._duration,
        prevTime = this._time,
        prevTotalTime = this._totalTime,
        prevStart = this._startTime,
        prevTimeScale = this._timeScale,
        prevRawPrevTime = this._rawPrevTime,
        prevPaused = this._paused,
        prevCycle = this._cycle,
        tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
      if(time >= totalDur - 0.0000001) { //to work around occasional floating point math artifacts.
        if(!this._locked) {
          this._totalTime = totalDur;
          this._cycle = this._repeat;
        }
        if(!this._reversed)
          if(!this._hasPausedChild()) {
            isComplete = true;
            callback = "onComplete";
            internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
            if(this._duration === 0)
              if((time <= 0 && time >= -0.0000001) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)
                if(prevRawPrevTime !== time && this._first) {
                  internalForce = true;
                  if(prevRawPrevTime > _tinyNum) {
                    callback = "onReverseComplete";
                  }
                }
          }
        this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        if(this._yoyo && (this._cycle & 1) !== 0) {
          this._time = time = 0;
        } else {
          this._time = dur;
          time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
        }

      } else if(time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
        if(!this._locked) {
          this._totalTime = this._cycle = 0;
        }
        this._time = 0;
        if(prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
          callback = "onReverseComplete";
          isComplete = this._reversed;
        }
        if(time < 0) {
          this._active = false;
          if(this._timeline.autoRemoveChildren && this._reversed) {
            internalForce = isComplete = true;
            callback = "onReverseComplete";
          } else if(prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
            internalForce = true;
          }
          this._rawPrevTime = time;
        } else {
          this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
          if(time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
            tween = this._first;
            while(tween && tween._startTime === 0) {
              if(!tween._duration) {
                isComplete = false;
              }
              tween = tween._next;
            }
          }
          time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
          if(!this._initted) {
            internalForce = true;
          }
        }

      } else {
        if(dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
          internalForce = true;
        }
        this._time = this._rawPrevTime = time;
        if(!this._locked) {
          this._totalTime = time;
          if(this._repeat !== 0) {
            cycleDuration = dur + this._repeatDelay;
            this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
            if(this._cycle !== 0)
              if(this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
                this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
              }
            this._time = this._totalTime - (this._cycle * cycleDuration);
            if(this._yoyo)
              if((this._cycle & 1) !== 0) {
                this._time = dur - this._time;
              }
            if(this._time > dur) {
              this._time = dur;
              time = dur + 0.0001; //to avoid occasional floating point rounding error
            } else if(this._time < 0) {
              this._time = time = 0;
            } else {
              time = this._time;
            }
          }
        }

        if(this._hasPause && !this._forcingPlayhead && !suppressEvents) {
          time = this._time;
          if(time >= prevTime) {
            tween = this._first;
            while(tween && tween._startTime <= time && !pauseTween) {
              if(!tween._duration)
                if(tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                  pauseTween = tween;
                }
              tween = tween._next;
            }
          } else {
            tween = this._last;
            while(tween && tween._startTime >= time && !pauseTween) {
              if(!tween._duration)
                if(tween.data === "isPause" && tween._rawPrevTime > 0) {
                  pauseTween = tween;
                }
              tween = tween._prev;
            }
          }
          if(pauseTween) {
            this._time = time = pauseTween._startTime;
            this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
          }
        }

      }

      if(this._cycle !== prevCycle)
        if(!this._locked) {
          /*
          make sure children at the end/beginning of the timeline are rendered properly. If, for example,
          a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
          would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
          could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
          we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
          ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
          */
          var backwards = (this._yoyo && (prevCycle & 1) !== 0),
            wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
            recTotalTime = this._totalTime,
            recCycle = this._cycle,
            recRawPrevTime = this._rawPrevTime,
            recTime = this._time;

          this._totalTime = prevCycle * dur;
          if(this._cycle < prevCycle) {
            backwards = !backwards;
          } else {
            this._totalTime += dur;
          }
          this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

          this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
          this._cycle = prevCycle;
          this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
          prevTime = (backwards) ? 0 : dur;
          this.render(prevTime, suppressEvents, (dur === 0));
          if(!suppressEvents)
            if(!this._gc) {
              if(this.vars.onRepeat) {
                this._callback("onRepeat");
              }
            }
          if(prevTime !== this._time) { //in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
            return;
          }
          if(wrap) {
            prevTime = (backwards) ? dur + 0.0001 : -0.0001;
            this.render(prevTime, true, false);
          }
          this._locked = false;
          if(this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
            return;
          }
          this._time = recTime;
          this._totalTime = recTotalTime;
          this._cycle = recCycle;
          this._rawPrevTime = recRawPrevTime;
        }

      if((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
        if(prevTotalTime !== this._totalTime)
          if(this._onUpdate)
            if(!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
              this._callback("onUpdate");
            }
        return;
      } else if(!this._initted) {
        this._initted = true;
      }

      if(!this._active)
        if(!this._paused && this._totalTime !== prevTotalTime && time > 0) {
          this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
        }

      if(prevTotalTime === 0)
        if(this.vars.onStart)
          if(this._totalTime !== 0 || !this._totalDuration)
            if(!suppressEvents) {
              this._callback("onStart");
            }

      curTime = this._time;
      if(curTime >= prevTime) {
        tween = this._first;
        while(tween) {
          next = tween._next; //record it here because the value could change after rendering...
          if(curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
            break;
          } else if(tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
            if(pauseTween === tween) {
              this.pause();
            }
            if(!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
            }
          }
          tween = next;
        }
      } else {
        tween = this._last;
        while(tween) {
          next = tween._prev; //record it here because the value could change after rendering...
          if(curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
            break;
          } else if(tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
            if(pauseTween === tween) {
              pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
              while(pauseTween && pauseTween.endTime() > this._time) {
                pauseTween.render((pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
                pauseTween = pauseTween._prev;
              }
              pauseTween = null;
              this.pause();
            }
            if(!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
            }
          }
          tween = next;
        }
      }

      if(this._onUpdate)
        if(!suppressEvents) {
          if(_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
            _lazyRender();
          }
          this._callback("onUpdate");
        }
      if(callback)
        if(!this._locked)
          if(!this._gc)
            if(prevStart === this._startTime || prevTimeScale !== this._timeScale)
              if(this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
                if(isComplete) {
                  if(_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
                    _lazyRender();
                  }
                  if(this._timeline.autoRemoveChildren) {
                    this._enabled(false, false);
                  }
                  this._active = false;
                }
                if(!suppressEvents && this.vars[callback]) {
                  this._callback(callback);
                }
              }
    };

    p.getActive = function(nested, tweens, timelines) {
      if(nested == null) {
        nested = true;
      }
      if(tweens == null) {
        tweens = true;
      }
      if(timelines == null) {
        timelines = false;
      }
      var a = [],
        all = this.getChildren(nested, tweens, timelines),
        cnt = 0,
        l = all.length,
        i, tween;
      for(i = 0; i < l; i++) {
        tween = all[i];
        if(tween.isActive()) {
          a[cnt++] = tween;
        }
      }
      return a;
    };


    p.getLabelAfter = function(time) {
      if(!time)
        if(time !== 0) { //faster than isNan()
          time = this._time;
        }
      var labels = this.getLabelsArray(),
        l = labels.length,
        i;
      for(i = 0; i < l; i++) {
        if(labels[i].time > time) {
          return labels[i].name;
        }
      }
      return null;
    };

    p.getLabelBefore = function(time) {
      if(time == null) {
        time = this._time;
      }
      var labels = this.getLabelsArray(),
        i = labels.length;
      while(--i > -1) {
        if(labels[i].time < time) {
          return labels[i].name;
        }
      }
      return null;
    };

    p.getLabelsArray = function() {
      var a = [],
        cnt = 0,
        p;
      for(p in this._labels) {
        a[cnt++] = { time: this._labels[p], name: p };
      }
      a.sort(function(a, b) {
        return a.time - b.time;
      });
      return a;
    };


    //---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

    p.progress = function(value, suppressEvents) {
      return(!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
    };

    p.totalProgress = function(value, suppressEvents) {
      return(!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
    };

    p.totalDuration = function(value) {
      if(!arguments.length) {
        if(this._dirty) {
          TimelineLite.prototype.totalDuration.call(this); //just forces refresh
          //Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
          this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
        }
        return this._totalDuration;
      }
      return(this._repeat === -1 || !value) ? this : this.timeScale(this.totalDuration() / value);
    };

    p.time = function(value, suppressEvents) {
      if(!arguments.length) {
        return this._time;
      }
      if(this._dirty) {
        this.totalDuration();
      }
      if(value > this._duration) {
        value = this._duration;
      }
      if(this._yoyo && (this._cycle & 1) !== 0) {
        value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
      } else if(this._repeat !== 0) {
        value += this._cycle * (this._duration + this._repeatDelay);
      }
      return this.totalTime(value, suppressEvents);
    };

    p.repeat = function(value) {
      if(!arguments.length) {
        return this._repeat;
      }
      this._repeat = value;
      return this._uncache(true);
    };

    p.repeatDelay = function(value) {
      if(!arguments.length) {
        return this._repeatDelay;
      }
      this._repeatDelay = value;
      return this._uncache(true);
    };

    p.yoyo = function(value) {
      if(!arguments.length) {
        return this._yoyo;
      }
      this._yoyo = value;
      return this;
    };

    p.currentLabel = function(value) {
      if(!arguments.length) {
        return this.getLabelBefore(this._time + 0.00000001);
      }
      return this.seek(value, true);
    };

    return TimelineMax;

  }, true);












  /*
   * ----------------------------------------------------------------
   * BezierPlugin
   * ----------------------------------------------------------------
   */
  (function() {

    var _RAD2DEG = 180 / Math.PI,
      _r1 = [],
      _r2 = [],
      _r3 = [],
      _corProps = {},
      _globals = _gsScope._gsDefine.globals,
      Segment = function(a, b, c, d) {
        if(c === d) { //if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
          c = d - (d - b) / 1000000;
        }
        if(a === b) { //if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
          b = a + (c - a) / 1000000;
        }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.da = d - a;
        this.ca = c - a;
        this.ba = b - a;
      },
      _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
      cubicToQuadratic = function(a, b, c, d) {
        var q1 = { a: a },
          q2 = {},
          q3 = {},
          q4 = { c: d },
          mab = (a + b) / 2,
          mbc = (b + c) / 2,
          mcd = (c + d) / 2,
          mabc = (mab + mbc) / 2,
          mbcd = (mbc + mcd) / 2,
          m8 = (mbcd - mabc) / 8;
        q1.b = mab + (a - mab) / 4;
        q2.b = mabc + m8;
        q1.c = q2.a = (q1.b + q2.b) / 2;
        q2.c = q3.a = (mabc + mbcd) / 2;
        q3.b = mbcd - m8;
        q4.b = mcd + (d - mcd) / 4;
        q3.c = q4.a = (q3.b + q4.b) / 2;
        return [q1, q2, q3, q4];
      },
      _calculateControlPoints = function(a, curviness, quad, basic, correlate) {
        var l = a.length - 1,
          ii = 0,
          cp1 = a[0].a,
          i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
        for(i = 0; i < l; i++) {
          seg = a[ii];
          p1 = seg.a;
          p2 = seg.d;
          p3 = a[ii + 1].d;

          if(correlate) {
            r1 = _r1[i];
            r2 = _r2[i];
            tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
            m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
            m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
            mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
          } else {
            m1 = p2 - (p2 - p1) * curviness * 0.5;
            m2 = p2 + (p3 - p2) * curviness * 0.5;
            mm = p2 - (m1 + m2) / 2;
          }
          m1 += mm;
          m2 += mm;

          seg.c = cp2 = m1;
          if(i !== 0) {
            seg.b = cp1;
          } else {
            seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
          }

          seg.da = p2 - p1;
          seg.ca = cp2 - p1;
          seg.ba = cp1 - p1;

          if(quad) {
            qb = cubicToQuadratic(p1, cp1, cp2, p2);
            a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
            ii += 4;
          } else {
            ii++;
          }

          cp1 = m2;
        }
        seg = a[ii];
        seg.b = cp1;
        seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
        seg.da = seg.d - seg.a;
        seg.ca = seg.c - seg.a;
        seg.ba = cp1 - seg.a;
        if(quad) {
          qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
          a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
        }
      },
      _parseAnchors = function(values, p, correlate, prepend) {
        var a = [],
          l, i, p1, p2, p3, tmp;
        if(prepend) {
          values = [prepend].concat(values);
          i = values.length;
          while(--i > -1) {
            if(typeof((tmp = values[i][p])) === "string")
              if(tmp.charAt(1) === "=") {
                values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
              }
          }
        }
        l = values.length - 2;
        if(l < 0) {
          a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
          return a;
        }
        for(i = 0; i < l; i++) {
          p1 = values[i][p];
          p2 = values[i + 1][p];
          a[i] = new Segment(p1, 0, 0, p2);
          if(correlate) {
            p3 = values[i + 2][p];
            _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
            _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
          }
        }
        a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
        return a;
      },
      bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
        var obj = {},
          props = [],
          first = prepend || values[0],
          i, p, a, j, r, l, seamless, last;
        correlate = (typeof(correlate) === "string") ? "," + correlate + "," : _correlate;
        if(curviness == null) {
          curviness = 1;
        }
        for(p in values[0]) {
          props.push(p);
        }
        //check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
        if(values.length > 1) {
          last = values[values.length - 1];
          seamless = true;
          i = props.length;
          while(--i > -1) {
            p = props[i];
            if(Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors.
              seamless = false;
              break;
            }
          }
          if(seamless) {
            values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
            if(prepend) {
              values.unshift(prepend);
            }
            values.push(values[1]);
            prepend = values[values.length - 3];
          }
        }
        _r1.length = _r2.length = _r3.length = 0;
        i = props.length;
        while(--i > -1) {
          p = props[i];
          _corProps[p] = (correlate.indexOf("," + p + ",") !== -1);
          obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
        }
        i = _r1.length;
        while(--i > -1) {
          _r1[i] = Math.sqrt(_r1[i]);
          _r2[i] = Math.sqrt(_r2[i]);
        }
        if(!basic) {
          i = props.length;
          while(--i > -1) {
            if(_corProps[p]) {
              a = obj[props[i]];
              l = a.length - 1;
              for(j = 0; j < l; j++) {
                r = (a[j + 1].da / _r2[j] + a[j].da / _r1[j]) || 0;
                _r3[j] = (_r3[j] || 0) + r * r;
              }
            }
          }
          i = _r3.length;
          while(--i > -1) {
            _r3[i] = Math.sqrt(_r3[i]);
          }
        }
        i = props.length;
        j = quadratic ? 4 : 1;
        while(--i > -1) {
          p = props[i];
          a = obj[p];
          _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
          if(seamless) {
            a.splice(0, j);
            a.splice(a.length - j, j);
          }
        }
        return obj;
      },
      _parseBezierData = function(values, type, prepend) {
        type = type || "soft";
        var obj = {},
          inc = (type === "cubic") ? 3 : 2,
          soft = (type === "soft"),
          props = [],
          a, b, c, d, cur, i, j, l, p, cnt, tmp;
        if(soft && prepend) {
          values = [prepend].concat(values);
        }
        if(values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
        for(p in values[0]) {
          props.push(p);
        }
        i = props.length;
        while(--i > -1) {
          p = props[i];
          obj[p] = cur = [];
          cnt = 0;
          l = values.length;
          for(j = 0; j < l; j++) {
            a = (prepend == null) ? values[j][p] : (typeof((tmp = values[j][p])) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
            if(soft)
              if(j > 1)
                if(j < l - 1) {
                  cur[cnt++] = (a + cur[cnt - 2]) / 2;
                }
            cur[cnt++] = a;
          }
          l = cnt - inc + 1;
          cnt = 0;
          for(j = 0; j < l; j += inc) {
            a = cur[j];
            b = cur[j + 1];
            c = cur[j + 2];
            d = (inc === 2) ? 0 : cur[j + 3];
            cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
          }
          cur.length = cnt;
        }
        return obj;
      },
      _addCubicLengths = function(a, steps, resolution) {
        var inc = 1 / resolution,
          j = a.length,
          d, d1, s, da, ca, ba, p, i, inv, bez, index;
        while(--j > -1) {
          bez = a[j];
          s = bez.a;
          da = bez.d - s;
          ca = bez.c - s;
          ba = bez.b - s;
          d = d1 = 0;
          for(i = 1; i <= resolution; i++) {
            p = inc * i;
            inv = 1 - p;
            d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
            index = j * resolution + i - 1;
            steps[index] = (steps[index] || 0) + d * d;
          }
        }
      },
      _parseLengthData = function(obj, resolution) {
        resolution = resolution >> 0 || 6;
        var a = [],
          lengths = [],
          d = 0,
          total = 0,
          threshold = resolution - 1,
          segments = [],
          curLS = [], //current length segments array
          p, i, l, index;
        for(p in obj) {
          _addCubicLengths(obj[p], a, resolution);
        }
        l = a.length;
        for(i = 0; i < l; i++) {
          d += Math.sqrt(a[i]);
          index = i % resolution;
          curLS[index] = d;
          if(index === threshold) {
            total += d;
            index = (i / resolution) >> 0;
            segments[index] = curLS;
            lengths[index] = total;
            d = 0;
            curLS = [];
          }
        }
        return { length: total, lengths: lengths, segments: segments };
      },



      BezierPlugin = _gsScope._gsDefine.plugin({
        propName: "bezier",
        priority: -1,
        version: "1.3.7",
        API: 2,
        global: true,

        //gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
        init: function(target, vars, tween) {
          this._target = target;
          if(vars instanceof Array) {
            vars = { values: vars };
          }
          this._func = {};
          this._mod = {};
          this._props = [];
          this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
          var values = vars.values || [],
            first = {},
            second = values[0],
            autoRotate = vars.autoRotate || tween.vars.orientToBezier,
            p, isFunc, i, j, prepend;

          this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [
            ["x", "y", "rotation", ((autoRotate === true) ? 0 : Number(autoRotate) || 0)]
          ] : null;
          for(p in second) {
            this._props.push(p);
          }

          i = this._props.length;
          while(--i > -1) {
            p = this._props[i];

            this._overwriteProps.push(p);
            isFunc = this._func[p] = (typeof(target[p]) === "function");
            first[p] = (!isFunc) ? parseFloat(target[p]) : target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))]();
            if(!prepend)
              if(first[p] !== values[0][p]) {
                prepend = first;
              }
          }
          this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
          this._segCount = this._beziers[p].length;

          if(this._timeRes) {
            var ld = _parseLengthData(this._beziers, this._timeRes);
            this._length = ld.length;
            this._lengths = ld.lengths;
            this._segments = ld.segments;
            this._l1 = this._li = this._s1 = this._si = 0;
            this._l2 = this._lengths[0];
            this._curSeg = this._segments[0];
            this._s2 = this._curSeg[0];
            this._prec = 1 / this._curSeg.length;
          }

          if((autoRotate = this._autoRotate)) {
            this._initialRotations = [];
            if(!(autoRotate[0] instanceof Array)) {
              this._autoRotate = autoRotate = [autoRotate];
            }
            i = autoRotate.length;
            while(--i > -1) {
              for(j = 0; j < 3; j++) {
                p = autoRotate[i][j];
                this._func[p] = (typeof(target[p]) === "function") ? target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))] : false;
              }
              p = autoRotate[i][2];
              this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
              this._overwriteProps.push(p);
            }
          }
          this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
          return true;
        },

        //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
        set: function(v) {
          var segments = this._segCount,
            func = this._func,
            target = this._target,
            notStart = (v !== this._startRatio),
            curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
          if(!this._timeRes) {
            curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
            t = (v - (curIndex * (1 / segments))) * segments;
          } else {
            lengths = this._lengths;
            curSeg = this._curSeg;
            v *= this._length;
            i = this._li;
            //find the appropriate segment (if the currently cached one isn't correct)
            if(v > this._l2 && i < segments - 1) {
              l = segments - 1;
              while(i < l && (this._l2 = lengths[++i]) <= v) {}
              this._l1 = lengths[i - 1];
              this._li = i;
              this._curSeg = curSeg = this._segments[i];
              this._s2 = curSeg[(this._s1 = this._si = 0)];
            } else if(v < this._l1 && i > 0) {
              while(i > 0 && (this._l1 = lengths[--i]) >= v) {}
              if(i === 0 && v < this._l1) {
                this._l1 = 0;
              } else {
                i++;
              }
              this._l2 = lengths[i];
              this._li = i;
              this._curSeg = curSeg = this._segments[i];
              this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
              this._s2 = curSeg[this._si];
            }
            curIndex = i;
            //now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
            v -= this._l1;
            i = this._si;
            if(v > this._s2 && i < curSeg.length - 1) {
              l = curSeg.length - 1;
              while(i < l && (this._s2 = curSeg[++i]) <= v) {}
              this._s1 = curSeg[i - 1];
              this._si = i;
            } else if(v < this._s1 && i > 0) {
              while(i > 0 && (this._s1 = curSeg[--i]) >= v) {}
              if(i === 0 && v < this._s1) {
                this._s1 = 0;
              } else {
                i++;
              }
              this._s2 = curSeg[i];
              this._si = i;
            }
            t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
          }
          inv = 1 - t;

          i = this._props.length;
          while(--i > -1) {
            p = this._props[i];
            b = this._beziers[p][curIndex];
            val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
            if(this._mod[p]) {
              val = this._mod[p](val, target);
            }
            if(func[p]) {
              target[p](val);
            } else {
              target[p] = val;
            }
          }

          if(this._autoRotate) {
            var ar = this._autoRotate,
              b2, x1, y1, x2, y2, add, conv;
            i = ar.length;
            while(--i > -1) {
              p = ar[i][2];
              add = ar[i][3] || 0;
              conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
              b = this._beziers[ar[i][0]];
              b2 = this._beziers[ar[i][1]];

              if(b && b2) { //in case one of the properties got overwritten.
                b = b[curIndex];
                b2 = b2[curIndex];

                x1 = b.a + (b.b - b.a) * t;
                x2 = b.b + (b.c - b.b) * t;
                x1 += (x2 - x1) * t;
                x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

                y1 = b2.a + (b2.b - b2.a) * t;
                y2 = b2.b + (b2.c - b2.b) * t;
                y1 += (y2 - y1) * t;
                y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

                val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

                if(this._mod[p]) {
                  val = this._mod[p](val, target); //for modProps
                }

                if(func[p]) {
                  target[p](val);
                } else {
                  target[p] = val;
                }
              }
            }
          }
        }
      }),
      p = BezierPlugin.prototype;


    BezierPlugin.bezierThrough = bezierThrough;
    BezierPlugin.cubicToQuadratic = cubicToQuadratic;
    BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
    BezierPlugin.quadraticToCubic = function(a, b, c) {
      return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
    };

    BezierPlugin._cssRegister = function() {
      var CSSPlugin = _globals.CSSPlugin;
      if(!CSSPlugin) {
        return;
      }
      var _internals = CSSPlugin._internals,
        _parseToProxy = _internals._parseToProxy,
        _setPluginRatio = _internals._setPluginRatio,
        CSSPropTween = _internals.CSSPropTween;
      _internals._registerComplexSpecialProp("bezier", {
        parser: function(t, e, prop, cssp, pt, plugin) {
          if(e instanceof Array) {
            e = { values: e };
          }
          plugin = new BezierPlugin();
          var values = e.values,
            l = values.length - 1,
            pluginValues = [],
            v = {},
            i, p, data;
          if(l < 0) {
            return pt;
          }
          for(i = 0; i <= l; i++) {
            data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
            pluginValues[i] = data.end;
          }
          for(p in e) {
            v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
          }
          v.values = pluginValues;
          pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
          pt.data = data;
          pt.plugin = plugin;
          pt.setRatio = _setPluginRatio;
          if(v.autoRotate === 0) {
            v.autoRotate = true;
          }
          if(v.autoRotate && !(v.autoRotate instanceof Array)) {
            i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
            v.autoRotate = (data.end.left != null) ? [
              ["left", "top", "rotation", i, false]
            ] : (data.end.x != null) ? [
              ["x", "y", "rotation", i, false]
            ] : false;
          }
          if(v.autoRotate) {
            if(!cssp._transform) {
              cssp._enableTransforms(false);
            }
            data.autoRotate = cssp._target._gsTransform;
            data.proxy.rotation = data.autoRotate.rotation || 0;
            cssp._overwriteProps.push("rotation");
          }
          plugin._onInitTween(data.proxy, v, cssp._tween);
          return pt;
        }
      });
    };

    p._mod = function(lookup) {
      var op = this._overwriteProps,
        i = op.length,
        val;
      while(--i > -1) {
        val = lookup[op[i]];
        if(val && typeof(val) === "function") {
          this._mod[op[i]] = val;
        }
      }
    };

    p._kill = function(lookup) {
      var a = this._props,
        p, i;
      for(p in this._beziers) {
        if(p in lookup) {
          delete this._beziers[p];
          delete this._func[p];
          i = a.length;
          while(--i > -1) {
            if(a[i] === p) {
              a.splice(i, 1);
            }
          }
        }
      }
      a = this._autoRotate;
      if(a) {
        i = a.length;
        while(--i > -1) {
          if(lookup[a[i][2]]) {
            a.splice(i, 1);
          }
        }
      }
      return this._super._kill.call(this, lookup);
    };

  }());














  /*
   * ----------------------------------------------------------------
   * CSSPlugin
   * ----------------------------------------------------------------
   */
  _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(TweenPlugin, TweenLite) {

    /** @constructor **/
    var CSSPlugin = function() {
        TweenPlugin.call(this, "css");
        this._overwriteProps.length = 0;
        this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
      },
      _globals = _gsScope._gsDefine.globals,
      _hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
      _suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
      _cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
      _overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
      _specialProps = {},
      p = CSSPlugin.prototype = new TweenPlugin("css");

    p.constructor = CSSPlugin;
    CSSPlugin.version = "1.19.0";
    CSSPlugin.API = 2;
    CSSPlugin.defaultTransformPerspective = 0;
    CSSPlugin.defaultSkewType = "compensated";
    CSSPlugin.defaultSmoothOrigin = true;
    p = "px"; //we'll reuse the "p" variable to keep file size down
    CSSPlugin.suffixMap = { top: p, right: p, bottom: p, left: p, width: p, height: p, fontSize: p, padding: p, margin: p, perspective: p, lineHeight: "" };


    var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
      _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
      _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
      _NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
      _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
      _opacityExp = /opacity *= *([^)]*)/i,
      _opacityValExp = /opacity:([^;]*)/i,
      _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
      _rgbhslExp = /^(rgb|hsl)/,
      _capsExp = /([A-Z])/g,
      _camelExp = /-([a-z])/gi,
      _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
      _camelFunc = function(s, g) { return g.toUpperCase(); },
      _horizExp = /(?:Left|Right|Width)/i,
      _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
      _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
      _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
      _complexExp = /[\s,\(]/i, //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
      _DEG2RAD = Math.PI / 180,
      _RAD2DEG = 180 / Math.PI,
      _forcePT = {},
      _doc = document,
      _createElement = function(type) {
        return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
      },
      _tempDiv = _createElement("div"),
      _tempImg = _createElement("img"),
      _internals = CSSPlugin._internals = { _specialProps: _specialProps }, //provides a hook to a few internal methods that we need to access from inside other plugins
      _agent = navigator.userAgent,
      _autoRound,
      _reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

      _isSafari,
      _isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
      _isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
      _ieVers,
      _supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
        var i = _agent.indexOf("Android"),
          a = _createElement("a");
        _isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3));
        _isSafariLT6 = (_isSafari && (Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6));
        _isFirefox = (_agent.indexOf("Firefox") !== -1);
        if((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
          _ieVers = parseFloat(RegExp.$1);
        }
        if(!a) {
          return false;
        }
        a.style.cssText = "top:1px;opacity:.55;";
        return /^0.55/.test(a.style.opacity);
      }()),
      _getIEOpacity = function(v) {
        return(_opacityExp.test(((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "")) ? (parseFloat(RegExp.$1) / 100) : 1);
      },
      _log = function(s) { //for logging messages, but in a way that won't throw errors in old versions of IE.
        if(window.console) {
          console.log(s);
        }
      },
      _target, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
      _index, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params

      _prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
      _prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

      // @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
      _checkPropPrefix = function(p, e) {
        e = e || _tempDiv;
        var s = e.style,
          a, i;
        if(s[p] !== undefined) {
          return p;
        }
        p = p.charAt(0).toUpperCase() + p.substr(1);
        a = ["O", "Moz", "ms", "Ms", "Webkit"];
        i = 5;
        while(--i > -1 && s[a[i] + p] === undefined) {}
        if(i >= 0) {
          _prefix = (i === 3) ? "ms" : a[i];
          _prefixCSS = "-" + _prefix.toLowerCase() + "-";
          return _prefix + p;
        }
        return null;
      },

      _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},

      /**
       * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
       * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
       *
       * @param {!Object} t Target element whose style property you want to query
       * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
       * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
       * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
       * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
       * @return {?string} The current property value
       */
      _getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
        var rv;
        if(!_supportsOpacity)
          if(p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
            return _getIEOpacity(t);
          }
        if(!calc && t.style[p]) {
          rv = t.style[p];
        } else if((cs = cs || _getComputedStyle(t))) {
          rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
        } else if(t.currentStyle) {
          rv = t.currentStyle[p];
        }
        return(dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
      },

      /**
       * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
       * @param {!Object} t Target element
       * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
       * @param {!number} v Value
       * @param {string=} sfx Suffix (like "px" or "%" or "em")
       * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
       * @return {number} value in pixels
       */
      _convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
        if(sfx === "px" || !sfx) { return v; }
        if(sfx === "auto" || !v) { return 0; }
        var horiz = _horizExp.test(p),
          node = t,
          style = _tempDiv.style,
          neg = (v < 0),
          precise = (v === 1),
          pix, cache, time;
        if(neg) {
          v = -v;
        }
        if(precise) {
          v *= 100;
        }
        if(sfx === "%" && p.indexOf("border") !== -1) {
          pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
        } else {
          style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
          if(sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
            node = t.parentNode || _doc.body;
            cache = node._gsCache;
            time = TweenLite.ticker.frame;
            if(cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
              return cache.width * v / 100;
            }
            style[(horiz ? "width" : "height")] = v + sfx;
          } else {
            style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
          }
          node.appendChild(_tempDiv);
          pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
          node.removeChild(_tempDiv);
          if(horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
            cache = node._gsCache = node._gsCache || {};
            cache.time = time;
            cache.width = pix / v * 100;
          }
          if(pix === 0 && !recurse) {
            pix = _convertToPixels(t, p, v, sfx, true);
          }
        }
        if(precise) {
          pix /= 100;
        }
        return neg ? -pix : pix;
      },
      _calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
        if(_getStyle(t, "position", cs) !== "absolute") { return 0; }
        var dim = ((p === "left") ? "Left" : "Top"),
          v = _getStyle(t, "margin" + dim, cs);
        return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
      },

      // @private returns at object containing ALL of the style properties in camelCase and their associated values.
      _getAllStyles = function(t, cs) {
        var s = {},
          i, tr, p;
        if((cs = cs || _getComputedStyle(t, null))) {
          if((i = cs.length)) {
            while(--i > -1) {
              p = cs[i];
              if(p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
                s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
              }
            }
          } else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
            for(i in cs) {
              if(i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
                s[i] = cs[i];
              }
            }
          }
        } else if((cs = t.currentStyle || t.style)) {
          for(i in cs) {
            if(typeof(i) === "string" && s[i] === undefined) {
              s[i.replace(_camelExp, _camelFunc)] = cs[i];
            }
          }
        }
        if(!_supportsOpacity) {
          s.opacity = _getIEOpacity(t);
        }
        tr = _getTransform(t, cs, false);
        s.rotation = tr.rotation;
        s.skewX = tr.skewX;
        s.scaleX = tr.scaleX;
        s.scaleY = tr.scaleY;
        s.x = tr.x;
        s.y = tr.y;
        if(_supports3D) {
          s.z = tr.z;
          s.rotationX = tr.rotationX;
          s.rotationY = tr.rotationY;
          s.scaleZ = tr.scaleZ;
        }
        if(s.filters) {
          delete s.filters;
        }
        return s;
      },

      // @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
      _cssDif = function(t, s1, s2, vars, forceLookup) {
        var difs = {},
          style = t.style,
          val, p, mpt;
        for(p in s2) {
          if(p !== "cssText")
            if(p !== "length")
              if(isNaN(p))
                if(s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p]))
                  if(p.indexOf("Origin") === -1)
                    if(typeof(val) === "number" || typeof(val) === "string") {
                      difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
                      if(style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
                        mpt = new MiniPropTween(style, p, style[p], mpt);
                      }
                    }
        }
        if(vars) {
          for(p in vars) { //copy properties (except className)
            if(p !== "className") {
              difs[p] = vars[p];
            }
          }
        }
        return { difs: difs, firstMPT: mpt };
      },
      _dimensions = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
      _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],

      /**
       * @private Gets the width or height of an element
       * @param {!Object} t Target element
       * @param {!string} p Property name ("width" or "height")
       * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
       * @return {number} Dimension (in pixels)
       */
      _getDimension = function(t, p, cs) {
        if((t.nodeName + "").toLowerCase() === "svg") { //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
          return(cs || _getComputedStyle(t))[p] || 0;
        } else if(t.getBBox && _isSVG(t)) {
          return t.getBBox()[p] || 0;
        }
        var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
          a = _dimensions[p],
          i = a.length;
        cs = cs || _getComputedStyle(t, null);
        while(--i > -1) {
          v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
          v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
        }
        return v;
      },

      // @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
      _parsePosition = function(v, recObj) {
        if(v === "contain" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
          return v + " ";
        }
        if(v == null || v === "") {
          v = "0 0";
        }
        var a = v.split(" "),
          x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
          y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1],
          i;
        if(a.length > 3 && !recObj) { //multiple positions
          a = v.split(", ").join(",").split(",");
          v = [];
          for(i = 0; i < a.length; i++) {
            v.push(_parsePosition(a[i]));
          }
          return v.join(",");
        }
        if(y == null) {
          y = (x === "center") ? "50%" : "0";
        } else if(y === "center") {
          y = "50%";
        }
        if(x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
          x = "50%";
        }
        v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
        if(recObj) {
          recObj.oxp = (x.indexOf("%") !== -1);
          recObj.oyp = (y.indexOf("%") !== -1);
          recObj.oxr = (x.charAt(1) === "=");
          recObj.oyr = (y.charAt(1) === "=");
          recObj.ox = parseFloat(x.replace(_NaNExp, ""));
          recObj.oy = parseFloat(y.replace(_NaNExp, ""));
          recObj.v = v;
        }
        return recObj || v;
      },

      /**
       * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
       * @param {(number|string)} e End value which is typically a string, but could be a number
       * @param {(number|string)} b Beginning value which is typically a string but could be a number
       * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
       */
      _parseChange = function(e, b) {
        if(typeof(e) === "function") {
          e = e(_index, _target);
        }
        return(typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : (parseFloat(e) - parseFloat(b)) || 0;
      },

      /**
       * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
       * @param {Object} v Value to be parsed
       * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
       * @return {number} Parsed value
       */
      _parseVal = function(v, d) {
        if(typeof(v) === "function") {
          v = v(_index, _target);
        }
        return(v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
      },

      /**
       * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
       * @param {Object} v Value to be parsed
       * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
       * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
       * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
       * @return {number} parsed angle in radians
       */
      _parseAngle = function(v, d, p, directionalEnd) {
        var min = 0.000001,
          cap, split, dif, result, isRelative;
        if(typeof(v) === "function") {
          v = v(_index, _target);
        }
        if(v == null) {
          result = d;
        } else if(typeof(v) === "number") {
          result = v;
        } else {
          cap = 360;
          split = v.split("_");
          isRelative = (v.charAt(1) === "=");
          dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
          if(split.length) {
            if(directionalEnd) {
              directionalEnd[p] = d + dif;
            }
            if(v.indexOf("short") !== -1) {
              dif = dif % cap;
              if(dif !== dif % (cap / 2)) {
                dif = (dif < 0) ? dif + cap : dif - cap;
              }
            }
            if(v.indexOf("_cw") !== -1 && dif < 0) {
              dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
            } else if(v.indexOf("ccw") !== -1 && dif > 0) {
              dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
            }
          }
          result = d + dif;
        }
        if(result < min && result > -min) {
          result = 0;
        }
        return result;
      },

      _colorLookup = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        fuchsia: [255, 0, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      },

      _hue = function(h, m1, m2) {
        h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
        return((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
      },

      /**
       * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
       * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
       * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
       * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
       */
      _parseColor = CSSPlugin.parseColor = function(v, toHSL) {
        var a, r, g, b, h, s, l, max, min, d, wasHSL;
        if(!v) {
          a = _colorLookup.black;
        } else if(typeof(v) === "number") {
          a = [v >> 16, (v >> 8) & 255, v & 255];
        } else {
          if(v.charAt(v.length - 1) === ",") { //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
            v = v.substr(0, v.length - 1);
          }
          if(_colorLookup[v]) {
            a = _colorLookup[v];
          } else if(v.charAt(0) === "#") {
            if(v.length === 4) { //for shorthand like #9F0
              r = v.charAt(1);
              g = v.charAt(2);
              b = v.charAt(3);
              v = "#" + r + r + g + g + b + b;
            }
            v = parseInt(v.substr(1), 16);
            a = [v >> 16, (v >> 8) & 255, v & 255];
          } else if(v.substr(0, 3) === "hsl") {
            a = wasHSL = v.match(_numExp);
            if(!toHSL) {
              h = (Number(a[0]) % 360) / 360;
              s = Number(a[1]) / 100;
              l = Number(a[2]) / 100;
              g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
              r = l * 2 - g;
              if(a.length > 3) {
                a[3] = Number(v[3]);
              }
              a[0] = _hue(h + 1 / 3, r, g);
              a[1] = _hue(h, r, g);
              a[2] = _hue(h - 1 / 3, r, g);
            } else if(v.indexOf("=") !== -1) { //if relative values are found, just return the raw strings with the relative prefixes in place.
              return v.match(_relNumExp);
            }
          } else {
            a = v.match(_numExp) || _colorLookup.transparent;
          }
          a[0] = Number(a[0]);
          a[1] = Number(a[1]);
          a[2] = Number(a[2]);
          if(a.length > 3) {
            a[3] = Number(a[3]);
          }
        }
        if(toHSL && !wasHSL) {
          r = a[0] / 255;
          g = a[1] / 255;
          b = a[2] / 255;
          max = Math.max(r, g, b);
          min = Math.min(r, g, b);
          l = (max + min) / 2;
          if(max === min) {
            h = s = 0;
          } else {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
            h *= 60;
          }
          a[0] = (h + 0.5) | 0;
          a[1] = (s * 100 + 0.5) | 0;
          a[2] = (l * 100 + 0.5) | 0;
        }
        return a;
      },
      _formatColors = function(s, toHSL) {
        var colors = s.match(_colorExp) || [],
          charIndex = 0,
          parsed = colors.length ? "" : s,
          i, color, temp;
        for(i = 0; i < colors.length; i++) {
          color = colors[i];
          temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
          charIndex += temp.length + color.length;
          color = _parseColor(color, toHSL);
          if(color.length === 3) {
            color.push(1);
          }
          parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
        }
        return parsed + s.substr(charIndex);
      },
      _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

    for(p in _colorLookup) {
      _colorExp += "|" + p + "\\b";
    }
    _colorExp = new RegExp(_colorExp + ")", "gi");

    CSSPlugin.colorStringFilter = function(a) {
      var combined = a[0] + a[1],
        toHSL;
      if(_colorExp.test(combined)) {
        toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
        a[0] = _formatColors(a[0], toHSL);
        a[1] = _formatColors(a[1], toHSL);
      }
      _colorExp.lastIndex = 0;
    };

    if(!TweenLite.defaultStringFilter) {
      TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
    }

    /**
     * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
     * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
     * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
     * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
     * @return {Function} formatter function
     */
    var _getFormatter = function(dflt, clr, collapsible, multi) {
        if(dflt == null) {
          return function(v) { return v; };
        }
        var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
          dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
          pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
          sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
          delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
          numVals = dVals.length,
          dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
          formatter;
        if(!numVals) {
          return function(v) { return v; };
        }
        if(clr) {
          formatter = function(v) {
            var color, vals, i, a;
            if(typeof(v) === "number") {
              v += dSfx;
            } else if(multi && _commasOutsideParenExp.test(v)) {
              a = v.replace(_commasOutsideParenExp, "|").split("|");
              for(i = 0; i < a.length; i++) {
                a[i] = formatter(a[i]);
              }
              return a.join(",");
            }
            color = (v.match(_colorExp) || [dColor])[0];
            vals = v.split(color).join("").match(_valuesExp) || [];
            i = vals.length;
            if(numVals > i--) {
              while(++i < numVals) {
                vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
              }
            }
            return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
          };
          return formatter;

        }
        formatter = function(v) {
          var vals, a, i;
          if(typeof(v) === "number") {
            v += dSfx;
          } else if(multi && _commasOutsideParenExp.test(v)) {
            a = v.replace(_commasOutsideParenExp, "|").split("|");
            for(i = 0; i < a.length; i++) {
              a[i] = formatter(a[i]);
            }
            return a.join(",");
          }
          vals = v.match(_valuesExp) || [];
          i = vals.length;
          if(numVals > i--) {
            while(++i < numVals) {
              vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
            }
          }
          return pfx + vals.join(delim) + sfx;
        };
        return formatter;
      },

      /**
       * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
       * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
       * @return {Function} a formatter function
       */
      _getEdgeParser = function(props) {
        props = props.split(",");
        return function(t, e, p, cssp, pt, plugin, vars) {
          var a = (e + "").split(" "),
            i;
          vars = {};
          for(i = 0; i < 4; i++) {
            vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
          }
          return cssp.parse(t, vars, pt, plugin);
        };
      },

      // @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
      _setPluginRatio = _internals._setPluginRatio = function(v) {
        this.plugin.setRatio(v);
        var d = this.data,
          proxy = d.proxy,
          mpt = d.firstMPT,
          min = 0.000001,
          val, pt, i, str, p;
        while(mpt) {
          val = proxy[mpt.v];
          if(mpt.r) {
            val = Math.round(val);
          } else if(val < min && val > -min) {
            val = 0;
          }
          mpt.t[mpt.p] = val;
          mpt = mpt._next;
        }
        if(d.autoRotate) {
          d.autoRotate.rotation = d.mod ? d.mod(proxy.rotation, this.t) : proxy.rotation; //special case for ModifyPlugin to hook into an auto-rotating bezier
        }
        //at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
        if(v === 1 || v === 0) {
          mpt = d.firstMPT;
          p = (v === 1) ? "e" : "b";
          while(mpt) {
            pt = mpt.t;
            if(!pt.type) {
              pt[p] = pt.s + pt.xs0;
            } else if(pt.type === 1) {
              str = pt.xs0 + pt.s + pt.xs1;
              for(i = 1; i < pt.l; i++) {
                str += pt["xn" + i] + pt["xs" + (i + 1)];
              }
              pt[p] = str;
            }
            mpt = mpt._next;
          }
        }
      },

      /**
       * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
       * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
       * @param {!string} p property name
       * @param {(number|string|object)} v value
       * @param {MiniPropTween=} next next MiniPropTween in the linked list
       * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
       */
      MiniPropTween = function(t, p, v, next, r) {
        this.t = t;
        this.p = p;
        this.v = v;
        this.r = r;
        if(next) {
          next._prev = this;
          this._next = next;
        }
      },

      /**
       * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
       * This method returns an object that has the following properties:
       *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
       *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
       *  - firstMPT: the first MiniPropTween in the linked list
       *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
       * @param {!Object} t target object to be tweened
       * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
       * @param {!CSSPlugin} cssp The CSSPlugin instance
       * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
       * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
       * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
       * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
       */
      _parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
        var bpt = pt,
          start = {},
          end = {},
          transform = cssp._transform,
          oldForce = _forcePT,
          i, p, xp, mpt, firstPT;
        cssp._transform = null;
        _forcePT = vars;
        pt = firstPT = cssp.parse(t, vars, pt, plugin);
        _forcePT = oldForce;
        //break off from the linked list so the new ones are isolated.
        if(shallow) {
          cssp._transform = transform;
          if(bpt) {
            bpt._prev = null;
            if(bpt._prev) {
              bpt._prev._next = null;
            }
          }
        }
        while(pt && pt !== bpt) {
          if(pt.type <= 1) {
            p = pt.p;
            end[p] = pt.s + pt.c;
            start[p] = pt.s;
            if(!shallow) {
              mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
              pt.c = 0;
            }
            if(pt.type === 1) {
              i = pt.l;
              while(--i > 0) {
                xp = "xn" + i;
                p = pt.p + "_" + xp;
                end[p] = pt.data[xp];
                start[p] = pt[xp];
                if(!shallow) {
                  mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
                }
              }
            }
          }
          pt = pt._next;
        }
        return { proxy: start, end: end, firstMPT: mpt, pt: firstPT };
      },



      /**
       * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
       * CSSPropTweens have the following optional properties as well (not defined through the constructor):
       *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
       *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
       *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
       *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
       *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
       * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
       * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
       * @param {number} s Starting numeric value
       * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
       * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
       * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
       * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
       * @param {boolean=} r If true, the value(s) should be rounded
       * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
       * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
       * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
       */
      CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
        this.t = t; //target
        this.p = p; //property
        this.s = s; //starting value
        this.c = c; //change value
        this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
        if(!(t instanceof CSSPropTween)) {
          _overwriteProps.push(this.n);
        }
        this.r = r; //round (boolean)
        this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
        if(pr) {
          this.pr = pr;
          _hasPriority = true;
        }
        this.b = (b === undefined) ? s : b;
        this.e = (e === undefined) ? s + c : e;
        if(next) {
          this._next = next;
          next._prev = this;
        }
      },

      _addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) { //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
        var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
        pt.b = start;
        pt.e = pt.xs0 = end;
        return pt;
      },

      /**
       * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
       * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
       * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
       * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
       *
       * @param {!Object} t Target whose property will be tweened
       * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
       * @param {string} b Beginning value
       * @param {string} e Ending value
       * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
       * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
       * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
       * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
       * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
       * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
       * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
       */
      _parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
        //DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
        b = b || dflt || "";
        if(typeof(e) === "function") {
          e = e(_index, _target);
        }
        pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
        e += ""; //ensures it's a string
        if(clrs && _colorExp.test(e + b)) { //if colors are found, normalize the formatting to rgba() or hsla().
          e = [b, e];
          CSSPlugin.colorStringFilter(e);
          b = e[0];
          e = e[1];
        }
        var ba = b.split(", ").join(",").split(" "), //beginning array
          ea = e.split(", ").join(",").split(" "), //ending array
          l = ba.length,
          autoRound = (_autoRound !== false),
          i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
        if(e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
          ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
          ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
          l = ba.length;
        }
        if(l !== ea.length) {
          //DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
          ba = (dflt || "").split(" ");
          l = ba.length;
        }
        pt.plugin = plugin;
        pt.setRatio = setRatio;
        _colorExp.lastIndex = 0;
        for(i = 0; i < l; i++) {
          bv = ba[i];
          ev = ea[i];
          bn = parseFloat(bv);
          //if the value begins with a number (most common). It's fine if it has a suffix like px
          if(bn || bn === 0) {
            pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);

            //if the value is a color
          } else if(clrs && _colorExp.test(bv)) {
            str = ev.indexOf(")") + 1;
            str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
            useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
            bv = _parseColor(bv, useHSL);
            ev = _parseColor(ev, useHSL);
            hasAlpha = (bv.length + ev.length > 6);
            if(hasAlpha && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
              pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
              pt.e = pt.e.split(ea[i]).join("transparent");
            } else {
              if(!_supportsOpacity) { //old versions of IE don't support rgba().
                hasAlpha = false;
              }
              if(useHSL) {
                pt.appendXtra((hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true)
                  .appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false)
                  .appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
              } else {
                pt.appendXtra((hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)
                  .appendXtra("", bv[1], ev[1] - bv[1], ",", true)
                  .appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), true);
              }

              if(hasAlpha) {
                bv = (bv.length < 4) ? 1 : bv[3];
                pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
              }
            }
            _colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.

          } else {
            bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

            //if no number is found, treat it as a non-tweening value and just append the string to the current xs.
            if(!bnums) {
              pt["xs" + pt.l] += (pt.l || pt["xs" + pt.l]) ? " " + ev : ev;

              //loop through all the numbers that are found and construct the extra values on the pt.
            } else {
              enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
              if(!enums || enums.length !== bnums.length) {
                //DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
                return pt;
              }
              ni = 0;
              for(xi = 0; xi < bnums.length; xi++) {
                cv = bnums[xi];
                temp = bv.indexOf(cv, ni);
                pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
                ni = temp + cv.length;
              }
              pt["xs" + pt.l] += bv.substr(ni);
            }
          }
        }
        //if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
        if(e.indexOf("=") !== -1)
          if(pt.data) {
            str = pt.xs0 + pt.data.s;
            for(i = 1; i < pt.l; i++) {
              str += pt["xs" + i] + pt.data["xn" + i];
            }
            pt.e = str + pt["xs" + i];
          }
        if(!pt.l) {
          pt.type = -1;
          pt.xs0 = pt.e;
        }
        return pt.xfirst || pt;
      },
      i = 9;


    p = CSSPropTween.prototype;
    p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
    while(--i > 0) {
      p["xn" + i] = 0;
      p["xs" + i] = "";
    }
    p.xs0 = "";
    p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


    /**
     * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
     * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
     * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
     * @param {string=} pfx Prefix (if any)
     * @param {!number} s Starting value
     * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
     * @param {string=} sfx Suffix (if any)
     * @param {boolean=} r Round (if true).
     * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
     * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
     */
    p.appendXtra = function(pfx, s, c, sfx, r, pad) {
      var pt = this,
        l = pt.l;
      pt["xs" + l] += (pad && (l || pt["xs" + l])) ? " " + pfx : pfx || "";
      if(!c)
        if(l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
          pt["xs" + l] += s + (sfx || "");
          return pt;
        }
      pt.l++;
      pt.type = pt.setRatio ? 2 : 1;
      pt["xs" + pt.l] = sfx || "";
      if(l > 0) {
        pt.data["xn" + l] = s + c;
        pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
        pt["xn" + l] = s;
        if(!pt.plugin) {
          pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
          pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
        }
        return pt;
      }
      pt.data = { s: s + c };
      pt.rxp = {};
      pt.s = s;
      pt.c = c;
      pt.r = r;
      return pt;
    };

    /**
     * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
     * @param {!string} p Property name (like "boxShadow" or "throwProps")
     * @param {Object=} options An object containing any of the following configuration options:
     *                      - defaultValue: the default value
     *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
     *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
     *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
     *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
     *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
     *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
     *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
     *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
     */
    var SpecialProp = function(p, options) {
        options = options || {};
        this.p = options.prefix ? _checkPropPrefix(p) || p : p;
        _specialProps[p] = _specialProps[this.p] = this;
        this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
        if(options.parser) {
          this.parse = options.parser;
        }
        this.clrs = options.color;
        this.multi = options.multi;
        this.keyword = options.keyword;
        this.dflt = options.defaultValue;
        this.pr = options.priority || 0;
      },

      //shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
      _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
        if(typeof(options) !== "object") {
          options = { parser: defaults }; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
        }
        var a = p.split(","),
          d = options.defaultValue,
          i, temp;
        defaults = defaults || [d];
        for(i = 0; i < a.length; i++) {
          options.prefix = (i === 0 && options.prefix);
          options.defaultValue = defaults[i] || d;
          temp = new SpecialProp(a[i], options);
        }
      },

      //creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
      _registerPluginProp = _internals._registerPluginProp = function(p) {
        if(!_specialProps[p]) {
          var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
          _registerComplexSpecialProp(p, {
            parser: function(t, e, p, cssp, pt, plugin, vars) {
              var pluginClass = _globals.com.greensock.plugins[pluginName];
              if(!pluginClass) {
                _log("Error: " + pluginName + " js file not loaded.");
                return pt;
              }
              pluginClass._cssRegister();
              return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
            }
          });
        }
      };


    p = SpecialProp.prototype;

    /**
     * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
     * @param {!Object} t target element
     * @param {(string|number|object)} b beginning value
     * @param {(string|number|object)} e ending (destination) value
     * @param {CSSPropTween=} pt next CSSPropTween in the linked list
     * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
     * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
     * @return {CSSPropTween=} First CSSPropTween in the linked list
     */
    p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
      var kwd = this.keyword,
        i, ba, ea, l, bi, ei;
      //if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
      if(this.multi)
        if(_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
          ba = b.replace(_commasOutsideParenExp, "|").split("|");
          ea = e.replace(_commasOutsideParenExp, "|").split("|");
        } else if(kwd) {
        ba = [b];
        ea = [e];
      }
      if(ea) {
        l = (ea.length > ba.length) ? ea.length : ba.length;
        for(i = 0; i < l; i++) {
          b = ba[i] = ba[i] || this.dflt;
          e = ea[i] = ea[i] || this.dflt;
          if(kwd) {
            bi = b.indexOf(kwd);
            ei = e.indexOf(kwd);
            if(bi !== ei) {
              if(ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
                ba[i] = ba[i].split(kwd).join("");
              } else if(bi === -1) { //if the keyword isn't in the beginning, add it.
                ba[i] += " " + kwd;
              }
            }
          }
        }
        b = ba.join(", ");
        e = ea.join(", ");
      }
      return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
    };

    /**
     * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
     * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
     * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
     * @param {!Object} t Target object whose property is being tweened
     * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
     * @param {!string} p Property name
     * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
     * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
     * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
     * @param {Object=} vars Original vars object that contains the data for parsing.
     * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
     */
    p.parse = function(t, e, p, cssp, pt, plugin, vars) {
      return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
    };

    /**
     * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
     *  1) Target object whose property should be tweened (typically a DOM element)
     *  2) The end/destination value (could be a string, number, object, or whatever you want)
     *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
     *
     * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
     *
     * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
     *      var start = target.style.width;
     *      return function(ratio) {
     *              target.style.width = (start + value * ratio) + "px";
     *              console.log("set width to " + target.style.width);
     *          }
     * }, 0);
     *
     * Then, when I do this tween, it will trigger my special property:
     *
     * TweenLite.to(element, 1, {css:{myCustomProp:100}});
     *
     * In the example, of course, we're just changing the width, but you can do anything you want.
     *
     * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
     * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
     * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
     */
    CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
      _registerComplexSpecialProp(name, {
        parser: function(t, e, p, cssp, pt, plugin, vars) {
          var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
          rv.plugin = plugin;
          rv.setRatio = onInitTween(t, e, cssp._tween, p);
          return rv;
        },
        priority: priority
      });
    };






    //transform-related methods and properties
    CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
    var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
      _transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
      _transformPropCSS = _prefixCSS + "transform",
      _transformOriginProp = _checkPropPrefix("transformOrigin"),
      _supports3D = (_checkPropPrefix("perspective") !== null),
      Transform = _internals.Transform = function() {
        this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
        this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
      },
      _SVGElement = window.SVGElement,
      _useSVGTransformAttr,
      //Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

      _createSVG = function(type, container, attributes) {
        var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
          reg = /([a-z])([A-Z])/g,
          p;
        for(p in attributes) {
          element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
        }
        container.appendChild(element);
        return element;
      },
      _docElement = _doc.documentElement,
      _forceSVGTransformAttr = (function() {
        //IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
        var force = _ieVers || (/Android/i.test(_agent) && !window.chrome),
          svg, rect, width;
        if(_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
          svg = _createSVG("svg", _docElement);
          rect = _createSVG("rect", svg, { width: 100, height: 50, x: 100 });
          width = rect.getBoundingClientRect().width;
          rect.style[_transformOriginProp] = "50% 50%";
          rect.style[_transformProp] = "scaleX(0.5)";
          force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
          _docElement.removeChild(svg);
        }
        return force;
      })(),
      _parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
        var tm = e._gsTransform,
          m = _getMatrix(e, true),
          v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
        if(tm) {
          xOriginOld = tm.xOrigin; //record the original values before we alter them.
          yOriginOld = tm.yOrigin;
        }
        if(!absolute || (v = absolute.split(" ")).length < 2) {
          b = e.getBBox();
          local = _parsePosition(local).split(" ");
          v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x,
            (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y
          ];
        }
        decoratee.xOrigin = xOrigin = parseFloat(v[0]);
        decoratee.yOrigin = yOrigin = parseFloat(v[1]);
        if(absolute && m !== _identity2DMatrix) { //if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
          a = m[0];
          b = m[1];
          c = m[2];
          d = m[3];
          tx = m[4];
          ty = m[5];
          determinant = (a * d - b * c);
          x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
          y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
          xOrigin = decoratee.xOrigin = v[0] = x;
          yOrigin = decoratee.yOrigin = v[1] = y;
        }
        if(tm) { //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
          if(skipRecord) {
            decoratee.xOffset = tm.xOffset;
            decoratee.yOffset = tm.yOffset;
            tm = decoratee;
          }
          if(smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
            x = xOrigin - xOriginOld;
            y = yOrigin - yOriginOld;
            //originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
            //tm.x -= x - (x * m[0] + y * m[2]);
            //tm.y -= y - (x * m[1] + y * m[3]);
            tm.xOffset += (x * m[0] + y * m[2]) - x;
            tm.yOffset += (x * m[1] + y * m[3]) - y;
          } else {
            tm.xOffset = tm.yOffset = 0;
          }
        }
        if(!skipRecord) {
          e.setAttribute("data-svg-origin", v.join(" "));
        }
      },
      _canGetBBox = function(e) {
        try {
          return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
        } catch(e) {}
      },
      _isSVG = function(e) { //reports if the element is an SVG on which getBBox() actually works
        return !!(_SVGElement && e.getBBox && e.getCTM && _canGetBBox(e) && (!e.parentNode || (e.parentNode.getBBox && e.parentNode.getCTM)));
      },
      _identity2DMatrix = [1, 0, 0, 1, 0, 0],
      _getMatrix = function(e, force2D) {
        var tm = e._gsTransform || new Transform(),
          rnd = 100000,
          style = e.style,
          isDefault, s, m, n, dec, none;
        if(_transformProp) {
          s = _getStyle(e, _transformPropCSS, null, true);
        } else if(e.currentStyle) {
          //for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
          s = e.currentStyle.filter.match(_ieGetMatrixExp);
          s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
        }
        isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
        if(isDefault && _transformProp && ((none = (_getComputedStyle(e).display === "none")) || !e.parentNode)) {
          if(none) { //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none".
            n = style.display;
            style.display = "block";
          }
          if(!e.parentNode) {
            dec = 1; //flag
            _docElement.appendChild(e);
          }
          s = _getStyle(e, _transformPropCSS, null, true);
          isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
          if(n) {
            style.display = n;
          } else if(none) {
            _removeProp(style, "display");
          }
          if(dec) {
            _docElement.removeChild(e);
          }
        }
        if(tm.svg || (e.getBBox && _isSVG(e))) {
          if(isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
            s = style[_transformProp];
            isDefault = 0;
          }
          m = e.getAttribute("transform");
          if(isDefault && m) {
            if(m.indexOf("matrix") !== -1) { //just in case there's a "transform" value specified as an attribute instead of CSS style. Accept either a matrix() or simple translate() value though.
              s = m;
              isDefault = 0;
            } else if(m.indexOf("translate") !== -1) {
              s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
              isDefault = 0;
            }
          }
        }
        if(isDefault) {
          return _identity2DMatrix;
        }
        //split the matrix values out into an array (m for matrix)
        m = (s || "").match(_numExp) || [];
        i = m.length;
        while(--i > -1) {
          n = Number(m[i]);
          m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
        }
        return(force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
      },

      /**
       * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
       * @param {!Object} t target element
       * @param {Object=} cs computed style object (optional)
       * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
       * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
       * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
       */
      _getTransform = _internals.getTransform = function(t, cs, rec, parse) {
        if(t._gsTransform && rec && !parse) {
          return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
        }
        var tm = rec ? t._gsTransform || new Transform() : new Transform(),
          invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
          min = 0.00002,
          rnd = 100000,
          zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
          defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
          m, i, scaleX, scaleY, rotation, skewX;

        tm.svg = !!(t.getBBox && _isSVG(t));
        if(tm.svg) {
          _parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
          _useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
        }
        m = _getMatrix(t);
        if(m !== _identity2DMatrix) {

          if(m.length === 16) {
            //we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
            var a11 = m[0],
              a21 = m[1],
              a31 = m[2],
              a41 = m[3],
              a12 = m[4],
              a22 = m[5],
              a32 = m[6],
              a42 = m[7],
              a13 = m[8],
              a23 = m[9],
              a33 = m[10],
              a14 = m[12],
              a24 = m[13],
              a34 = m[14],
              a43 = m[11],
              angle = Math.atan2(a32, a33),
              t1, t2, t3, t4, cos, sin;

            //we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
            if(tm.zOrigin) {
              a34 = -tm.zOrigin;
              a14 = a13 * a34 - m[12];
              a24 = a23 * a34 - m[13];
              a34 = a33 * a34 + tm.zOrigin - m[14];
            }
            tm.rotationX = angle * _RAD2DEG;
            //rotationX
            if(angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a12 * cos + a13 * sin;
              t2 = a22 * cos + a23 * sin;
              t3 = a32 * cos + a33 * sin;
              a13 = a12 * -sin + a13 * cos;
              a23 = a22 * -sin + a23 * cos;
              a33 = a32 * -sin + a33 * cos;
              a43 = a42 * -sin + a43 * cos;
              a12 = t1;
              a22 = t2;
              a32 = t3;
            }
            //rotationY
            angle = Math.atan2(-a31, a33);
            tm.rotationY = angle * _RAD2DEG;
            if(angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a11 * cos - a13 * sin;
              t2 = a21 * cos - a23 * sin;
              t3 = a31 * cos - a33 * sin;
              a23 = a21 * sin + a23 * cos;
              a33 = a31 * sin + a33 * cos;
              a43 = a41 * sin + a43 * cos;
              a11 = t1;
              a21 = t2;
              a31 = t3;
            }
            //rotationZ
            angle = Math.atan2(a21, a11);
            tm.rotation = angle * _RAD2DEG;
            if(angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              a11 = a11 * cos + a12 * sin;
              t2 = a21 * cos + a22 * sin;
              a22 = a21 * -sin + a22 * cos;
              a32 = a31 * -sin + a32 * cos;
              a21 = t2;
            }

            if(tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
              tm.rotationX = tm.rotation = 0;
              tm.rotationY = 180 - tm.rotationY;
            }

            tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
            tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;
            tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;
            if(tm.rotationX || tm.rotationY) {
              tm.skewX = 0;
            } else {
              tm.skewX = (a12 || a22) ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0;
              if(Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
                if(invX) {
                  tm.scaleX *= -1;
                  tm.skewX += (tm.rotation <= 0) ? 180 : -180;
                  tm.rotation += (tm.rotation <= 0) ? 180 : -180;
                } else {
                  tm.scaleY *= -1;
                  tm.skewX += (tm.skewX <= 0) ? 180 : -180;
                }
              }
            }
            tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
            tm.x = a14;
            tm.y = a24;
            tm.z = a34;
            if(tm.svg) {
              tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
              tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
            }

          } else if((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY))) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
            var k = (m.length >= 6),
              a = k ? m[0] : 1,
              b = m[1] || 0,
              c = m[2] || 0,
              d = k ? m[3] : 1;
            tm.x = m[4] || 0;
            tm.y = m[5] || 0;
            scaleX = Math.sqrt(a * a + b * b);
            scaleY = Math.sqrt(d * d + c * c);
            rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
            skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
            if(Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
              if(invX) {
                scaleX *= -1;
                skewX += (rotation <= 0) ? 180 : -180;
                rotation += (rotation <= 0) ? 180 : -180;
              } else {
                scaleY *= -1;
                skewX += (skewX <= 0) ? 180 : -180;
              }
            }
            tm.scaleX = scaleX;
            tm.scaleY = scaleY;
            tm.rotation = rotation;
            tm.skewX = skewX;
            if(_supports3D) {
              tm.rotationX = tm.rotationY = tm.z = 0;
              tm.perspective = defaultTransformPerspective;
              tm.scaleZ = 1;
            }
            if(tm.svg) {
              tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
              tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
            }
          }
          tm.zOrigin = zOrigin;
          //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
          for(i in tm) {
            if(tm[i] < min)
              if(tm[i] > -min) {
                tm[i] = 0;
              }
          }
        }
        //DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
        if(rec) {
          t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
          if(tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
            if(_useSVGTransformAttr && t.style[_transformProp]) {
              TweenLite.delayedCall(0.001, function() { //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
                _removeProp(t.style, _transformProp);
              });
            } else if(!_useSVGTransformAttr && t.getAttribute("transform")) {
              TweenLite.delayedCall(0.001, function() {
                t.removeAttribute("transform");
              });
            }
          }
        }
        return tm;
      },

      //for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
      _setIETransformRatio = function(v) {
        var t = this.data, //refers to the element's _gsTransform object
          ang = -t.rotation * _DEG2RAD,
          skew = ang + t.skewX * _DEG2RAD,
          rnd = 100000,
          a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
          b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
          c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
          d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
          style = this.t.style,
          cs = this.t.currentStyle,
          filters, val;
        if(!cs) {
          return;
        }
        val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
        b = -c;
        c = -val;
        filters = cs.filter;
        style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
        var w = this.t.offsetWidth,
          h = this.t.offsetHeight,
          clip = (cs.position !== "absolute"),
          m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
          ox = t.x + (w * t.xPercent / 100),
          oy = t.y + (h * t.yPercent / 100),
          dx, dy;

        //if transformOrigin is being used, adjust the offset x and y
        if(t.ox != null) {
          dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
          dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
          ox += dx - (dx * a + dy * b);
          oy += dy - (dx * c + dy * d);
        }

        if(!clip) {
          m += ", sizingMethod='auto expand')";
        } else {
          dx = (w / 2);
          dy = (h / 2);
          //translate to ensure that transformations occur around the correct origin (default is center).
          m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
        }
        if(filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
          style.filter = filters.replace(_ieSetMatrixExp, m);
        } else {
          style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
        }

        //at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
        if(v === 0 || v === 1)
          if(a === 1)
            if(b === 0)
              if(c === 0)
                if(d === 1)
                  if(!clip || m.indexOf("Dx=0, Dy=0") !== -1)
                    if(!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100)
                      if(filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
                        style.removeAttribute("filter");
                      }

        //we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
        if(!clip) {
          var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
            marg, prop, dif;
          dx = t.ieOffsetX || 0;
          dy = t.ieOffsetY || 0;
          t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
          t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
          for(i = 0; i < 4; i++) {
            prop = _margins[i];
            marg = cs[prop];
            //we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
            val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
            if(val !== t[prop]) {
              dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
            } else {
              dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
            }
            style[prop] = (t[prop] = Math.round(val - dif * ((i === 0 || i === 2) ? 1 : mult))) + "px";
          }
        }
      },

      /* translates a super small decimal to a string WITHOUT scientific notation
      _safeDecimal = function(n) {
      	var s = (n < 0 ? -n : n) + "",
      		a = s.split("e-");
      	return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
      },
      */

      _setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
        var t = this.data, //refers to the element's _gsTransform object
          style = this.t.style,
          angle = t.rotation,
          rotationX = t.rotationX,
          rotationY = t.rotationY,
          sx = t.scaleX,
          sy = t.scaleY,
          sz = t.scaleZ,
          x = t.x,
          y = t.y,
          z = t.z,
          isSVG = t.svg,
          perspective = t.perspective,
          force3D = t.force3D,
          a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
          zOrigin, min, cos, sin, t1, t2, transform, comma, zero, skew, rnd;
        //check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
        if(((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

          //2D
          if(angle || t.skewX || isSVG) {
            angle *= _DEG2RAD;
            skew = t.skewX * _DEG2RAD;
            rnd = 100000;
            a11 = Math.cos(angle) * sx;
            a21 = Math.sin(angle) * sx;
            a12 = Math.sin(angle - skew) * -sy;
            a22 = Math.cos(angle - skew) * sy;
            if(skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
              t1 = Math.tan(skew - t.skewY * _DEG2RAD);
              t1 = Math.sqrt(1 + t1 * t1);
              a12 *= t1;
              a22 *= t1;
              if(t.skewY) {
                t1 = Math.tan(t.skewY * _DEG2RAD);
                t1 = Math.sqrt(1 + t1 * t1);
                a11 *= t1;
                a21 *= t1;
              }
            }
            if(isSVG) {
              x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
              y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
              if(_useSVGTransformAttr && (t.xPercent || t.yPercent)) { //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
                min = this.t.getBBox();
                x += t.xPercent * 0.01 * min.width;
                y += t.yPercent * 0.01 * min.height;
              }
              min = 0.000001;
              if(x < min)
                if(x > -min) {
                  x = 0;
                }
              if(y < min)
                if(y > -min) {
                  y = 0;
                }
            }
            transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
            if(isSVG && _useSVGTransformAttr) {
              this.t.setAttribute("transform", "matrix(" + transform);
            } else {
              //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
              style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
            }
          } else {
            style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
          }
          return;

        }
        if(_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
          min = 0.0001;
          if(sx < min && sx > -min) {
            sx = sz = 0.00002;
          }
          if(sy < min && sy > -min) {
            sy = sz = 0.00002;
          }
          if(perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
            perspective = 0;
          }
        }
        if(angle || t.skewX) {
          angle *= _DEG2RAD;
          cos = a11 = Math.cos(angle);
          sin = a21 = Math.sin(angle);
          if(t.skewX) {
            angle -= t.skewX * _DEG2RAD;
            cos = Math.cos(angle);
            sin = Math.sin(angle);
            if(t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
              t1 = Math.tan((t.skewX - t.skewY) * _DEG2RAD);
              t1 = Math.sqrt(1 + t1 * t1);
              cos *= t1;
              sin *= t1;
              if(t.skewY) {
                t1 = Math.tan(t.skewY * _DEG2RAD);
                t1 = Math.sqrt(1 + t1 * t1);
                a11 *= t1;
                a21 *= t1;
              }
            }
          }
          a12 = -sin;
          a22 = cos;

        } else if(!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) { //if we're only translating and/or 2D scaling, this is faster...
          style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
          return;
        } else {
          a11 = a22 = 1;
          a12 = a21 = 0;
        }
        // KEY  INDEX   AFFECTS
        // a11  0       rotation, rotationY, scaleX
        // a21  1       rotation, rotationY, scaleX
        // a31  2       rotationY, scaleX
        // a41  3       rotationY, scaleX
        // a12  4       rotation, skewX, rotationX, scaleY
        // a22  5       rotation, skewX, rotationX, scaleY
        // a32  6       rotationX, scaleY
        // a42  7       rotationX, scaleY
        // a13  8       rotationY, rotationX, scaleZ
        // a23  9       rotationY, rotationX, scaleZ
        // a33  10      rotationY, rotationX, scaleZ
        // a43  11      rotationY, rotationX, perspective, scaleZ
        // a14  12      x, zOrigin, svgOrigin
        // a24  13      y, zOrigin, svgOrigin
        // a34  14      z, zOrigin
        // a44  15
        // rotation: Math.atan2(a21, a11)
        // rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
        // rotationX: Math.atan2(a32, a33)
        a33 = 1;
        a13 = a23 = a31 = a32 = a41 = a42 = 0;
        a43 = (perspective) ? -1 / perspective : 0;
        zOrigin = t.zOrigin;
        min = 0.000001; //threshold below which browsers use scientific notation which won't work.
        comma = ",";
        zero = "0";
        angle = rotationY * _DEG2RAD;
        if(angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          a31 = -sin;
          a41 = a43 * -sin;
          a13 = a11 * sin;
          a23 = a21 * sin;
          a33 = cos;
          a43 *= cos;
          a11 *= cos;
          a21 *= cos;
        }
        angle = rotationX * _DEG2RAD;
        if(angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          a32 = a33 * sin;
          a42 = a43 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a33 * cos;
          a43 = a43 * cos;
          a12 = t1;
          a22 = t2;
        }
        if(sz !== 1) {
          a13 *= sz;
          a23 *= sz;
          a33 *= sz;
          a43 *= sz;
        }
        if(sy !== 1) {
          a12 *= sy;
          a22 *= sy;
          a32 *= sy;
          a42 *= sy;
        }
        if(sx !== 1) {
          a11 *= sx;
          a21 *= sx;
          a31 *= sx;
          a41 *= sx;
        }

        if(zOrigin || isSVG) {
          if(zOrigin) {
            x += a13 * -zOrigin;
            y += a23 * -zOrigin;
            z += a33 * -zOrigin + zOrigin;
          }
          if(isSVG) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
            x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
            y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
          }
          if(x < min && x > -min) {
            x = zero;
          }
          if(y < min && y > -min) {
            y = zero;
          }
          if(z < min && z > -min) {
            z = 0; //don't use string because we calculate perspective later and need the number.
          }
        }

        //optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
        transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
        transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
        transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
        if(rotationX || rotationY || sz !== 1) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
          transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
          transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
        } else {
          transform += ",0,0,0,0,1,0,";
        }
        transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

        style[_transformProp] = transform;
      };

    p = Transform.prototype;
    p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
    p.scaleX = p.scaleY = p.scaleZ = 1;

    _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
      parser: function(t, e, parsingProp, cssp, pt, plugin, vars) {
        if(cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
        cssp._lastParsedTransform = vars;
        var swapFunc;
        if(typeof(vars[parsingProp]) === "function") { //whatever property triggers the initial parsing might be a function-based value in which case it already got called in parse(), thus we don't want to call it again in here. The most efficient way to avoid this is to temporarily swap the value directly into the vars object, and then after we do all our parsing in this function, we'll swap it back again.
          swapFunc = vars[parsingProp];
          vars[parsingProp] = e;
        }
        var originalGSTransform = t._gsTransform,
          style = t.style,
          min = 0.000001,
          i = _transformProps.length,
          v = vars,
          endRotations = {},
          transformOriginString = "transformOrigin",
          m1 = _getTransform(t, _cs, true, v.parseTransform),
          orig = v.transform && ((typeof(v.transform) === "function") ? v.transform(_index, _target) : v.transform),
          m2, copy, has3D, hasChange, dr, x, y, matrix, p;
        cssp._transform = m1;
        if(orig && typeof(orig) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
          copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
          copy[_transformProp] = orig;
          copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
          copy.position = "absolute";
          _doc.body.appendChild(_tempDiv);
          m2 = _getTransform(_tempDiv, null, false);
          if(m1.svg) { //if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
            x = m1.xOrigin;
            y = m1.yOrigin;
            m2.x -= m1.xOffset;
            m2.y -= m1.yOffset;
            if(v.transformOrigin || v.svgOrigin) { //if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
              orig = {};
              _parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
              x = orig.xOrigin;
              y = orig.yOrigin;
              m2.x -= orig.xOffset - m1.xOffset;
              m2.y -= orig.yOffset - m1.yOffset;
            }
            if(x || y) {
              matrix = _getMatrix(_tempDiv, true);
              m2.x -= x - (x * matrix[0] + y * matrix[2]);
              m2.y -= y - (x * matrix[1] + y * matrix[3]);
            }
          }
          _doc.body.removeChild(_tempDiv);
          if(!m2.perspective) {
            m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
          }
          if(v.xPercent != null) {
            m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
          }
          if(v.yPercent != null) {
            m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
          }
        } else if(typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
          m2 = {
            scaleX: _parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
            scaleY: _parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
            scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
            x: _parseVal(v.x, m1.x),
            y: _parseVal(v.y, m1.y),
            z: _parseVal(v.z, m1.z),
            xPercent: _parseVal(v.xPercent, m1.xPercent),
            yPercent: _parseVal(v.yPercent, m1.yPercent),
            perspective: _parseVal(v.transformPerspective, m1.perspective)
          };
          dr = v.directionalRotation;
          if(dr != null) {
            if(typeof(dr) === "object") {
              for(copy in dr) {
                v[copy] = dr[copy];
              }
            } else {
              v.rotation = dr;
            }
          }
          if(typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
            m2.x = 0;
            m2.xPercent = _parseVal(v.x, m1.xPercent);
          }
          if(typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
            m2.y = 0;
            m2.yPercent = _parseVal(v.y, m1.yPercent);
          }

          m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation - m1.skewY, m1.rotation - m1.skewY, "rotation", endRotations); //see notes below about skewY for why we subtract it from rotation here
          if(_supports3D) {
            m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
            m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
          }
          m2.skewX = _parseAngle(v.skewX, m1.skewX - m1.skewY); //see notes below about skewY and why we subtract it from skewX here

          //note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
          if((m2.skewY = _parseAngle(v.skewY, m1.skewY))) {
            m2.skewX += m2.skewY;
            m2.rotation += m2.skewY;
          }
        }
        if(_supports3D && v.force3D != null) {
          m1.force3D = v.force3D;
          hasChange = true;
        }

        m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

        has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
        if(!has3D && v.scale != null) {
          m2.scaleZ = 1; //no need to tween scaleZ.
        }

        while(--i > -1) {
          p = _transformProps[i];
          orig = m2[p] - m1[p];
          if(orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
            hasChange = true;
            pt = new CSSPropTween(m1, p, m1[p], orig, pt);
            if(p in endRotations) {
              pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
            }
            pt.xs0 = 0; //ensures the value stays numeric in setRatio()
            pt.plugin = plugin;
            cssp._overwriteProps.push(pt.n);
          }
        }

        orig = v.transformOrigin;
        if(m1.svg && (orig || v.svgOrigin)) {
          x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
          y = m1.yOffset;
          _parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
          pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
          pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
          if(x !== m1.xOffset || y !== m1.yOffset) {
            pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
            pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
          }
          orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
        }
        if(orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
          if(_transformProp) {
            hasChange = true;
            p = _transformOriginProp;
            orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
            pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
            pt.b = style[p];
            pt.plugin = plugin;
            if(_supports3D) {
              copy = m1.zOrigin;
              orig = orig.split(" ");
              m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
              pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
              pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
              pt.b = copy;
              pt.xs0 = pt.e = m1.zOrigin;
            } else {
              pt.xs0 = pt.e = orig;
            }

            //for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
          } else {
            _parsePosition(orig + "", m1);
          }
        }
        if(hasChange) {
          cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
        }
        if(swapFunc) {
          vars[parsingProp] = swapFunc;
        }
        return pt;
      },
      prefix: true
    });

    _registerComplexSpecialProp("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: true, color: true, multi: true, keyword: "inset" });

    _registerComplexSpecialProp("borderRadius", {
      defaultValue: "0px",
      parser: function(t, e, p, cssp, pt, plugin) {
        e = this.format(e);
        var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
          style = t.style,
          ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
        w = parseFloat(t.offsetWidth);
        h = parseFloat(t.offsetHeight);
        ea1 = e.split(" ");
        for(i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
          if(this.p.indexOf("border")) { //older browsers used a prefix
            props[i] = _checkPropPrefix(props[i]);
          }
          bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
          if(bs.indexOf(" ") !== -1) {
            bs2 = bs.split(" ");
            bs = bs2[0];
            bs2 = bs2[1];
          }
          es = es2 = ea1[i];
          bn = parseFloat(bs);
          bsfx = bs.substr((bn + "").length);
          rel = (es.charAt(1) === "=");
          if(rel) {
            en = parseInt(es.charAt(0) + "1", 10);
            es = es.substr(2);
            en *= parseFloat(es);
            esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
          } else {
            en = parseFloat(es);
            esfx = es.substr((en + "").length);
          }
          if(esfx === "") {
            esfx = _suffixMap[p] || bsfx;
          }
          if(esfx !== bsfx) {
            hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
            vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
            if(esfx === "%") {
              bs = (hn / w * 100) + "%";
              bs2 = (vn / h * 100) + "%";
            } else if(esfx === "em") {
              em = _convertToPixels(t, "borderLeft", 1, "em");
              bs = (hn / em) + "em";
              bs2 = (vn / em) + "em";
            } else {
              bs = hn + "px";
              bs2 = vn + "px";
            }
            if(rel) {
              es = (parseFloat(bs) + en) + esfx;
              es2 = (parseFloat(bs2) + en) + esfx;
            }
          }
          pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
        }
        return pt;
      },
      prefix: true,
      formatter: _getFormatter("0px 0px 0px 0px", false, true)
    });
    _registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
      defaultValue: "0px",
      parser: function(t, e, p, cssp, pt, plugin) {
        return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
      },
      prefix: true,
      formatter: _getFormatter("0px 0px", false, true)
    });
    _registerComplexSpecialProp("backgroundPosition", {
      defaultValue: "0 0",
      parser: function(t, e, p, cssp, pt, plugin) {
        var bp = "background-position",
          cs = (_cs || _getComputedStyle(t, null)),
          bs = this.format(((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
          es = this.format(e),
          ba, ea, i, pct, overlap, src;
        if((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
          src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
          if(src && src !== "none") {
            ba = bs.split(" ");
            ea = es.split(" ");
            _tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
            i = 2;
            while(--i > -1) {
              bs = ba[i];
              pct = (bs.indexOf("%") !== -1);
              if(pct !== (ea[i].indexOf("%") !== -1)) {
                overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
                ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
              }
            }
            bs = ba.join(" ");
          }
        }
        return this.parseComplex(t.style, bs, es, pt, plugin);
      },
      formatter: _parsePosition
    });
    _registerComplexSpecialProp("backgroundSize", {
      defaultValue: "0 0",
      formatter: function(v) {
        v += ""; //ensure it's a string
        return _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v); //if set to something like "100% 100%", Safari typically reports the computed style as just "100%" (no 2nd value), but we should ensure that there are two values, so copy the first one. Otherwise, it'd be interpreted as "100% 0" (wrong).
      }
    });
    _registerComplexSpecialProp("perspective", { defaultValue: "0px", prefix: true });
    _registerComplexSpecialProp("perspectiveOrigin", { defaultValue: "50% 50%", prefix: true });
    _registerComplexSpecialProp("transformStyle", { prefix: true });
    _registerComplexSpecialProp("backfaceVisibility", { prefix: true });
    _registerComplexSpecialProp("userSelect", { prefix: true });
    _registerComplexSpecialProp("margin", { parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft") });
    _registerComplexSpecialProp("padding", { parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft") });
    _registerComplexSpecialProp("clip", {
      defaultValue: "rect(0px,0px,0px,0px)",
      parser: function(t, e, p, cssp, pt, plugin) {
        var b, cs, delim;
        if(_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
          cs = t.currentStyle;
          delim = _ieVers < 8 ? " " : ",";
          b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
          e = this.format(e).split(",").join(delim);
        } else {
          b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
          e = this.format(e);
        }
        return this.parseComplex(t.style, b, e, pt, plugin);
      }
    });
    _registerComplexSpecialProp("textShadow", { defaultValue: "0px 0px 0px #999", color: true, multi: true });
    _registerComplexSpecialProp("autoRound,strictUnits", { parser: function(t, e, p, cssp, pt) { return pt; } }); //just so that we can ignore these properties (not tween them)
    _registerComplexSpecialProp("border", {
      defaultValue: "0px solid #000",
      parser: function(t, e, p, cssp, pt, plugin) {
        var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
          end = this.format(e).split(" "),
          esfx = end[0].replace(_suffixExp, "");
        if(esfx !== "px") { //if we're animating to a non-px value, we need to convert the beginning width to that unit.
          bw = (parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx)) + esfx;
        }
        return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
      },
      color: true,
      formatter: function(v) {
        var a = v.split(" ");
        return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
      }
    });
    _registerComplexSpecialProp("borderWidth", { parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
    _registerComplexSpecialProp("float,cssFloat,styleFloat", {
      parser: function(t, e, p, cssp, pt, plugin) {
        var s = t.style,
          prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
        return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
      }
    });

    //opacity-related
    var _setIEOpacityRatio = function(v) {
      var t = this.t, //refers to the element's style property
        filters = t.filter || _getStyle(this.data, "filter") || "",
        val = (this.s + this.c * v) | 0,
        skip;
      if(val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
        if(filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
          t.removeAttribute("filter");
          skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
        } else {
          t.filter = filters.replace(_alphaFilterExp, "");
          skip = true;
        }
      }
      if(!skip) {
        if(this.xn1) {
          t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
        }
        if(filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
          if(val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
            t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
          }
        } else {
          t.filter = filters.replace(_opacityExp, "opacity=" + val);
        }
      }
    };
    _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
      defaultValue: "1",
      parser: function(t, e, p, cssp, pt, plugin) {
        var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
          style = t.style,
          isAutoAlpha = (p === "autoAlpha");
        if(typeof(e) === "string" && e.charAt(1) === "=") {
          e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
        }
        if(isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
          b = 0;
        }
        if(_supportsOpacity) {
          pt = new CSSPropTween(style, "opacity", b, e - b, pt);
        } else {
          pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
          pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
          style.zoom = 1; //helps correct an IE issue.
          pt.type = 2;
          pt.b = "alpha(opacity=" + pt.s + ")";
          pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
          pt.data = t;
          pt.plugin = plugin;
          pt.setRatio = _setIEOpacityRatio;
        }
        if(isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
          pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
          pt.xs0 = "inherit";
          cssp._overwriteProps.push(pt.n);
          cssp._overwriteProps.push(p);
        }
        return pt;
      }
    });


    var _removeProp = function(s, p) {
        if(p) {
          if(s.removeProperty) {
            if(p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
              p = "-" + p;
            }
            s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
          } else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
            s.removeAttribute(p);
          }
        }
      },
      _setClassNameRatio = function(v) {
        this.t._gsClassPT = this;
        if(v === 1 || v === 0) {
          this.t.setAttribute("class", (v === 0) ? this.b : this.e);
          var mpt = this.data, //first MiniPropTween
            s = this.t.style;
          while(mpt) {
            if(!mpt.v) {
              _removeProp(s, mpt.p);
            } else {
              s[mpt.p] = mpt.v;
            }
            mpt = mpt._next;
          }
          if(v === 1 && this.t._gsClassPT === this) {
            this.t._gsClassPT = null;
          }
        } else if(this.t.getAttribute("class") !== this.e) {
          this.t.setAttribute("class", this.e);
        }
      };
    _registerComplexSpecialProp("className", {
      parser: function(t, e, p, cssp, pt, plugin, vars) {
        var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
          cssText = t.style.cssText,
          difData, bs, cnpt, cnptLookup, mpt;
        pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
        pt.setRatio = _setClassNameRatio;
        pt.pr = -11;
        _hasPriority = true;
        pt.b = b;
        bs = _getAllStyles(t, _cs);
        //if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
        cnpt = t._gsClassPT;
        if(cnpt) {
          cnptLookup = {};
          mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
          while(mpt) {
            cnptLookup[mpt.p] = 1;
            mpt = mpt._next;
          }
          cnpt.setRatio(1);
        }
        t._gsClassPT = pt;
        pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
        t.setAttribute("class", pt.e);
        difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
        t.setAttribute("class", b);
        pt.data = difData.firstMPT;
        t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
        pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
        return pt;
      }
    });


    var _setClearPropsRatio = function(v) {
      if(v === 1 || v === 0)
        if(this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
          var s = this.t.style,
            transformParse = _specialProps.transform.parse,
            a, p, i, clearTransform, transform;
          if(this.e === "all") {
            s.cssText = "";
            clearTransform = true;
          } else {
            a = this.e.split(" ").join("").split(",");
            i = a.length;
            while(--i > -1) {
              p = a[i];
              if(_specialProps[p]) {
                if(_specialProps[p].parse === transformParse) {
                  clearTransform = true;
                } else {
                  p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
                }
              }
              _removeProp(s, p);
            }
          }
          if(clearTransform) {
            _removeProp(s, _transformProp);
            transform = this.t._gsTransform;
            if(transform) {
              if(transform.svg) {
                this.t.removeAttribute("data-svg-origin");
                this.t.removeAttribute("transform");
              }
              delete this.t._gsTransform;
            }
          }

        }
    };
    _registerComplexSpecialProp("clearProps", {
      parser: function(t, e, p, cssp, pt) {
        pt = new CSSPropTween(t, p, 0, 0, pt, 2);
        pt.setRatio = _setClearPropsRatio;
        pt.e = e;
        pt.pr = -10;
        pt.data = cssp._tween;
        _hasPriority = true;
        return pt;
      }
    });

    p = "bezier,throwProps,physicsProps,physics2D".split(",");
    i = p.length;
    while(i--) {
      _registerPluginProp(p[i]);
    }








    p = CSSPlugin.prototype;
    p._firstPT = p._lastParsedTransform = p._transform = null;

    //gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
    p._onInitTween = function(target, vars, tween, index) {
      if(!target.nodeType) { //css is only for dom elements
        return false;
      }
      this._target = _target = target;
      this._tween = tween;
      this._vars = vars;
      _index = index;
      _autoRound = vars.autoRound;
      _hasPriority = false;
      _suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
      _cs = _getComputedStyle(target, "");
      _overwriteProps = this._overwriteProps;
      var style = target.style,
        v, pt, pt2, first, last, next, zIndex, tpt, threeD;
      if(_reqSafariFix)
        if(style.zIndex === "") {
          v = _getStyle(target, "zIndex", _cs);
          if(v === "auto" || v === "") {
            //corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
            this._addLazySet(style, "zIndex", 0);
          }
        }

      if(typeof(vars) === "string") {
        first = style.cssText;
        v = _getAllStyles(target, _cs);
        style.cssText = first + ";" + vars;
        v = _cssDif(target, v, _getAllStyles(target)).difs;
        if(!_supportsOpacity && _opacityValExp.test(vars)) {
          v.opacity = parseFloat(RegExp.$1);
        }
        vars = v;
        style.cssText = first;
      }

      if(vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
        this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
      } else {
        this._firstPT = pt = this.parse(target, vars, null);
      }

      if(this._transformType) {
        threeD = (this._transformType === 3);
        if(!_transformProp) {
          style.zoom = 1; //helps correct an IE issue.
        } else if(_isSafari) {
          _reqSafariFix = true;
          //if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
          if(style.zIndex === "") {
            zIndex = _getStyle(target, "zIndex", _cs);
            if(zIndex === "auto" || zIndex === "") {
              this._addLazySet(style, "zIndex", 0);
            }
          }
          //Setting WebkitBackfaceVisibility corrects 3 bugs:
          // 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
          // 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
          // 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
          //Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
          if(_isSafariLT6) {
            this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
          }
        }
        pt2 = pt;
        while(pt2 && pt2._next) {
          pt2 = pt2._next;
        }
        tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
        this._linkCSSP(tpt, null, pt2);
        tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
        tpt.data = this._transform || _getTransform(target, _cs, true);
        tpt.tween = tween;
        tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
        _overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
      }

      if(_hasPriority) {
        //reorders the linked list in order of pr (priority)
        while(pt) {
          next = pt._next;
          pt2 = first;
          while(pt2 && pt2.pr > pt.pr) {
            pt2 = pt2._next;
          }
          if((pt._prev = pt2 ? pt2._prev : last)) {
            pt._prev._next = pt;
          } else {
            first = pt;
          }
          if((pt._next = pt2)) {
            pt2._prev = pt;
          } else {
            last = pt;
          }
          pt = next;
        }
        this._firstPT = first;
      }
      return true;
    };


    p.parse = function(target, vars, pt, plugin) {
      var style = target.style,
        p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
      for(p in vars) {
        es = vars[p]; //ending value string
        if(typeof(es) === "function") {
          es = es(_index, _target);
        }
        sp = _specialProps[p]; //SpecialProp lookup.
        if(sp) {
          pt = sp.parse(target, es, p, this, pt, plugin, vars);

        } else {
          bs = _getStyle(target, p, _cs) + "";
          isStr = (typeof(es) === "string");
          if(p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
            if(!isStr) {
              es = _parseColor(es);
              es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
            }
            pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

          } else if(isStr && _complexExp.test(es)) {
            pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

          } else {
            bn = parseFloat(bs);
            bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

            if(bs === "" || bs === "auto") {
              if(p === "width" || p === "height") {
                bn = _getDimension(target, p, _cs);
                bsfx = "px";
              } else if(p === "left" || p === "top") {
                bn = _calculateOffset(target, p, _cs);
                bsfx = "px";
              } else {
                bn = (p !== "opacity") ? 0 : 1;
                bsfx = "";
              }
            }

            rel = (isStr && es.charAt(1) === "=");
            if(rel) {
              en = parseInt(es.charAt(0) + "1", 10);
              es = es.substr(2);
              en *= parseFloat(es);
              esfx = es.replace(_suffixExp, "");
            } else {
              en = parseFloat(es);
              esfx = isStr ? es.replace(_suffixExp, "") : "";
            }

            if(esfx === "") {
              esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
            }

            es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

            //if the beginning/ending suffixes don't match, normalize them...
            if(bsfx !== esfx)
              if(esfx !== "")
                if(en || en === 0)
                  if(bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
                    bn = _convertToPixels(target, p, bn, bsfx);
                    if(esfx === "%") {
                      bn /= _convertToPixels(target, p, 100, "%") / 100;
                      if(vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
                        bs = bn + "%";
                      }

                    } else if(esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
                      bn /= _convertToPixels(target, p, 1, esfx);

                      //otherwise convert to pixels.
                    } else if(esfx !== "px") {
                      en = _convertToPixels(target, p, en, esfx);
                      esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
                    }
                    if(rel)
                      if(en || en === 0) {
                        es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
                      }
                  }

            if(rel) {
              en += bn;
            }

            if((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
              pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
              pt.xs0 = esfx;
              //DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
            } else if(style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
              _log("invalid " + p + " tween value: " + vars[p]);
            } else {
              pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
              pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
              //DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
            }
          }
        }
        if(plugin)
          if(pt && !pt.plugin) {
            pt.plugin = plugin;
          }
      }
      return pt;
    };


    //gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
    p.setRatio = function(v) {
      var pt = this._firstPT,
        min = 0.000001,
        val, str, i;
      //at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
      if(v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
        while(pt) {
          if(pt.type !== 2) {
            if(pt.r && pt.type !== -1) {
              val = Math.round(pt.s + pt.c);
              if(!pt.type) {
                pt.t[pt.p] = val + pt.xs0;
              } else if(pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
                i = pt.l;
                str = pt.xs0 + val + pt.xs1;
                for(i = 1; i < pt.l; i++) {
                  str += pt["xn" + i] + pt["xs" + (i + 1)];
                }
                pt.t[pt.p] = str;
              }
            } else {
              pt.t[pt.p] = pt.e;
            }
          } else {
            pt.setRatio(v);
          }
          pt = pt._next;
        }

      } else if(v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
        while(pt) {
          val = pt.c * v + pt.s;
          if(pt.r) {
            val = Math.round(val);
          } else if(val < min)
            if(val > -min) {
              val = 0;
            }
          if(!pt.type) {
            pt.t[pt.p] = val + pt.xs0;
          } else if(pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
            i = pt.l;
            if(i === 2) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
            } else if(i === 3) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
            } else if(i === 4) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
            } else if(i === 5) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
            } else {
              str = pt.xs0 + val + pt.xs1;
              for(i = 1; i < pt.l; i++) {
                str += pt["xn" + i] + pt["xs" + (i + 1)];
              }
              pt.t[pt.p] = str;
            }

          } else if(pt.type === -1) { //non-tweening value
            pt.t[pt.p] = pt.xs0;

          } else if(pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
            pt.setRatio(v);
          }
          pt = pt._next;
        }

        //if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
      } else {
        while(pt) {
          if(pt.type !== 2) {
            pt.t[pt.p] = pt.b;
          } else {
            pt.setRatio(v);
          }
          pt = pt._next;
        }
      }
    };

    /**
     * @private
     * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
     * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
     * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
     * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
     * doesn't have any transform-related properties of its own. You can call this method as many times as you
     * want and it won't create duplicate CSSPropTweens.
     *
     * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
     */
    p._enableTransforms = function(threeD) {
      this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
      this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
    };

    var lazySet = function(v) {
      this.t[this.p] = this.e;
      this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
    };
    /** @private Gives us a way to set a value on the first render (and only the first render). **/
    p._addLazySet = function(t, p, v) {
      var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
      pt.e = v;
      pt.setRatio = lazySet;
      pt.data = this;
    };

    /** @private **/
    p._linkCSSP = function(pt, next, prev, remove) {
      if(pt) {
        if(next) {
          next._prev = pt;
        }
        if(pt._next) {
          pt._next._prev = pt._prev;
        }
        if(pt._prev) {
          pt._prev._next = pt._next;
        } else if(this._firstPT === pt) {
          this._firstPT = pt._next;
          remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
        }
        if(prev) {
          prev._next = pt;
        } else if(!remove && this._firstPT === null) {
          this._firstPT = pt;
        }
        pt._next = next;
        pt._prev = prev;
      }
      return pt;
    };

    p._mod = function(lookup) {
      var pt = this._firstPT;
      while(pt) {
        if(typeof(lookup[pt.p]) === "function" && lookup[pt.p] === Math.round) { //only gets called by RoundPropsPlugin (ModifyPlugin manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently in this plugin for performance reasons, leveraging "r" as an indicator that the value should be rounded internally..
          pt.r = 1;
        }
        pt = pt._next;
      }
    };

    //we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
    p._kill = function(lookup) {
      var copy = lookup,
        pt, p, xfirst;
      if(lookup.autoAlpha || lookup.alpha) {
        copy = {};
        for(p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
          copy[p] = lookup[p];
        }
        copy.opacity = 1;
        if(copy.autoAlpha) {
          copy.visibility = 1;
        }
      }
      if(lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
        xfirst = pt.xfirst;
        if(xfirst && xfirst._prev) {
          this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
        } else if(xfirst === this._firstPT) {
          this._firstPT = pt._next;
        }
        if(pt._next) {
          this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
        }
        this._classNamePT = null;
      }
      pt = this._firstPT;
      while(pt) {
        if(pt.plugin && pt.plugin !== p && pt.plugin._kill) { //for plugins that are registered with CSSPlugin, we should notify them of the kill.
          pt.plugin._kill(lookup);
          p = pt.plugin;
        }
        pt = pt._next;
      }
      return TweenPlugin.prototype._kill.call(this, copy);
    };



    //used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
    var _getChildStyles = function(e, props, targets) {
      var children, i, child, type;
      if(e.slice) {
        i = e.length;
        while(--i > -1) {
          _getChildStyles(e[i], props, targets);
        }
        return;
      }
      children = e.childNodes;
      i = children.length;
      while(--i > -1) {
        child = children[i];
        type = child.type;
        if(child.style) {
          props.push(_getAllStyles(child));
          if(targets) {
            targets.push(child);
          }
        }
        if((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
          _getChildStyles(child, props, targets);
        }
      }
    };

    /**
     * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
     * and then compares the style properties of all the target's child elements at the tween's start and end, and
     * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
     * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
     * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
     * is because it creates entirely new tweens that may have completely different targets than the original tween,
     * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
     * and it would create other problems. For example:
     *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
     *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
     *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
     *
     * @param {Object} target object to be tweened
     * @param {number} Duration in seconds (or frames for frames-based tweens)
     * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
     * @return {Array} An array of TweenLite instances
     */
    CSSPlugin.cascadeTo = function(target, duration, vars) {
      var tween = TweenLite.to(target, duration, vars),
        results = [tween],
        b = [],
        e = [],
        targets = [],
        _reservedProps = TweenLite._internals.reservedProps,
        i, difs, p, from;
      target = tween._targets || tween.target;
      _getChildStyles(target, b, targets);
      tween.render(duration, true, true);
      _getChildStyles(target, e);
      tween.render(0, true, true);
      tween._enabled(true);
      i = targets.length;
      while(--i > -1) {
        difs = _cssDif(targets[i], b[i], e[i]);
        if(difs.firstMPT) {
          difs = difs.difs;
          for(p in vars) {
            if(_reservedProps[p]) {
              difs[p] = vars[p];
            }
          }
          from = {};
          for(p in difs) {
            from[p] = b[i][p];
          }
          results.push(TweenLite.fromTo(targets[i], duration, from, difs));
        }
      }
      return results;
    };

    TweenPlugin.activate([CSSPlugin]);
    return CSSPlugin;

  }, true);











  /*
   * ----------------------------------------------------------------
   * RoundPropsPlugin
   * ----------------------------------------------------------------
   */
  (function() {

    var RoundPropsPlugin = _gsScope._gsDefine.plugin({
        propName: "roundProps",
        version: "1.6.0",
        priority: -1,
        API: 2,

        //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
        init: function(target, value, tween) {
          this._tween = tween;
          return true;
        }

      }),
      _roundLinkedList = function(node) {
        while(node) {
          if(!node.f && !node.blob) {
            node.m = Math.round;
          }
          node = node._next;
        }
      },
      p = RoundPropsPlugin.prototype;

    p._onInitAllProps = function() {
      var tween = this._tween,
        rp = (tween.vars.roundProps.join) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
        i = rp.length,
        lookup = {},
        rpt = tween._propLookup.roundProps,
        prop, pt, next;
      while(--i > -1) {
        lookup[rp[i]] = Math.round;
      }
      i = rp.length;
      while(--i > -1) {
        prop = rp[i];
        pt = tween._firstPT;
        while(pt) {
          next = pt._next; //record here, because it may get removed
          if(pt.pg) {
            pt.t._mod(lookup);
          } else if(pt.n === prop) {
            if(pt.f === 2 && pt.t) { //a blob (text containing multiple numeric values)
              _roundLinkedList(pt.t._firstPT);
            } else {
              this._add(pt.t, prop, pt.s, pt.c);
              //remove from linked list
              if(next) {
                next._prev = pt._prev;
              }
              if(pt._prev) {
                pt._prev._next = next;
              } else if(tween._firstPT === pt) {
                tween._firstPT = next;
              }
              pt._next = pt._prev = null;
              tween._propLookup[prop] = rpt;
            }
          }
          pt = next;
        }
      }
      return false;
    };

    p._add = function(target, p, s, c) {
      this._addTween(target, p, s, s + c, p, Math.round);
      this._overwriteProps.push(p);
    };

  }());










  /*
   * ----------------------------------------------------------------
   * AttrPlugin
   * ----------------------------------------------------------------
   */

  (function() {

    _gsScope._gsDefine.plugin({
      propName: "attr",
      API: 2,
      version: "0.6.0",

      //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
      init: function(target, value, tween, index) {
        var p, end;
        if(typeof(target.setAttribute) !== "function") {
          return false;
        }
        for(p in value) {
          end = value[p];
          if(typeof(end) === "function") {
            end = end(index, target);
          }
          this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
          this._overwriteProps.push(p);
        }
        return true;
      }

    });

  }());










  /*
   * ----------------------------------------------------------------
   * DirectionalRotationPlugin
   * ----------------------------------------------------------------
   */
  _gsScope._gsDefine.plugin({
    propName: "directionalRotation",
    version: "0.3.0",
    API: 2,

    //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
    init: function(target, value, tween, index) {
      if(typeof(value) !== "object") {
        value = { rotation: value };
      }
      this.finals = {};
      var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
        min = 0.000001,
        p, v, start, end, dif, split;
      for(p in value) {
        if(p !== "useRadians") {
          end = value[p];
          if(typeof(end) === "function") {
            end = end(index, target);
          }
          split = (end + "").split("_");
          v = split[0];
          start = parseFloat((typeof(target[p]) !== "function") ? target[p] : target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))]());
          end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
          dif = end - start;
          if(split.length) {
            v = split.join("_");
            if(v.indexOf("short") !== -1) {
              dif = dif % cap;
              if(dif !== dif % (cap / 2)) {
                dif = (dif < 0) ? dif + cap : dif - cap;
              }
            }
            if(v.indexOf("_cw") !== -1 && dif < 0) {
              dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
            } else if(v.indexOf("ccw") !== -1 && dif > 0) {
              dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
            }
          }
          if(dif > min || dif < -min) {
            this._addTween(target, p, start, start + dif, p);
            this._overwriteProps.push(p);
          }
        }
      }
      return true;
    },

    //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
    set: function(ratio) {
      var pt;
      if(ratio !== 1) {
        this._super.setRatio.call(this, ratio);
      } else {
        pt = this._firstPT;
        while(pt) {
          if(pt.f) {
            pt.t[pt.p](this.finals[pt.p]);
          } else {
            pt.t[pt.p] = this.finals[pt.p];
          }
          pt = pt._next;
        }
      }
    }

  })._autoCSS = true;











  /*
   * ----------------------------------------------------------------
   * EasePack
   * ----------------------------------------------------------------
   */
  _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {

    var w = (_gsScope.GreenSockGlobals || _gsScope),
      gs = w.com.greensock,
      _2PI = Math.PI * 2,
      _HALF_PI = Math.PI / 2,
      _class = gs._class,
      _create = function(n, f) {
        var C = _class("easing." + n, function() {}, true),
          p = C.prototype = new Ease();
        p.constructor = C;
        p.getRatio = f;
        return C;
      },
      _easeReg = Ease.register || function() {}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
      _wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
        var C = _class("easing." + name, {
          easeOut: new EaseOut(),
          easeIn: new EaseIn(),
          easeInOut: new EaseInOut()
        }, true);
        _easeReg(C, name);
        return C;
      },
      EasePoint = function(time, value, next) {
        this.t = time;
        this.v = value;
        if(next) {
          this.next = next;
          next.prev = this;
          this.c = next.v - value;
          this.gap = next.t - time;
        }
      },

      //Back
      _createBack = function(n, f) {
        var C = _class("easing." + n, function(overshoot) {
            this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
            this._p2 = this._p1 * 1.525;
          }, true),
          p = C.prototype = new Ease();
        p.constructor = C;
        p.getRatio = f;
        p.config = function(overshoot) {
          return new C(overshoot);
        };
        return C;
      },

      Back = _wrap("Back",
        _createBack("BackOut", function(p) {
          return((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
        }),
        _createBack("BackIn", function(p) {
          return p * p * ((this._p1 + 1) * p - this._p1);
        }),
        _createBack("BackInOut", function(p) {
          return((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
        })
      ),


      //SlowMo
      SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
        power = (power || power === 0) ? power : 0.7;
        if(linearRatio == null) {
          linearRatio = 0.7;
        } else if(linearRatio > 1) {
          linearRatio = 1;
        }
        this._p = (linearRatio !== 1) ? power : 0;
        this._p1 = (1 - linearRatio) / 2;
        this._p2 = linearRatio;
        this._p3 = this._p1 + this._p2;
        this._calcEnd = (yoyoMode === true);
      }, true),
      p = SlowMo.prototype = new Ease(),
      SteppedEase, RoughEase, _createElastic;

    p.constructor = SlowMo;
    p.getRatio = function(p) {
      var r = p + (0.5 - p) * this._p;
      if(p < this._p1) {
        return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
      } else if(p > this._p3) {
        return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
      }
      return this._calcEnd ? 1 : r;
    };
    SlowMo.ease = new SlowMo(0.7, 0.7);

    p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
      return new SlowMo(linearRatio, power, yoyoMode);
    };


    //SteppedEase
    SteppedEase = _class("easing.SteppedEase", function(steps) {
      steps = steps || 1;
      this._p1 = 1 / steps;
      this._p2 = steps + 1;
    }, true);
    p = SteppedEase.prototype = new Ease();
    p.constructor = SteppedEase;
    p.getRatio = function(p) {
      if(p < 0) {
        p = 0;
      } else if(p >= 1) {
        p = 0.999999999;
      }
      return((this._p2 * p) >> 0) * this._p1;
    };
    p.config = SteppedEase.config = function(steps) {
      return new SteppedEase(steps);
    };


    //RoughEase
    RoughEase = _class("easing.RoughEase", function(vars) {
      vars = vars || {};
      var taper = vars.taper || "none",
        a = [],
        cnt = 0,
        points = (vars.points || 20) | 0,
        i = points,
        randomize = (vars.randomize !== false),
        clamp = (vars.clamp === true),
        template = (vars.template instanceof Ease) ? vars.template : null,
        strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
        x, y, bump, invX, obj, pnt;
      while(--i > -1) {
        x = randomize ? Math.random() : (1 / points) * i;
        y = template ? template.getRatio(x) : x;
        if(taper === "none") {
          bump = strength;
        } else if(taper === "out") {
          invX = 1 - x;
          bump = invX * invX * strength;
        } else if(taper === "in") {
          bump = x * x * strength;
        } else if(x < 0.5) { //"both" (start)
          invX = x * 2;
          bump = invX * invX * 0.5 * strength;
        } else { //"both" (end)
          invX = (1 - x) * 2;
          bump = invX * invX * 0.5 * strength;
        }
        if(randomize) {
          y += (Math.random() * bump) - (bump * 0.5);
        } else if(i % 2) {
          y += bump * 0.5;
        } else {
          y -= bump * 0.5;
        }
        if(clamp) {
          if(y > 1) {
            y = 1;
          } else if(y < 0) {
            y = 0;
          }
        }
        a[cnt++] = { x: x, y: y };
      }
      a.sort(function(a, b) {
        return a.x - b.x;
      });

      pnt = new EasePoint(1, 1, null);
      i = points;
      while(--i > -1) {
        obj = a[i];
        pnt = new EasePoint(obj.x, obj.y, pnt);
      }

      this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
    }, true);
    p = RoughEase.prototype = new Ease();
    p.constructor = RoughEase;
    p.getRatio = function(p) {
      var pnt = this._prev;
      if(p > pnt.t) {
        while(pnt.next && p >= pnt.t) {
          pnt = pnt.next;
        }
        pnt = pnt.prev;
      } else {
        while(pnt.prev && p <= pnt.t) {
          pnt = pnt.prev;
        }
      }
      this._prev = pnt;
      return(pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
    };
    p.config = function(vars) {
      return new RoughEase(vars);
    };
    RoughEase.ease = new RoughEase();


    //Bounce
    _wrap("Bounce",
      _create("BounceOut", function(p) {
        if(p < 1 / 2.75) {
          return 7.5625 * p * p;
        } else if(p < 2 / 2.75) {
          return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
        } else if(p < 2.5 / 2.75) {
          return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
        }
        return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
      }),
      _create("BounceIn", function(p) {
        if((p = 1 - p) < 1 / 2.75) {
          return 1 - (7.5625 * p * p);
        } else if(p < 2 / 2.75) {
          return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
        } else if(p < 2.5 / 2.75) {
          return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
        }
        return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
      }),
      _create("BounceInOut", function(p) {
        var invert = (p < 0.5);
        if(invert) {
          p = 1 - (p * 2);
        } else {
          p = (p * 2) - 1;
        }
        if(p < 1 / 2.75) {
          p = 7.5625 * p * p;
        } else if(p < 2 / 2.75) {
          p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
        } else if(p < 2.5 / 2.75) {
          p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
        } else {
          p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
        }
        return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
      })
    );


    //CIRC
    _wrap("Circ",
      _create("CircOut", function(p) {
        return Math.sqrt(1 - (p = p - 1) * p);
      }),
      _create("CircIn", function(p) {
        return -(Math.sqrt(1 - (p * p)) - 1);
      }),
      _create("CircInOut", function(p) {
        return((p *= 2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
      })
    );


    //Elastic
    _createElastic = function(n, f, def) {
      var C = _class("easing." + n, function(amplitude, period) {
          this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
          this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
          this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
          this._p2 = _2PI / this._p2; //precalculate to optimize
        }, true),
        p = C.prototype = new Ease();
      p.constructor = C;
      p.getRatio = f;
      p.config = function(amplitude, period) {
        return new C(amplitude, period);
      };
      return C;
    };
    _wrap("Elastic",
      _createElastic("ElasticOut", function(p) {
        return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
      }, 0.3),
      _createElastic("ElasticIn", function(p) {
        return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
      }, 0.3),
      _createElastic("ElasticInOut", function(p) {
        return((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
      }, 0.45)
    );


    //Expo
    _wrap("Expo",
      _create("ExpoOut", function(p) {
        return 1 - Math.pow(2, -10 * p);
      }),
      _create("ExpoIn", function(p) {
        return Math.pow(2, 10 * (p - 1)) - 0.001;
      }),
      _create("ExpoInOut", function(p) {
        return((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
      })
    );


    //Sine
    _wrap("Sine",
      _create("SineOut", function(p) {
        return Math.sin(p * _HALF_PI);
      }),
      _create("SineIn", function(p) {
        return -Math.cos(p * _HALF_PI) + 1;
      }),
      _create("SineInOut", function(p) {
        return -0.5 * (Math.cos(Math.PI * p) - 1);
      })
    );

    _class("easing.EaseLookup", {
      find: function(s) {
        return Ease.map[s];
      }
    }, true);

    //register the non-standard eases
    _easeReg(w.SlowMo, "SlowMo", "ease,");
    _easeReg(RoughEase, "RoughEase", "ease,");
    _easeReg(SteppedEase, "SteppedEase", "ease,");

    return Back;

  }, true);


});

if(_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function(window, moduleName) {

  "use strict";
  var _exports = {},
    _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
  if(_globals.TweenLite) {
    return; //in case the core set of classes is already loaded, don't instantiate twice.
  }
  var _namespace = function(ns) {
      var a = ns.split("."),
        p = _globals,
        i;
      for(i = 0; i < a.length; i++) {
        p[a[i]] = p = p[a[i]] || {};
      }
      return p;
    },
    gs = _namespace("com.greensock"),
    _tinyNum = 0.0000000001,
    _slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
      var b = [],
        l = a.length,
        i;
      for(i = 0; i !== l; b.push(a[i++])) {}
      return b;
    },
    _emptyFunc = function() {},
    _isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
      var toString = Object.prototype.toString,
        array = toString.call([]);
      return function(obj) {
        return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
      };
    }()),
    a, i, p, _ticker, _tickerActive,
    _defLookup = {},

    /**
     * @constructor
     * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
     * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
     * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
     * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
     *
     * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
     * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
     * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
     * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
     * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
     * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
     * sandbox the banner one like:
     *
     * <script>
     *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
     * </script>
     * <script src="js/greensock/v1.7/TweenMax.js"></script>
     * <script>
     *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
     * </script>
     * <script src="js/greensock/v1.6/TweenMax.js"></script>
     * <script>
     *     gs.TweenLite.to(...); //would use v1.7
     *     TweenLite.to(...); //would use v1.6
     * </script>
     *
     * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
     * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
     * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
     * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
     */
    Definition = function(ns, dependencies, func, global) {
      this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
      _defLookup[ns] = this;
      this.gsClass = null;
      this.func = func;
      var _classes = [];
      this.check = function(init) {
        var i = dependencies.length,
          missing = i,
          cur, a, n, cl, hasModule;
        while(--i > -1) {
          if((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
            _classes[i] = cur.gsClass;
            missing--;
          } else if(init) {
            cur.sc.push(this);
          }
        }
        if(missing === 0 && func) {
          a = ("com.greensock." + ns).split(".");
          n = a.pop();
          cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

          //exports to multiple environments
          if(global) {
            _globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
            hasModule = (typeof(module) !== "undefined" && module.exports);
            if(!hasModule && typeof(define) === "function" && define.amd) { //AMD
              define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
            } else if(hasModule) { //node
              if(ns === moduleName) {
                module.exports = _exports[moduleName] = cl;
                for(i in _exports) {
                  cl[i] = _exports[i];
                }
              } else if(_exports[moduleName]) {
                _exports[moduleName][n] = cl;
              }
            }
          }
          for(i = 0; i < this.sc.length; i++) {
            this.sc[i].check();
          }
        }
      };
      this.check(true);
    },

    //used to create Definition instances (which basically registers a class that has dependencies).
    _gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
      return new Definition(ns, dependencies, func, global);
    },

    //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
    _class = gs._class = function(ns, func, global) {
      func = func || function() {};
      _gsDefine(ns, [], function() { return func; }, global);
      return func;
    };

  _gsDefine.globals = _globals;



  /*
   * ----------------------------------------------------------------
   * Ease
   * ----------------------------------------------------------------
   */
  var _baseParams = [0, 0, 1, 1],
    _blankArray = [],
    Ease = _class("easing.Ease", function(func, extraParams, type, power) {
      this._func = func;
      this._type = type || 0;
      this._power = power || 0;
      this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
    }, true),
    _easeMap = Ease.map = {},
    _easeReg = Ease.register = function(ease, names, types, create) {
      var na = names.split(","),
        i = na.length,
        ta = (types || "easeIn,easeOut,easeInOut").split(","),
        e, name, j, type;
      while(--i > -1) {
        name = na[i];
        e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
        j = ta.length;
        while(--j > -1) {
          type = ta[j];
          _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
        }
      }
    };

  p = Ease.prototype;
  p._calcEnd = false;
  p.getRatio = function(p) {
    if(this._func) {
      this._params[0] = p;
      return this._func.apply(null, this._params);
    }
    var t = this._type,
      pw = this._power,
      r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
    if(pw === 1) {
      r *= r;
    } else if(pw === 2) {
      r *= r * r;
    } else if(pw === 3) {
      r *= r * r * r;
    } else if(pw === 4) {
      r *= r * r * r * r;
    }
    return(t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
  };

  //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
  a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
  i = a.length;
  while(--i > -1) {
    p = a[i] + ",Power" + i;
    _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
    _easeReg(new Ease(null, null, 2, i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
    _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
  }
  _easeMap.linear = gs.easing.Linear.easeIn;
  _easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


  /*
   * ----------------------------------------------------------------
   * EventDispatcher
   * ----------------------------------------------------------------
   */
  var EventDispatcher = _class("events.EventDispatcher", function(target) {
    this._listeners = {};
    this._eventTarget = target || this;
  });
  p = EventDispatcher.prototype;

  p.addEventListener = function(type, callback, scope, useParam, priority) {
    priority = priority || 0;
    var list = this._listeners[type],
      index = 0,
      listener, i;
    if(this === _ticker && !_tickerActive) {
      _ticker.wake();
    }
    if(list == null) {
      this._listeners[type] = list = [];
    }
    i = list.length;
    while(--i > -1) {
      listener = list[i];
      if(listener.c === callback && listener.s === scope) {
        list.splice(i, 1);
      } else if(index === 0 && listener.pr < priority) {
        index = i + 1;
      }
    }
    list.splice(index, 0, { c: callback, s: scope, up: useParam, pr: priority });
  };

  p.removeEventListener = function(type, callback) {
    var list = this._listeners[type],
      i;
    if(list) {
      i = list.length;
      while(--i > -1) {
        if(list[i].c === callback) {
          list.splice(i, 1);
          return;
        }
      }
    }
  };

  p.dispatchEvent = function(type) {
    var list = this._listeners[type],
      i, t, listener;
    if(list) {
      i = list.length;
      if(i > 1) {
        list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
      }
      t = this._eventTarget;
      while(--i > -1) {
        listener = list[i];
        if(listener) {
          if(listener.up) {
            listener.c.call(listener.s || t, { type: type, target: t });
          } else {
            listener.c.call(listener.s || t);
          }
        }
      }
    }
  };


  /*
   * ----------------------------------------------------------------
   * Ticker
   * ----------------------------------------------------------------
   */
  var _reqAnimFrame = window.requestAnimationFrame,
    _cancelAnimFrame = window.cancelAnimationFrame,
    _getTime = Date.now || function() { return new Date().getTime(); },
    _lastUpdate = _getTime();

  //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
  a = ["ms", "moz", "webkit", "o"];
  i = a.length;
  while(--i > -1 && !_reqAnimFrame) {
    _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
  }

  _class("Ticker", function(fps, useRAF) {
    var _self = this,
      _startTime = _getTime(),
      _useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _tickWord = "tick", //helps reduce gc burden
      _fps, _req, _id, _gap, _nextTime,
      _tick = function(manual) {
        var elapsed = _getTime() - _lastUpdate,
          overlap, dispatch;
        if(elapsed > _lagThreshold) {
          _startTime += elapsed - _adjustedLag;
        }
        _lastUpdate += elapsed;
        _self.time = (_lastUpdate - _startTime) / 1000;
        overlap = _self.time - _nextTime;
        if(!_fps || overlap > 0 || manual === true) {
          _self.frame++;
          _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
          dispatch = true;
        }
        if(manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
          _id = _req(_tick);
        }
        if(dispatch) {
          _self.dispatchEvent(_tickWord);
        }
      };

    EventDispatcher.call(_self);
    _self.time = _self.frame = 0;
    _self.tick = function() {
      _tick(true);
    };

    _self.lagSmoothing = function(threshold, adjustedLag) {
      _lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    };

    _self.sleep = function() {
      if(_id == null) {
        return;
      }
      if(!_useRAF || !_cancelAnimFrame) {
        clearTimeout(_id);
      } else {
        _cancelAnimFrame(_id);
      }
      _req = _emptyFunc;
      _id = null;
      if(_self === _ticker) {
        _tickerActive = false;
      }
    };

    _self.wake = function(seamless) {
      if(_id !== null) {
        _self.sleep();
      } else if(seamless) {
        _startTime += -_lastUpdate + (_lastUpdate = _getTime());
      } else if(_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
        _lastUpdate = _getTime() - _lagThreshold + 5;
      }
      _req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
      if(_self === _ticker) {
        _tickerActive = true;
      }
      _tick(2);
    };

    _self.fps = function(value) {
      if(!arguments.length) {
        return _fps;
      }
      _fps = value;
      _gap = 1 / (_fps || 60);
      _nextTime = this.time + _gap;
      _self.wake();
    };

    _self.useRAF = function(value) {
      if(!arguments.length) {
        return _useRAF;
      }
      _self.sleep();
      _useRAF = value;
      _self.fps(_fps);
    };
    _self.fps(fps);

    //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
    setTimeout(function() {
      if(_useRAF === "auto" && _self.frame < 5 && document.visibilityState !== "hidden") {
        _self.useRAF(false);
      }
    }, 1500);
  });

  p = gs.Ticker.prototype = new gs.events.EventDispatcher();
  p.constructor = gs.Ticker;


  /*
   * ----------------------------------------------------------------
   * Animation
   * ----------------------------------------------------------------
   */
  var Animation = _class("core.Animation", function(duration, vars) {
    this.vars = vars = vars || {};
    this._duration = this._totalDuration = duration || 0;
    this._delay = Number(vars.delay) || 0;
    this._timeScale = 1;
    this._active = (vars.immediateRender === true);
    this.data = vars.data;
    this._reversed = (vars.reversed === true);

    if(!_rootTimeline) {
      return;
    }
    if(!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
      _ticker.wake();
    }

    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
    tl.add(this, tl._time);

    if(this.vars.paused) {
      this.paused(true);
    }
  });

  _ticker = Animation.ticker = new gs.Ticker();
  p = Animation.prototype;
  p._dirty = p._gc = p._initted = p._paused = false;
  p._totalTime = p._time = 0;
  p._rawPrevTime = -1;
  p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
  p._paused = false;


  //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
  var _checkTimeout = function() {
    if(_tickerActive && _getTime() - _lastUpdate > 2000) {
      _ticker.wake();
    }
    setTimeout(_checkTimeout, 2000);
  };
  _checkTimeout();


  p.play = function(from, suppressEvents) {
    if(from != null) {
      this.seek(from, suppressEvents);
    }
    return this.reversed(false).paused(false);
  };

  p.pause = function(atTime, suppressEvents) {
    if(atTime != null) {
      this.seek(atTime, suppressEvents);
    }
    return this.paused(true);
  };

  p.resume = function(from, suppressEvents) {
    if(from != null) {
      this.seek(from, suppressEvents);
    }
    return this.paused(false);
  };

  p.seek = function(time, suppressEvents) {
    return this.totalTime(Number(time), suppressEvents !== false);
  };

  p.restart = function(includeDelay, suppressEvents) {
    return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
  };

  p.reverse = function(from, suppressEvents) {
    if(from != null) {
      this.seek((from || this.totalDuration()), suppressEvents);
    }
    return this.reversed(true).paused(false);
  };

  p.render = function(time, suppressEvents, force) {
    //stub - we override this method in subclasses.
  };

  p.invalidate = function() {
    this._time = this._totalTime = 0;
    this._initted = this._gc = false;
    this._rawPrevTime = -1;
    if(this._gc || !this.timeline) {
      this._enabled(true);
    }
    return this;
  };

  p.isActive = function() {
    var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
      startTime = this._startTime,
      rawTime;
    return(!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
  };

  p._enabled = function(enabled, ignoreTimeline) {
    if(!_tickerActive) {
      _ticker.wake();
    }
    this._gc = !enabled;
    this._active = this.isActive();
    if(ignoreTimeline !== true) {
      if(enabled && !this.timeline) {
        this._timeline.add(this, this._startTime - this._delay);
      } else if(!enabled && this.timeline) {
        this._timeline._remove(this, true);
      }
    }
    return false;
  };


  p._kill = function(vars, target) {
    return this._enabled(false, false);
  };

  p.kill = function(vars, target) {
    this._kill(vars, target);
    return this;
  };

  p._uncache = function(includeSelf) {
    var tween = includeSelf ? this : this.timeline;
    while(tween) {
      tween._dirty = true;
      tween = tween.timeline;
    }
    return this;
  };

  p._swapSelfInParams = function(params) {
    var i = params.length,
      copy = params.concat();
    while(--i > -1) {
      if(params[i] === "{self}") {
        copy[i] = this;
      }
    }
    return copy;
  };

  p._callback = function(type) {
    var v = this.vars,
      callback = v[type],
      params = v[type + "Params"],
      scope = v[type + "Scope"] || v.callbackScope || this,
      l = params ? params.length : 0;
    switch(l) { //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
      case 0:
        callback.call(scope);
        break;
      case 1:
        callback.call(scope, params[0]);
        break;
      case 2:
        callback.call(scope, params[0], params[1]);
        break;
      default:
        callback.apply(scope, params);
    }
  };

  //----Animation getters/setters --------------------------------------------------------

  p.eventCallback = function(type, callback, params, scope) {
    if((type || "").substr(0, 2) === "on") {
      var v = this.vars;
      if(arguments.length === 1) {
        return v[type];
      }
      if(callback == null) {
        delete v[type];
      } else {
        v[type] = callback;
        v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
        v[type + "Scope"] = scope;
      }
      if(type === "onUpdate") {
        this._onUpdate = callback;
      }
    }
    return this;
  };

  p.delay = function(value) {
    if(!arguments.length) {
      return this._delay;
    }
    if(this._timeline.smoothChildTiming) {
      this.startTime(this._startTime + value - this._delay);
    }
    this._delay = value;
    return this;
  };

  p.duration = function(value) {
    if(!arguments.length) {
      this._dirty = false;
      return this._duration;
    }
    this._duration = this._totalDuration = value;
    this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
    if(this._timeline.smoothChildTiming)
      if(this._time > 0)
        if(this._time < this._duration)
          if(value !== 0) {
            this.totalTime(this._totalTime * (value / this._duration), true);
          }
    return this;
  };

  p.totalDuration = function(value) {
    this._dirty = false;
    return(!arguments.length) ? this._totalDuration : this.duration(value);
  };

  p.time = function(value, suppressEvents) {
    if(!arguments.length) {
      return this._time;
    }
    if(this._dirty) {
      this.totalDuration();
    }
    return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
  };

  p.totalTime = function(time, suppressEvents, uncapped) {
    if(!_tickerActive) {
      _ticker.wake();
    }
    if(!arguments.length) {
      return this._totalTime;
    }
    if(this._timeline) {
      if(time < 0 && !uncapped) {
        time += this.totalDuration();
      }
      if(this._timeline.smoothChildTiming) {
        if(this._dirty) {
          this.totalDuration();
        }
        var totalDuration = this._totalDuration,
          tl = this._timeline;
        if(time > totalDuration && !uncapped) {
          time = totalDuration;
        }
        this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
        if(!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
          this._uncache(false);
        }
        //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
        if(tl._timeline) {
          while(tl._timeline) {
            if(tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
              tl.totalTime(tl._totalTime, true);
            }
            tl = tl._timeline;
          }
        }
      }
      if(this._gc) {
        this._enabled(true, false);
      }
      if(this._totalTime !== time || this._duration === 0) {
        if(_lazyTweens.length) {
          _lazyRender();
        }
        this.render(time, suppressEvents, false);
        if(_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
          _lazyRender();
        }
      }
    }
    return this;
  };

  p.progress = p.totalProgress = function(value, suppressEvents) {
    var duration = this.duration();
    return(!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
  };

  p.startTime = function(value) {
    if(!arguments.length) {
      return this._startTime;
    }
    if(value !== this._startTime) {
      this._startTime = value;
      if(this.timeline)
        if(this.timeline._sortChildren) {
          this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
        }
    }
    return this;
  };

  p.endTime = function(includeRepeats) {
    return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
  };

  p.timeScale = function(value) {
    if(!arguments.length) {
      return this._timeScale;
    }
    value = value || _tinyNum; //can't allow zero because it'll throw the math off
    if(this._timeline && this._timeline.smoothChildTiming) {
      var pauseTime = this._pauseTime,
        t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
      this._startTime = t - ((t - this._startTime) * this._timeScale / value);
    }
    this._timeScale = value;
    return this._uncache(false);
  };

  p.reversed = function(value) {
    if(!arguments.length) {
      return this._reversed;
    }
    if(value != this._reversed) {
      this._reversed = value;
      this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
    }
    return this;
  };

  p.paused = function(value) {
    if(!arguments.length) {
      return this._paused;
    }
    var tl = this._timeline,
      raw, elapsed;
    if(value != this._paused)
      if(tl) {
        if(!_tickerActive && !value) {
          _ticker.wake();
        }
        raw = tl.rawTime();
        elapsed = raw - this._pauseTime;
        if(!value && tl.smoothChildTiming) {
          this._startTime += elapsed;
          this._uncache(false);
        }
        this._pauseTime = value ? raw : null;
        this._paused = value;
        this._active = this.isActive();
        if(!value && elapsed !== 0 && this._initted && this.duration()) {
          raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
          this.render(raw, (raw === this._totalTime), true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
        }
      }
    if(this._gc && !value) {
      this._enabled(true, false);
    }
    return this;
  };


  /*
   * ----------------------------------------------------------------
   * SimpleTimeline
   * ----------------------------------------------------------------
   */
  var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
    Animation.call(this, 0, vars);
    this.autoRemoveChildren = this.smoothChildTiming = true;
  });

  p = SimpleTimeline.prototype = new Animation();
  p.constructor = SimpleTimeline;
  p.kill()._gc = false;
  p._first = p._last = p._recent = null;
  p._sortChildren = false;

  p.add = p.insert = function(child, position, align, stagger) {
    var prevTween, st;
    child._startTime = Number(position || 0) + child._delay;
    if(child._paused)
      if(this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
        child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
      }
    if(child.timeline) {
      child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
    }
    child.timeline = child._timeline = this;
    if(child._gc) {
      child._enabled(true, true);
    }
    prevTween = this._last;
    if(this._sortChildren) {
      st = child._startTime;
      while(prevTween && prevTween._startTime > st) {
        prevTween = prevTween._prev;
      }
    }
    if(prevTween) {
      child._next = prevTween._next;
      prevTween._next = child;
    } else {
      child._next = this._first;
      this._first = child;
    }
    if(child._next) {
      child._next._prev = child;
    } else {
      this._last = child;
    }
    child._prev = prevTween;
    this._recent = child;
    if(this._timeline) {
      this._uncache(true);
    }
    return this;
  };

  p._remove = function(tween, skipDisable) {
    if(tween.timeline === this) {
      if(!skipDisable) {
        tween._enabled(false, true);
      }

      if(tween._prev) {
        tween._prev._next = tween._next;
      } else if(this._first === tween) {
        this._first = tween._next;
      }
      if(tween._next) {
        tween._next._prev = tween._prev;
      } else if(this._last === tween) {
        this._last = tween._prev;
      }
      tween._next = tween._prev = tween.timeline = null;
      if(tween === this._recent) {
        this._recent = this._last;
      }

      if(this._timeline) {
        this._uncache(true);
      }
    }
    return this;
  };

  p.render = function(time, suppressEvents, force) {
    var tween = this._first,
      next;
    this._totalTime = this._time = this._rawPrevTime = time;
    while(tween) {
      next = tween._next; //record it here because the value could change after rendering...
      if(tween._active || (time >= tween._startTime && !tween._paused)) {
        if(!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
        }
      }
      tween = next;
    }
  };

  p.rawTime = function() {
    if(!_tickerActive) {
      _ticker.wake();
    }
    return this._totalTime;
  };

  /*
   * ----------------------------------------------------------------
   * TweenLite
   * ----------------------------------------------------------------
   */
  var TweenLite = _class("TweenLite", function(target, duration, vars) {
      Animation.call(this, duration, vars);
      this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

      if(target == null) {
        throw "Cannot tween a null target.";
      }

      this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

      var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
        overwrite = this.vars.overwrite,
        i, targ, targets;

      this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

      if((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
        this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
        this._propLookup = [];
        this._siblings = [];
        for(i = 0; i < targets.length; i++) {
          targ = targets[i];
          if(!targ) {
            targets.splice(i--, 1);
            continue;
          } else if(typeof(targ) === "string") {
            targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
            if(typeof(targ) === "string") {
              targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
            }
            continue;
          } else if(targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
            targets.splice(i--, 1);
            this._targets = targets = targets.concat(_slice(targ));
            continue;
          }
          this._siblings[i] = _register(targ, this, false);
          if(overwrite === 1)
            if(this._siblings[i].length > 1) {
              _applyOverwrite(targ, this, null, 1, this._siblings[i]);
            }
        }

      } else {
        this._propLookup = {};
        this._siblings = _register(target, this, false);
        if(overwrite === 1)
          if(this._siblings.length > 1) {
            _applyOverwrite(target, this, null, 1, this._siblings);
          }
      }
      if(this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
        this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
        this.render(Math.min(0, -this._delay)); //in case delay is negative
      }
    }, true),
    _isSelector = function(v) {
      return(v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
    },
    _autoCSS = function(vars, target) {
      var css = {},
        p;
      for(p in vars) {
        if(!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
          css[p] = vars[p];
          delete vars[p];
        }
      }
      vars.css = css;
    };

  p = TweenLite.prototype = new Animation();
  p.constructor = TweenLite;
  p.kill()._gc = false;

  //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

  p.ratio = 0;
  p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
  p._notifyPluginsOfEnabled = p._lazy = false;

  TweenLite.version = "1.19.0";
  TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
  TweenLite.defaultOverwrite = "auto";
  TweenLite.ticker = _ticker;
  TweenLite.autoSleep = 120;
  TweenLite.lagSmoothing = function(threshold, adjustedLag) {
    _ticker.lagSmoothing(threshold, adjustedLag);
  };

  TweenLite.selector = window.$ || window.jQuery || function(e) {
    var selector = window.$ || window.jQuery;
    if(selector) {
      TweenLite.selector = selector;
      return selector(e);
    }
    return(typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
  };

  var _lazyTweens = [],
    _lazyLookup = {},
    _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    //_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
    _setRatio = function(v) {
      var pt = this._firstPT,
        min = 0.000001,
        val;
      while(pt) {
        val = !pt.blob ? pt.c * v + pt.s : v ? this.join("") : this.start;
        if(pt.m) {
          val = pt.m(val, this._target || pt.t);
        } else if(val < min)
          if(val > -min) { //prevents issues with converting very small numbers to strings in the browser
            val = 0;
          }
        if(!pt.f) {
          pt.t[pt.p] = val;
        } else if(pt.fp) {
          pt.t[pt.p](pt.fp, val);
        } else {
          pt.t[pt.p](val);
        }
        pt = pt._next;
      }
    },
    //compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
    _blobDif = function(start, end, filter, pt) {
      var a = [start, end],
        charIndex = 0,
        s = "",
        color = 0,
        startNums, endNums, num, i, l, nonNumbers, currentNum;
      a.start = start;
      if(filter) {
        filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
        start = a[0];
        end = a[1];
      }
      a.length = 0;
      startNums = start.match(_numbersExp) || [];
      endNums = end.match(_numbersExp) || [];
      if(pt) {
        pt._next = null;
        pt.blob = 1;
        a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
      }
      l = endNums.length;
      for(i = 0; i < l; i++) {
        currentNum = endNums[i];
        nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
        s += (nonNumbers || !i) ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        charIndex += nonNumbers.length;
        if(color) { //sense rgba() values and round them.
          color = (color + 1) % 5;
        } else if(nonNumbers.substr(-5) === "rgba(") {
          color = 1;
        }
        if(currentNum === startNums[i] || startNums.length <= i) {
          s += currentNum;
        } else {
          if(s) {
            a.push(s);
            s = "";
          }
          num = parseFloat(startNums[i]);
          a.push(num);
          a._firstPT = { _next: a._firstPT, t: a, p: a.length - 1, s: num, c: ((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0, f: 0, m: (color && color < 4) ? Math.round : 0 };
          //note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
        }
        charIndex += currentNum.length;
      }
      s += end.substr(charIndex);
      if(s) {
        a.push(s);
      }
      a.setRatio = _setRatio;
      return a;
    },
    //note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
    _addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
      if(typeof(end) === "function") {
        end = end(index || 0, target);
      }
      var s = (start === "get") ? target[prop] : start,
        type = typeof(target[prop]),
        isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
        pt = { t: target, p: prop, s: s, f: (type === "function"), pg: 0, n: overwriteProp || prop, m: (!mod ? 0 : (typeof(mod) === "function") ? mod : Math.round), pr: 0, c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0 },
        blob, getterName;
      if(type !== "number") {
        if(type === "function" && start === "get") {
          getterName = ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3));
          pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]();
        }
        if(typeof(s) === "string" && (funcParam || isNaN(s))) {
          //a blob (string that has multiple numbers in it)
          pt.fp = funcParam;
          blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt);
          pt = { t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0, m: 0 }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
        } else if(!isRelative) {
          pt.s = parseFloat(s);
          pt.c = (parseFloat(end) - pt.s) || 0;
        }
      }
      if(pt.c) { //only add it to the linked list if there's a change.
        if((pt._next = this._firstPT)) {
          pt._next._prev = pt;
        }
        this._firstPT = pt;
        return pt;
      }
    },
    _internals = TweenLite._internals = { isArray: _isArray, isSelector: _isSelector, lazyTweens: _lazyTweens, blobDif: _blobDif }, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
    _plugins = TweenLite._plugins = {},
    _tweenLookup = _internals.tweenLookup = {},
    _tweenLookupNum = 0,
    _reservedProps = _internals.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1 },
    _overwriteLookup = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 },
    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
    _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
    _nextGCFrame = 30,
    _lazyRender = _internals.lazyRender = function() {
      var i = _lazyTweens.length,
        tween;
      _lazyLookup = {};
      while(--i > -1) {
        tween = _lazyTweens[i];
        if(tween && tween._lazy !== false) {
          tween.render(tween._lazy[0], tween._lazy[1], true);
          tween._lazy = false;
        }
      }
      _lazyTweens.length = 0;
    };

  _rootTimeline._startTime = _ticker.time;
  _rootFramesTimeline._startTime = _ticker.frame;
  _rootTimeline._active = _rootFramesTimeline._active = true;
  setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

  Animation._updateRoot = TweenLite.render = function() {
    var i, a, p;
    if(_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
      _lazyRender();
    }
    _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
    _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
    if(_lazyTweens.length) {
      _lazyRender();
    }
    if(_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
      _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
      for(p in _tweenLookup) {
        a = _tweenLookup[p].tweens;
        i = a.length;
        while(--i > -1) {
          if(a[i]._gc) {
            a.splice(i, 1);
          }
        }
        if(a.length === 0) {
          delete _tweenLookup[p];
        }
      }
      //if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
      p = _rootTimeline._first;
      if(!p || p._paused)
        if(TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
          while(p && p._paused) {
            p = p._next;
          }
          if(!p) {
            _ticker.sleep();
          }
        }
    }
  };

  _ticker.addEventListener("tick", Animation._updateRoot);

  var _register = function(target, tween, scrub) {
      var id = target._gsTweenID,
        a, i;
      if(!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
        _tweenLookup[id] = { target: target, tweens: [] };
      }
      if(tween) {
        a = _tweenLookup[id].tweens;
        a[(i = a.length)] = tween;
        if(scrub) {
          while(--i > -1) {
            if(a[i] === tween) {
              a.splice(i, 1);
            }
          }
        }
      }
      return _tweenLookup[id].tweens;
    },
    _onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
      var func = overwrittenTween.vars.onOverwrite,
        r1, r2;
      if(func) {
        r1 = func(overwrittenTween, overwritingTween, target, killedProps);
      }
      func = TweenLite.onOverwrite;
      if(func) {
        r2 = func(overwrittenTween, overwritingTween, target, killedProps);
      }
      return(r1 !== false && r2 !== false);
    },
    _applyOverwrite = function(target, tween, props, mode, siblings) {
      var i, changed, curTween, l;
      if(mode === 1 || mode >= 4) {
        l = siblings.length;
        for(i = 0; i < l; i++) {
          if((curTween = siblings[i]) !== tween) {
            if(!curTween._gc) {
              if(curTween._kill(null, target, tween)) {
                changed = true;
              }
            }
          } else if(mode === 5) {
            break;
          }
        }
        return changed;
      }
      //NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
      var startTime = tween._startTime + _tinyNum,
        overlaps = [],
        oCount = 0,
        zeroDur = (tween._duration === 0),
        globalStart;
      i = siblings.length;
      while(--i > -1) {
        if((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
          //ignore
        } else if(curTween._timeline !== tween._timeline) {
          globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
          if(_checkOverlap(curTween, globalStart, zeroDur) === 0) {
            overlaps[oCount++] = curTween;
          }
        } else if(curTween._startTime <= startTime)
          if(curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)
            if(!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
              overlaps[oCount++] = curTween;
            }
      }

      i = oCount;
      while(--i > -1) {
        curTween = overlaps[i];
        if(mode === 2)
          if(curTween._kill(props, target, tween)) {
            changed = true;
          }
        if(mode !== 2 || (!curTween._firstPT && curTween._initted)) {
          if(mode !== 2 && !_onOverwrite(curTween, tween)) {
            continue;
          }
          if(curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
            changed = true;
          }
        }
      }
      return changed;
    },
    _checkOverlap = function(tween, reference, zeroDur) {
      var tl = tween._timeline,
        ts = tl._timeScale,
        t = tween._startTime;
      while(tl._timeline) {
        t += tl._startTime;
        ts *= tl._timeScale;
        if(tl._paused) {
          return -100;
        }
        tl = tl._timeline;
      }
      t /= ts;
      return(t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
    };


  //---- TweenLite instance methods -----------------------------------------------------------------------------

  p._init = function() {
    var v = this.vars,
      op = this._overwrittenProps,
      dur = this._duration,
      immediate = !!v.immediateRender,
      ease = v.ease,
      i, initPlugins, pt, p, startVars, l;
    if(v.startAt) {
      if(this._startAt) {
        this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
        this._startAt.kill();
      }
      startVars = {};
      for(p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
        startVars[p] = v.startAt[p];
      }
      startVars.overwrite = false;
      startVars.immediateRender = true;
      startVars.lazy = (immediate && v.lazy !== false);
      startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
      this._startAt = TweenLite.to(this.target, 0, startVars);
      if(immediate) {
        if(this._time > 0) {
          this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
        } else if(dur !== 0) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if(v.runBackwards && dur !== 0) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if(this._startAt) {
        this._startAt.render(-1, true);
        this._startAt.kill();
        this._startAt = null;
      } else {
        if(this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          immediate = false;
        }
        pt = {};
        for(p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
          if(!_reservedProps[p] || p === "autoCSS") {
            pt[p] = v[p];
          }
        }
        pt.overwrite = 0;
        pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        pt.lazy = (immediate && v.lazy !== false);
        pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        this._startAt = TweenLite.to(this.target, 0, pt);
        if(!immediate) {
          this._startAt._init(); //ensures that the initial values are recorded
          this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
          if(this.vars.immediateRender) {
            this._startAt = null;
          }
        } else if(this._time === 0) {
          return;
        }
      }
    }
    this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
    if(v.easeParams instanceof Array && ease.config) {
      this._ease = ease.config.apply(ease, v.easeParams);
    }
    this._easeType = this._ease._type;
    this._easePower = this._ease._power;
    this._firstPT = null;

    if(this._targets) {
      l = this._targets.length;
      for(i = 0; i < l; i++) {
        if(this._initProps(this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null), i)) {
          initPlugins = true;
        }
      }
    } else {
      initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
    }

    if(initPlugins) {
      TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
    }
    if(op)
      if(!this._firstPT)
        if(typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
          this._enabled(false, false);
        }
    if(v.runBackwards) {
      pt = this._firstPT;
      while(pt) {
        pt.s += pt.c;
        pt.c = -pt.c;
        pt = pt._next;
      }
    }
    this._onUpdate = v.onUpdate;
    this._initted = true;
  };

  p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
    var p, i, initPlugins, plugin, pt, v;
    if(target == null) {
      return false;
    }

    if(_lazyLookup[target._gsTweenID]) {
      _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
    }

    if(!this.vars.css)
      if(target.style)
        if(target !== window && target.nodeType)
          if(_plugins.css)
            if(this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
              _autoCSS(this.vars, target);
            }
    for(p in this.vars) {
      v = this.vars[p];
      if(_reservedProps[p]) {
        if(v)
          if((v instanceof Array) || (v.push && _isArray(v)))
            if(v.join("").indexOf("{self}") !== -1) {
              this.vars[p] = v = this._swapSelfInParams(v, this);
            }

      } else if(_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {

        //t - target 		[object]
        //p - property 		[string]
        //s - start			[number]
        //c - change		[number]
        //f - isFunction	[boolean]
        //n - name			[string]
        //pg - isPlugin 	[boolean]
        //pr - priority		[number]
        //m - mod           [function | 0]
        this._firstPT = pt = { _next: this._firstPT, t: plugin, p: "setRatio", s: 0, c: 1, f: 1, n: p, pg: 1, pr: plugin._priority, m: 0 };
        i = plugin._overwriteProps.length;
        while(--i > -1) {
          propLookup[plugin._overwriteProps[i]] = this._firstPT;
        }
        if(plugin._priority || plugin._onInitAllProps) {
          initPlugins = true;
        }
        if(plugin._onDisable || plugin._onEnable) {
          this._notifyPluginsOfEnabled = true;
        }
        if(pt._next) {
          pt._next._prev = pt;
        }

      } else {
        propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
      }
    }

    if(overwrittenProps)
      if(this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
        return this._initProps(target, propLookup, siblings, overwrittenProps, index);
      }
    if(this._overwrite > 1)
      if(this._firstPT)
        if(siblings.length > 1)
          if(_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
            this._kill(propLookup, target);
            return this._initProps(target, propLookup, siblings, overwrittenProps, index);
          }
    if(this._firstPT)
      if((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
        _lazyLookup[target._gsTweenID] = true;
      }
    return initPlugins;
  };

  p.render = function(time, suppressEvents, force) {
    var prevTime = this._time,
      duration = this._duration,
      prevRawPrevTime = this._rawPrevTime,
      isComplete, callback, pt, rawPrevTime;
    if(time >= duration - 0.0000001) { //to work around occasional floating point math artifacts.
      this._totalTime = this._time = duration;
      this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
      if(!this._reversed) {
        isComplete = true;
        callback = "onComplete";
        force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
      }
      if(duration === 0)
        if(this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          if(this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
            time = 0;
          }
          if(prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause"))
            if(prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
              force = true;
              if(prevRawPrevTime > _tinyNum) {
                callback = "onReverseComplete";
              }
            }
          this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }

    } else if(time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
      this._totalTime = this._time = 0;
      this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
      if(prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
        callback = "onReverseComplete";
        isComplete = this._reversed;
      }
      if(time < 0) {
        this._active = false;
        if(duration === 0)
          if(this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
            if(prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
              force = true;
            }
            this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
          }
      }
      if(!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
        force = true;
      }
    } else {
      this._totalTime = this._time = time;

      if(this._easeType) {
        var r = time / duration,
          type = this._easeType,
          pow = this._easePower;
        if(type === 1 || (type === 3 && r >= 0.5)) {
          r = 1 - r;
        }
        if(type === 3) {
          r *= 2;
        }
        if(pow === 1) {
          r *= r;
        } else if(pow === 2) {
          r *= r * r;
        } else if(pow === 3) {
          r *= r * r * r;
        } else if(pow === 4) {
          r *= r * r * r * r;
        }

        if(type === 1) {
          this.ratio = 1 - r;
        } else if(type === 2) {
          this.ratio = r;
        } else if(time / duration < 0.5) {
          this.ratio = r / 2;
        } else {
          this.ratio = 1 - (r / 2);
        }

      } else {
        this.ratio = this._ease.getRatio(time / duration);
      }
    }

    if(this._time === prevTime && !force) {
      return;
    } else if(!this._initted) {
      this._init();
      if(!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
        return;
      } else if(!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
        this._time = this._totalTime = prevTime;
        this._rawPrevTime = prevRawPrevTime;
        _lazyTweens.push(this);
        this._lazy = [time, suppressEvents];
        return;
      }
      //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
      if(this._time && !isComplete) {
        this.ratio = this._ease.getRatio(this._time / duration);
      } else if(isComplete && this._ease._calcEnd) {
        this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
      }
    }
    if(this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
      this._lazy = false;
    }
    if(!this._active)
      if(!this._paused && this._time !== prevTime && time >= 0) {
        this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
      }
    if(prevTime === 0) {
      if(this._startAt) {
        if(time >= 0) {
          this._startAt.render(time, suppressEvents, force);
        } else if(!callback) {
          callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
        }
      }
      if(this.vars.onStart)
        if(this._time !== 0 || duration === 0)
          if(!suppressEvents) {
            this._callback("onStart");
          }
    }
    pt = this._firstPT;
    while(pt) {
      if(pt.f) {
        pt.t[pt.p](pt.c * this.ratio + pt.s);
      } else {
        pt.t[pt.p] = pt.c * this.ratio + pt.s;
      }
      pt = pt._next;
    }

    if(this._onUpdate) {
      if(time < 0)
        if(this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
          this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
        }
      if(!suppressEvents)
        if(this._time !== prevTime || isComplete || force) {
          this._callback("onUpdate");
        }
    }
    if(callback)
      if(!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
        if(time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
          this._startAt.render(time, suppressEvents, force);
        }
        if(isComplete) {
          if(this._timeline.autoRemoveChildren) {
            this._enabled(false, false);
          }
          this._active = false;
        }
        if(!suppressEvents && this.vars[callback]) {
          this._callback(callback);
        }
        if(duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
          this._rawPrevTime = 0;
        }
      }
  };

  p._kill = function(vars, target, overwritingTween) {
    if(vars === "all") {
      vars = null;
    }
    if(vars == null)
      if(target == null || target === this.target) {
        this._lazy = false;
        return this._enabled(false, false);
      }
    target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
    var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
      i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
    if((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
      i = target.length;
      while(--i > -1) {
        if(this._kill(vars, target[i], overwritingTween)) {
          changed = true;
        }
      }
    } else {
      if(this._targets) {
        i = this._targets.length;
        while(--i > -1) {
          if(target === this._targets[i]) {
            propLookup = this._propLookup[i] || {};
            this._overwrittenProps = this._overwrittenProps || [];
            overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
            break;
          }
        }
      } else if(target !== this.target) {
        return false;
      } else {
        propLookup = this._propLookup;
        overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
      }

      if(propLookup) {
        killProps = vars || propLookup;
        record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
        if(overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
          for(p in killProps) {
            if(propLookup[p]) {
              if(!killed) {
                killed = [];
              }
              killed.push(p);
            }
          }
          if((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
            return false;
          }
        }

        for(p in killProps) {
          if((pt = propLookup[p])) {
            if(simultaneousOverwrite) { //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
              if(pt.f) {
                pt.t[pt.p](pt.s);
              } else {
                pt.t[pt.p] = pt.s;
              }
              changed = true;
            }
            if(pt.pg && pt.t._kill(killProps)) {
              changed = true; //some plugins need to be notified so they can perform cleanup tasks first
            }
            if(!pt.pg || pt.t._overwriteProps.length === 0) {
              if(pt._prev) {
                pt._prev._next = pt._next;
              } else if(pt === this._firstPT) {
                this._firstPT = pt._next;
              }
              if(pt._next) {
                pt._next._prev = pt._prev;
              }
              pt._next = pt._prev = null;
            }
            delete propLookup[p];
          }
          if(record) {
            overwrittenProps[p] = 1;
          }
        }
        if(!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
          this._enabled(false, false);
        }
      }
    }
    return changed;
  };

  p.invalidate = function() {
    if(this._notifyPluginsOfEnabled) {
      TweenLite._onPluginEvent("_onDisable", this);
    }
    this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
    this._notifyPluginsOfEnabled = this._active = this._lazy = false;
    this._propLookup = (this._targets) ? {} : [];
    Animation.prototype.invalidate.call(this);
    if(this.vars.immediateRender) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
      this.render(Math.min(0, -this._delay)); //in case delay is negative.
    }
    return this;
  };

  p._enabled = function(enabled, ignoreTimeline) {
    if(!_tickerActive) {
      _ticker.wake();
    }
    if(enabled && this._gc) {
      var targets = this._targets,
        i;
      if(targets) {
        i = targets.length;
        while(--i > -1) {
          this._siblings[i] = _register(targets[i], this, true);
        }
      } else {
        this._siblings = _register(this.target, this, true);
      }
    }
    Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
    if(this._notifyPluginsOfEnabled)
      if(this._firstPT) {
        return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
      }
    return false;
  };


  //----TweenLite static methods -----------------------------------------------------

  TweenLite.to = function(target, duration, vars) {
    return new TweenLite(target, duration, vars);
  };

  TweenLite.from = function(target, duration, vars) {
    vars.runBackwards = true;
    vars.immediateRender = (vars.immediateRender != false);
    return new TweenLite(target, duration, vars);
  };

  TweenLite.fromTo = function(target, duration, fromVars, toVars) {
    toVars.startAt = fromVars;
    toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
    return new TweenLite(target, duration, toVars);
  };

  TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
    return new TweenLite(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, lazy: false, useFrames: useFrames, overwrite: 0 });
  };

  TweenLite.set = function(target, vars) {
    return new TweenLite(target, 0, vars);
  };

  TweenLite.getTweensOf = function(target, onlyActive) {
    if(target == null) { return []; }
    target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
    var i, a, j, t;
    if((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
      i = target.length;
      a = [];
      while(--i > -1) {
        a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
      }
      i = a.length;
      //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
      while(--i > -1) {
        t = a[i];
        j = i;
        while(--j > -1) {
          if(t === a[j]) {
            a.splice(i, 1);
          }
        }
      }
    } else {
      a = _register(target).concat();
      i = a.length;
      while(--i > -1) {
        if(a[i]._gc || (onlyActive && !a[i].isActive())) {
          a.splice(i, 1);
        }
      }
    }
    return a;
  };

  TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
    if(typeof(onlyActive) === "object") {
      vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
      onlyActive = false;
    }
    var a = TweenLite.getTweensOf(target, onlyActive),
      i = a.length;
    while(--i > -1) {
      a[i]._kill(vars, target);
    }
  };



  /*
   * ----------------------------------------------------------------
   * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
   * ----------------------------------------------------------------
   */
  var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
    this._overwriteProps = (props || "").split(",");
    this._propName = this._overwriteProps[0];
    this._priority = priority || 0;
    this._super = TweenPlugin.prototype;
  }, true);

  p = TweenPlugin.prototype;
  TweenPlugin.version = "1.19.0";
  TweenPlugin.API = 2;
  p._firstPT = null;
  p._addTween = _addPropTween;
  p.setRatio = _setRatio;

  p._kill = function(lookup) {
    var a = this._overwriteProps,
      pt = this._firstPT,
      i;
    if(lookup[this._propName] != null) {
      this._overwriteProps = [];
    } else {
      i = a.length;
      while(--i > -1) {
        if(lookup[a[i]] != null) {
          a.splice(i, 1);
        }
      }
    }
    while(pt) {
      if(lookup[pt.n] != null) {
        if(pt._next) {
          pt._next._prev = pt._prev;
        }
        if(pt._prev) {
          pt._prev._next = pt._next;
          pt._prev = null;
        } else if(this._firstPT === pt) {
          this._firstPT = pt._next;
        }
      }
      pt = pt._next;
    }
    return false;
  };

  p._mod = p._roundProps = function(lookup) {
    var pt = this._firstPT,
      val;
    while(pt) {
      val = lookup[this._propName] || (pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]);
      if(val && typeof(val) === "function") { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
        if(pt.f === 2) {
          pt.t._applyPT.m = val;
        } else {
          pt.m = val;
        }
      }
      pt = pt._next;
    }
  };

  TweenLite._onPluginEvent = function(type, tween) {
    var pt = tween._firstPT,
      changed, pt2, first, last, next;
    if(type === "_onInitAllProps") {
      //sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
      while(pt) {
        next = pt._next;
        pt2 = first;
        while(pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }
        if((pt._prev = pt2 ? pt2._prev : last)) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }
        if((pt._next = pt2)) {
          pt2._prev = pt;
        } else {
          last = pt;
        }
        pt = next;
      }
      pt = tween._firstPT = first;
    }
    while(pt) {
      if(pt.pg)
        if(typeof(pt.t[type]) === "function")
          if(pt.t[type]()) {
            changed = true;
          }
      pt = pt._next;
    }
    return changed;
  };

  TweenPlugin.activate = function(plugins) {
    var i = plugins.length;
    while(--i > -1) {
      if(plugins[i].API === TweenPlugin.API) {
        _plugins[(new plugins[i]())._propName] = plugins[i];
      }
    }
    return true;
  };

  //provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
  _gsDefine.plugin = function(config) {
    if(!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
    var propName = config.propName,
      priority = config.priority || 0,
      overwriteProps = config.overwriteProps,
      map = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_mod", mod: "_mod", initAll: "_onInitAllProps" },
      Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
        function() {
          TweenPlugin.call(this, propName, priority);
          this._overwriteProps = overwriteProps || [];
        }, (config.global === true)),
      p = Plugin.prototype = new TweenPlugin(propName),
      prop;
    p.constructor = Plugin;
    Plugin.API = config.API;
    for(prop in map) {
      if(typeof(config[prop]) === "function") {
        p[map[prop]] = config[prop];
      }
    }
    Plugin.version = config.version;
    TweenPlugin.activate([Plugin]);
    return Plugin;
  };


  //now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
  a = window._gsQueue;
  if(a) {
    for(i = 0; i < a.length; i++) {
      a[i]();
    }
    for(p in _defLookup) {
      if(!_defLookup[p].func) {
        window.console.log("GSAP encountered missing dependency: " + p);
      }
    }
  }

  _tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

/**
 * 资源路径
 * resource 就是图片音频数据文件
 * widget 是零件资源文件
 * @type {String}
 */
var defaultSourcePath = "content/gallery/";
var defaultWidgetPath = "content/widget/";

/**
 * 资源根路径
 * @type {String}
 */
var getSourcePath = function getSourcePath() {
  if (config.launch.resource) {
    return config.launch.resource + '/gallery/';
  } else {
    return defaultSourcePath;
  }
};

/**
 * 零件
 * @param  {[type]} 'source' [description]
 * @return {[type]}          [description]
 */
var getWidgetPath = function getWidgetPath() {
  if (config.launch.resource) {
    return config.launch.resource + '/widget/';
  } else {
    return defaultWidgetPath;
  }
};

var isIOS = Xut.plat.isIOS;
var isAndroid = Xut.plat.isAndroid;

//杂志直接打开
var nativeConfig = {

  /**
   * 资源图片
   * @return {[type]} [description]
   */
  resources: function resources(config) {
    if (isIOS) {
      return getSourcePath();
    }
    if (isAndroid) {
      if (parseInt(config.launch.storageMode)) {
        //sd卡加载资源数据
        return "/sdcard/appcarrier/magazine/" + config.data.appId + "/" + getSourcePath();
      } else {
        //android_asset缓存加载资源
        return "/android_asset/www/" + getSourcePath();
      }
    }
  },


  /**
   * 视频路径
   * ios平台在缓存
   * 安卓在编译raw中
   */
  video: function video() {
    if (isIOS) {
      return getSourcePath();
    }
    if (isAndroid) {
      return 'android.resource://#packagename#/raw/';
    }
  },


  /**
   * 音频路径
   * ios平台在缓存
   * 安卓在缓存中
   * @return {[type]} [description]
   */
  audio: function audio() {
    if (isIOS) {
      return getSourcePath();
    }
    if (isAndroid) {
      return "/android_asset/www/" + getSourcePath();
    }
  },


  /**
   * 读取svg路径前缀
   * @return {[type]} [description]
   */
  svg: function svg() {
    return 'www/' + getSourcePath();
  },


  /**
   * js零件
   * 2016.8.3 喵喵学
   * @return {[type]} [description]
   */
  jsWidget: function jsWidget() {
    if (isIOS) {
      return getWidgetPath();
    }
    if (isAndroid) {
      return "/android_asset/www/" + getWidgetPath();
    }
  }
};

var isIOS$1 = Xut.plat.isIOS;
var isAndroid$1 = Xut.plat.isAndroid;
var DUKUCONFIG = window.DUKUCONFIG;
var MMXCONFIG$1 = window.MMXCONFIG;
var CLIENTCONFIGT$1 = window.CLIENTCONFIGT;
var SUbCONFIGT = window.SUbCONFIGT;

/**
 * 读酷模式下的路径
 * @param  {[type]} DUKUCONFIG [description]
 * @return {[type]}                   [description]
 */
if (DUKUCONFIG) {
  DUKUCONFIG.path = DUKUCONFIG.path.replace('//', '/');
}

/**
 * 除右端的"/"
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
var rtrim = function rtrim(str) {
  if (typeof str != 'string') return str;
  var lastIndex = str.length - 1;
  if (str.charAt(lastIndex) === '/') {
    return str.substr(0, lastIndex);
  } else {
    return str;
  }
};

// var MMXCONFIGPath = '.'
// if (MMXCONFIG && MMXCONFIG.path) {
//     MMXCONFIGPath = location.href.replace(/^file:\/\/\/?/i, '/').replace(/[^\/]*$/, '');
// }
var MMXCONFIGPath = location.href.replace(/^file:\/\/\/?/i, '/').replace(/[^\/]*$/, '');
if (MMXCONFIG$1 && MMXCONFIG$1.path) {
  MMXCONFIGPath = rtrim(MMXCONFIG$1.path);
}

/**
 *  通过iframe加载判断当前的加载方式
 *  1 本地iframe打开子文档
 *  2 读酷加载电子杂志
 *  3 读酷加载电子杂志打开子文档
 */
var iframeMode = function () {
  var mode = void 0;
  if (SUbCONFIGT && DUKUCONFIG) {
    //通过读酷客户端开打子文档方式
    mode = 'iframeDuKuSubDoc';
  } else {
    //子文档加载
    if (SUbCONFIGT) {
      mode = 'iframeSubDoc';
    }
    //读酷客户端加载
    if (DUKUCONFIG) {
      mode = 'iframeDuKu';
    }
    //客户端模式
    //通过零件加载
    if (CLIENTCONFIGT$1) {
      mode = 'iframeClient';
    }
    //秒秒学客户端加载
    if (MMXCONFIG$1) {
      mode = 'iframeMiaomiaoxue';
    }
  }
  return mode;
}();

//iframe嵌套配置
//1 新阅读
//2 子文档
//3 秒秒学
var iframeConfig = {

  /**
   * 资源图片
   * @return {[type]} [description]
   */
  resources: function resources() {
    if (isIOS$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          return getSourcePath();
        case 'iframeDuKuSubDoc':
          return getSourcePath();
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }

    if (isAndroid$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeDuKuSubDoc':
          return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }
  },


  /**
   * 视频路径
   * @return {[type]} [description]
   */
  video: function video() {
    if (isIOS$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          return getSourcePath();
        case 'iframeDuKuSubDoc':
          return getSourcePath();
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }

    if (isAndroid$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          return 'android.resource://#packagename#/raw/';
        case 'iframeDuKuSubDoc':
          return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }
  },


  /**
   * 音频路径
   * @return {[type]} [description]
   */
  audio: function audio() {
    if (isIOS$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          return getSourcePath();
        case 'iframeDuKuSubDoc':
          return getSourcePath();
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }
    if (isAndroid$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          return '/android_asset/www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeDuKuSubDoc':
          return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }
  },


  /**
   * 调用插件处理
   * @return {[type]} [description]
   */
  svg: function svg() {
    if (isIOS$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          //www/content/subdoc/00c83e668a6b6bad7eda8eedbd2110ad/content/gallery/
          return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeDuKuSubDoc':
          return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }

    if (isAndroid$1) {
      switch (iframeMode) {
        case 'iframeDuKu':
          return DUKUCONFIG.path;
        case 'iframeSubDoc':
          return 'www/content/subdoc/' + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeDuKuSubDoc':
          return DUKUCONFIG.path.replace('gallery', 'subdoc') + SUbCONFIGT.path + '/content/gallery/';
        case 'iframeClient':
          return CLIENTCONFIGT$1.path;
        case 'iframeMiaomiaoxue':
          return MMXCONFIGPath + '/content/gallery/';
      }
    }
  },


  /**
   * js零件
   * 2016.8.3 喵喵学
   * @return {[type]} [description]
   */
  jsWidget: function jsWidget() {
    return MMXCONFIGPath + '/content/widget/';
  }
};

var CEIL = Math.ceil;

/**
 * 全局可视区域布局处理
 * 4种可选模式，1/2/3/4
 *
 * noModifyValue 是否强制修改值，主要用来第一次进应用探测是否有全局宽度溢出的情况
 */
function getVisualSize(config, fullProportion, setVisualMode, noModifyValue) {

  var screenWidth = config.screenSize.width;
  var screenHeight = config.screenSize.height;
  var newBottom = 0;
  var newTop = 0;
  var newLeft = 0;

  //2017.12.4
  //秒秒学的全局工具栏，这个比较特殊
  //因为设计到工具栏合并页面，所以需要修改页面的显示值了
  //默认秒秒学工具栏是1/17
  //如果没有float就是合并一个整体页面
  //如果有float，就是浮动在页面上，这里就不需改变值了
  var pageBar = config.launch.pageBar;
  if (pageBar && pageBar.type === 'globalBar' && !pageBar.float) {
    newBottom = Math.round(screenHeight / 17);
    screenHeight = screenHeight - newBottom;
    config.launch.pageBar.bottom = newBottom;
  }

  var newWidth = screenWidth;
  var newHeight = screenHeight;

  if (!setVisualMode) {
    Xut.$warn({
      type: 'visual',
      content: 'getVisualSize没有提供setVisualMode'
    });
  }

  /**
   * 模式2：
   * 宽度100%，正比缩放高度
   */
  if (setVisualMode === 2) {

    //竖版PPT
    if (config.pptVertical) {
      //竖版显示：正常
      if (config.screenVertical) {
        newHeight = fullProportion.pptHeight * fullProportion.width;
        newTop = (screenHeight - newHeight) / 2;
      }
      //横版显示：反向
      if (config.screenHorizontal) {
        newWidth = fullProportion.pptWidth * fullProportion.height;
        newLeft = (screenWidth - newWidth) / 2;
      }
    }

    //横版PPT
    if (config.pptHorizontal) {
      //横版显示：正常
      if (config.screenHorizontal) {
        newHeight = fullProportion.pptHeight * fullProportion.width;
        newTop = (screenHeight - newHeight) / 2;
      }
      //竖版显示：反向
      if (config.screenVertical) {
        newHeight = fullProportion.pptHeight * fullProportion.width;
        newTop = (screenHeight - newHeight) / 2;
      }
    }

    //保证模式2高度不能溢出分辨率最大距离
    if (newHeight > screenHeight) {
      newHeight = screenHeight;
      newTop = 0;
    }
  }

  /**
   * 模式3：
   * 高度100%,宽度溢出可视区隐藏
   */
  if (setVisualMode === 3) {

    //竖版：PPT
    if (config.pptVertical) {
      //竖版显示：正常
      if (config.screenVertical) {
        //宽度溢出的情况
        newWidth = fullProportion.pptWidth * fullProportion.height;
        newLeft = (screenWidth - newWidth) / 2;

        //宽度没办法溢出
        //要强制宽度100%
        if (newWidth < screenWidth) {
          newWidth = screenWidth;
          newLeft = 0;
        }
      }
      //横版显示：反向
      if (config.screenHorizontal) {
        newWidth = fullProportion.pptWidth * fullProportion.height;
        newLeft = (screenWidth - newWidth) / 2;
      }
    }

    //横版：PPT
    if (config.pptHorizontal) {

      //横版显示:正常
      if (config.screenHorizontal) {
        newWidth = fullProportion.pptWidth * fullProportion.height;
        newLeft = (screenWidth - newWidth) / 2;

        //宽度没办法溢出
        //要强制宽度100%
        if (!noModifyValue && newWidth < screenWidth) {
          newWidth = screenWidth;
          newLeft = 0;
        }
      }

      //竖版显示：反向
      if (config.screenVertical) {
        newHeight = fullProportion.pptHeight * fullProportion.width;
        newTop = (screenHeight - newHeight) / 2;
      }
    }
  }

  /**
   * 模式1
   * 如果启动了双页模式
   */
  if (config.launch.doublePageMode && setVisualMode === 1) {
    newWidth = newWidth / 2;
  }

  /**
   * 模式5
   */
  if (setVisualMode === 5) {
    newWidth = screenWidth * 2;
  }

  /**
   * 模式2.3.4
   * config.launch.visualMode === 1
   * @return {[type]}
   */
  return {
    width: CEIL(newWidth),
    height: CEIL(newHeight),
    left: CEIL(newLeft),
    top: CEIL(newTop),
    bottom: newBottom
  };
}

/**
 * 屏幕尺寸
 * @return {[type]} [description]
 */
function getSize() {
  //如果是IBooks模式处理
  if (Xut.IBooks.Enabled) {
    var screen = Xut.IBooks.CONFIG.screenSize;
    if (screen) {
      return {
        "width": screen.width,
        "height": screen.height
      };
    }
  }

  var clientWidth = document.documentElement.clientWidth || $(window).width();
  var clientHeight = document.documentElement.clientHeight || $(window).height();

  //配置可视区窗口
  //用户在外部指定了可视区域
  if (config.launch.visualHeight) {
    config.launch.visualTop = clientHeight - config.launch.visualHeight;
    clientHeight = config.launch.visualHeight;
  }

  return {
    "width": clientWidth,
    "height": clientHeight
  };
}

/**
 * 排版判断
 * @return {[type]} [description]
 */
function getLayerMode(screenSize) {
  return screenSize.width > screenSize.height ? "horizontal" : "vertical";
}

/**
 * 默认ppt尺寸
 * @type {Number}
 */
var PPTWIDTH = 1024;
var PPTHEIGHT = 768;

/**
 * 获取默认全屏比值关系
 * 用来设置新的view尺寸
 * @param  {[type]} config    [description]
 * @param  {[type]} pptWidth  [description]
 * @param  {[type]} pptHeight [description]
 * @return {[type]}           [description]
 */
function getFullProportion(config, pptWidth, pptHeight) {
  //设备分辨率
  var screenWidth = config.screenSize.width;
  var screenHeight = config.screenSize.height;

  var screenHorizontal = config.screenHorizontal;

  //默认ppt尺寸
  var designWidth = pptWidth ? pptWidth : screenHorizontal ? PPTWIDTH : PPTHEIGHT;
  var designHeight = pptHeight ? pptHeight : screenHorizontal ? PPTHEIGHT : PPTWIDTH;

  //当前屏幕的尺寸与数据库设计的尺寸，比例
  var widthProp = screenWidth / designWidth;
  var heightProp = screenHeight / designHeight;

  return {
    width: widthProp,
    height: heightProp,
    left: widthProp,
    top: heightProp,
    pptWidth: designWidth,
    pptHeight: designHeight
  };
}

/**
 * 计算真正的缩放比
 * 依照真正的view尺寸设置
 * @param  {[type]} pptWidth  [description]
 * @param  {[type]} pptHeight [description]
 * @return {[type]}           [description]
 */
function getRealProportion(config, visualSize, fullProportion) {
  var widthProp = visualSize.width / fullProportion.pptWidth;
  var heightProp = visualSize.height / fullProportion.pptHeight;

  //布局的偏移量，可能是采用了画轴模式，一个可视区可以容纳3个页面
  var offsetTop = 0;
  var offsetLeft = 0;

  return {
    width: widthProp,
    height: heightProp,
    left: widthProp,
    top: heightProp,
    offsetTop: offsetTop,
    offsetLeft: offsetLeft
  };
}

/**
 * 全局配置文件
 * 2种使用方式
 *   1：Xut.Application.setConfig
 *   2：Xut.Application.Launch
 * @type {[type]}
 */

var DEFAULT = undefined;

var improtGlobalConfig = {

  /**
   * 应用的加载模式
   * 0： 应用自行启动
   * 1： 应用通过接口启动
   *     Xut.Application.Launch
   *     提供全局可配置参数
   * @type {Number}
   */
  lauchMode: 0,

  /**
   * 页面可视模式
   * 2016.9.19
   * 4种分辨率显示模式:
   * 默认全屏缩放
   * 1：永远100%屏幕尺寸自适应
   * 2：宽度100% 正比自适应高度
   *     横版PPT：
   *        1：横板显示(充满全屏。第1种模式)
   *        2：竖版显示(宽度100%。上下自适应，显示居中小块)
   *     竖版PPT:
   *        1: 竖版显示(宽度100%。上下空白，显示居中，整体缩短, 整理变化不大)
   *        2: 在横版显示(高度100%，缩放宽度，左右留边)
   *
   * 3: 高度100%,宽度溢出可视区隐藏
   * 4：高度100% 正比自适应宽度
   *     横版：
   *        1：横板显示(充满全屏。第1种模式)
   *        2：竖版显示(宽度100%。上下自适应，显示居中小块)
   *     竖版:
   *        1: 竖版ppt竖版显示(高度100%。宽度溢出，只显示中间部分，整体拉长)
   *        2: 竖版ppt在横版显示(高度100%，显示居中，左右空白，整体缩短)
   *
   * 5: 竖版显示横版PPT：高度100%，双页面模式
   *
      1 全屏自适应
      2 宽度100%，自适应高度
      3 高度100%, 自适应宽度
      4 画轴模式
      5 虚拟页面模式
       用户接口设定> PPT数据库设定 > 默认取1
   */
  visualMode: DEFAULT, //等填充


  /**
   * 全局翻页模式
   * 给妙妙单独开的一个模式
   * 一个novel对应多个season表 所以这里其实不能算全局设置，可以存在多个novel
   * novel表定义，数据库定义的翻页模式
   * 用来兼容客户端的制作模式
   * 妙妙学模式处理，多页面下翻页切换
   *
   * 后期增加竖版模式修正接口
   *
   * scrollMode
   *   横版翻页 horizontal  h
   *   竖版翻页 vertical    v
   *
   */
  scrollMode: 'h',

  /**
   * 切换切换模式
   * 多模式判断
   * 如果
   *   缓存存在
   *   否则数据库解析
         数据库filpMode全局翻页模式
         0 滑动翻页 =》true
         1 直接换  =》 false
   * 所以pageFlip只有在左面的情况下
   * @type {Boolean}
   */
  gestureSwipe: DEFAULT, //等之后全局设置，或者数据库填充，这里可以全局优先

  /**
   * 是否预加载资源
   * 每次翻页必须等待资源加载完毕后才可以
  //2017.9.1
  //如果不是浏览器模式
  //强制关闭预加载模式
   * @type {Boolean}
   */
  preload: DEFAULT, //可以填数量，预加载的数量限制

  /*
  跨域处理资源
  资源转化处理，默认资源可能是svg，在跨域的情况下没办法访问
  比如，mini客户端
  所以svg的资源会强制转化成js
   */
  crossDomain: DEFAULT, //默认不处理svg转化  参数 'svg'

  /**
   * 是否关闭启动动画，默认是true启动，false为关闭
   * 加快进入的速度
   */
  launchAnim: true,

  /**
   * 双页面模式，竖版ppt在横版显示
   * 一个view中，显示2个page
   * 一个页面宽度50%，拼接2个页面100%
   * 默认禁止：
   * 1 true 启动
   * 2 false 禁止
   */
  doublePageMode: false,

  /**
   * 监听代码追踪
   * type:类型
   *   keepAppTime //应用运行时间
   *   keepPageTime //每个页面运行时间
   *   action => (包含，content的事件，action,audio,video,widget零件触发的事件)
   *
   *  options:参数
   *    keepAppTime => time 运行时间
   *    keepPageTime => time 运行时间
   *
   *    action => {
   *      appId  应用的id
   *      appName 应用标题
   *      id 元素的id
   *      type  触发的类型
   *      pageId 页面的id,对应数据库chapter ID
   *      eventName 事件名
   *    }
   *
    Xut.Application.Watch('trackCode', function(type, options) {
        console.log(type, options)
        switch (type) {
            case 'launch':
                break;
            case 'init':
                break;
            case 'exit':
                break;
            ...........
        }
    }
    launch    应用启动后触发
    init      初始化加载完毕，能显示正常页面后触发
    exit      应用关闭触发
    flip      翻页触发
    content   点击有事件对象触发(content类型)
    hot       点击没有绑定事件,但是又能触发的对象(除了content的其余对象)
    swipe     垂直滑动触发
     ['launch', 'init', 'exit', 'flip', 'content', 'hot'，'swipe']
     特别注意，配置中有'content' 'hot'
    但是实际返回的数据中改成了统一接口 action然后type带类型
    */
  trackCode: null,

  /**
  * 图片模式webp
     0：旧版本
     1：自适应
     2：Ios
     3：Android
  、
     brMode === 0，则什么都不变
      brMode === 1/2/3，
       在线版：
         brMode为ios或android，获取了数据库的文件名之后，去掉扩展名。
         如果是ios，则文件名之后加上_i
         Android，则文件名之后，加上_a
        本地版：
         brMode为ios或android，后缀不改变，用数据库定义的文件名
        图像带有蒙板
         首先，忽略蒙板设置
         然后按照上面的规则，合成新的文件名即
     2017.8.4
      如果有perload那么就会自适应 webp/apng
      如果没有就强制为0，只支持png,jpng
  */
  brMode: 0,

  /**
   * 是否启动分栏高度检测
   * 变更依赖
   * 如果检测到有column数据，会自动启动
   */
  columnCheck: DEFAULT, //如果强制false了就是永远关闭，如果DEFAULT就让其默认处理

  /**
   * 迷你杂志页码显示配置
   * 1 数字 digital (默认)
   * 2 原点 circular {
   *            mode: 1/2/3/4/5/6
   *            position:
   *        }
   * 3 滚动工具栏 scrollbar
   *             direction 滚动方向 'v' / 'h'
   *
   * 组合模式['digital','circular','scrollbar']
   * @type {Object}
   *
   * 2017.12.4
   * 新增秒秒学全局工具栏
   *
   * pageBar：{
   *   type:'globalBar'
   *   mode:1/2/3/4/5/6
   *   float:true //是否全局浮动
   *   button:{
   *     keepLearn  继续学习
   *     commitWork 提交作业
   *     forum
   *   }
   *   hasNextSection:是否有下一个ppt  这个给苗苗学使用，是否用来显示原点
   * }
   *
   *
   */
  pageBar: {
    type: 'digital',
    mode: DEFAULT,
    position: DEFAULT
  },

  /**
   * 是否支持鼠标滑动
   * @type {Boolean}
   * false 关闭
   */
  mouseWheel: DEFAULT, //默认根据横竖屏幕自定义

  /**
   * 适配平台
   * mini //迷你杂志
   * @type {[type]}
   */
  platform: DEFAULT,

  /**
   * 是否支持快速翻页
   * 这个为超星处理，可以配置关闭快速翻页，必须要等页面创建完毕后才能翻页
   */
  quickFlip: true, //默认是支持

  /**
   * 支持二维码图片
   * 如果有二维码针对img元素放开默认行为的阻止
   * @type {Boolean}
   */
  supportQR: false,

  /**
   * 控制可视区的高度
   * 给mini杂志的客户端使用
   * 因为有工具栏挤压的问题
   */
  visualHeight: DEFAULT,
  visualTop: 0, //根据高度内部算出的top提供给缩放图片的全屏放大使用

  /**
   * 忙碌光标
   * 1 cursor:false 关闭
   * 2 可配置
   *   cursor: {
   *      url: 'images/icons/showNote.png',
   *      time: 500
   *   },
   * @type {[type]}
   */
  cursor: {
    delayTime: DEFAULT, //延时间显示时间
    url: DEFAULT //url
  },

  /**
   * 启动自适应图片分辨率
   * iphone的750*1334，android的720*1280及以下的设备，用标准的
   * iphone plus的1080*1920，android的1080*1920，用mi后缀的
   * android的1440*2560用hi后缀的
   *{
   *   750: '', //0-750
   *   1080: '', //mi:751-1080
   *   1440: '' //hi:1081->
   *}
   */
  imageSuffix: null,

  /**
   * @私有方法
   * 基础图片后缀
   * content类型
   * flow类型
   * @type {String}
   * 通过imageSuffix方法填充
   */
  baseImageSuffix: '',

  /**
   * 不使用高清图片
   * false
   * true
   */
  useHDImageZoom: true,

  /**
   * 是否允许图片缩放
   */
  salePicture: true, //默认启动图片缩放的
  salePictureMultiples: 4, //默认缩放的倍数4倍

  /**
   * 是否允许页面缩放页面
   * 默认情况下页面是不允许被缩放的
   * @type {[type]}
   * salePageType:'flow' / 'page' / 'all'
   * 可选项，缩放流式页面
   *        缩放page页面
   *        all全部支持
   */
  salePageType: DEFAULT, //默认页面是不允许被缩放的，这里可以单独启动页面缩放

  /**
   * 是否需要保存记录加载
   * 1 true 启动缓存
   * 2 false 关闭缓存
   * @type {[type]}
   */
  historyMode: DEFAULT, //不处理，因为有调试的方式

  /**
   * 滑动事件委托
   * 这个东东是针对mini开发的
   * 左右翻页手势提升到全局响应
   * 相应的对象形成形成事件队列
   * [content1,content2,...,翻页]
   * 1 true 启动
   * 2 false 禁止
   */
  swipeDelegate: DEFAULT, //默认关闭，min杂志自动启用


  /**
   * 存储模式
   * 0 APK应用本身
   * 1 外置SD卡
   */
  storageMode: 0
};

////////////////////////
///   内部调试配置
///
///   Xut.Application.setConfig ={
///       debug:{
///          terminal:true,
///          silent:'all'
//        }
///   }
///
////////////////////////

var DEFAULT$1 = undefined;

var improtDebugConfig = {

  /**
   * 是否支持debug.js的远程处理
   * @type {Boolean}
   */
  terminal: false,

  /**
   * 是否支持错误日志打印
   * silent 启动是所有的调试内容
   * 也可以单独启用每一项的调试内容
   * ['all','api','preload','column','visual','scale',
   *   'config','pagebase','swiper','event','util','database','logic',html5Audio]
   * api 级别
   * create 创建相关
   * preload 预加载处理
   * column 根流式布局相关的
   * visual 跟visualMode相关的
   * scale 跟图片缩放相关
   * config 跟基本配置相关
   * pagebase pagebase页面相关
   * swiper 跟滑动相关的
   * event 根事件相关
   * util 工具处理相关
   * database 数据库处理相关
   * logic 跟逻辑相关的，流程跑通测试
   * html5Audio html5音频相关
   * record 录音相关
   */
  silent: null,

  /**
   * 独立canvas模式处理
   * 为了测试方便
   * 可以直接切换到dom模式
   *
   * 默认禁止：
   * 1 true 启动
   * 2 false 禁止
   * @type {Boolean}
   */
  onlyDomMode: false,

  /**
   * 仅做测试处理，因为每个section都可以对应配置tpType参数
   * 配置工具栏行为
   *
   *  工具栏类型
   *  toolType：(如果用户没有选择任何工具栏信息处理，tbType字段就为空)
   *   0  禁止工具栏
   *   1  系统工具栏   - 显示IOS系统工具栏
   *   2  场景工具栏   - 显示关闭按钮
   *   3  场景工具栏   - 显示返回按钮
   *   4  场景工具栏   - 显示顶部小圆点式标示
   *   填充数组格式，可以多项选择[1,2,3,4]
   */
  toolType: { //默认不设置，待数据库填充。如设置,数据库设置忽略
    main: DEFAULT$1, //主场景，系统工具栏
    deputy: DEFAULT$1, //副场景，函数工具栏
    number: DEFAULT$1 //独立配置，默认会启动页面，针对分栏处理
  },

  /**
   * 直接定位页面
   * 直接通过数据库的历史记录定位到指定的页面
   * Xut.View.LoadScenario({
   *     'seasonId' : scenarioInfo[0],
   *     'chapterId'  : scenarioInfo[1],
   *     'pageIndex'  : scenarioInfo[2]
   *  })
   *  {
   *     'seasonId' : 7,
   *     'chapterId'  : 9
   *  }
   * @type {Boolean}
   */
  locationPage: DEFAULT$1,

  /**
   *  仅做测试处理，因为每个section都可以对应配置pageMode参数
   *  翻页模式（数据库section指定）
   *
   *  每个场景对应自己的模式
   *  所以如果这里配置了，那么所有的场景全部统一配置了
   *  这里其实是不合理的，所以仅作为测试
   *
   *  pageMode：(如果用户没有选择任何处理，pageMode字段就为空)
   *   0 禁止滑动
   *   1 允许滑动无翻页按钮
   *   2 允许滑动带翻页按钮
   *
   *  主场景工具栏配置：默认2
   *  副场景工具栏配置：默认 0
   */
  pageMode: DEFAULT$1 //默认不设置，待数据库填充。如设置,数据库设置忽略

};

////////////////////////
///   数据配置接口文件
////////////////////////

var improtDataConfig = {

  /**
   * 应用novelId
   * @type {[type]}
   */
  novelId: null,

  /**
   * 应用页码索引
   * @type {[type]}
   */
  pageIndex: null,

  /**
   * 数据库尺寸
   */
  dbSize: 1,

  /**
   * 应用路径唯一标示
   */
  appId: null,

  /**
   * 默认图标高度
   */
  iconHeight: Xut.plat.isIphone ? 32 : 44,

  /**
   * 数据库名
   */
  dbName: window.xxtmagzinedbname || 'magazine',

  /**
   * 支持电子在在线阅读,向服务端取数据
   * 自定义配置地址即可'
   * @type {String}
   */
  onlineModeUrl: 'lib/data/database.php',

  /**
   * 资源路径
   * @type {[type]}
   */
  pathAddress: null
};

/**
 * 配置文件
 * @return {[type]}         [description]
 */
/*
导入
1 全局配置
2 内部配置
3 依赖数据
 */
var isBrowser = Xut.plat.isBrowser;
var GLOBALIFRAME$1 = window.GLOBALIFRAME;
var CLIENTCONFIGT = window.CLIENTCONFIGT;
var MMXCONFIG = window.MMXCONFIG;

var config = {};

var layoutMode = void 0;
var proportion = void 0;
var fullProportion = void 0;

/*层级关系*/
var _zIndex = 1000;
Xut.zIndexlevel = function () {
  return ++_zIndex;
};

//通过新学堂加载
//用于处理iframe窗口去全屏
if (/xinxuetang/.test(window.location.href)) {
  config.iframeFullScreen = true;
}

/**
 * 是否启动缓存机制
 * 第一次默认是关闭
 * 必须读取一次后，缓存启动
 * 为了支持Xut.config.launch模式
 * @type {Boolean}
 */
var isCacheVideoPath = false;
var isCacheAudioPath = false;
var isCacheSvgPath = false;
var isCacheJsWidgetPath = false;

var cacheVideoPath = void 0;
var cacheAudioPath = void 0;
var cacheSvgPath = void 0;
var cacheJsWidgetPath = void 0;

/**
 * pc端模式
 * 而且是客户端模式
 * @return {[type]} [description]
 */
var desktopPlat = function desktopPlat() {

  //2016.9.13
  //新增动态模式
  if (config.launch.resource) {
    return getSourcePath();
  }

  //如果是iframe加载
  //而且是客户端模式
  if (GLOBALIFRAME$1 && CLIENTCONFIGT) {
    return CLIENTCONFIGT.path;
  }

  if (typeof initGalleryUrl != 'undefined') {
    return getSourcePath();
  } else {
    //资源存放位置
    // * storageMode 存放的位置
    // * 0 APK应用本身
    // 1 外置SD卡
    if (Number(config.launch.storageMode)) {
      return "sdcard/" + config.data.appId + "/" + getSourcePath();
    } else {
      return getSourcePath();
    }
  }
};

/**
 * 平台加载用于
 * 视频.音频妙妙学处理
 * 1 桌面
 * 2 移动端
 * 3 安卓打包后通过网页访问=>妙妙学
 * @return {[type]} [description]
 */
var runMode = function () {
  if (MMXCONFIG) {
    return false;
  }
  return isBrowser;
}();

/**
 * 图片资源配置路径
 * [resourcesPath description]
 * @return {[type]} [description]
 */
var _rsourcesPath = function _rsourcesPath() {
  return isBrowser ? desktopPlat() : GLOBALIFRAME$1 ? iframeConfig.resources(config) : nativeConfig.resources(config);
};

/**
 * mp3 mp4 音频文件路径
 * 1 音频加载就会自动拷贝到SD卡上
 * 2 或者asset上的资源
 * @return {[type]} [description]
 */
var _videoPath = function _videoPath() {
  return runMode ? desktopPlat() : GLOBALIFRAME$1 ? iframeConfig.video() : nativeConfig.video();
};

/**
 * 音频路径
 * @return {[type]} [description]
 */
var _audioPath = function _audioPath() {
  return runMode ? desktopPlat() : GLOBALIFRAME$1 ? iframeConfig.audio() : nativeConfig.audio();
};

/**
 * SVG文件路径
 * @return {[type]} [description]
 */
var _svgPath = function _svgPath() {
  return isBrowser ? desktopPlat() : GLOBALIFRAME$1 ? iframeConfig.svg() : nativeConfig.svg();
};

/**
 * js零件
 * 2016.8.3 妙妙学新增
 * 只提供相对路径
 * @return {[type]} [description]
 */
var _jsWidgetPath = function _jsWidgetPath() {
  return isBrowser ? getWidgetPath() : GLOBALIFRAME$1 ? iframeConfig.jsWidget() : nativeConfig.jsWidget();
};

/**
 * 全局配置文件
 * @type {Boolean}
 */
_.extend(config, {

  /**
   * 应用横竖自适应切换
   * 默认在浏览器端打开
   * 这里可以定义打开关闭
   * 打开：1
   * 默认：0
   * [orientate description]
   * @type {[type]}
   */
  orientateMode: Xut.plat.isBrowser ? true : false,

  /**
   * 视频文件路径
   */
  getVideoPath: function getVideoPath() {
    if (isCacheVideoPath && cacheVideoPath) {
      return cacheVideoPath;
    }
    isCacheVideoPath = true;
    return cacheVideoPath = _videoPath();
  },


  /**
   * 音频文件路径
   */
  getAudioPath: function getAudioPath() {
    if (isCacheAudioPath && cacheAudioPath) {
      return cacheAudioPath;
    }
    isCacheAudioPath = true;
    return cacheAudioPath = _audioPath();
  },


  /**
   * 配置SVG文件路径
   */
  getSvgPath: function getSvgPath() {
    if (isCacheSvgPath && cacheSvgPath) {
      return cacheSvgPath;
    }
    isCacheSvgPath = true;
    return cacheSvgPath = _svgPath();
  },


  /**
   * 配置js零件文件路径
   * 2016.8.3增加
   */
  getWidgetPath: function getWidgetPath$$1() {
    if (isCacheJsWidgetPath && cacheJsWidgetPath) {
      return cacheJsWidgetPath;
    }
    isCacheJsWidgetPath = true;
    return cacheJsWidgetPath = _jsWidgetPath();
  },


  /**
   * 2016.7.26
   * 读酷增加强制插件模式
   */
  isPlugin: window.DUKUCONFIG && Xut.plat.isIOS,
  /*排版模式*/
  layoutMode: layoutMode,
  /*缩放比例*/
  proportion: proportion,
  /*全局数据配置*/
  data: improtDataConfig,
  /*全局debug配置*/
  debug: improtDebugConfig,
  /*默认全局配置*/
  global: improtGlobalConfig,
  /*默认的提供postMessage的方式配置*/
  postMessage: {}
});

Xut.config = config;

/**
 * 销毁配置
 */
function clearConfig() {
  cacheVideoPath = null;
  cacheAudioPath = null;
  cacheSvgPath = null;
  cacheJsWidgetPath = null;
}

/**
 * 初始化资源路径
 * 配置图片路径地址
 */
function initPathAddress() {
  //设置资源缓存关闭
  isCacheVideoPath = false;
  isCacheAudioPath = false;
  isCacheSvgPath = false;
  isCacheJsWidgetPath = false;

  /*资源路径*/
  config.data.pathAddress = _rsourcesPath();

  /*根路径*/
  config.data.rootPath = config.data.pathAddress.replace('/gallery/', '');
}

/**
 * 默认设置
 * 通过数据库中的设置的模板尺寸与实际尺寸修复
 */
function resetProportion(pptWidth, pptHeight, setVisualMode, noModifyValue) {
  //获取全屏比值，用来设定view的尺寸
  //根据分辨率与PPT排版的比值来确定
  fullProportion = getFullProportion(config, pptWidth, pptHeight);

  var visualSize = config.visualSize = getVisualSize(config, fullProportion, setVisualMode, noModifyValue);

  //溢出宽度
  visualSize.overflowWidth = false;
  if (visualSize.left < 0) {
    visualSize.overflowWidth = Math.abs(visualSize.left) * 2;
  }
  //溢出高度
  visualSize.overflowHeight = false;
  if (visualSize.top < 0) {
    visualSize.overflowHeight = true;
  }
  //获取全局缩放比
  proportion = config.proportion = getRealProportion(config, visualSize, fullProportion);
}

/**
 * 获取基本尺寸
 * @param  {[type]} pptWidth   [description]
 * @param  {[type]} pptHeight  [description]
 * @param  {[type]} screenSize [description]
 * @return {[type]}            [description]
 */
function getBasicSize(pptWidth, pptHeight, screenSize) {
  //获取分辨率
  config.screenSize = screenSize || getSize();
  //根据设备判断设备的横竖屏
  config.screenHorizontal = config.screenSize.width > config.screenSize.height ? true : false;
  config.screenVertical = !config.screenHorizontal;
  layoutMode = config.layoutMode = getLayerMode(config.screenSize);
  //数据ppt排版设计
  if (pptWidth && pptHeight) {
    config.pptHorizontal = pptWidth > pptHeight ? true : false;
    config.pptVertical = !config.pptHorizontal;
  }
}

/**
 * 重新设置config
 * @param  {[type]} pptWidth      [description]
 * @param  {[type]} pptHeight     [description]
 * @param  {[type]} screenSize    [description]
 * @param  {[type]} setVisualMode [description]
 * @param  {[type]} noModifyValue [description]
 * @return {[type]}               [description]
 */
function resetConfig(pptWidth, pptHeight, screenSize, setVisualMode, noModifyValue) {
  getBasicSize(pptWidth, pptHeight, screenSize);
  resetProportion(pptWidth, pptHeight, setVisualMode, noModifyValue);
}

/****************************************
 *  反向模式探测(PPT设置与显示相反,例如竖版PPT=>横版显示)
 *  为了在originalVisualSize中重置容器的布局
 *  让容器的布局是反向模式的等比缩放的尺寸
 *  这样算法可以保持兼容正向一致
 * ***************************************/
function initConfig(pptWidth, pptHeight) {

  //第一次探测实际的PPT与屏幕尺寸
  getBasicSize(pptWidth, pptHeight);

  ////////////////////////////////////
  /// 横版PPT，竖版显示，强制为竖版双页面
  ////////////////////////////////////
  if (config.launch.visualMode === 5) {
    resetProportion(pptWidth, pptHeight, config.launch.visualMode);
    config.originalVisualSize = config.visualSize;
    return;
  }

  ////////////////////////////////////
  /// 竖版PPT，横版显示，并启动了双页模式
  ////////////////////////////////////
  if (config.launch.doublePageMode && config.pptVertical && config.screenHorizontal) {
    resetProportion(pptWidth, pptHeight, config.launch.visualMode === 3 ? 2 : config.launch.visualMode);
    config.originalVisualSize = config.visualSize;
    return;
  }

  //////////////////////////////////////////////////////////
  /// 反向设置的情况下
  /// 要计算出实际的显示范围与偏移量 visualSize的数据 d
  /// 比如竖版PPT=》
  ///   screenSize => height : 414 width : 736
  ///   visualSize => height : 414 width : 311 left : 213
  /// 屏幕尺寸与显示范围是不一样的，按照竖版的比例，等比缩小了
  //////////////////////////////////////////////////////////

  if (config.pptHorizontal && config.screenHorizontal && config.launch.visualMode === 3) {
    //如果是横版PPT，横版显示的情况下，并且是全局模式3的情况
    //可能存在宽度，不能铺满全屏的情况
    //所以可能存在要修改尺寸
    //可能会修改全局布局尺寸，所以采用3模式探测
    resetProportion(pptWidth, pptHeight, config.launch.visualMode, true);
  } else {
    //强制检测是否是反向显示模式
    //如果是模式3的情况下，用2检测
    resetProportion(pptWidth, pptHeight, config.launch.visualMode === 3 ? 2 : config.launch.visualMode);
  }

  //如果是PPT与设备反向显示
  //这里可能会溢出left的值
  //那么把每个visual就当做一个整体处理
  // config.originalScreenSize = config.screenSize
  config.originalVisualSize = config.visualSize;

  //竖版PPT,横版显示
  if (config.pptVertical && config.screenHorizontal) {
    config.verticalToHorizontalVisual = true;
  }

  //横版PPT,竖版显示
  if (config.pptHorizontal && config.screenVertical) {
    config.horizontalToVerticalVisual = true;
  }

  /*******************************
   *   受反向检测影响了，需要修正config
   * ******************************/
  if (config.launch.visualMode === 2) {
    //如果是反向模式
    //强制设置visualSize=screenSize
    //从新计算config依赖比值
    if (config.visualSize.left) {
      resetConfig(pptWidth, pptHeight, {
        width: config.visualSize.width,
        height: config.visualSize.height
      }, config.launch.visualMode);
    }
  } else if (config.launch.visualMode === 3) {
    //反模式下，重置高度
    //已经尺寸因为探测已经被改过一次了
    //实际使用的时候，需要还原
    if (config.visualSize.left) {
      resetConfig(pptWidth, pptHeight, {
        width: config.visualSize.width,
        height: config.visualSize.height
      }, 1);
    } else {
      //重新把3模式下按照正常1的情况设置
      //2不行，因为高度不对，只有1与3接近
      resetConfig(pptWidth, pptHeight, '', 1);
    }
  }
}

/**
 * 动态计算计算可视区View
 * 每个页面可以重写页面的view
 */
function resetVisualLayout(setVisualMode) {
  return getVisualSize(config, fullProportion, setVisualMode);
}

/**
 * 动态计算缩放比
 * 每个页面可以重写页面的元素缩放比
 */
function resetVisualProportion(newVisualSize) {
  return getRealProportion(config, newVisualSize, fullProportion);
}

//定义属性
var def = Object.defineProperty;

/**
//  * var emp = ['abs','dsf','sdf','fd']
//  * emp.remove('fd');
//  * @param  {[type]} val [description]
//  * @return {[type]}     [description]
//  */
function removeArray(array, val, callback) {
  var index = array.indexOf(val);
  //如果找到
  if (index > -1) {
    callback && callback();
    array.splice(index, 1);
  }
}

/**
 * 定义一个新的对象
 * 重写属性
 */
function defProtected(obj, key, val, enumerable, writable) {
  def(obj, key, {
    value: val,
    enumerable: enumerable,
    writable: writable,
    configurable: true
  });
}

/**
 * 定义访问控制器
 * @return {[type]} [description]
 */
function defAccess(obj, key, access) {
  def(obj, key, {
    get: access.get,
    set: access.set
  });
}

/**
 * 首字母大写
 * @return {[type]} [description]
 *  string.charAt(0).toUpperCase() + string.slice(1);
 */
function titleCase(category) {
  return category && category.replace(/(\w)/, function (v) {
    return v.toUpperCase();
  });
}

/**
 * 判断存在
 */
function hasIndexOf(para, value) {
  if (para && value) {
    /*数组形式*/
    if (value.length) {
      if (~value.indexOf(para)) {
        return true;
      }
    }
    /*字符串*/
    if (typeof value === 'string') {
      if (para === value) {
        return true;
      }
    }
  }
}

/**
 * 转化数组
 * @param  {[type]} o [description]
 * @return {[type]}   [description]
 */
function toNumber(o) {
  return Number(o) || null;
}

/**
 * 创建一个纯存的hash对象
 */
function hash() {
  return Object.create(null);
}

/**
 * 存在值
 * 只有值不为undefined
 */


function $extend(object, config) {
  for (var i in config) {
    if (i) {
      if (object[i]) {
        Xut.$warn({
          type: 'util',
          content: '\'\u63A5\u53E3\u65B9\u6CD5\u91CD\u590D\', \'Key->\' + i, \'Value->\' + object[i]'
        });
      } else {
        object[i] = config[i];
      }
    }
  }
}

/**
 * /解析json字符串
 * @return {[type]}           [description]
 */
function parseJSON(parameter) {
  if (!parameter) return;
  var json = void 0;
  try {
    json = JSON.parse(parameter);
  } catch (error) {
    Xut.$warn({
      type: 'util',
      content: 'parseJSON\u5931\u8D25:' + parameter
    });
    return false;
  }
  return json;
}

/**
 * 回车符处理
 */
function enterReplace(str) {
  return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
}

/**
 * 解析json代码
 * 包装脚本
 * @param  {[type]} itemArray [description]
 * execJson("(function(){" + enterReplace(data.postCode) + "})");
 */
function makeJsonPack(code) {
  try {
    var post = "(function(){" + enterReplace(code) + "})";
    return new Function("return " + post)();
  } catch (error) {
    Xut.$warn('util', '解析json出错' + code);
  }
}

/**
 * 修正判断是否存在处理
 * @param  {[type]} arr [description]
 * @return {[type]}     [description]
 */
function arrayUnique(arr) {
  //去重
  if (arr && arr.length) {
    var length = arr.length;
    while (--length) {
      //如果在前面已经出现，则将该位置的元素删除
      if (arr.lastIndexOf(arr[length], length - 1) > -1) {
        arr.splice(length, 1);
      }
    }
    return arr;
  } else {
    return arr;
  }
}

/**
 *  文件路径拼接
 * @return {[type]} [description]
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * 2015.3.24
 * 1 isBrowser
 * 2 isMobile
 * 3 isMouseTouch
 */
var transitionEnd = Xut.style.transitionEnd;

//2015.3.23
//可以点击与触摸
var isMouseTouch = Xut.plat.isMouseTouch;
var hasTouch = Xut.plat.hasTouch;

//触发事件名
var touchList = ['click', 'touchstart', 'touchmove', 'touchend', 'touchcancel', transitionEnd];
var mouseList = ['click', 'mousedown', 'mousemove', 'mouseup', 'mousecancel', transitionEnd, 'mouseleave'];

//绑定事件名排序
var orderName = {
  click: 0,
  start: 1,
  move: 2,
  end: 3,
  cancel: 4,
  transitionend: 5,
  leave: 6
};

var eventNames = function () {
  if (isMouseTouch) {
    return {
      touch: touchList,
      mouse: mouseList
    };
  }
  return hasTouch ? touchList : mouseList;
}();

/**
 * 事件数据缓存
 * @type {Object}
 */
var eventDataCache = {};
var guid = 1;

/**
 * 增加缓存句柄
 * @param {[type]} element   [description]
 * @param {[type]} eventName [description]
 * @param {[type]} handler   [description]
 */
function addHandler(element, eventName, handler, capture) {
  if (element.xutHandler) {
    var uuid = element.xutHandler;
    var dataCache = eventDataCache[uuid];
    if (dataCache) {
      if (dataCache[eventName]) {
        //如果是isMouseTouch支持同样的事件
        //所以transitionend就比较特殊了，因为都是同一个事件名称
        //所以只要一份，所以重复绑定就需要去掉
        if (eventName !== 'transitionend') {
          Xut.$warn({
            type: 'event',
            content: eventName + '：事件重复绑定添加'
          });
        }
      } else {
        dataCache[eventName] = [handler, capture];
      }
    }
  } else {
    eventDataCache[guid] = defineProperty({}, eventName, [handler, capture]);
    element.xutHandler = guid++;
  }
}

var eachApply = function eachApply(events, callbacks, processor, isRmove) {
  _.each(callbacks, function (handler, key) {
    var eventName = void 0;
    if (isRmove) {
      //如果是移除，callbacks是数组
      //转化事件名
      if (eventName = events[orderName[handler]]) {
        processor(eventName);
      }
    } else {
      eventName = events[orderName[key]];
      //on的情况，需要传递handler
      handler && eventName && processor(eventName, handler);
    }
  });
};

/**
 * 合并事件绑定处理
 * 因为isMouseTouch设备上
 * 要同时支持2种方式
 * @return {[type]} [description]
 */
var addEvent = function addEvent(element, events, callbacks, capture) {
  eachApply(events, callbacks, function (eventName, handler) {
    addHandler(element, eventName, handler, capture);
    element.addEventListener(eventName, handler, capture);
  });
};

/**
 * 移除所有事件
 * @param  {[type]} element [description]
 * @return {[type]}         [description]
 */
function removeAll(element) {
  var uuid = element.xutHandler;
  var dataCache = eventDataCache[uuid];
  if (!dataCache) {

    Xut.$warn({
      type: 'event',
      content: '移除所有事件出错'
    });

    return;
  }
  _.each(dataCache, function (data, eventName) {
    if (data) {
      element.removeEventListener(eventName, data[0], data[1]);
      dataCache[eventName] = null;
    }
  });
  delete eventDataCache[uuid];
}

/**
 * 移除指定的事件
 * @return {[type]} [description]
 */
function removeone(element, eventName) {
  var uuid = element.xutHandler;
  var dataCache = eventDataCache[uuid];
  if (!dataCache) {
    Xut.$warn({
      type: 'event',
      content: '移除事件' + eventName + '出错'
    });
    return;
  }
  var data = dataCache[eventName];
  if (data) {
    element.removeEventListener(eventName, data[0], data[1]);
    dataCache[eventName] = null;
    delete dataCache[eventName];
  } else {
    Xut.$warn({
      type: 'event',
      content: '移除事件' + eventName + '出错'
    });
  }

  //如果没有数据
  if (!Object.keys(dataCache).length) {
    delete eventDataCache[uuid];
  }
}

/**
 * 销毁事件绑定处理
 * 因为isMouseTouch设备上
 * 要同时支持2种方式
 * @return {[type]} [description]
 */
var removeEvent = function removeEvent(element, events, callbacks) {
  eachApply(events, callbacks, function (eventName) {
    removeone(element, eventName);
  }, 'remove');
};

/**
 * 多设备绑定
 * @param  {[type]}   processor    [处理器]
 * @param  {[type]}   eventContext [上下文]
 * @param  {Function} callback     [回调函数]
 * @return {[type]}                [description]
 */
var compatibility = function compatibility(controller, element, callbacks, capture) {
  //如果两者都支持
  //鼠标与触摸
  if (isMouseTouch) {
    _.each(eventNames, function (events) {
      controller(element, events, callbacks, capture);
    });
  } else {
    controller(element, eventNames, callbacks, capture);
  }
};

/**
 * 变成节点对象
 * @param  {[type]} element [description]
 * @return {[type]}         [description]
 */
function toNodeObj(element) {
  if (element.length) {
    element = element[0];
  }
  return element;
}

/**
 * 检测end事件，默认要绑定cancel
 * @return {[type]} [description]
 */
var checkBindCancel = function checkBindCancel(callbacks) {
  if (callbacks && callbacks.end && !callbacks.cancel) {
    callbacks.cancel = callbacks.end;
  }
};

/**
 * 合并事件绑定处理
 * 因为isMouseTouch设备上
 * 要同时支持2种方式
 * bindTap(eventContext,{
 *     start   : start,
 *     move    : move,
 *     end     : end
 * })
 * capture 默认是冒泡，提供捕获处理
 * @return {[type]} [description]
 */
function $on(element, callbacks) {
  var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  checkBindCancel(callbacks);
  compatibility(addEvent, toNodeObj(element), callbacks, capture);
}

/**
 * 移除tap事件
 * @param  {[type]} context [description]
 * @param  {[type]} opts    [description]
 * @return {[type]}         [description]
 */
function $off(element, callbacks) {

  if (!element) {
    Xut.$warn({
      type: 'event',
      content: '移除事件对象不存在'
    });
    return;
  }

  element = toNodeObj(element);

  //全部移除
  if (arguments.length === 1) {
    removeAll(element);
    return;
  }

  if (!_.isArray(callbacks)) {
    Xut.$warn({
      type: 'event',
      content: '移除的事件句柄参数，必须是数组'
    });
    return;
  }

  checkBindCancel(callbacks);
  compatibility(removeEvent, element, callbacks);
}

/**
 * 如果是$on绑定的，那么获取事件就可能是多点的
 * 所以需要$hanle方法
 * @param  {[type]} callbacks [description]
 * @param  {[type]} context   [description]
 * @param  {[type]} event     [description]
 * @return {[type]}           [description]
 */
function $handle(callbacks, context, event) {
  switch (event.type) {
    case 'touchstart':
    case 'mousedown':
      callbacks.start && callbacks.start.call(context, event);
      break;
    case 'touchmove':
    case 'mousemove':
      callbacks.move && callbacks.move.call(context, event);
      break;
    case 'touchend':
    case 'mouseup':
    case 'mousecancel':
    case 'touchcancel':
    case 'mouseleave':
      callbacks.end && callbacks.end.call(context, event);
      break;
    case 'transitionend':
    case 'webkitTransitionEnd':
    case 'oTransitionEnd':
    case 'MSTransitionEnd':
      callbacks.transitionend && callbacks.transitionend.call(context, event);
      break;
  }
}

function $target(event, original) {
  var currTouches = null;
  if (hasTouch) {
    currTouches = event.touches;
    if (currTouches && currTouches.length > 0) {
      event = currTouches[0];
    }
  }
  return original ? event : event.target;
}

/**
 * 兼容事件对象
 * @return {[type]}   [description]
 */
function $event(e) {
  return e.touches && e.touches[0] ? e.touches[0] : e;
}

/**
 *  加载文件
 *  css/js
 */

var isOldWebKit = +navigator.userAgent.replace(/.*AppleWebKit\/(\d+)\..*/, "$1") < 536;

function pollCss(node, callback) {
  var sheet = node.sheet,
      isLoaded;

  // for WebKit < 536
  if (isOldWebKit) {
    if (sheet) {
      isLoaded = true;
    }
  }
  // for Firefox < 9.0
  else if (sheet) {
      try {
        if (sheet.cssRules) {
          isLoaded = true;
        }
      } catch (ex) {
        // The value of `ex.name` is changed from "NS_ERROR_DOM_SECURITY_ERR"
        // to "SecurityError" since Firefox 13.0. But Firefox is less than 9.0
        // in here, So it is ok to just rely on "NS_ERROR_DOM_SECURITY_ERR"
        if (ex.name === "NS_ERROR_DOM_SECURITY_ERR") {
          isLoaded = true;
        }
      }
    }

  setTimeout(function () {
    if (isLoaded) {
      // Place callback here to give time for style rendering
      callback();
    } else {
      pollCss(node, callback);
    }
  }, 20);
}

function addOnload(node, callback, isCSS, url) {
  var supportOnload = "onload" in node;

  if (isCSS && isOldWebKit) {
    setTimeout(function () {
      pollCss(node, callback);
    }, 1); // Begin after node insertion
    return;
  }

  function onload(error) {

    // Ensure only run once and handle memory leak in IE
    node.onload = node.onerror = node.onreadystatechange = null;

    // Remove the script to reduce memory leak
    if (!isCSS) {
      var head = document.getElementsByTagName("head")[0] || document.documentElement;
      head.removeChild(node);
    }
    // Dereference the node
    node = null;
    callback(error);
  }

  if (supportOnload) {
    node.onload = onload;
    node.onerror = function () {
      onload(true);
    };
  } else {
    node.onreadystatechange = function () {
      if (/loaded|complete/.test(node.readyState)) {
        onload();
      }
    };
  }
}

function loadFile(url, callback, charset) {
  var IS_CSS_RE = /\.css(?:\?|$)/i,
      isCSS = IS_CSS_RE.test(url),
      node = document.createElement(isCSS ? "link" : "script");

  if (charset) {
    var cs = $.isFunction(charset) ? charset(url) : charset;
    if (cs) {
      node.charset = cs;
    }
  }

  addOnload(node, callback, isCSS, url);

  if (isCSS) {
    node.rel = "stylesheet";
    node.href = url;
  } else {
    node.async = true;
    node.src = url;
  }
  // For some cache cases in IE 6-8, the script executes IMMEDIATELY after
  // the end of the insert execution, so use `currentlyAddingScript` to
  // hold current node, for deriving url in `define` call
  //currentlyAddingScript = node
  var head = document.getElementsByTagName("head")[0] || document.documentElement;
  var baseElement = head.getElementsByTagName("base")[0];
  // ref: #185 & http://dev.jquery.com/ticket/2709
  baseElement ? head.insertBefore(node, baseElement) : head.appendChild(node);
  //currentlyAddingScript = null

  return node;
}

////////////////////////
//
//  window debug调试信息
//
////////////////////////

var NULL = null;

var dom = document.querySelectorAll;
var toString = {}.toString;

function isNull(val) {
  return val === NULL;
}

var isArray = Array.isArray || function (val) {
  return val && "[object Array]" === toString.call(val);
};

function isObejct(val) {
  return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" && !isArray(val) && !isNull(val);
}

function getBody() {
  var ref, ref1;
  return document["body"] || ((ref = dom("body")) != null ? ref[0] : void 0) || ((ref1 = dom("html")) != null ? ref1[0] : void 0);
}

var debugMap = {
  log: "0074cc",
  danger: "da4f49",
  warn: "faa732",
  success: "5bb75b",
  error: "bd362f"
};

function render(msg) {
  var arr, i, item, len, text;
  text = "";
  arr = [];
  if (isArray(msg)) {
    for (i = 0, len = msg.length; i < len; i++) {
      item = msg[i];
      if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === "object") {
        arr.push(render(item));
        text = "[" + arr.join(',') + "]";
      } else {
        arr.push("" + item);
        text = "[" + arr.join(',') + "]";
      }
    }
  } else if (isObejct(msg)) {
    for (item in msg) {
      if (_typeof(msg[item]) === "object") {
        arr.push(item + ": " + render(msg[item]));
        text = "{" + arr.join(',') + "}";
      } else {
        arr.push(item + ": " + msg[item]);
        text = "{" + arr.join(',') + "}";
      }
    }
  } else {
    text = String(msg);
  }
  return text;
}

function translate(el, y) {
  el.style.webkitTransform = "translate3d(0," + y + ",0)";
  return el.style.transform = "translate3d(0," + y + ",0)";
}

function joinCss(css) {
  return css.join(";");
}

var parentBottom = 50;
var publicCss = ["-webkit-transition: all .3s ease", "transition: all .3s ease"];
var childCss = ["margin-top:-1px", "padding:1px", "border-top:1px solid rgba(255,255,255,.1)", "margin:0", "max-width:" + (window.outerWidth - 20) + "px"].concat(publicCss);
var parentCss = ["-webkit-overflow-scrolling:touch", "overflow-y:scroll", "line-height:1.2", "z-index:5000", "position:fixed", "left:0", "top:0", "font-size:11px", "background:rgba(0,0,0,.8)", "color:#fff", "width:100%", "padding-bottom:" + parentBottom + "px", "max-height:55%"].concat(publicCss);
var clearCSS = "text-align:right;font-size:16px;color:white;margin-top:30px;margin-right:10px;position:absolute;right:0;";
var clearCountCSS = "text-align:right;font-size:16px;;color:white;margin-right:10px;margin-top:30px;position:absolute;right:50px;";

var showNodeCSS = "text-align:right;font-size:16px;;color:white;margin-right:70px;margin-top:30px;position:absolute;right:50px;";
var hideNodeCSS = "text-align:right;font-size:16px;;color:white;margin-right:120px;position:absolute;right:50px;margin-top:30px;";

var containerCSS = "width:100%;height:90%;padding:10px";

function Debug() {
  this.isInit = this.isHide = false;
  this.msg = this.fn = this.color = "";
  this.el = NULL;
}

Debug.prototype.init = function () {
  var body, el;
  var self = this;

  el = this.el = document.createElement("div");

  var clearNode = document.createElement("a");
  var clearCount = document.createElement("a");
  var showNode = document.createElement("a");
  var hideNode = document.createElement("a");

  this.container = document.createElement("div");
  this.container.setAttribute("style", containerCSS);

  showNode.textContent = '显示';
  hideNode.textContent = '隐藏';
  clearNode.textContent = '清屏';
  clearCount.textContent = '清计数';

  clearNode.setAttribute("style", clearCSS);
  clearCount.setAttribute("style", clearCountCSS);
  showNode.setAttribute("style", showNodeCSS);
  hideNode.setAttribute("style", hideNodeCSS);

  el.setAttribute("style", joinCss(parentCss));
  el.appendChild(this.container);
  el.appendChild(clearNode);
  el.appendChild(clearCount);
  el.appendChild(showNode);
  el.appendChild(hideNode);

  body = getBody();
  body.appendChild(el);

  translate(el, 0);

  function setColor(node) {
    node.style.backgroundColor = 'red';
    setTimeout(function () {
      node.style.backgroundColor = '';
    }, 50);
  }

  $on(clearCount, {
    end: function end(e) {
      setColor(clearCount);
      e.stopPropagation();
      resetCount();
    }
  });

  $on(clearNode, {
    end: function end(e) {
      setColor(clearNode);
      e.stopPropagation();
      self.container.innerHTML = '';
    }
  });

  $on(showNode, {
    end: function end(e) {
      setColor(showNode);
      e.stopPropagation();
      self.show();
    }
  });

  $on(hideNode, {
    end: function end(e) {
      setColor(hideNode);
      e.stopPropagation();
      self.hide();
    }
  });

  this.isInit = true;
  return this;
};

Debug.prototype.print = function () {
  var child, css;
  if (!this.isInit) {
    this.init();
  }

  if (this.isHide) {
    this.show();
  }

  css = childCss.concat(["color:#" + this.color]);
  child = document.createElement("p");
  child.setAttribute("style", joinCss(css));
  child.innerHTML = this.msg;
  /*只显示一半的区域，然后可以被重复的替换*/
  if (this.container.offsetHeight > document.documentElement.clientHeight / 2) {
    var node = this.container.firstChild;
    if (node.nodeName === 'P') {
      this.container.removeChild(node);
    }
  }
  this.container.appendChild(child);
  return this;
};

Debug.prototype.toggle = function (event) {
  return (this.isHide ? this.show : this.hide).call(this, event);
};

Debug.prototype.show = function (event) {
  translate(this.el, 0);
  this.isHide = false;
  return this;
};

Debug.prototype.hide = function (event) {
  translate(this.el, "-" + (this.el.offsetHeight - parentBottom) + "px");
  this.isHide = true;
  return this;
};

var _loop = function _loop(fn) {
  Debug.prototype[fn] = function (msg) {
    this.fn = fn;
    this.msg = render(msg);
    this.color = debugMap[fn];
    return this.print();
  };
};

for (var fn in debugMap) {
  _loop(fn);
}

/*
  $warn('hello');
  $warn('信息','info');
  $warn('错误','error');
  $warn('警告','warn');

  debug.success("This is success message:)");
  debug.error("This is error message:)");
  debug.log("This is primary message:)");
  debug.log({a: 1, b: 2});
  debug.log([1,2,3]);
 */
var hasConsole = typeof console !== 'undefined';

var debug = void 0;
var count = 0;

function $warn(data, content, level, color) {

  var silent = config.debug.silent;

  if (!silent) {
    return;
  }

  if (!hasConsole) {
    return;
  }

  var dataType = typeof data === 'undefined' ? 'undefined' : _typeof(data);

  /**
   * 输出日志
   * @return {[type]} [description]
   */
  function outlog(type, content, level, color) {

    //如果启动了全部处理
    //如果能找到对应的处理
    //silent：['all','preload'.....]
    if (~silent.indexOf('all') || ~silent.indexOf(type)) {

      var stringType = typeof content === 'string';

      ++count;

      //远程debug输出
      if (config.debug.terminal) {
        var errListener = function errListener(error) {
          var msg = ["Error:", "filename: " + error.filename, "lineno: " + error.lineno, "message: " + error.message, "type: " + error.type];
          return debug.error(msg.join("<br/>"));
        };
        //监听错误


        if (!debug) {
          debug = new Debug();
        }

        window.addEventListener('error', errListener, false);
        debug.log(count + ' \u7C7B\u578B:' + type + ' \u5185\u5BB9:' + content);
        return;
      }

      //console输出
      var command = console[level] || console.log;
      if (stringType) {
        command('%c' + count + ' \u7C7B\u578B:%c' + type + ' %c\u5185\u5BB9:%c' + String.styleFormat(content), "color:#A0522D", "color:" + color, "color:#A0522D", "color:" + color);
      } else {
        command(count + ' \u7C7B\u578B:' + type + ' \u5185\u5BB9:', content);
      }
    }
  }

  //如果是对象数据
  //data = {
  //  type
  //  content
  //  level
  //  color
  //}
  if (dataType === 'object') {
    var type = data.type;
    var _content = data.content;
    var _level = data.level;
    var _color = data.color;
    outlog(type, _content, _level, _color);
  } else {
    //传递的是普通类型
    //$warn(type,content,level,color)
    outlog(data, content, level, color);
  }
}

function resetCount() {
  count = 0;
}

Xut.$warn = $warn;

/**
 * callback(1,2)
 * 1 图片加载状态 success / fail   true/false
 * 2 图片是否被缓存 hasCache       ture/false
 */
function loadFigure(data, callback) {

  if (!data) {
    $warn('util', 'loadFigure data有错误');
    callback && callback();
    return;
  }

  var img = void 0;
  if (typeof data === 'string') {
    img = new Image();
    img.src = data;
  } else {
    /*如果传递了图片对象*/
    img = data.image;
    img.src = data.url;
  }

  var width = img.width;
  var height = img.height;

  function clear() {
    img = img.onload = img.onerror = null;
  }

  // 如果图片被缓存，则直接返回缓存数据
  if (img.complete) {
    //加载成功，并且有缓存
    callback && callback({
      state: 'success',
      cache: true
    });
    //返回缓存的，不清理
    return img;
  }

  /**
   * 图片尺寸就绪
   * 判断图片是否已经被缓存了
   */
  function onReady() {
    //通过onload与onerror提前完成了
    if (onReady.end) {
      return;
    }
    var newWidth = img.width;
    var newHeight = img.height;
    // 如果图片已经在其他地方加载可使用面积检测
    if (newWidth !== width || newHeight !== height || newWidth * newHeight > 1024) {
      //标记完成了
      onReady.end = true;
      callback && callback({
        state: 'success',
        cache: true
      });
      clear();
    }
  }

  // 加载错误后的事件
  img.onerror = function () {
    if (onReady.end) {
      return;
    }
    onReady.end = true; //标记完成
    callback && callback({ state: 'fail' });
    clear();
  };

  //完全加载完毕的事件
  img.onload = function () {
    if (onReady.end) {
      return;
    }
    onReady.end = true; //标记完成
    callback && callback({ state: 'success' });
    clear();
  };

  //检测是不是已经缓存了
  //如果缓存存在，就跳过
  if (onReady()) {
    return;
  }

  //加入队列中定期执行
  // if (!onReady.end) {
  //   list.push(onReady);
  //   // 无论何时只允许出现一个定时器，减少浏览器性能损耗
  //   if (intervalId === null) {
  //     intervalId = setInterval(tick, 40);
  //   }
  // };

  return img;
}

var onlyId = void 0;

var storage = window.localStorage;

/*
过滤
 */
var filter = function filter(key) {
  //添加头部标示
  if (onlyId) {
    return key + onlyId;
  } else {
    if (!config.data.appId) {
      config.data.appId = 'aaron-' + new Date().getDate();
    }
    //子文档标记
    var sub = window.SUbCONFIGT && window.SUbCONFIGT.dbId ? "-" + window.SUbCONFIGT.dbId : '';
    onlyId = "-" + config.data.appId + sub;
  }
  return key + onlyId;
};

/**
 * 设置localStorage
 * @param {[type]} key [description]
 * @param {[type]} val [description]
 */
function setStorage(key, val) {
  var setkey;

  if (_.isObject(key)) {
    for (var i in key) {
      if (key.hasOwnProperty(i)) {
        setkey = filter(i);
        storage.setItem(setkey, key[i]);
      }
    }
  } else {
    key = filter(key);
    storage.setItem(key, val);
  }
}

/**
 * 获取localstorage中的值
 * @param  {[type]} key [description]
 * @return {[type]}     [description]
 */
function getStorage(key) {
  key = filter(key);
  var value = storage.getItem(key);
  //storage为null string的情况
  if (!value || value && value == 'null') {
    return undefined;
  }
  return storage.getItem(key);
}

/**
 * 删除localStorage中指定项
 * @param  {[type]} key [description]
 * @return {[type]}     [description]
 */
function removeStorage(key) {
  key = filter(key);
  storage.removeItem(key);
}

/**
 * 重设缓存的UUID
 * 为了只计算一次
 * @return {[type]} [description]
 */
function clearStorageId() {
  onlyId = null;
}

/////////////////////////////////////////////////////////////////////
///
///  默认用H5的localStorage保存数据
///  例外：safari开启了
///  1 safari无痕模式下被禁用的localStorage，不可写，只能读
///  2 有些机型不能存储信息到localStorage中,微信中通过cookie方式单独修复，直接用浏览器不可以
///
/////////////////////////////////////////////////////////////////////


/**
 * 设置setCookie
 * @param {[type]} c_name     [description]
 * @param {[type]} value      [description]
 * @param {[type]} expiredays [description]
 */
function setCookie(name, value, expiredays) {
  if (!expiredays) {
    var day = 30;
    var exp = new Date();
    exp.setTime(exp.getTime() + day * 24 * 60 * 60 * 1000);
    expiredays = exp.toGMTString();
  }
  document.cookie = name + "=" + escape(value) + ";expires=" + expiredays;
}

/**
 * 取回cookie
 * @param  {[type]} c_name [description]
 * @return {[type]}        [description]
 */
function getCookie(name) {
  if (document.cookie.length > 0) {
    var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)");
    if (arr = document.cookie.match(reg)) {
      return unescape(arr[2]);
    } else {
      return null;
    }
  }
  return null;
}

/**
 *  移除
 * @param  {[type]} c_name     [description]
 * @param  {[type]} value      [description]
 * @param  {[type]} expiredays [description]
 * @return {[type]}            [description]
 */
function removeCookie(name) {
  var exp = new Date();
  exp.setTime(exp.getTime() - 1);
  var cval = getCookie(name);
  if (cval != null) {
    document.cookie = name + "=" + cval + ";expires=" + exp.toGMTString();
  }
}

/////////////////////////////////////////////////////////////////////
///
///  默认用H5的localStorage保存数据
///  例外：safari开启了
///  1 safari无痕模式下被禁用的localStorage，不可写，只能读
///  2 有些机型不能存储信息到localStorage中,微信中通过cookie方式单独修复，直接用浏览器不可以
///
/////////////////////////////////////////////////////////

var supportPlat = function supportPlat(storage, cookie) {
  if (Xut.plat.supportStorage) {
    return storage;
  } else {
    /*微信支持cookie*/
    if (Xut.plat.isWeiXin) {
      return cookie;
    }
    /*剩余就下ios的safari无痕模式*/
    /*无痕模式用cookie暂时替代，至少在不关闭浏览器的情况有一定作用*/
    return cookie;
  }
};

var SET = supportPlat(setStorage, setCookie);
var GET = supportPlat(getStorage, getCookie);
var REMOVE = supportPlat(removeStorage, removeCookie);
var CLEAR = supportPlat(clearStorageId, clearStorageId);

/**
 * 设置localStorage
 * @param {[type]} key [description]
 * @param {[type]} value [description]
 */
function $setStorage(key, value) {

  if (!key) {
    return;
  }

  //字符串
  if (_.isString(key) && value !== undefined) {
    SET(key, value);
  }

  //对象
  if (_.isObject(key)) {
    for (var i in key) {
      $setStorage(i, key[i]);
    }
  }
}

/**
 * 获取localstorage中的值
 * @param  {[type]} key [description]
 * @return {[type]}     [description]
 */
function $getStorage(key) {
  if (key) {
    return GET(key);
  }
}

/**
 * 删除localStorage中指定项
 * @param  {[type]} key [description]
 * @return {[type]}     [description]
 */
function $removeStorage(key) {
  if (key) {
    REMOVE(key);
  }
}

/**
 * 退出清理
 * @return {[type]} [description]
 */
function clearId() {
  CLEAR();
}

////////////////////////////////////////////////////
///
///  * 杂志支持多种资源的组合形式
///  * _a _i .hi .mi
///  * 根据brModeType与的baseImageSuffix的组合
///
////////////////////////////////////////////////////

function showWarn(data) {
  Xut.$warn({
    type: 'util',
    content: data
  });
}

/**
 * 获取正确的图片文件名
 * 因为图片可能存在,因为图片可能是在flow数据中获取的
 * flow的数据是被处理过的
 * 所以文件路径可以是几种情况
 * .mi.jpg
 * .mi.php
 * .hi.jpg
 * .hi.php
 * 等等这样的地址

  src的地址 4种情况

  content/11/gallery/b9ba3dfc39ddd207.jpg
  content/11/gallery/b9ba3dfc39ddd207.hi.jpg
  content/11/gallery/b9ba3dfc39ddd207.mi.jpg

  content/11/gallery/b9ba3dfc39ddd207_a
  content/11/gallery/b9ba3dfc39ddd207_a.mi
  content/11/gallery/b9ba3dfc39ddd207_a.hi

  content/11/gallery/b9ba3dfc39ddd207_i
  content/11/gallery/b9ba3dfc39ddd207_i.mi
  content/11/gallery/b9ba3dfc39ddd207_i.hi

 *
   根据不同的模式
   解析出对应的文件名出来
 */
function converUrlName(src) {
  var result = void 0;
  var hdName = void 0; //高清图名
  var brModeType = config.launch.brModeType;
  var baseImageSuffix = config.launch.baseImageSuffix;

  //如果支持高清图
  //判断出高清图后缀
  var hdPostfix = config.launch.useHDImageZoom && config.launch.imageSuffix && config.launch.imageSuffix['1440'];

  //没有任何后缀
  //"1d7949a5585942ed.jpg"
  if (!brModeType && !baseImageSuffix) {
    result = src.match(/\w+\.\w+$/);
    if (result && result.length) {
      return {
        hdName: result[0],
        suffix: result[0],
        original: result[0]
      };
    } else {
      showWarn('zoom-image解析出错,result：' + result);
    }
  }

  //仅仅只有 _a _i的情况
  if (brModeType && !baseImageSuffix) {
    result = src.match(/(?!\/)\w+$/);
    if (result && result.length) {
      //因为不存在baseImageSuffix，所以不存在高清图
      return {
        hdName: result[0],
        suffix: result[0],
        original: result[0]
      };
    } else {
      showWarn('zoom-image-brModeType解析出错,result：' + result);
    }
  }

  //如果有_a _i 与 mi hi的 并存的情况
  //http://localhost:8888/content/326/gallery/96c09043866bd398_a.mi
  //0: "96c09043866bd398_a.mi"
  //1: "96c09043866bd398_a"
  //2: ".mi"
  if (baseImageSuffix && brModeType) {
    result = src.match(/(\w+)(\.\w+)$/);
    if (result && result.length) {
      if (hdPostfix) {
        //96c09043866bd398_a.hi
        hdName = result[1] + '.' + hdPostfix;
      } else {
        hdName = result[0];
      }
      return {
        hdName: hdName,
        suffix: result[0], //带有后缀的 "96c09043866bd398_a.mi"
        original: result[1] //解析出来原始的 "96c09043866bd398_a"
      };
    } else {
      showWarn('zoom-image-suffix解析出错,result：' + result);
    }
    return;
  }

  //仅仅只有 .hi/.mi的情况
  //http://localhost:8888/content/326/gallery/96c09043866bd398.mi.jpg"
  // 0 1d7949a5585942ed.mi.jpg"
  // 1 "1d7949a5585942ed"
  // 2 : ".mi"
  // 3: ".jpg"
  if (baseImageSuffix && !brModeType) {
    result = src.match(/(\w+)(\.\w+)(\.\w+)$/);
    if (result && result.length) {
      if (hdPostfix) {
        //96c09043866bd398.hi.jpg
        hdName = result[1] + '.' + hdPostfix + result[3];
      } else {
        hdName = result[0];
      }
      return {
        hdName: hdName,
        suffix: result[0], //带有后缀的 "1d7949a5585942ed.mi.jpg"
        original: result[1] + result[3] //解析出来原始的 1d7949a5585942ed" + ".jpg"
      };
    } else {
      showWarn('zoom-image-suffix解析出错,result：' + result);
    }
  }
}

/**
 * 普通资源路径转化
 * 载资源都是PNG.JPG的格式
 * 但是杂志支持多种资源的组合形式
 * _a _i .hi .mi
 * 根据brModeType与的baseImageSuffix的组合
 * 匹配正确的后缀名
 *
 * url 传入完成的URL

一种有四种大的组合情况

// 'd048193365eac224_a'
// 'd048193365eac224_i'
//
// 'b9ba3dfc39ddd207.jpg'
//
// 'd048193365eac224_i.mi'
// 'd048193365eac224_i.hi'
// 'd048193365eac224_a.hi'
// 'd048193365eac224_a.mi'
//
// 'b9ba3dfc39ddd207.hi.jpg'
// 'b9ba3dfc39ddd207.mi.jpg'

 */
function converImageURL(url, supportBrMode, supportSuffix) {

  if (!url) {
    return '';
  }

  var brModeType = supportBrMode ? supportBrMode : config.launch.brModeType;
  var baseImageSuffix = supportSuffix ? supportSuffix : config.launch.baseImageSuffix;

  //不需要转换
  if (!brModeType && !baseImageSuffix) {
    return url;
  }

  var imageData = url.split('.');
  var imagePrefix = imageData[0];
  var imgetPostfix = imageData[1];

  if (brModeType && baseImageSuffix) {
    //http://localhost:8888/content/11/gallery/1ffa8897140f3b99f7b3a5173fbc3ac2 _a .hi
    return '' + imagePrefix + brModeType + '.' + baseImageSuffix;
  }

  if (brModeType && !baseImageSuffix) {
    //http://localhost:8888/content/11/gallery/1ffa8897140f3b99f7b3a5173fbc3ac2 _a
    return '' + imagePrefix + brModeType;
  }

  if (!brModeType && baseImageSuffix) {
    //content/11/gallery/b9ba3dfc39ddd207 .hi .jpg
    return imagePrefix + '.' + baseImageSuffix + '.' + imgetPostfix;
  }
}

var CEIL$1 = Math.ceil;
var slashRE = /\/$/;

/**
 * 去掉后缀的斜杠
 * @return {[type]} [description]
 */
function removeSlash(resource) {
  if (resource && slashRE.test(resource)) {
    return resource.substring(0, resource.length - 1);
  }
  return resource;
}

/**
 * 动态加载link
 * @return {[type]} [description]
 */
function loadGlobalStyle(fileName, callback) {
  var path = config.launch.resource ? config.launch.resource + '/gallery/' + fileName + '.css' : config.data.pathAddress + fileName + '.css';
  var node = loadFile(path, callback);
  node && node.setAttribute('data-type', fileName);
}

/**
 * 文件是图片格式
 * @param  {[type]}  fileName [description]
 * @return {Boolean}          [description]
 */
function hasImages(fileName) {
  return (/\.[jpg|png|gif]+/i.test(fileName)
  );
}

/**
 * 获取文件的全路径
 * @param  {[type]} fileName  [description]
 * @param  {[type]} debugType [description]
 * @return {[type]}           [description]
 *
 * isGif 为true 跳过brModeType模式
 */
function getFileFullPath(fileName, debugType, isGif) {

  if (!fileName) {
    return '';
  }

  var fileNameData = fileName.split('.');
  var splitNumber = fileNameData.length;

  //没有点
  // 配置了brMode没有配置imageSuffix
  // 'd048193365eac224_a'
  // 'd048193365eac224_i'
  if (splitNumber === 1) {
    return config.data.pathAddress + fileName;
  }

  //有2个点
  // 没有brMode，有配置imageSuffix
  // 'b9ba3dfc39ddd207.hi.jpg'
  // 'b9ba3dfc39ddd207.mi.jpg'
  if (splitNumber === 3) {
    return config.data.pathAddress + fileName;
  }

  //只有一个点
  // 9b7adc63c04af0651a60a211ed03085c.svg
  //
  // 如果是正常的图片格式，就需要转化
  // 'b9ba3dfc39ddd207.jpg'
  //
  // 如果是转化后的就不需要再处理
  // 'd048193365eac224_i.mi'
  // 'd048193365eac224_i.hi'
  // 'd048193365eac224_a.hi'
  // 'd048193365eac224_a.mi'
  if (splitNumber === 2) {

    //排除非图片的情况
    //9b7adc63c04af0651a60a211ed03085c.svg
    if (!hasImages(fileName)) {
      return config.data.pathAddress + fileName;
    }

    //如果包含已经包含了执行的后缀
    //不需要处理，名字
    // 'd048193365eac224_i.mi'
    // 'd048193365eac224_i.hi'
    // 'd048193365eac224_a.hi'
    // 'd048193365eac224_a.mi
    if (/_[ia]\.(mi|hi)$/.test(fileName)) {
      return config.data.pathAddress + fileName;
    }

    //仅仅是正常的png jpg gif图片
    //需要生成新的后缀
    return config.data.pathAddress + converImageURL(fileName);
  }
}

/**
 * 获取资源
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
function getResources(url) {
  var option;
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url, false);
  xhr.send(null);
  option = parseJSON(xhr.responseText);
  return option;
}

function createFn(obj, id, callback) {
  var cObj = obj[id];
  if (!cObj) {
    cObj = obj[id] = {};
  }
  callback.call(cObj);
}

/**
 * 执行脚本注入
 */
function execScript(code, type) {
  //过滤回车符号
  var enterReplace$$1 = function enterReplace$$1(str) {
    return str.replace(/\r\n/ig, '').replace(/\r/ig, '').replace(/\n/ig, '');
  };
  try {
    new Function(enterReplace$$1(code))();
  } catch (e) {
    Xut.$warn({
      type: 'util',
      content: '加载脚本错误'
    });
  }
}

/**
 * 创建gif随机数
 * 用数字代码，不能用0.在有些电脑上不显示
 */
function createRandomImg(url) {
  var s = Math.random().toString();
  s = s.replace(/\b(0+)(\.+)/gi, "");
  s = parseInt(s);
  return url + ('?' + s);
}

/**
 * 路径替换
 * svg html文件的路径是原始处理的
 * 如果动态切换就需要替换
 * @return {[type]} [description]
 */
function replacePath(svgstr) {
  if (config.launch.lauchMode === 1) {
    //如果能找到对应的默认路径，则替换
    if (-1 !== svgstr.indexOf('content/gallery/')) {
      svgstr = svgstr.replace(/content\/gallery/ig, config.data.pathAddress);
    }
  }
  return svgstr;
}

/**
 * 转化缩放比
 */
var converProportion = function converProportion(_ref) {
  var width = _ref.width,
      height = _ref.height,
      left = _ref.left,
      top = _ref.top,
      padding = _ref.padding,
      proportion = _ref.proportion,
      zoomMode = _ref.zoomMode,
      getStyle = _ref.getStyle;


  if (!proportion) {
    Xut.$warn({
      type: 'util',
      content: '没有传递缩放比,取全局config'
    });
    proportion = config.proportion;
  }

  //页眉，保持横纵比
  //计算顶部显示中线位置
  //如果溢出就溢出，高度设置为白边中线
  if (zoomMode === 1) {
    var visualTop = getStyle.visualTop;
    var proportionalHeight = CEIL$1(height * proportion.width) || 0;
    return {
      width: CEIL$1(width * proportion.width) || 0,
      height: proportionalHeight,
      left: CEIL$1(left * proportion.left) || 0,
      top: -visualTop / 2 - proportionalHeight / 2 || 0,
      padding: CEIL$1(padding * proportion.width) || 0,
      isHide: proportionalHeight > visualTop //正比高度大于显示高度，隐藏元素
    };
  }
  //页脚，保持横纵比
  //计算底部显示中线位置
  //如果溢出就隐藏，高度设置为白边中线
  else if (zoomMode === 2) {
      var _visualTop = getStyle.visualTop;
      var _proportionalHeight = CEIL$1(height * proportion.width) || 0;
      return {
        width: CEIL$1(width * proportion.width) || 0,
        height: _proportionalHeight,
        left: CEIL$1(left * proportion.left) || 0,
        top: getStyle.visualHeight + _visualTop / 2 - _proportionalHeight / 2 || 0,
        padding: CEIL$1(padding * proportion.width) || 0,
        isHide: _proportionalHeight > _visualTop //正比高度大于显示高度，隐藏元素
      };
    }
    //图片正比缩放，而且保持上下居中
    else if (zoomMode === 3) {
        //高度为基本比值
        if (proportion.width > proportion.height) {
          var originalWidth = CEIL$1(width * proportion.width) || 0;
          var proportionalWidth = CEIL$1(width * proportion.height) || 0;
          var proportionalLeft = Math.abs(proportionalWidth - originalWidth) / 2;
          left = CEIL$1(left * proportion.left) + proportionalLeft;
          return {
            width: proportionalWidth,
            height: CEIL$1(height * proportion.height) || 0,
            left: left,
            top: CEIL$1(top * proportion.top) || 0,
            padding: CEIL$1(padding * proportion.width) || 0
          };
        } else {
          //宽度作为基本比值
          var originalHeight = CEIL$1(height * proportion.height) || 0;
          var _proportionalHeight2 = CEIL$1(height * proportion.width) || 0;
          var proportionalTop = Math.abs(_proportionalHeight2 - originalHeight) / 2;
          top = CEIL$1(top * proportion.top) + proportionalTop;
          return {
            width: CEIL$1(width * proportion.width) || 0,
            height: _proportionalHeight2,
            left: CEIL$1(left * proportion.left) || 0,
            top: top,
            padding: CEIL$1(padding * proportion.width) || 0
          };
        }
      }
      //默认缩放比
      else {
          return {
            width: CEIL$1(width * proportion.width) || 0,
            height: CEIL$1(height * proportion.height) || 0,
            left: CEIL$1(left * proportion.left) || 0,
            top: CEIL$1(top * proportion.top) || 0,
            padding: CEIL$1(padding * proportion.width) || 0
          };
        }
};

function setProportion() {
  return converProportion.apply(undefined, arguments);
}

/*
 * 修复元素的尺寸
 * @type {[type]}
 */
function reviseSize(_ref2) {
  var results = _ref2.results,
      proportion = _ref2.proportion,
      zoomMode = _ref2.zoomMode,
      getStyle = _ref2.getStyle;


  //不同设备下缩放比计算
  var layerSize = converProportion({
    proportion: proportion,
    zoomMode: zoomMode,
    getStyle: getStyle,
    width: results.width,
    height: results.height,
    left: results.left,
    top: results.top
  });

  //新的背景图尺寸
  var backSize = converProportion({
    proportion: proportion,
    zoomMode: zoomMode,
    getStyle: getStyle,
    width: results.backwidth,
    height: results.backheight,
    left: results.backleft,
    top: results.backtop
  });

  //赋值新的坐标
  results.scaleWidth = layerSize.width;
  results.scaleHeight = layerSize.height;
  results.scaleLeft = layerSize.left;
  results.scaleTop = layerSize.top;

  //元素状态
  if (layerSize.isHide) {
    results.isHide = layerSize.isHide;
  }

  //背景坐标
  results.scaleBackWidth = backSize.width;
  results.scaleBackHeight = backSize.height;
  results.scaleBackLeft = backSize.left;
  results.scaleBackTop = backSize.top;

  return results;
}

/**
 * 提供全局配置文件
 */
function mixGlobalConfig(setConfig) {
  if (setConfig) {
    Xut.mixin(config.global, setConfig);
  }
}

/**
 * 清理图片
 * @return {[type]} [description]
 * action  'show' / 'hide'  在什么状态下删除
 * clone   克隆一份解决删除的闪动
 * default: 'hide'
 */
function cleanImage(context, action) {

  if (!context) {
    return;
  }

  if (!context.length) {
    context = $(context);
  }
  /**
   * 2017.6.26
   * 销毁图片apng
   * 一次性的apng图片，必须要清理src
   * 否则重复不生效，因为缓存的关系
   */
  function removeSRC(img) {
    if (img) {
      img.removeAttribute('onerror');
      img.src = null;
      img.removeAttribute('src');
    }
  }

  try {
    if (action === 'show') {
      context.find('img').each(function (index, img) {
        return removeSRC(img);
      });
    } else {
      context.hide().find('img').each(function (index, img) {
        return removeSRC(img);
      });
    }
  } catch (e) {
    console.log('销毁图片出错');
  }
}

/**
 * 设置图片src
 * @param {[type]} context [description]
 * @param {[type]} path    [description]
 */
function setImage$1(context, path) {
  if (!context) {
    return;
  }
  if (!context.length) {
    context = $(context);
  }
  context.find('img').each(function (index, img) {
    img.src = path;
  });
}

/**
 * 缓存池
 * @return {[type]} [description]
 */

/**
 * 当监听的节点内容发生变化时,触发指定的回调
 * @param opts {
 *   container:父容器,dom对象或jQuery对象
 *   content  :要加入父容器的内容,字符串或jQuery对象
 *   position :内容插入父容器的位置,'first' 表示在前加入,默认在末尾
 *   delay    :延时,默认0
 *   }
 * @version  1.02
 * @author [author] bjtqti
 * @return {[type]} [description]
 */

var DOC = document;
var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

var implementation = DOC.implementation.hasFeature("MutationEvents", "2.0");

/**
 * Defer a task to execute it asynchronously. Ideally this
 * should be executed as a microtask, so we leverage
 * MutationObserver if it's available, and fallback to
 * setTimeout(0).
 *
 * @param {Function} cb
 * @param {Object} ctx
 */
var _nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks = [];
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  if (typeof MutationObserver !== 'undefined' && Xut.plat.supportMutationObserver) {
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(counter);
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function timerFunc() {
      counter = (counter + 1) % 2;
      textNode.data = counter;
    };
  } else {
    // webpack attempts to inject a shim for setImmediate
    // if it is used as a global, so we have to work around that to
    // avoid bundling unnecessary code.
    var context = Xut.plat.isBrowser ? window : typeof global !== 'undefined' ? global : {};
    timerFunc = context.setImmediate || setTimeout;
  }
  return function (cb, ctx) {
    var func = ctx ? function () {
      cb.call(ctx);
    } : cb;
    callbacks.push(func);
    if (pending) return;
    pending = true;
    timerFunc(nextTickHandler, 0);
  };
}();

var nextTick = function nextTick(_ref, callback, context) {
  var container = _ref.container,
      content = _ref.content,
      position = _ref.position,
      _ref$delay = _ref.delay,
      delay = _ref$delay === undefined ? 0 : _ref$delay;


  //如果只提供一个回到函数
  if (arguments.length === 1 && typeof arguments[0] === 'function') {
    callback = arguments[0];
    if (typeof callback === 'function') {
      return _nextTick(callback);
    }
    console.log('nextTick: 参数提供错误');
    return;
  }

  if (!container || !content) {
    return;
  }

  //检查容器---$(container) 转为dom对象
  if (container instanceof $) {
    container = container[0];
  }

  if (container.nodeType !== 1) {
    console.log('nextTick: container must be HTMLLIElement ');
    return;
  }

  var animatId = 'T' + (Math.random() * 10000 << 1);
  var tick = DOC.createElement('input');

  //标记任务
  tick.setAttribute('value', animatId);

  //检查内容
  if (typeof content === 'string') {
    var temp = $(content);
    if (!temp[0]) {
      //纯文本内容
      temp = DOC.createTextNode(content);
      temp = $(temp);
    }
    content = temp;
    temp = null;
  }

  /**
   * 完成任务后处理&Observer
   * @return {[type]} [description]
   */
  var _completeTask = function _completeTask() {
    container.removeChild(tick);
    callback.call(context);
    container = null;
    tick = null;
    context = null;
  };

  /**
   * 将内容加入父容器
   * @return {[type]} [description]
   */
  var _appendChild = function _appendChild() {
    //拼接内容
    var frag = DOC.createDocumentFragment();
    var len = content.length;
    for (var i = 0; i < len; i++) {
      frag.appendChild(content[i]);
    }
    frag.appendChild(tick);

    //判断插入的位置
    if (position === 'first') {
      container.insertBefore(frag, container.firstChild);
    } else {
      container.appendChild(frag);
    }

    frag = null;

    //触发变动事件
    tick.setAttribute('value', animatId);
  };

  if (MutationObserver) {
    var observer = new MutationObserver(function (mutations) {
      mutations.forEach(function (record) {
        if (record.oldValue === animatId) {
          _completeTask();
          observer = null;
        }
      });
    });

    //设置要监听的属性
    observer.observe(tick, {
      attributes: true,
      //childList: true,
      attributeOldValue: true,
      attributeFilter: ["value"] //只监听value属性,提高性能
    });

    _appendChild();
  } else {

    //检测是否支持DOM变动事件
    if (implementation) {

      /**
       * 完成任务后处理&Event
       * @param  {[type]} event [description]
       * @return {[type]}       [description]
       */
      var _finishTask = function _finishTask(event) {
        if (event.target.value === animatId) {
          //container.removeEventListener('DOMNodeRemoved',_finishTask,false);
          container.removeEventListener('DOMNodeInserted', _finishTask, false);
          callback.call(context);
        }
      };

      //container.addEventListener('DOMNodeRemoved',_finishTask,false);
      container.addEventListener('DOMNodeInserted', _finishTask, false);
      _appendChild();
      container.removeChild(tick);
    } else {
      //歉容Android2.xx处理
      _appendChild();
      setTimeout(function () {
        _completeTask();
      }, delay);
    }
  }
};

Xut.nextTick = nextTick;

////////////////////////
///  获取文件的内容
///  1 js
///  2 svg->js
///  3 IBooks
///  4 PHP请求 => svg
///  5 插件    => svg
///////////////////////

/**
 * 随机Url地址
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
function randomUrl(url) {
  /*启动了预览，就必须要要缓存*/
  if (config.launch.preload) {
    return url;
  } else {
    return url + '?r=' + new Date().getTime();
  }
}

/**
 *  读取文件内容
 *  @return {[type]} [string]
 */
function readFileContent(path, callback, type) {

  var paths = void 0;
  var name = void 0;
  var data = void 0;
  var svgUrl = void 0;

  /**
   * js脚本加载
   */
  function loadJs(fileUrl, fileName) {
    loadFile(randomUrl(fileUrl), function () {
      data = window.HTMLCONFIG[fileName];
      if (data) {
        callback(data);
        delete window.HTMLCONFIG[fileName];
      } else {
        Xut.$warn({
          type: 'util',
          content: 'js文件加载失败，文件名:' + path
        });
        callback('');
      }
    });
  }

  //con str
  //externalFile使用
  //如果是js动态文件
  //content的html结构
  if (type === "js") {
    paths = config.getSvgPath() + path;
    name = path.replace(".js", '');
    loadJs(paths, name);
    return;
  }

  /**
   * 如果启动了跨域处理
   * crossDomain = true
   * 那么所有的svg文件就强制转化成js读取
   */
  if (config.launch.crossDomain || config.launch.convert === 'svg') {
    path = path.replace('.svg', '.js');
    name = path.replace(".js", '');
    svgUrl = config.getSvgPath() + path;
    loadJs(svgUrl, name); //直接采用脚本加载
    return;
  }

  /**
   * ibooks模式 单独处理svg转化策划给你js,加载js文件
   */
  if (Xut.IBooks.CONFIG) {
    //如果是.svg结尾
    //把svg替换成js
    if (/.svg$/.test(path)) {
      path = path.replace(".svg", '.js');
    }
    //全路径
    paths = config.getSvgPath().replace("svg", 'js') + path;
    //文件名
    name = path.replace(".js", '');
    //加载脚本
    loadFile(randomUrl(paths), function () {
      data = window.HTMLCONFIG[name] || window.IBOOKSCONFIG[name];
      if (data) {
        callback(data);
        delete window.HTMLCONFIG[name];
        delete window.IBOOKSCONFIG[name];
      } else {
        Xut.$warn({
          type: 'util',
          content: '编译:脚本加载失败，文件名:' + name
        });
        callback('');
      }
    });
    return;
  }

  //svg文件
  //游览器模式 && 非强制插件模式
  if (Xut.plat.isBrowser && !config.isPlugin) {
    //默认的地址
    svgUrl = config.getSvgPath().replace("www/", "") + path;

    //mini杂志的情况，不处理目录的www
    if (config.launch.resource) {
      svgUrl = config.getSvgPath() + path;
    }

    $.ajax({
      type: 'get',
      dataType: 'html',
      url: randomUrl(svgUrl),
      success: function success(svgContent) {
        callback(svgContent);
      },
      error: function error(xhr, type) {
        Xut.$warn({
          type: 'util',
          content: 'svg文件解释出错，文件名:' + path
        });
        callback('');
      }
    });
    return;
  }

  /**
   * 插件读取
   * 手机客户端模式
   */
  Xut.Plugin.ReadAssetsFile.readAssetsFileAction(config.getSvgPath() + path, function (svgContent) {
    callback(svgContent);
  }, function (err) {
    callback('');
  });
}

/**
 * 利用canvas绘制出蒙板效果替换，需要蒙板效果的图片先用一个canvas占位，绘制是异步的
 */

function _getCanvas(className) {
  var children = document.getElementsByTagName('canvas'),
      elements = new Array(),
      i = 0,
      child,
      classNames,
      j = 0;
  for (i = 0; i < children.length; i++) {
    child = children[i];
    classNames = child.className.split(' ');
    for (var j = 0; j < classNames.length; j++) {
      if (classNames[j] == className) {
        elements.push(child);
        break;
      }
    }
  }
  return elements;
}

function _addEdge(canvas) {

  var img = new Image(),
      maskimg = new Image();

  var classNames = canvas.className.split(' ');
  var context = canvas.getContext("2d");
  img.addEventListener("load", loadimg);
  maskimg.addEventListener("load", loadmask);

  function loadimg() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.globalCompositeOperation = "source-over";
    context.drawImage(img, 0, 0, canvas.width, canvas.height);
    maskimg.src = canvas.getAttribute("mask");
    img.removeEventListener("load", loadimg);
    img.src = null;
    img = null;
  }

  function loadmask() {
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(maskimg, 0, 0, canvas.width, canvas.height);
    canvas.style.opacity = 1;
    maskimg.removeEventListener("load", loadmask);
    maskimg.src = null;
    maskimg = null;
    context = null;
    classNames = null;
    canvas.className = canvas.className.replace("edges", "");
  }
  img.src = canvas.getAttribute("src");
}

function addEdges() {
  var thecanvas = _getCanvas('edges'),
      i;
  for (i = 0; i < thecanvas.length; i++) {
    _addEdge(thecanvas[i]);
  }
}

/**
 * 一些特殊的功能函数
 */

/**
 * 捕获完成
 * 用于多组回调循环
 * 只捕获到唯一的回调
 * count次数
 * callback={
 *   pre  回调处理
 *   post 后回调处理
 * }
 */

//替换url
//1. 路径
//2. 基础后缀
var urlRE = /(img\s+src|xlink:href)=\"[\w\/]*gallery\/(\w+)(\.[png|jpg|gif]+)/ig;

//替换style中的vw,vh单位尺寸
//width\s*:\s*(\d+[.\d]*)\s*(?=[vw|vh])/gi
//height\s*:\s*(\d+[.\d]*)\s*(?=[vw|vh])/gi
// const sizeRE = /([width|height]+)\s*:\s*(\d+[.\d]*)\s*(?=[vw|vh])/ig

//中文符号
// const symbols = {
//     "，": ",",
//     "。": ".",
//     "：": ":",
//     "；": ";",
//     "！": "!",
//     "？": "?",
//     "（": "(",
//     "）": ")",
//     "【": "[",
//     "】": "]"
// }
// const symbolRE = new RegExp(Object.keys(symbols).join("|"), "ig")


/**
 * 数据库缓存结果集
 */
var result = void 0;

/*
fileName + brModeType + baseSuffix + type
 */
function parseFileName(fileName, baseSuffix, type) {
  //如果启动了模式
  if (config.launch.brModeType) {
    //增加brModeType，增加后缀，去掉类型
    return '' + fileName + config.launch.brModeType + baseSuffix;
  }
  //如果只加了baseSuffix模式处理
  return '' + fileName + baseSuffix + type;
}

/**
 * json数据过滤
 * 1 flow数据
 * 2 flow样式
 * 3 svgsheet
 */
function filterJsonData() {
  result = window.SQLResult;

  /*必须保证数据存在*/
  if (!result) {
    $warn('database', 'json数据库加载出错');
    return;
  }
  /*快速刷新会出错，加强判断*/
  if (!_.isObject(result)) {
    $warn('database', 'json数据库必须是对象');
    return;
  }
  if (!result.Setting) {
    $warn('database', 'json数据库必须要表');
    return;
  }

  //配置了远程地址
  //需要把flow的给处理掉
  if (config.launch.resource && result.FlowData) {

    /*如果没有强制关闭，并且有flow数据，那么就默认启动*/
    if (config.launch.columnCheck !== false) {
      config.launch.columnCheck = true;
    }

    //有基础后缀，需要补上所有的图片地址
    var baseSuffix = config.launch.baseImageSuffix ? '.' + config.launch.baseImageSuffix : '';

    //xlink:href
    //<img src
    //<img src="content/gallery/0920c97a591f525044c8d0d5dbdf12b3.png"
    //<img src="content/310/gallery/0920c97a591f525044c8d0d5dbdf12b3.png"
    //xlink:href="content/310/gallery/696c9e701f5e3fd82510d86e174c46a0.png"
    //img src="content/11/gallery/b9ba3dfc39ddd207_a.hi
    result.FlowData = result.FlowData.replace(urlRE, function (a, prefix, fileName, type) {
      return prefix + '="' + config.launch.resource + '/gallery/' + parseFileName(fileName, baseSuffix, type);
    });
  }

  window.SQLResult = null;

  //标记有Flow数据处理
  config.launch.hasFlowData = true;

  return result;
}

/**
 * style width,height替换值
 * height:42vw
 * height:42.48vw
 * height : 42.48vw
 * height:  66.99vw
 * height:42.48 vw
 */
// function replaceSize(str, prop) {
//     return str.replace(sizeRE, function(a, key, value) {
//         return `${key}:${value * prop}`
//     })
// }


/**
 * 设置数据缓存
 * 加载配置文件指定路径数据库
 * 加载外部动态js加载的数据库文件
 *
 * 1 去掉全局挂着
 * 2 缓存
 */
function importJsonDatabase(callback) {
  var path = config.launch.database;
  //如果外联指定路径json数据
  if (path && /.js$/.test(path)) {
    //防止外部链接影响
    window.SQLResult = null;
    loadFile(path, function () {
      callback(filterJsonData());
    });
  }
  //如果外联index.html路径json数据
  else if (window.SQLResult) {
      callback(filterJsonData());
    } else {
      callback();
    }
}

/**
 * 删除挂载的flow数据
 * @return {[type]} [description]
 */
function removeColumnData() {
  result['FlowData'] = null;
}

/**
 * 获取数据缓存
 * @return {[type]} [description]
 */
function getResults() {
  return result;
}

/**
 * 移除缓存数据
 * @return {[type]} [description]
 */
function removeResults() {
  result = null;
}

/**
 * 创建执行方法
 * @return {[type]} [description]
 */
function createfactory(sql, fn) {
  var key;
  if (typeof sql === 'string') {
    fn(key, sql);
  } else {
    for (key in sql) {
      fn(key, sql[key]);
    }
  }
}

/**
 * 模拟database获取数据
 * @return {[type]}            [description]
 */
function executeDB(sql, callback, errorCB, tName) {
  var jsonResult = getResults();
  var data = void 0;
  var resultObj = void 0;

  //如果json格式数据
  if (jsonResult) {
    if (jsonResult[tName]) {
      data = jsonResult[tName];
      resultObj = {
        length: Object.keys(data).length,
        item: function item(num) {
          return data[num];
        }
      };
      callback(resultObj);
    } else {
      errorCB({
        tName: ':table not exist!!'
      });
    }
  }
  //否则直接ajax php
  else {
      $.ajax({
        url: config.data.onlineModeUrl,
        dataType: 'json',
        data: {
          xxtsql: sql
        },
        success: function success(rs) {
          data = rs;
          resultObj = {
            length: rs.length,
            item: function item(num) {
              return data[num];
            }
          };
          callback(resultObj);
        },

        error: errorCB
      });
    }
}

//建立sql查询
function execute(selectSql, callback) {

  var database = config.data.db,
      tableName,
      //表名
  successResults = {},
      //成功的数据
  tempClosure = [],
      //临时收集器
  collectError = [],
      //收集错误查询
  buildTotal = function () {
    //如果只有一条
    if (typeof selectSql === 'string') {
      return 1;
    } else {
      return Object.keys(selectSql).length;
    }
  }();

  createfactory(selectSql, function (key, value) {
    //开始执行查询
    createSelect(key || 'results', value);
  });

  /**
   * 创建查询
   */
  function createSelect(key, value) {
    buildTotal--;
    tempClosure.push(executeTemplate(key, value));
    0 === buildTotal && executeBuild();
  }

  /**
   * 执行查询
   * @return {[type]} [description]
   */
  function executeBuild() {
    if (tempClosure.length) {
      var temp = tempClosure.shift();
      tableName = temp.tableName;
      temp.execute();
    } else {
      //successResults['results'] 成功表数据
      //collectError 失败表
      callback(successResults['results'] ? successResults['results'] : successResults, collectError);
    }
  }

  //成功后方法
  function success() {
    executeBuild();
  }

  //失败
  function errorCB(error) {
    collectError.push(tableName);
    console.log("数据查询错误 " + error.message, '类型', tableName);
    executeBuild();
  }

  /**
   * 构建执行作用域
   */
  function executeTemplate(tName, sql) {
    return {
      tableName: tName,
      execute: function execute() {
        //支持本地查询
        if (database) {
          database.transaction(function (tx) {
            tx.executeSql(sql, [], function (tx, result) {
              successResults[tName] = result.rows;
            });
          }, errorCB, success);
        }
        //json与ajax
        else {
            executeDB(sql, function (result) {
              successResults[tName] = result;
              success();
            }, errorCB, tName);
          }
      }
    };
  }
}

var statement = {};

'Setting,Parallax,Master,Activity,Content,Video,Image,Action,Animation,Widget,Novel,Season,Chapter'.replace(/[^, ]+/g, function (name) {
  statement[name] = 'select * FROM ' + name + ' order by _id ASC';
});

/**
 * 查询单一的数据
 * @return {[type]} [description]
 */
function oneQuery(tableName, callback) {
  execute('select * FROM ' + tableName + ' order by _id ASC', function (successRet, collectError) {
    callback(successRet, collectError);
  });
}

/**
 * 查询总数据
 */
function dataQuery(callback) {
  //ibook模式，数据库外部注入的
  if (Xut.IBooks.CONFIG) {
    callback(Xut.IBooks.CONFIG.data);
  } else {
    //查询所有数据
    execute(statement, function (successRet, collectError) {
      return callback(successRet, collectError);
    });
  }
}

/**
 * 删除数据
 * @type {[type]}
 */
function dataRemove(tableName, id, success, fail) {
  var sql = 'delete from ' + tableName + ' where _id = ' + id;
  //查询所有数据
  execute(sql, function (success, failure) {
    if (success) {
      //成功回调
      success();
    } else if (failure) {
      //失败回调
      fail();
    }
  });
}

/**
 * 计算数据偏移量
 * @param  {[type]} tableName [description]
 * @return {[type]}           [description]
 */
function dataOffset(dataCache) {

  var set = function set(tableName) {
    var start = void 0;
    var data = dataCache[tableName];
    if (data.length) {
      if (data.item(0)) {
        if (start = data.item(0)._id) {
          dataCache[tableName].start = start;
        }
      }
    }
  };

  //数据段标记
  for (var key in dataCache) {
    if (dataCache[key].item) {
      set(key);
    }
  }

  return dataCache;
}

/**
 * 转化video的activtiy信息
 * 因为Video不是靠id关联的 是靠activtiy关联
 * [description]
 * @return {[type]} [description]
 */
function transformVideoActivity(dataCache) {
  var data = void 0;
  var activityIds = {};
  var video = dataCache.Video;
  _.each(video, function (_, index) {
    data = video.item(index);

    //确保activityIdID是有值，
    //这样才是靠activity关联的video,
    //而不是动画的video
    if (data && data.activityId) {
      activityIds[data.activityId] = data._id;
    }
  });
  return activityIds;
}

/**
 * chpater分段
 * 转化section信息
 * 带有场景处理
 * @return {[type]} [description]
 */
var transformSectionRelated = function transformSectionRelated(dataCache) {
  var seasonId,
      start,
      length,
      sid,
      i,
      id,
      seasonInfo,
      toolbar,
      Chapters,
      container = {},
      Chapter = dataCache.Chapter,
      l = Chapter.length,
      end = 0;

  //找到指定的season信息
  var findSeasonInfo = function findSeasonInfo(seasonId) {
    var temp,
        seasonNum = dataCache.Season.length;
    while (seasonNum--) {
      if (temp = dataCache.Season.item(seasonNum)) {
        if (temp._id == seasonId) {
          return temp;
        }
      }
    }
  };

  for (i = 0; i < l; i++) {
    Chapters = Chapter.item(i);
    if (Chapters) {
      id = Chapters._id - 1; //保存兼容性,用0开头
      seasonId = Chapters.seasonId;
      sid = 'seasonId->' + seasonId;
      //如果不在集合,先创建
      if (!container[sid]) {
        //场景工具栏配置信息
        if (seasonInfo = findSeasonInfo(seasonId)) {
          toolbar = seasonInfo.parameter;
        }
        container[sid] = {
          start: id,
          length: 1,
          end: id,
          toolbar: toolbar
        };
      } else {
        container[sid].end = id;
        container[sid].length = container[sid].length + 1;
      }
    }
  }

  return container;
};

/**
 * 数据缓存
 */
var dataCache = void 0;

/**
 * 带有场景信息存数
 */
var sectionRelated = void 0;

/**
 * 音频的ActivityId信息
 */
var videoActivityIdCache = void 0;

/**
 * 错误表
 */
var errortables = void 0;

/**
 * 错误表
 * @return {[type]} [description]
 */
function errorTable() {
  return errortables;
}

/**
 * 保存缓存
 * @param {[type]} results [description]
 */
function saveCache(results, collectError) {
  //错表
  errortables = collectError || [];

  //数据结果集
  Xut.data = dataCache = results;
}

/**
 * 销毁数据
 * @return {[type]} [description]
 */
function removeCache() {
  dataCache = null;
  sectionRelated = null;
  videoActivityIdCache = null;
  Xut.data = null;
}

/**
 * 转化缓存
 */
function convertCache() {

  /**
   * 计算数据偏移量
   */
  dataOffset(dataCache);

  /**
   * vidoe特殊处理，需要记录chapterId范围
   */
  if (dataCache.Video) {
    videoActivityIdCache = transformVideoActivity(dataCache);
  }

  /**
   * 带有场景处理
   * @type {[type]}
   */
  sectionRelated = transformSectionRelated(dataCache);
}

/**
 *  查询数据接口
 *  1 video表传递是activityId关联
 *  2 其余表都是传递当前表的id
 *  type 查询ID的类型, 数据的id或者activityId
 *  callback 提供给chapterId使用
 * @return {[type]} [description]
 */
function setApi(novelId) {

  /**
   * 标记应用ID
   * @type {[type]}
   */
  dataCache.novelId = novelId;

  /**
   * 针对数据库content为空的处理
   * @return {[type]} [description]
   */
  dataCache.preventContent = function () {
    return dataCache.Content.length ? false : true;
  }();

  /**
   * 通过ID查询方式
   * @param  {[type]}  tableName [description]
   */
  dataCache.query = function (tableName, id, type, callback) {
    /**
     * 特殊的字段关联
     * 1 activityId
     * 2 chpaterId
     */
    switch (type) {
      /**
       * 通过activityId查询的方式
       *
       * 表名,ID,类型
       * Xut.data.query('Action', id, 'activityId');
       *
       * @type {[type]}
       */
      case 'activityId':
        var item;
        var activityId = id;
        var data = dataCache[tableName];
        for (var i = 0, len = data.length; i < len; i++) {
          item = data.item(i);
          if (item) {
            if (item[type] == activityId) {
              return item;
            }
          }
        }
        return;

      /**
       * 通过chpaterId查询方式
       * parser中的scanActivity过滤处理
       */
      case 'chapterId':
      case 'seasonId':
        var chapterId = id;
        var data = dataCache[tableName];
        if (data) {
          var item;
          for (var i = 0, len = data.length; i < len; i++) {
            item = data.item(i);
            if (item) {
              if (item[type] == chapterId) {
                callback && callback(item);
              }
            }
          }
        }
        return;
    }

    /**
     * 数据信息
     * @return {[type]} [description]
     */
    var Query = function Query() {
      var data = dataCache[tableName];
      if (id) {
        var index = id - data.start;
        return data.item(index);
      } else {
        return data.length ? data.item(0) : null;
      }
    };

    /**
     * 通过id查询的方式
     */
    switch (tableName) {
      //获取整个一个用的chapter数据
      case 'appPage':
        return dataCache.Chapter;
      ///获取整个一个用的Section数据 
      case 'appSection':
        return dataCache.Season;
      //如果是是section信息
      case 'sectionRelated':
        return sectionRelated['seasonId->' + id];
      //如果是音频
      case 'Video':
        if (type) {
          return Query();
        } else {
          //传递的id是activityId
          var id = videoActivityIdCache[id];
          return dataCache.query('Video', id, true);
        }

      default:
        //默认其余所有表
        return Query();
    }
  };

  /**
   * 针对动态表查询
   * 每次需要重新取数据
   * Xut.data.oneQuery('Image',function(){});
   * @return {[type]} [description]
   */
  dataCache.oneQuery = function (tableName, callback) {
    oneQuery(tableName, function (data) {
      callback && callback(data);
    });
  };

  /**
   * 删除数据
   * 表名,表ID
   * @return {[type]} [description]
   */
  dataCache.remove = function (tableName, id, success, failure) {
    dataRemove(tableName, id, success, failure);
  };
}

/**
 * 初始化数据类
 * 获取ppt总数
 * @return {[type]} [description]
 */
function createStore(callback) {
  dataQuery(function (results, collectError) {
    //保存缓存
    saveCache(results, collectError);
    //数据缓存转化
    convertCache();
    //设置API
    setApi(results.Novel.item(0)['_id']);
    callback(results);
  });
}

/**
 * 数据库支持
 * @return {[type]} [description]
 */
var supportTransaction = function supportTransaction(callback) {
  if (window.openDatabase) {
    try {
      //数据库链接对象
      config.data.db = window.openDatabase(config.data.dbName, "1.0", "Xxtebook Database", config.data.dbSize);
    } catch (err) {
      console.log('window.openDatabase出错');
    }
  }

  //如果读不出数据
  if (config.data.db) {
    config.data.db.transaction(function (tx) {
      tx.executeSql('SELECT * FROM Novel', [], function (tx, rs) {
        callback();
      }, function () {
        config.data.db = null;
        callback();
      });
    });
  } else {
    callback();
  }
};

/*
初始化数据库Store
 */
var initStore = function initStore(callback) {
  createStore(function (dataRet) {
    return callback(dataRet);
  });
};

/**
 * 初始化
 * 数据结构
 */
var initDatabse = function (hasResults, callback) {
  if (hasResults) {
    config.data.db = null;
    initStore(callback);
    return;
  }
  /*如果没有外链数据，需要查找本地是否支持*/
  supportTransaction(function () {
    initStore(callback);
  });
};

/**
 * 默认工具栏配置
 * @type {Object}
 */
var defaults$1 = {
  ToolbarPos: 0, //工具栏[0顶部,1底部]
  NavbarPos: 1, //左右翻页按钮[0顶部, 1中间, 2底部]
  HomeBut: 1, //主页按钮[0不显示,1显示]
  ContentBut: 1, //目录按钮[0不显示,1显示]
  PageBut: 1, //页码按钮[0不显示,1显示]
  NavLeft: 1, //左翻页按钮[0不显示,1显示]
  NavRight: 1, //右翻页按钮[0不显示,1显示]
  customButton: 0, //自定义翻页按钮
  CloseBut: window.SUbDOCCONTEXT ? 1 : 0 //关闭按钮[0不显示,1显示]


  /**
   * 配置默认数据
   * @return {[type]} [description]
   */
};function initDefaults(setData) {

  var rs = void 0;
  var data = {};
  var setConfig = {};

  _.each(setData, function (key, index) {
    rs = setData.item(index);
    data[rs.name] = rs.value;
  });

  _.defaults(data, defaults$1);

  for (var i in defaults$1) {
    setConfig[i] = Number(data[i]);
  }

  _.extend(config.data, {
    originalAppId: Number(data.appId),
    //应用的唯一标识符
    //生成时间+appid
    appId: data.adUpdateTime ? data.appId + '-' + /\S*/.exec(data.adUpdateTime)[0] : data.appId,
    settings: setConfig,
    delayTime: data.delayTime,
    Inapp: data.Inapp,
    shortName: data.shortName,
    /*字符串类型，需要转化*/
    visualMode: data.visualMode ? Number(data.visualMode) : 0
  });

  //广告Id
  //2014.9.2
  Xut.Presentation.AdsId = data.adsId;

  return data;
}

/**
 * 用css3实现的忙碌光标
 * @return {[type]} [description]
 */

/**
 * 延时加载
 * @type {Number}
 */
var delayTime = 500;

/**
 * 光标对象
 * @type {[type]}
 */
var node = null;

/**
 * 是否禁用忙了光标
 * @type {Boolean}
 */
var isDisable = false;

/**
 * 光标状态
 * 调用隐藏
 * @type {Boolean}
 */
var isCallHide = false;

/**
 * setTimouet
 * @type {[type]}
 */
var timer = null;

/**
 * 设置忙碌光标的图片地址
 */
var path = void 0;

/**
 * create
 * @return {[type]} [description]
 *   return hasDisable() ? '' : '<div class="xut-busy-icon xut-fullscreen"></div>'
 */
function createCursor() {
  if (isDisable) return;
  var sWidth = config.visualSize.width;
  var sHeight = config.visualSize.height;
  var width = Math.min(sWidth, sHeight) / 4;
  var space = Math.round((sHeight - width) / 2);
  var delay = [0, 0.9167, 0.833, 0.75, 0.667, 0.5833, 0.5, 0.41667, 0.333, 0.25, 0.1667, 0.0833];
  var deg = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];

  var count = 12;
  var container = '';

  /*自定义*/
  if (path) {
    container += '<div class="xut-busy-middle fullscreen-background"\n                       style="background-image: url(' + path + ');">\n                  </div>';
  } else {
    /*自带*/
    while (count--) {
      container += '<div class="xut-busy-spinner"\n              style="' + Xut.style.transform + ':rotate(' + deg[count] + 'deg) translate(0,-142%);' + Xut.style.animationDelay + ':-' + delay[count] + 's">\n         </div>';
    }
    container = '<div class="xut-busy-middle">' + container + '</div>';
  }

  return '<div class="xut-busy-icon xut-fullscreen">\n            <div style="width:' + width + 'px;height:' + width + 'px;margin:' + space + 'px auto;margin-top:' + (config.visualSize.top + space) + 'px;">\n                <div style="height:30%;"></div>\n                  ' + container + '\n                <div class="xut-busy-text"></div>\n             </div>\n          </div>';
}

var clear = function clear() {
  clearTimeout(timer);
  timer = null;
};

function access(callback) {
  if (!node) {
    node = $('.xut-busy-icon');
  }
  if (node && node.length) {
    callback(node);
  }
}

/**
 * 显示光标
 */
var showBusy = function showBusy() {
  if (isDisable || Xut.IBooks.Enabled || timer) return;
  timer = setTimeout(function () {
    access(function (context) {
      context.show();
    });
    clear();
    if (isCallHide) {
      hideBusy();
      isCallHide = false;
    }
  }, delayTime);
};

/**
 * 隐藏光标
 */
var hideBusy = function hideBusy() {
  //显示忙碌加锁，用于不处理hideBusy
  if (isDisable || Xut.IBooks.Enabled || showBusy.lock) return;
  if (!timer) {
    access(function (context) {
      context.hide();
    });
  } else {
    isCallHide = true;
  }
};

/**
 * 显示光标
 * @param {[type]} txt [description]
 */
var showTextBusy = function showTextBusy(txt) {
  if (isDisable || Xut.IBooks.Enabled) return;
  access(function (context) {
    context.css('pointer-events', 'none').find('.xut-busy-text').html(txt);
  });
  showBusy();
};

/**
 * 重置忙碌光标
 * 因为设置被覆盖了
 */
var resetCursor = function resetCursor(data) {
  path = null;
  delayTime = 500;
  node = null;
};

/**
 * 通过lanuch重设接口
 */
var setPath = function setPath(url) {
  path = url;
};

/**
 * 设置时间显示的时间间隔
 */
var setDelay = function setDelay(time) {
  delayTime = time;
};

/**
 * 设置禁用光标
 * isDisable 是否禁用
 * @return {[type]} [description]
 */
var setDisable = function setDisable() {
  isDisable = true;
};

/*
是否禁止了
 */
var hasDisable = function hasDisable() {
  return isDisable;
};

/**
 * 忙碌光标
 * @return {[type]} [description]
 */
function getBusyHTML() {
  //创建忙碌光标
  if (!hasDisable() && !Xut.IBooks.Enabled) {
    return createCursor();
  }
  return '';
}

/**
 * 初始化根节点
 * @param  {[type]} newCursor [description]
 * @return {[type]}           [description]
 */
function getContentHTML() {
  var coverStyle = '';
  //mini平台不要背景图
  if (config.launch.platform === 'mini') {} else {
    //默认背景图
    var coverUrl = './content/gallery/cover.jpg';
    //重写背景图
    if (config.launch.resource) {
      coverUrl = config.launch.resource + '/gallery/cover.jpg';
    }
    //背景样式
    coverStyle = 'style="background-image: url(' + coverUrl + ');"';
  }
  return getBusyHTML() + '\n            <div class="xut-adaptive-image"></div>\n            <div class="xut-cover xut-fullscreen" ' + coverStyle + '></div>\n            <div class="xut-scene-container xut-fullscreen xut-overflow-hidden"></div>';
}

/**
 * 根节点
 */
var $rootNode = void 0;
var $contentNode = void 0;
function initRootNode() {
  var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#xxtppt-app-container';
  var cursor = arguments[1];


  var contentHtml = void 0;

  if (el) {
    $rootNode = $(el);
  }

  //如果没有传递节点名，直接放到body下面
  if (!$rootNode.length) {
    el = '';
    $rootNode = $('body');
  }

  if (el) {
    contentHtml = getContentHTML(cursor);
  } else {
    //如果根节点不存在,配置根节点
    contentHtml = '<div id="xxtppt-app-container" class="xut-fullscreen xut-overflow-hidden">' + contentHtml + '</div>';
  }

  $contentNode = $(String.styleFormat(contentHtml));

  return { $rootNode: $rootNode, $contentNode: $contentNode };
}

function clearRootNode() {
  if ($contentNode) {
    $contentNode.remove();
    $contentNode = null;
  }
  $rootNode = null;
}

/**
 * 移除背景
 * @return {[type]} [description]
 */
function removeCover(callback) {
  //第一次进入，处理背景
  var $cover = $(".xut-cover");
  if ($cover.length) {
    //主动探测,只检查一次
    var complete = function complete() {
      $cover && $cover.remove();
      $cover = null;
      callback();
    };
    //是否配置启动动画关闭


    if (config.launch.launchAnim === false) {
      complete();
    } else {
      //有动画
      $cover.transition({
        opacity: 0,
        duration: 1000,
        easing: 'in',
        complete: complete
      });
    }
  } else {
    $cover = null;
    callback();
  }
}

/**
 * 记录分栏数据
 * columnData[seasonsId][chapterId] = {
 *     count,
 *     height
 * }
 * @type {Object}
 */
var columnData = void 0;

/**
 * 缓存流式布局对象
 */
function addCache(data) {
  columnData = data;
}

/**
 * 后台补全，如果数量错误，重设分栏的数量
 */
function resetColumnCount(seasonsId, chapterId, value) {
  if (columnData[seasonsId] && columnData[seasonsId][chapterId]) {
    columnData[seasonsId][chapterId] = value;
  }
}

/**
 * 是否有流式排版
 * 加快计算
 * @return {Boolean} [description]
 */
function hasColumn() {
  return columnData;
}

/**
 * 获取当前当前到前置的总和
 * @return {[type]} [description]
 */
function getCurrentBeforeCount(seasonId, chapterId) {
  if (!columnData) return;
  if (!seasonId && !chapterId) return;
  var seasonIds = columnData[seasonId];
  var count = 0;
  for (var key in seasonIds) {
    if (key <= chapterId) {
      count += seasonIds[key];
      --count;
    }
  }
  return count > 0 ? count : 0;
}

/**
 * 获取当前chapterId之前的总页数
 * @return {[type]} [description]
 */
function getBeforeCount(seasonId, chapterId) {
  if (columnData && seasonId && chapterId) {
    var seasonIds = columnData[seasonId];
    var count = 0;
    for (var key in seasonIds) {
      if (key < chapterId) {
        count += seasonIds[key];
        --count;
      }
    }
    return count > 0 ? count : 0;
  }
}

/**
 * 获取chpater总数
 * 一共有多少chapter页面有分栏
 */
function getColumnChapterCount(seasonId) {
  if (!columnData) return;
  return Object.keys(columnData[seasonId]).length;
}

/**
 * reutrn seasonIds
 * return chpaterIds
 */
function getColumnCount$1(seasonId, chapterId) {
  if (!columnData) return;
  if (seasonId) {
    if (chapterId) {
      return columnData[seasonId] && columnData[seasonId][chapterId];
    } else {
      var seasonIds = columnData[seasonId];
      var count = 0;
      for (var key in seasonIds) {
        count += seasonIds[key];
      }
      return count;
    }
  } else {
    console.log('getCounts失败');
  }
}

/**
 * 判断是否为分栏布局页面
 * @param  {[type]} seasonId  [description]
 * @param  {[type]} chpaterId [description]
 * @return {[type]}           [description]
 */
function isColumnPage(seasonId, chapterId) {
  return getColumnCount$1(seasonId, chapterId) ? true : false;
}

/**
 * debug调试
 */
var debug$1 = false;
var simulateCount = 2;

/**
 * 模拟检测次数
 */
var simulateTimer = 13;

/**
 * 检测引用
 */
var timerId = null;

/**
 * 基本检测次数 20*500 ~ 10秒范围
 */
var baseCheckCount = 20;

/**
 * 分栏探测
 */
var makeDelay = function makeDelay(seasonsId, chapterId, count) {
  return function () {
    resetColumnCount(seasonsId, chapterId, count);
  };
};

var execDelay = function execDelay(tempDelay) {
  if (tempDelay.length) {
    var fn = void 0;
    while (fn = tempDelay.pop()) {
      fn();
    }
    Xut.Application.Notify('change:number:total');
    Xut.Application.Notify('change:column');
  }
};

/**
 * 检测分栏数
 */
function detectColumn($seasons, columnCollection, callback, checkCount) {
  var tempDelay = [];

  getColumnData($seasons, function (seasonsId, chapterId, count) {
    if (debug$1 && checkCount > simulateTimer) {
      count = simulateCount;
    }
    //假如高度改变
    if (columnCollection[seasonsId][chapterId] !== count) {
      columnCollection[seasonsId][chapterId] = count;
      tempDelay.push(makeDelay(seasonsId, chapterId, count));
    }
  });

  --checkCount;

  //执行监控改变
  tempDelay.length && execDelay(tempDelay);

  if (checkCount) {
    timerId = setTimeout(function () {
      detectColumn($seasons, columnCollection, callback, checkCount);
    }, 500);
  } else {
    //如果探测完毕就强制关闭检测了
    config.launch.columnCheck = false;
    clearColumnDetection();
    callback();
  }
}

/**
 * 开始分栏探测
 */
function startColumnDetect($seasons, columnCollection, callback) {
  detectColumn($seasons, columnCollection, callback, baseCheckCount);
}

/**
 * 停止分栏高度探测
 */
function clearColumnDetection() {
  Xut.Application.unWatch('change:number:total change:column');
  clearTimeout(timerId);
  timerId = null;
}

var COLUMNWIDTH = Xut.style.columnWidth;
var COLUMNTAP = Xut.style.columnGap;

/**
 * 高度marginTop - marginBottom处理了
 * 不一定等于设备高度
 * @type {Number}
 */
var newViewHight = 0;

/**
 * create dom...
 */
function createStr(chapterId, data, visualWidth, visualHeight, margin) {

  var percentageTop = Number(margin[0]);
  var percentageLeft = Number(margin[1]);
  var percentageBottom = Number(margin[2]);
  var percentageRight = Number(margin[3]);

  //减去的宽度值
  var negativeWidth = visualWidth / 100 * (percentageLeft + percentageRight);

  //减去的高度值
  var negativeHeight = visualHeight / 100 * (percentageTop + percentageBottom);

  //容器宽度 = 宽度 - 左右距离比值
  var containerWidth = visualWidth - negativeWidth;

  //容器高度值 = 宽度 - 上下距离比值
  var containerHeight = visualHeight - negativeHeight;

  //容器左边偏移量
  var containerLeft = negativeWidth / 2;

  //容器上偏移量
  var containerTop = visualHeight / 100 * percentageTop;

  //重复加载杂志
  //不刷新的情况处理
  if (/section-transform/.test(data)) {
    data = $(data).find("#columns-content").html();
  }

  if (config.launch.scrollMode === 'v') {
    /*竖版的情况下，不需要分栏了，直接处理*/
    var columnGap = COLUMNTAP + ':' + negativeWidth + 'px';
    var columnWidth = COLUMNWIDTH + ':' + containerWidth + 'px';
    var container = '\n            <section id="wrapper-section" class="section-transform" data-flow="true" style="width:' + (visualWidth - containerLeft) + 'px;height:' + (visualHeight - containerTop) + 'px;top:' + containerTop + 'px;left:' + containerLeft + 'px;">\n                <div  id="scroller-section" class="page-flow-scale" data-role="margin" style="width:' + containerWidth + 'px;height:auto;">\n                      ' + data + '\n                </div>\n            </section>';
    newViewHight = visualHeight - containerTop;
    return String.styleFormat(container);
  } else {
    /*配置分栏*/
    var _columnGap = COLUMNTAP + ':' + negativeWidth + 'px';
    var _columnWidth = COLUMNWIDTH + ':' + containerWidth + 'px';
    var _container = '\n            <section class="section-transform" data-flow="true">\n                <div class="page-flow-scale" data-role="margin" style="width:' + containerWidth + 'px;height:' + containerHeight + 'px;margin-top:' + containerTop + 'px;margin-left:' + containerLeft + 'px;">\n                    <div data-role="column" id="columns-content" style="' + _columnWidth + ';height:100%;' + _columnGap + '">\n                        ' + data + '\n                    </div>\n                </div>\n            </section>';
    newViewHight = containerHeight;
    return String.styleFormat(_container);
  }
}

function insertColumn(seasonNode, seasonsId, visualWidth, visualHeight, columnData) {
  for (var i = 0; i < seasonNode.childNodes.length; i++) {
    var chapterNode = seasonNode.childNodes[i];
    if (chapterNode.nodeType == 1) {
      var tag = chapterNode.id;
      if (tag) {
        var id = /\d+/.exec(tag)[0];
        if (id) {
          var margin = chapterNode.getAttribute('data-margin');
          if (margin) {
            margin = margin.split(",");
          } else {
            margin = [0, 0, 0, 0];
          }
          chapterNode.innerHTML = createStr(id, chapterNode.innerHTML, visualWidth, visualHeight, margin);
          columnData[seasonsId][id] = 0;
        } else {
          $warn({
            type: 'column',
            content: 'insertColumn节点是空的'
          });
        }
      } else {
        $warn({
          type: 'column',
          content: 'insertColumn节点是空的'
        });
      }
    }
  }
}

function eachColumn(columnData, $seasons, visualWidth, visualHeight) {
  $seasons.each(function (index, node) {
    var tag = node.id;
    var seasonsId = tag.match(/\d/)[0];
    var $chapters = $seasons.children();
    columnData[seasonsId] = {};
    insertColumn(node, seasonsId, visualWidth, visualHeight, columnData);
  });
}

/**
 * 获取分栏数
 */
function getColumnCount(content, id) {
  var theChildren = $(content).find(id).children();
  var paraHeight = 0;
  for (var i = 0; i < theChildren.length; i++) {
    paraHeight += Math.max(theChildren[i].scrollHeight, theChildren[i].clientHeight);
  }
  return Math.ceil(paraHeight / newViewHight);
}

/**
 * 获取分栏的数量与高度
 * 1 横版，数量
 * 2 竖版，高度
 */
function getColumnData($seasons, callback) {
  $seasons.each(function (index, node) {
    var tag = node.id;
    var seasonsId = tag.match(/\d/)[0];
    var $chapters = $seasons.children();
    $chapters.each(function (index, node) {
      var tag = node.id;
      if (tag) {
        var chapterId = tag.match(/\d+/)[0];
        var count = void 0;
        if (config.launch.scrollMode === 'h') {
          count = getColumnCount(node, '#columns-content');
        } else if (config.launch.scrollMode === 'v') {
          count = getColumnCount(node, '#scroller-section');
        }
        callback(seasonsId, chapterId, count);
      }
    });
  });
}

/**
 * 构建column页面代码结构
 */
function initColumn(callback) {

  var $container = $("#xut-stream-flow");
  if ($container.length) {
    $container.remove();
  }

  var setHeight = function setHeight($container, visualWidth, visualHeight) {
    $container.css({
      width: visualWidth,
      height: visualHeight,
      display: 'block'
    });
  };

  var setInit = function setInit(visualWidth, visualHeight) {
    var $seasons = $container.children();
    if (!$seasons.length) {
      callback();
      return;
    }

    /**
     * 记录分栏数据
     * columnData[seasonsId][chapterId] = {
     *     count,
     *     height
     * }
     * @type {Object}
     */
    var columnData = {};
    setHeight($container, visualWidth, visualHeight);
    eachColumn(columnData, $seasons, visualWidth, visualHeight);

    /**
     * 得到分栏的数据
     * 1 数量
     * 2 高度
     * 3 检测是否有丢失
     */
    setTimeout(function () {

      //第一次获取分栏数与高度 analysis
      getColumnData($seasons, function (seasonsId, chapterId, count) {
        if (debug$1 && config.launch.columnCheck) {
          count = simulateCount;
        }
        columnData[seasonsId][chapterId] = count;
      });

      addCache(columnData);

      //检测分栏是否丢失，补充
      if (config.launch.columnCheck) {
        startColumnDetect($seasons, $.extend(true, {}, columnData), function () {
          $container.hide();
        });
      } else {
        $container.hide();
      }

      callback(Object.keys(columnData).length);
    }, 100);

    $('body').append($container);
  };

  //如果存在json的flow数据
  var results = getResults();
  if (results && results.FlowData) {
    //容器尺寸设置
    var visuals = resetVisualLayout(1);
    var visualHeight = newViewHight = visuals.height;

    //加载flow样式
    loadGlobalStyle('xxtflow', function () {
      $container = $(results.FlowData);
      removeColumnData(); //删除flowdata，优化缓存
      setInit(visuals.width, visualHeight);
    });
  } else {
    //没有任何flow
    callback();
  }
}

/**
 * content对象的创建过滤器
 * 用于阻断对象的创建
 */
function contentFilter(filterName) {

  function setCache(listFilters) {
    $setStorage(filterName || 'aaron', JSON.stringify(listFilters));
  }

  function getCache() {
    var jsonStr = $getStorage(filterName);
    if (jsonStr) {
      return parseJSON(jsonStr);
    }
    return '';
  }

  //过滤的节点
  var listFilters = function () {
    var values = getCache();
    var h = hash();
    if (values) {
      //keep the listFilters has no property
      _.each(values, function (v, i) {
        h[i] = v;
      });
    }
    return h;
  }();

  function access(callback, pageId, contentId) {
    //如果是transformFilter,不需要pageIndex处理
    if (filterName === 'transformFilter' && contentId === undefined) {
      contentId = pageId;
      pageId = 'transformFilter';
    }
    return callback(pageId, Number(contentId));
  }

  return {
    add: function add(pageId, contentId) {
      access(function (pageId, contentId) {
        if (!listFilters[pageId]) {
          listFilters[pageId] = [];
        }
        //去重
        if (-1 === listFilters[pageId].indexOf(contentId)) {
          listFilters[pageId].push(contentId);
          setCache(listFilters);
        }
      }, pageId, contentId);
    },
    remove: function remove(pageId, contentId) {
      access(function (pageId, contentId) {
        var target = listFilters[pageId] || [],
            index = target.indexOf(contentId);
        if (-1 !== index) {
          target.splice(index, 1);
          setCache(listFilters);
        }
      }, pageId, contentId);
    },
    has: function has(pageId, contentId) {
      return access(function (pageId, contentId) {
        var target = listFilters[pageId];
        return target ? -1 !== target.indexOf(contentId) ? true : false : false;
      }, pageId, contentId);
    },


    /**
     * 创建过滤器
     * @param  {[type]} pageId [description]
     * @return {[type]}        [description]
     */
    each: function each(pageId) {
      return access(function (pageId, contentId) {
        var target, indexOf;
        if (target = listFilters[pageId]) {
          return function (contentIds, callback) {
            _.each(target, function (ids) {
              var indexOf = contentIds.indexOf(ids);
              if (-1 !== indexOf) {
                callback(indexOf); //如果找到的过滤项目
              }
            });
          };
        }
      }, pageId);
    },


    //过滤器数量
    size: function size() {
      return _.keys(listFilters).length;
    },
    empty: function empty() {
      $removeStorage(filterName);
      listFilters = {};
    }
  };
}

/**
 * 创建共享对象
 * 这里是为了限制对象的创建数
 * 优化
 *
 * @param  {[type]} total [description]
 * @return {[type]}       [description]
 */

var Share = function () {
  function Share(name) {
    classCallCheck(this, Share);

    this.state = 'init';
    this.cache = [];
  }

  createClass(Share, [{
    key: "add",
    value: function add(object) {
      this.cache.push(object);
    }
  }, {
    key: "get",
    value: function get$$1() {

      if (this.cache.length) {
        return this.cache.shift();
      }
    }
  }, {
    key: "destory",
    value: function destory() {
      for (var i = 0; i < this.cache.length; i++) {
        if (this.cache[i]) {
          this.cache[i].src = null;
          this.cache[i].removeAttribute("src");
          this.cache[i] = null;
        }
      }
    }
  }]);
  return Share;
}();

/**
 * 音频文件解析
 * @param  {[type]}   filePath [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 *
 * */

var audioShare = null;

/**
 * 如果有共享的音频对象就返回
 * @return {[type]} [description]
 */
function getAudio() {
  if (!audioShare) {
    audioShare = new Share();
  }
  if (audioShare) {
    var audio = audioShare.get();
    if (audio) {
      return audio;
    }
  }
  return new Audio();
}

/**
 * 预加载完毕后清除对象
 * @return {[type]} [description]
 */
function clearAudio() {
  if (audioShare) {
    audioShare.destory();
  }
  audioShare = null;
}

/**
 * 音频文件解析
 */
function audioParse(url, callback) {

  //在ios10以内，预加载音频无法静音
  if (Xut.plat.iosVersion < 10) {
    return;
  }

  var audio = getAudio();
  audio.src = url;
  audio.preload = "auto";
  audio.autoplay = true;
  audio.muted = true; //ios 10以上静音后可以自动播放
  audio.volume = 0; //静音 ios 9 不静音的问题

  var loopTimer = null; //循环检测时间

  /**
   * 清理检测对象
   * @return {[type]} [description]
   */
  function clear(isExit) {
    if (loopTimer) {
      clearTimeout(loopTimer);
      loopTimer = null;
    }
    if (audio) {
      audio.removeEventListener("loadedmetadata", success, false);
      audio.removeEventListener("error", exit, false);
      //置空src后会报错 找不到null资源 移除src属性即可
      audio.src = null;
      audio.removeAttribute("src");
      audioShare && audioShare.add(audio); //加入到循环队列
      audio = null;
    }
  }

  /**
   * 成功退出
   * @return {[type]} [description]
   */
  function exit(isExit) {
    clear(isExit);
    callback();
  }

  /**
   * 支持buffered的情况下
   * 可以通过buffered提前判断
   * 为了优化下载的时间
   * @return {[type]} [description]
   */
  function startBuffered() {

    /*如果第一次就已经加载结束
      加载完成之后就不需要再调play了 不然chrome会报打断错误
    */
    if (getComplete()) {
      exit('isExit');
      return;
    }

    audio.play();

    /*总时间*/
    var allTime = audio.duration;

    /*是否缓存完毕*/
    function getComplete(loop) {
      //移动端浏览器loadedmetadata事件执行时可能还没有开始缓存
      //判断是否缓存完毕时要加上audio.buffered.length条件
      if (audio.buffered.length && allTime == audio.buffered.end(audio.buffered.length - 1)) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * loopBuffered检测
     * 循环500毫秒一次
     * @return {[type]} [description]
     */
    function loopBuffered() {
      loopTimer = setTimeout(function () {
        if (getComplete()) {
          exit('isExit');
          return;
        } else {
          loopBuffered();
        }
      }, 500);
    }
    loopBuffered();
  }

  /**
   * 在loadedmetadata事件完成后
   * 1 如果支持buffered判断，那么走buffered
   * 2 如果不支持buffered那么靠外部的定时器处理
   */
  function success() {
    if (!audio.buffered) {
      exit(); //如果不支持buffered，直接退出
      return;
    }
    /////////////////////////////
    /// ios 10与PC端
    /// 1、速度很快的情况马上就缓存完毕
    /// 2、如果文件已经被缓存过了
    /////////////////////////////
    startBuffered();
  }

  audio.addEventListener("loadedmetadata", success, false);
  audio.addEventListener("error", exit, false);

  return {
    destory: clear
  };
}

var imageShare = null;

function getImage() {
  if (!imageShare) {
    imageShare = new Share();
  }
  if (imageShare) {
    var image = imageShare.get();
    if (image) {
      return image;
    }
  }
  return new Image();
}

function clearImage() {
  if (imageShare) {
    imageShare.destory();
  }
  imageShare = null;
}

/**
 * 图片解析
 */
function imageParse(url, callback) {

  url = converImageURL(url);

  /**
   * 这里最主要是替换了图片对象，优化了创建
   */
  var imageObject = loadFigure({
    image: getImage(),
    url: url
  }, function (data) {
    imageShare && imageShare.add(imageObject); //加入到循环队列
    callback(url, data);
  });

  return {
    destory: function destory() {
      if (imageObject) {
        imageObject.src = null;
        imageObject.removeAttribute("src");
        imageObject = null;
      }
    }
  };
}

/**
 * 视频文件解析
 * @param  {[type]}   filePath [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 */

/**
 * 视频SVG解析
 */
function svgParse(filePath, callback) {
  $.ajax({
    url: filePath,
    complete: callback
  });
}

////////////////////////////
/// 文件路径生成器
/// 不同类型对应不同的路径配置
////////////////////////////

/**
 * 格式字符串
 */
var formatString = function formatString(data, basePath) {
  data = data.split(',');
  var dataset = void 0;
  var sizes = [];
  var fileNames = [];
  data.forEach(function (name) {
    dataset = name.split('-');
    /*如果没有尺寸*/
    if (dataset.length === 1) {
      fileNames.push(basePath + name);
    } else {
      sizes.push(Number(dataset[0]));
      fileNames.push(basePath + dataset[1]);
    }
  });
  return {
    sizes: sizes,
    fileNames: fileNames,
    length: data.length
  };
};

/**
 * 格式对象
 */
var formatObject = function formatObject(data, basePath) {
  var dataset = void 0;
  var fileNames = [];
  var sizes = []; //尺寸

  var _loop = function _loop(dir) {
    var d = data[dir].split(',');
    d.forEach(function (name) {
      dataset = name.split('-');
      if (dataset.length === 1) {
        fileNames.push(basePath + dir + '/' + name);
      } else {
        sizes.push(Number(dataset[0]));
        fileNames.push(basePath + dir + '/' + dataset[1]);
      }
    });
  };

  for (var dir in data) {
    _loop(dir);
  }
  return {
    sizes: sizes,
    fileNames: fileNames,
    length: fileNames.length
  };
};

var pathHooks = {

  /**
   * 文本图片
   */
  content: function content(data) {
    return formatString(data, config.data.pathAddress);
  },


  /**
   * 媒体
   * @type {[type]}
   */
  audio: function audio(data) {
    return formatString(data, config.data.pathAddress);
  },
  video: function video(data) {
    return formatString(data, config.data.pathAddress);
  },


  /**
   * svg
   */
  svg: function svg(data) {
    return formatString(data, config.data.pathAddress);
  },


  /**
   * 零件图片
   */
  widget: function widget(data) {
    return formatString(data, config.data.rootPath + '/widget/gallery/');
  },


  /**
   * content下的自动精灵动画
   * autoSprite: {
   *   2: '1.jpg,2.jpg',
   *   3: '1.jpg,2.jpg'
   * }
   */
  autoSprite: function autoSprite(data) {
    return formatObject(data, config.data.pathAddress);
  },


  /*
    高级精灵动画
    seniorSprite: {
      2: '1.jpg,2.jpg',
      3: '1.jpg,2.jpg'
    }
  */
  seniorSprite: function seniorSprite(data) {
    return formatObject(data, config.data.rootPath + '/widget/gallery/');
  }
};

/**
 *
 * 基本事件管理
 * 1 异步
 * 2 同步
 *
 */

var ArrayProto = Array.prototype;
var nativeIndexOf = ArrayProto.indexOf;
var slice = ArrayProto.slice;
var _indexOf = function _indexOf(array, needle) {
  var i, l;
  if (nativeIndexOf && array.indexOf === nativeIndexOf) {
    return array.indexOf(needle);
  }
  for (i = 0, l = array.length; i < l; i++) {
    if (array[i] === needle) {
      return i;
    }
  }
  return -1;
};

var Observer = function () {
  function Observer() {
    classCallCheck(this, Observer);

    this.$$watch = this.bind;
    this.$$unWatch = this.unbind;
    this.$$emit = this.trigger;
    this.$$once = this.one;

    //触发列表名称
    //防止同步触发
    this._handleName = {};
  }

  createClass(Observer, [{
    key: "bind",
    value: function bind(event, fn) {
      var i, part;
      var events = this.events = this.events || {};
      var parts = event.split(/\s+/);
      var num = parts.length;

      for (i = 0; i < num; i++) {
        events[part = parts[i]] = events[part] || [];
        if (_indexOf(events[part], fn) === -1) {
          events[part].push(fn);
        }
      }

      //假如存在同步句柄
      //执行
      var data;
      if (data = this._handleName[event]) {
        this.$$emit(event, data[0]);
      }

      return this;
    }
  }, {
    key: "one",
    value: function one(event, fn) {
      // [notice] The value of fn and fn1 is not equivalent in the case of the following MSIE.
      // var fn = function fn1 () { alert(fn === fn1) } ie.<9 false
      var fnc = function fnc() {
        this.unbind(event, fnc);
        fn.apply(this, slice.call(arguments));
      };
      this.bind(event, fnc);
      return this;
    }

    //event = 'a b c' 空格分离多个事件名
    //提供fn 指定在某个事件中删除某一个
    //否则只提供事件名 ，全删除

  }, {
    key: "unbind",
    value: function unbind(event, fn) {

      var eventName, i, index, num, parts;
      var events = this.events;

      if (!events) return this;

      //指定
      if (arguments.length) {
        parts = event.split(/\s+/);
        for (i = 0, num = parts.length; i < num; i++) {
          if ((eventName = parts[i]) in events !== false) {
            //如果提供函数引用
            //那么就是在数组中删除其中一个
            if (fn) {
              index = _indexOf(events[eventName], fn);
              if (index !== -1) {
                events[eventName].splice(index, 1);
              }
            } else {
              //如果只提供了名字，则全删除
              events[eventName] = null;
            }

            //如果没有内容了
            if (!events[eventName] || !events[eventName].length) {
              delete events[eventName];
            }
          }
        }
      } else {
        this.events = null;
      }

      return this;
    }
  }, {
    key: "trigger",
    value: function trigger(event) {
      var args, i;
      var events = this.events,
          handlers;

      //参数
      args = slice.call(arguments, 1);

      if (!events || event in events === false) {
        // console.log(event)
        //同步的情况
        //如果除非了事件，可能事件句柄还没有加载
        this._handleName[event] = args;
        return this;
      }

      handlers = events[event];
      for (i = 0; i < handlers.length; i++) {
        handlers[i].apply(this, args);
      }
      return this;
    }
  }]);
  return Observer;
}();

/**
 *  异步存取器
 *  用于异步任务创建
 *  转化同步处理的一个类
 */
var AsyAccess = function (_Observer) {
  inherits(AsyAccess, _Observer);

  function AsyAccess() {
    classCallCheck(this, AsyAccess);

    var _this = possibleConstructorReturn(this, (AsyAccess.__proto__ || Object.getPrototypeOf(AsyAccess)).call(this));

    _this.asys = [];
    return _this;
  }

  /**
   * 只接受函数类型
   * @param  {Function} fn [description]
   * @return {[type]}      [description]
   */


  createClass(AsyAccess, [{
    key: 'create',
    value: function create(fn) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';

      if (fn && typeof fn === 'function') {
        this.asys[position](fn);
      }
    }
  }, {
    key: 'destory',
    value: function destory() {
      this.asys = [];
    }

    /**
     * 执行
     * @return {[type]} [description]
     */

  }, {
    key: 'exec',
    value: function exec() {
      var _this2 = this;

      if (this.asys && this.asys.length) {
        var next = function next() {
          if (_this2.asys.length) {
            var asy = _this2.asys.shift();
            asy(next);
          } else {
            _this2.$$emit('complete');
          }
        };
        next();
      }
      return this;
    }
  }]);
  return AsyAccess;
}(Observer);

////////////////////////////////
/// 资源加载错误后，开始循环检测2次
/// 分别是6秒 - 12秒的时间
///////////////////////////////

/**
 * 循环的列表对象
 * @type {Array}
 */
var loopQueue = {};

/**
 * 增加循环列表
 * @param {[type]} argument [description]
 */
function addLoop(filePath, detect) {
  if (loopQueue[filePath]) {
    Xut.$warn({
      type: 'preload',
      content: '\u91CD\u590D\u589E\u52A0,\u6587\u4EF6\u5DF2\u7ECF\u5B58\u5728\u5FAA\u73AF\u5217\u8868 ' + filePath,
      level: 'error'
    });
  } else {
    /**
     * 重设循环检测
     * 不重新创建新的对象
     * 通过实例重设检测
     * 1 减少http检测
     * 2 不重复创建对象
     */
    loopQueue[filePath] = detect;
    detect.reset(12000, function () {
      loopQueue[filePath].destory();
      loopQueue[filePath] = null;
      delete loopQueue[filePath];
    });
  }
}

/**
 * 清理循环检测
 * @return {[type]} [description]
 */
function clearLoop() {
  if (loopQueue) {
    for (var key in loopQueue) {
      loopQueue[key].destory();
      loopQueue[key] = null;
    }
  }
  loopQueue = {};
}

/////////////////////////////////////////////////////////////////////
///  探测资源的正确性
///
///  1. 通过每个parser自己去请求缓存成功
///  2. 如果parser的第一次请求时间大于2秒，那么主动就默认返回失败
///  3. 失败文件就会走loop队列
///
/////////////////////////////////////////////////////////////////////

var Detect = function () {

  /**
   * [constructor description]
   * @param  {[type]} parser   [解析器]
   * @param  {[type]} filePath [路径]
   * @return {[type]}          [description]
   */
  function Detect(parser, filePath) {
    classCallCheck(this, Detect);

    this.state = false;
    this.timer = null;
    this.parser = parser;
    this.filePath = filePath;
  }

  /**
   * 销毁检测对象
   * 如果parser解析完毕后，主动调用销毁接口
   * 1 audio
   */


  createClass(Detect, [{
    key: "_clearDownload",
    value: function _clearDownload() {
      if (this._downObj) {
        this._downObj.destory && this._downObj.destory();
        this._downObj = null;
      }
    }

    /**
     * 开始通过API下载文件
     * @return {[type]} [description]
     */

  }, {
    key: "_downloadFile",
    value: function _downloadFile() {
      var _this = this;

      this._downObj = this.parser(this.filePath, function () {
        _this.state = true;
        _this.callback && _this.callback();
      });
    }

    /**
     * 清理定时器
     * @return {[type]} [description]
     */

  }, {
    key: "_clearWatcher",
    value: function _clearWatcher() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }

    /**
     * 创建主动监听
     * @return {[type]} [description]
     */

  }, {
    key: "_createWather",
    value: function _createWather(time) {
      var _this2 = this;

      if (!this.state) {
        this.timer = setTimeout(function () {
          _this2.callback && _this2.callback();
        }, time);
      }
    }

    /**
     * 创建退出函数
     * @return {[type]} [description]
     */

  }, {
    key: "_createExitFn",
    value: function _createExitFn(fn) {
      var _this3 = this;

      this.callback = function () {
        _this3._clearWatcher(); //清理主动观察
        _this3.callback = null;
        fn(_this3.state);
      };
    }

    /////////////////////////////////////
    ///
    ///          对外接口
    ///
    /////////////////////////////////////

    /**
     * 开始下载
     * @param  {[type]}   checkTime [主动检测时间]
     * @param  {Function} fn        [不管成功或者失败都会调用]
     * @return {[type]}             [description]
     */

  }, {
    key: "start",
    value: function start(checkTime, fn) {

      this._createExitFn(fn);

      /*开始下载*/
      this._downloadFile();

      /**
       * 主动监听
       * 如果在主动观察指定的时间内自动下载没有完毕
       * 那么主动就会被调用，这个detect对象就会走循环队列
       * 执行reset长轮询
       */
      this._createWather(checkTime);
    }

    /**
     * 重设检测
     * 1 在第一次检测失败后
     * 2 循环队列中开始重复检测
     * @return {[type]} [description]
     */

  }, {
    key: "reset",
    value: function reset(checkTime, fn) {

      this._createExitFn(fn);

      // 开始新的主动检测最长12秒
      this._createWather(checkTime);
    }

    /**
     * 销毁
     * @return {[type]} [description]
     */

  }, {
    key: "destory",
    value: function destory() {
      this._clearDownload();
      this._clearWatcher();
      this.callback = null;
      this.parse = null;
    }
  }]);
  return Detect;
}();

/***************
资源预加载
一共有5处位置需要验证是否预加载完毕
1 swpier 移动翻页反弹
2 Xut.View.LoadScenario 全局跳转
3 Xut.View.GotoPrevSlide
4 Xut.View.GotoNextSlide
5 Xut.View.GotoSlide
****************/
/**
 * 是否启动预加载
 * true 启动
 * false 关闭
 * 翻页的时候停止
 * 动画结束后开始
 * @type {Boolean}
 */
var enable = true;

/**
 * 页面chpater Id 总数
 * @type {Number}
 */
var chapterIdCount = 0;

/**
 * 正在加载的id标记
 * @type {Number}
 */
var loadingId = 0;

/**
 * 预加载回调通知
 * @type {Array}
 */
var notification = null;

var asyObject = null;

/**
 * 用于检测图片是否有缓存的情况
 * 检测chapter 1的数据情况
 * 只检测第一个成功的content图片的缓存状态
 * 如果本身图片获取失败，就递归图片检测
 * @return {Boolean} [description]
 */
function checkFigure(url, callback) {
  return imageParse(url, function (newUrl, data) {
    if (data.state === 'success') {
      //保持最后一张加载图片的有效值
      //用于处理加载检测
      //这里必须用data.url因为原始的url被修改了
      checkFigure.url = newUrl;
    }
    callback();
  });
}

var PARSER = {
  // master 母版标记特殊处理，递归PARSE
  // video: videoParse
  content: checkFigure,
  widget: checkFigure,
  autoSprite: checkFigure,
  seniorSprite: checkFigure,
  audio: audioParse,
  svg: svgParse
};

function getDataset(id) {
  if (!window.preloadData) {
    return '';
  }
  return window.preloadData[id];
}

/**
 * 完成后删除资源的列表
 * 2个好处
 * 1 优化内存空间
 * 2 跳页面检测，如果遇到不存在的资源就不处理了
 *   这代表，1.已经加载了
 *          2.资源或错
 * @return {[type]} [description]
 */
function deleteResource(chaperId) {
  if (window.preloadData) {
    window.preloadData[chaperId] = null;
  }
}

/**
 * 获取初始化数
 * @return {[type]} [description]
 */
function getNumber() {
  //退出清理的情况下
  if (!config.launch) {
    return false;
  }
  return typeof config.launch.preload === 'number' ? config.launch.preload : 5;
}

/**
 * 母版类型处理
 * 需要重新递归解析,类型需要递归创建
 * @return {[type]} [description]
 */
function masterHandle(childData) {
  var masterId = childData;
  var masterData = getDataset(masterId);
  if (masterData) {
    return function (callback) {
      loadResource(masterId, masterData, function () {
        /*删除母版数据，多个Page会共享同一个母版加载*/
        deleteResource(masterId);
        callback();
      });
    };
  }
}

/**
 * 页面层的处理
 * content/widget/audio/video/autoSprite/seniorSprite/svg
 * @return {[type]} [description]
 */
function pageHandle(type, childData, parser) {
  childData = pathHooks[type](childData);
  var total = childData.length;

  return function (callback) {
    var section = getNumber();

    /**
     * 分段处理
     * section 是分段数量
     */
    function segmentHandle() {

      var detectObjs = {}; /*预加载对象列表*/
      var analyticData = void 0;
      var hasComplete = false;

      /*如果可以取整*/
      if (childData.fileNames.length > section) {
        analyticData = childData.fileNames.splice(0, section);
      } else {
        /*如果小于等于检测数*/
        analyticData = childData.fileNames;
        hasComplete = true;
      }

      /**
       * 分段检测的回到次数
       * @type {[type]}
       */
      var analyticCount = analyticData.length;

      /**
       * 检测完成度
       * @return {[type]} [description]
       */
      function complete() {
        if (analyticCount === 1) {
          if (hasComplete) {
            /*分段处理完毕就清理，用于判断跳出*/
            callback();
            return;
          } else {
            segmentHandle();
          }
        }
        --analyticCount;
      }

      function reduce(path) {
        detectObjs[path] = new Detect(parser, path);
        detectObjs[path].start(2000, function (state) {
          if (state) {
            /*如果请求成功了，就必须销毁*/
            detectObjs[path].destory();
          } else {
            /*失败加入到循环队列*/
            addLoop(path, detectObjs[path]);
          }
          detectObjs[path] = null;
          window.preloadData && complete();
        });
      }

      /**
       * 分配任务
       * 1 分配到每个解析器去处理
       * 2 给一个定时器的范围
       * 主动检测2秒
       * 成功与失败都认为通过
       * 失败单独加到循环队列中去处理
       */
      for (var i = 0; i < analyticData.length; i++) {
        reduce(analyticData[i]);
      }
    }

    section && segmentHandle();
  };
}

/**
 * 创建对应的处理器
 */
function createHandle(type, childData, parser) {
  if (type === 'master') {
    return masterHandle(childData);
  } else {
    return pageHandle(type, childData, parser);
  }
}

/**
 * 开始加载资源
 */
function loadResource(id, data, callback) {
  asyObject = new AsyAccess();
  for (var key in data) {
    var parser = PARSER[key];
    if (parser) {
      /*audio优先解析*/
      asyObject.create(createHandle(key, data[key], parser), key === 'audio' ? 'unshift' : 'push');
    }
  }

  /*执行后监听,监听完成*/
  asyObject.exec().$$watch('complete', function () {
    asyObject = null;
    callback();
  });
}

/**
 * 检测下一个解析任务
 * 以及任务的完成度
 */
function repeatCheck(id, callback) {

  //判断是否所有页面加载完毕
  function completeLoad() {
    /*如果加载数等于总计量数，这个证明加载完毕*/
    if (id === chapterIdCount) {
      $warn({
        type: 'preload',
        content: '\u5168\u90E8\u9884\u52A0\u8F7D\u5B8C\u6210,\u672C\u6B21\u5904\u7406\u4E86' + chapterIdCount + '\u9875',
        color: 'red'
      });
      $setStorage('preload', checkFigure.url);
      clearAudio();
      clearImage();
      window.preloadData = null; //全加载完毕了，就可以清理了
      return true;
    }
    return false;
  }

  /*第一次加载才有回调*/
  if (callback) {
    callback();
    if (completeLoad()) {
      return;
    }
    return;
  }

  /*执行预加载等待的回调通知对象*/
  if (notification) {
    var newChapterId = notification[0];
    if (id === newChapterId) {
      /*如果下一个解析正好是等待的页面*/
      notification[1]();
      notification = null;
    } else {
      /*跳转页面的情况,跳到任何一页，newChapterId不等于id*/
      nextTask(newChapterId);
      return;
    }
  }

  /*如果加载数等于总计量数，这个证明加载完毕*/
  if (completeLoad()) {
    return;
  }

  /*启动了才继续可以预加载*/
  if (enable) {
    nextTask();
  }
}

/**
 * 检测下一个页面加载执行
 * 如果传入了检测chpaterId
 * 否则就用默认的正索引
 */
function nextTask(chapterId, callback) {
  if (!chapterId) {
    /*新加载的Id游标*/
    ++loadingId;
    chapterId = loadingId;
  }

  /*只有没有预加载的数据才能被找到*/
  var pageData = getDataset(chapterId);

  function complete(data) {
    //如果加载了数据，但是数据还未加载完毕
    if (window.preloadData) {
      $warn({
        type: 'preload',
        content: data
      });
      deleteResource(chapterId);
      repeatCheck(chapterId, callback);
    }
  }

  /*必须保证pageData不是一个空对象*/
  if (pageData && Object.keys(pageData).length) {
    // $warn('----预加资源开始chapterId: ' + chapterId)
    loadResource(chapterId, pageData, function () {
      return complete('\u7B2C' + chapterId + '\u9875\uFF0C\u9884\u52A0\u8D44\u6E90\u5B8C\u6210');
    });
  } else {
    complete('\u7B2C' + chapterId + '\u9875\uFF0C\u9884\u52A0\u8F7D\u6570\u636E\u662F\u7A7A');
  }
}

/**
 * 判断是否有预加载文件
 * @return {Boolean} [description]
 */
function loadPrelaod(callback) {
  loadFile(config.data.pathAddress + 'preload.js', function () {
    if (window.preloadData) {
      callback(true, window.globalBrMode);
    } else {
      callback(false);
    }
  });
}

/**
 * 监听预加载初始化调用
 * 1 原则上是监听一次autoRunComplete事件
 * 2 可能autoRunComplete会丢失，所以需要定时器处理
 * @return {[type]} [description]
 */
function watchPreloadInit() {

  //如果预加载的只有1页数据 判断第一页加载完成后return
  if (!getDataset(chapterIdCount)) {
    return;
  }

  var timer = null;
  var count = 2;

  /*从第二次开始加载数据*/
  function startDownload(type) {
    if (count === 2) {
      clearTimeout(timer);
      timer = null;
      enable = true;
      nextTask();
    }
    --count;
  }

  /*监听初始化第一次完成*/
  Xut.Application.onceWatch('autoRunComplete', startDownload);

  /*防止autoRunComplete事件丢失处理,或者autoRunComplete执行很长*/
  timer = setTimeout(startDownload, 5000);
}

/**
 * 资源加载接口
 * 必须先预加载第一页
 */
function initPreload(total, callback) {

  function exitFn() {
    config.launch.preload = null;
    callback(false);
  }

  /**
   * 初始化，只预加载第一次的内容
   */
  function firstDownload() {
    $warn({
      type: 'preload',
      content: '\u5F00\u59CB\u6267\u884C\u8D44\u6E90\u9884\u52A0\u8F7D'
    });
    /*监听预加载初始化*/
    nextTask('', function () {
      watchPreloadInit();
      callback(true);
    });
  }

  /**
   * 检测缓存是否存在
   * 如果没有预加载完毕就继续加载
   * 否则缓存存在就退出
   */
  function checkCache(next, finish) {
    var cahceUrl = $getStorage('preload');
    if (cahceUrl) {
      //这里主要加强判断，用户可能会清理数据的情况
      loadFigure(cahceUrl, function (data) {
        if (data.state === 'success') {
          $warn({
            type: 'preload',
            content: '预加载已完成了',
            color: 'red'
          });
          finish();
        } else {
          next();
        }
      });
    } else {
      next();
    }
  }

  if (window.preloadData) {
    chapterIdCount = total;
    checkCache(firstDownload, exitFn);
  } else {
    exitFn();
  }
}

/**
 * 翻页停止预加载
 */


/**
 * 预加载请求中断处理
 * 监听线性翻页预加载加载
 * 类型，方向，处理器
 * context 处理器的上下文
 */
function requestInterrupt(_ref, context) {
  var type = _ref.type,
      chapterId = _ref.chapterId,
      direction = _ref.direction,
      processed = _ref.processed;


  /*如果是线性模式，左右翻页的情况处理*/
  if (type === 'linear') {
    var currentId = Xut.Presentation.GetPageId();
    chapterId = direction === 'next' ? currentId + 1 : currentId - 1;
  } else if (type === 'nolinear') {}
  /*非线性模式,跳转模式*/


  /*如果不存在预加载数据，就说明加载完毕，或者没有这个数据*/
  if (!getDataset(chapterId)) {
    return false;
  } else {
    /*正在预加载，等待记录回调*/
    if (!processed) {
      $warn({
        type: 'preload',
        content: '\u9519\u8BEF,\u9884\u52A0\u8F7D\u5FC5\u987B\u4F20\u9012\u5904\u7406\u5668',
        level: 'error'
      });
    }
    //等待预加载完毕后调用
    notification = [chapterId, function () {
      processed.call(context);
    }];
    return true;
  }
}

/**
 * 资源销毁接口
 * @return {[type]} [description]
 */
function clearPreload() {

  if (asyObject) {
    asyObject.destory();
    asyObject = null;
  }

  checkFigure.url = null;
  enable = true;
  chapterIdCount = 0;
  loadingId = 0;
  window.preloadData = null;
  notification = null;
  clearLoop();
}

/**
 * 自适应图片
 * @return {[type]} [description]
 */
function adaptiveImage() {
  var $adaptiveImageNode = $('.xut-adaptive-image');
  if ($adaptiveImageNode.length) {
    var baseImageType = $adaptiveImageNode.width();
    var type = config.launch.imageSuffix[baseImageType];
    if (type) {
      config.launch.baseImageSuffix = type;
      return;
    }
  }
  setDefaultSuffix();
}

/**
 * 最大屏屏幕尺寸
 * @return {[type]} [description]
 */
function getMaxWidth() {
  if (config.visualSize) {
    return config.visualSize.width;
  }
  return window.screen.width > document.documentElement.clientWidth ? window.screen.width : document.documentElement.clientWidth;
}

/**
 * 检车分辨率失败的情况
 * 强制用js转化
 * 750:  '', //0-1079
 * 1080: 'mi', //1080-1439
 * 1440: 'hi' //1440->
 */
function setDefaultSuffix() {
  var doc = document.documentElement;
  //竖版的情况才调整
  if (doc.clientHeight > doc.clientWidth) {
    var ratio = window.devicePixelRatio || 1;
    var maxWidth = getMaxWidth() * ratio;
    if (maxWidth >= 1080 && maxWidth < 1439) {
      config.launch.baseImageSuffix = config.launch.imageSuffix['1080'];
    }
    if (maxWidth >= 1440) {
      config.launch.baseImageSuffix = config.launch.imageSuffix['1440'];
    }
    Xut.$warn({
      type: 'config',
      content: 'css media匹配suffix失败，采用js采用计算 config.launch.baseImageSuffix = ' + config.launch.baseImageSuffix
    });
  }
}

//////////////////////////////////
/// 如果启动了代码追踪，配置基本信息
//////////////////////////////////
function setTrack(launch, global) {

  var trackTypes = launch && launch.trackCode || global.trackCode;
  config.sendTrackCode = function () {};
  config.hasTrackCode = function () {};
  /*
  'launch'
  'init'
  'exit'
  'flip'
  'content'
  'hot'
  'swipe'
  'enter' 进入每次页面触发
  */
  if (trackTypes && _.isArray(trackTypes) && trackTypes.length) {
    if (!launch.trackCode) {
      launch.trackCode = {};
    }
    trackTypes.forEach(function (type) {
      launch.trackCode[type] = true;
    });
    var uuid = Xut.guid();

    /*检测是否有代码追踪*/
    config.hasTrackCode = function (type) {
      if (launch && launch.trackCode && launch.trackCode[type]) {
        return true;
      }
    };

    /*合并命令，动作类型归类为action*/
    var modifyName = ['content', 'hot'];
    var getTrackName = function getTrackName(type) {
      if (~modifyName.indexOf(type)) {
        return 'action';
      }
      return type;
    };

    /*发送代码追踪数据*/
    config.sendTrackCode = function (type) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (config.hasTrackCode(type)) {
        if (options.time) {
          //转化秒
          options.time = Math.round(options.time % (1000 * 60) / 1000);
        }
        Xut.Application.Notify('trackCode', getTrackName(type), _.extend(options || {}, {
          uuid: uuid,
          appId: config.data.originalAppId,
          appName: config.data.shortName
        }));
      }
    };
  }
}

//////////////////////////////////
/// 忙碌光标
//////////////////////////////////
function setCursor(launch, global) {

  if (launch) {
    /*因为光标可以配置false 关闭，所以这里需要注意判断*/
    var cursor = launch.cursor || launch.cursor === false ? launch.cursor : global.cursor;

    /*每次配置光标之前都重置，可能被上个给覆盖默认的*/
    resetCursor();

    //设置关闭
    if (cursor == false) {
      setDisable();
      return;
    }

    //自定义忙绿光标
    if (cursor.time) {
      setDelay(cursor.time);
    }
    if (cursor.url) {
      setPath(cursor.url);
    }
  }
}

/**
 * 新增模式,用于记录浏览器退出记录
 * 默认启动
 * 是否回到退出的页面
 * set表中写一个recordHistory
 * 是   1
 * 否   0
 */
function setHistory(data) {
  //Launch接口定义
  if (config.launch.historyMode !== undefined) {
    return;
  }

  //数据库定义 && == 1
  if (data.recordHistory !== undefined && Number(data.recordHistory)) {
    config.launch.historyMode = true;
    return;
  }
}

/**
 * 通过数据库的定义
 * 设置用户是否允许翻页
 * 设置手势gestureSwipe
 * @return {[type]} [description]
 */
function setGestureSwipe(novelData) {

  /**
   * 切换切换模式
   * 多模式判断
   * 如果
   *   缓存存在
   *   否则数据库解析
         全局翻页模式
         0 滑动翻页 =》true
         1 直接换  =》 false
   * 所以pageFlip只有在左面的情况下
   * @type {Boolean}
   */
  if (novelData.parameter) {
    var parameter = parseJSON(novelData.parameter);
    /*全局优先设置覆盖*/
    if (config.launch.gestureSwipe === undefined && parameter.pageflip !== undefined) {
      switch (Number(parameter.pageflip)) {
        case 0:
          //滑动翻页
          config.launch.gestureSwipe = true;
          break;
        case 1:
          //直接换
          config.launch.pageFlip = true;
          config.launch.gestureSwipe = false;
          break;
      }
    }
  }

  /*默认不锁定页面，支持手势滑动*/
  if (config.launch.gestureSwipe === undefined) {
    config.launch.gestureSwipe = true;
  }
}

//////////////////////////////////
/// 图片模式webp
/// 需要兼容老版本的png模式，base-config会重设
//////////////////////////////////
function setBrType(launch, global) {
  if (launch) {
    if (!launch.brMode && global.brMode) {
      launch.brMode = global.brMode;
    }

    /*预先判断出基础类型*/
    if (launch.brMode) {
      launch.brModeType = getBrType(launch.brMode);
    }
  }
}

/**
 * 重写配置文件
 * 由于一些数据库，或者不支持的
 * 在框架内部强制修改用户的设定
 *
 * 如果没有预加载文件
 * 如果启动了图片模式，那么就需要去掉
 */
function resetBrMode(hasPreFile, globalBrMode) {
  //如果在没有hasPreFile，并且没有hasFlowData，那么就是兼容读库的旧版的处理
  //如果没有hasPreFile，但是有hasFlowData，那么就是迷你杂志，不能去掉
  if (!hasPreFile && !config.launch.hasFlowData) {
    config.launch.brMode = '';
    config.launch.brModel = '被resetBrMode清空了';
    config.launch.brModeType = '';
    return;
  }

  //全局指定模式
  //globalBrMode:单模式 1 =>png
  //globalBrMode:混合模式 2 =>_i _a
  if (globalBrMode === 1) {
    /*如果用单模式，但是判断出来是混合模式，那么直接清空*/
    if (config.launch.brModeType) {
      config.launch.brMode = '';
      config.launch.brModeType = '';
    }
  } else if (globalBrMode === 2) {
    /*如果是混合模式，判断出来是单模式，需要重新处理*/
    if (!config.launch.brModeType) {
      config.launch.brModeType = getBrType(1);
    }
  }
}

/**
 * 获取后缀
 * @return {[type]} [description]
 * ios 支持apng '_i'
 * 安卓支持webp  '_a'
 */
function getSuffix() {
  return Xut.plat.supportWebp ? '_a' : '_i';
}

/*预先判断br的基础类型*/
// 1 在线模式 返回增加后缀
// 2 手机模式 不修改，保留后缀
// 3 PC模式，不修改，保留后缀
function getBrType(mode) {

  //自适应平台
  if (mode === 1) {
    if (Xut.plat.isIOS) {
      return getBrType(2);
    }
    if (Xut.plat.isAndroid) {
      return getBrType(3);
    }
  }

  //ios
  if (mode === 2) {
    if (Xut.plat.isBrowser) {
      //浏览器访问
      return getSuffix();
    } else {
      //app访问
      return '';
    }
  }

  //android
  if (mode === 3) {
    if (Xut.plat.isBrowser) {
      //浏览器访问
      return getSuffix();
    } else {
      //app访问
      return '';
    }
  }

  /**
   * 纯PC端
   * 自动选择支持的
   * 但是不用APNG了
   */
  if (Xut.plat.isBrowser) {
    //浏览器访问，要探测下是否支持Webp
    if (Xut.plat.supportWebp) {
      return getSuffix();
    }
    //否则用默认的格式
    return '';
  }

  /*默认选择png，理论不会走这里了*/
  return '';
}

/**
 * 重设视图显示模式
 * @return {[type]} [description]
 */
function setVisualMode() {

  //竖版的情况下，页面模式都强制为1
  if (config.launch.scrollMode === 'v') {
    config.launch.visualMode = 1;
    return;
  }

  //如果数据库定义了模式
  //那么优先数据库
  //因为数据库默认写1了。所以1排除
  //只是有一种情况，就是你全局设了模式3，然后编辑想某些页面或者应用，用模式1，就会出现问题了
  if (config.data.visualMode !== undefined && config.data.visualMode != 1) {
    config.launch.visualMode = config.data.visualMode;
  }

  //默认为1
  if (config.launch.visualMode === undefined) {
    config.launch.visualMode = 1;
  }

  //模式5 只在竖版下使用
  if (config.launch.visualMode === 5) {
    var screen = getSize();
    if (screen.height < screen.width) {
      config.launch.visualMode = 1;
    }
  }
}

/**
 * 动画事件委托
 * @return {[type]} [description]
 */
function resetDelegate() {
  if (config.launch.swipeDelegate !== false) {
    config.launch.swipeDelegate = true;
  }
}

/**
 * 画轴模式
 * @param {[type]} data [description]
 */
function setPaintingMode(data) {
  if (!config.launch.visualMode && Number(data.scrollPaintingMode)) {
    config.launch.visualMode = 4;
  }
}

////////////////////////////////
///
/// 全局config与 launch配置优先级
/// lauch可以覆盖全局config配置
///
////////////////////////////////

/*
  获取真实的配置文件 priority
  优先级： launch > config
  1 cursor
  2 trackCode
  3 brMode
 */
function setLaunch(novelData) {

  /*独立app与全局配置文件*/
  var launch = config.launch;
  var global = config.global;
  var postMessage = config.postMessage;

  /*通过postMessage的配置重写全局配置文件*/
  for (var key in postMessage) {
    global[key] = postMessage[key];
  }

  //////////////////////////////////
  /// brModel命名被修改该了
  /// 这个为了兼容老版本采用了brModel的配置
  //////////////////////////////////
  if (launch.brModel && !launch.brMode) {
    launch.brMode = launch.brModel;
  }
  if (global.brModel && !global.brMode) {
    global.brMode = global.brModel;
  }

  //debug模式
  for (var _key in global.debug) {
    if (global.debug[_key] !== undefined) {
      config.debug[_key] = global.debug[_key];
    }
  }

  //忙碌光标
  setCursor(launch, global);

  //如果启动了代码追踪，配置基本信息
  setTrack(launch, global);

  //设置图片模式webp
  setBrType(launch, global);

  //global混入到launch中
  //优先级数据库>launch>postMessage>global
  for (var _key2 in global) {
    if (launch[_key2] === undefined) {
      launch[_key2] = global[_key2];
    }
  }

  //如果不是浏览器模式
  //强制关闭预加载模式
  if (!Xut.plat.isBrowser) {
    config.launch.preload = null;
  }

  //配置VisualMode
  setVisualMode();

  //配置手势
  setGestureSwipe(novelData);
}

function baseConfig(callback) {

  //导入数据库
  importJsonDatabase(function (results) {
    return setDatabse(results);
  });

  /**
   * 根据数据库的配置设置
   */
  function setDatabse(results) {
    initDatabse(results, function (dataRet) {
      $warn('logic', '初始化数据库完成');
      var novelData = dataRet.Novel.item(0);
      var setData = initDefaults(dataRet.Setting);
      var chapterTotal = dataRet.Chapter.length;
      setBaseConfig(novelData, setData, chapterTotal);
    });
  }

  /**
   * 设置一些基础配置
   */
  function setBaseConfig(novelData, setData, chapterTotal) {
    //配置lanuch
    setLaunch(novelData);
    //配置config
    setConfig(novelData, setData);
    //配置图片
    setImage();
    //创建根节点
    //开始预加载文件
    createRoot(function () {
      return initPrelaod(novelData, chapterTotal);
    });
  }

  /**
   * 处理预加载文件
   * @return {[type]} [description]
   */
  function initPrelaod(novelData, chapterTotal) {
    loadPrelaod(function (hasPreFile, globalBrMode) {
      resetBrMode(hasPreFile, globalBrMode);
      loadStyle(novelData, chapterTotal);
    });
  }

  /**
   * 加载样式
   * @return {[type]} [description]
   */
  function loadStyle(novelData, chapterTotal) {
    /*加载svg的样式*/
    loadGlobalStyle('svgsheet', function () {
      //判断是否有分栏处理
      setColumn(function () {
        //如果启动预加载配置
        //先探测下是否能支持
        if (config.launch.preload) {
          initPreload(chapterTotal, function () {
            return callback(novelData);
          });
        } else {
          callback(novelData);
        }
      });
    });
  }
}

/**
 * 创建根节点
 * @return {[type]} [description]
 */
function createRoot(complete) {
  //根节点
  var _initRootNode = initRootNode(config.launch.el, config.launch.cursor),
      $rootNode = _initRootNode.$rootNode,
      $contentNode = _initRootNode.$contentNode;

  $warn('logic', '初始化设置参数完成');
  nextTick({
    container: $rootNode,
    content: $contentNode
  }, complete);
}

/*
  配置初始化
 */
function setConfig(novelData, tempSettingData) {
  /*启动代码用户操作跟踪:启动*/
  config.sendTrackCode('launch');
  //创建过滤器
  Xut.CreateFilter = contentFilter('createFilter');
  Xut.TransformFilter = contentFilter('transformFilter');
  //初始化配置一些信息
  initConfig(novelData.pptWidth, novelData.pptHeight);
  //新增模式,用于记录浏览器退出记录
  //如果强制配置文件recordHistory = false则跳过数据库的给值
  setHistory(tempSettingData);
  //2015.2.26
  //启动画轴模式
  setPaintingMode(tempSettingData);
  //初始资源地址
  initPathAddress();
}

/**
 * 初始分栏排版
 * 嵌入index分栏
 * 默认有并且没有强制设置关闭的情况，打开缩放
 */
function setColumn(callback) {
  initColumn(function (haColumnCounts) {
    if (haColumnCounts) {
      resetDelegate();
    }
    callback();
  });
}

function setImage() {
  //mini杂志设置
  //如果是pad的情况下设置font为125%
  if (config.launch.platform === 'mini' && Xut.plat.isTablet) {
    $('body').css('font-size', '125%');
  }
  /*图片分辨了自适应*/
  if (config.launch.imageSuffix) {
    adaptiveImage();
  }
}

/**
 * 设置缓存，必须要可设置
 */
function saveData() {
  if (config.launch.historyMode) {
    var data = config.data;
    $setStorage({ "pageIndex": data.pageIndex, "novelId": data.novelId });
  } else {
    //清理
    if ($getStorage('novelId')) {
      $removeStorage('pageIndex');
      $removeStorage('novelId');
    }
  }
}

/**a
 * 初始化值
 * @param {[type]} options [description]
 */
function initDefaultValues(options) {
  return {
    'novelId': Number(options.novelId),
    'pageIndex': Number(options.pageIndex),
    'history': options.history
  };
}

/**
 * 检测脚本注入
 * @return {[type]} [description]
 */
function runScript() {
  var preCode = void 0,
      novels = Xut.data.query('Novel');
  if (preCode = novels.preCode) {
    execScript(preCode, 'novelpre脚本');
  }
}

/**
 * 加载主场景
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
var initMainScene = function (options) {

  options = initDefaultValues(options || {});

  config.data.novelId = options.novelId;
  config.data.pageIndex = options.pageIndex;

  //设置缓存
  saveData();

  //应用脚本注入
  runScript();

  //检测下seasonId的正确性
  //seasonId = 1 找不到chapter数据
  //通过sectionRelated递归检测下一条数据
  var seasonId = void 0,
      seasondata = void 0,
      i = void 0;
  for (i = 0; i < Xut.data.Season.length; i++) {
    seasondata = Xut.data.Season.item(i);
    if (Xut.data.query('sectionRelated', seasondata._id)) {
      seasonId = seasondata._id;
      break;
    }
  }

  $warn('logic', '加载主场景');

  //加载新的场景
  Xut.View.LoadScenario({
    'main': true, //主场景入口
    'seasonId': seasonId,
    'pageIndex': options.pageIndex,
    'history': options.history
  }, function () {

    $warn('logic', '主场景加载完毕');

    /*应用初始化加载完毕*/
    Xut.Application.Notify('initComplete');

    /*发送初始化完毕代码跟踪*/
    config.sendTrackCode('init', { time: +new Date() - config.launch.launchTime });
  });
};

/**
 * 这里有四种播放器:
 *    1：基于html5原生实现的video标签 for ios
 *    2：基于phoneGap插件实现的media  for android
 *    3: 基于videoJS用flash实现的播放 for pc
 *    4: 用于插入一个网页的webview
 */
/**
 * 创建视频容器
 */
function createVideoWrap(type, options) {
  var width = options.width,
      height = options.height,
      zIndex = options.zIndex,
      top = options.top,
      left = options.left;

  /*数据可能为100%，或者纯数字*/

  var setWidth = 'width:' + width + 'px';
  var setHeight = 'height:' + height + 'px';

  if (typeof width === 'string') {
    if (~width.indexOf('%')) {
      setWidth = 'width:' + width;
    }
  }

  if (typeof height === 'string') {
    if (~height.indexOf('%')) {
      setHeight = 'height:' + height;
    }
  }

  return $(String.styleFormat('<div data-type="' + type + '"\n          style="' + setWidth + ';\n                 ' + setHeight + ';\n                 position:absolute;\n                 visibility:hidden;\n                 z-index:' + zIndex + ';\n                 top:' + top + 'px;\n                 left:' + left + 'px;">\n     </div>'));
}

/*获取视频文件路径*/
function getFilePath(url) {
  return config.getVideoPath() + url;
}

/**
 * 获取容器
 * 1 浮动视频单独处理
 * 2 没有浮动视频
 * @return {[type]} [description]
 */
function getContainer(options) {

  /*视频已经浮动,找到浮动容器的根节点floatGroup*/
  if (options.isfloat) {
    return Xut.Presentation.GetFloatContainer(options.pageType);
  }

  var container = options.container;

  /*如果是isColumn的使用，直接用触发节点*/
  if (options.isColumn) {
    return $(container);
  }

  //jquery对象
  if (container.length) {
    return container.children();
  }

  //dom
  return container.children ? $(container.children) : $('body');
}

/*
 增强判断
 ios上支持行内播放，不能用默认的H5控制条，拖动失效，必须要加进度条
 ios低于10的情况下，用原生播放,而且不能是平板，只能是手机，touch

201.7.6.30
 *微信版本的安卓上面，需要增加这２个属性，要不会弹出广告
**/
/**
 * html5 and flash player
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */

var FlarePlayer = function () {
  function FlarePlayer(options, removeVideo) {
    classCallCheck(this, FlarePlayer);


    var url = getFilePath(options.url);
    var width = options.width,
        height = options.height,
        top = options.top,
        left = options.left,
        zIndex = options.zIndex;


    this.container = getContainer(options);

    var $videoWrap = createVideoWrap('video-flare', {
      width: width,
      height: height,
      top: top,
      left: left,
      zIndex: zIndex
    });

    var fv = this.fv = $videoWrap.flareVideo({
      width: width,
      height: height,
      autoplay: true,
      srcs: url
    });

    /*窗口化*/
    fv.video.setAttribute('playsinline', 'playsinline');

    /**
     * 微信版本的安卓上面，需要增加这２个属性，要不会弹出广告
     * 如果是column页面触发的广告
     * 需要排除，会出现视频错乱的问题
     */
    if (Xut.plat.isAndroid && Xut.plat.isWeiXin && !options.isColumn) {
      fv.video.setAttribute("x5-video-player-type", "h5");
      fv.video.setAttribute("x5-video-player-fullscreen", true);

      //默认竖屏 设置属性跟随屏幕方向变化
      fv.video.setAttribute("x5-video-orientation", "landscape|portrait");
      //浮动层会脱离文档流 在视频全屏时仍然会显示 现将其隐藏 然后还原visibility
      var floatLayerVisibility = $(".xut-float").css("visibility");
      //小窗播放时 安卓微信浏览器自动全屏
      //则视频有一部分会被遮挡  进入全屏事件时调整视频top值 退出全屏事件恢复原有top值
      fv.video.addEventListener("x5videoenterfullscreen", function () {
        $videoWrap[0].style.top = '0px';
        $videoWrap[0].style.left = '0px';
        $(".xut-float").css("visibility", "hidden");
      });
      fv.video.addEventListener("x5videoexitfullscreen", function () {
        $videoWrap[0].style.top = top + 'px';
        $videoWrap[0].style.left = left + 'px';
        $(".xut-float").css("visibility", floatLayerVisibility);
      });
    }

    /*播放完毕，关闭视频窗口*/
    fv.bind('ended', function () {
      if (options.startBoot) {
        options.startBoot();
      }
      /*非迷你平台关闭视频*/
      if (config.launch.platform !== 'mini') {
        removeVideo(options.chapterId);
      }
    });

    /*播放出错*/
    fv.bind('error', function () {
      if (options.startBoot) {
        options.startBoot();
      }
      removeVideo(options.chapterId);
    });

    this.container.append($videoWrap);

    /*触发了关闭按钮*/
    fv.bind('close', function () {
      removeVideo(options.chapterId);
    });

    /*如果启动了浮动工具栏，那么需要调节播放器控制器的高度*/
    var pageBar = config.launch.pageBar;
    if (pageBar && pageBar.type === 'globalBar' && pageBar.float) {

      //溢出高度
      //保护工具栏能显示
      var overflowHeight = top + height - (config.visualSize.height - pageBar.height);
      if (overflowHeight && overflowHeight > 0) {
        fv.controls.css('bottom', overflowHeight);
      }
    }
  }

  createClass(FlarePlayer, [{
    key: 'play',
    value: function play() {
      this.fv.play();
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.fv.pause();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.fv.remove();
      this.fv = null;
      this.container = null;
    }
  }]);
  return FlarePlayer;
}();

var preloadVideo = {

  //播放状态
  state: false,

  //地址
  path: window.DUKUCONFIG ? window.DUKUCONFIG.path + "duku.mp4" : 'android.resource://#packagename#/raw/duku',

  //加载视频
  load: function load() {
    // if (window.localStorage.getItem("videoPlayer") == 'error') {
    //       alert("error")
    //     return preloadVideo.launchApp();
    // }
    this.play();
    this.state = true;
  },


  //播放视频
  play: function play() {
    //延时应用加载
    Xut.Application.delayAppRun();
    Xut.Plugin.VideoPlayer.play(function () {
      preloadVideo.launchApp();
    }, function () {
      //捕获出错,下次不进入了,,暂无ID号
      // window.localStorage.setItem("videoPlayer", "error")
      preloadVideo.launchApp();
    }, preloadVideo.path, 1, 0, 0, window.innerHeight, window.innerWidth);
  },


  //清理视频
  closeVideo: function closeVideo() {
    Xut.Plugin.VideoPlayer.close(function () {
      preloadVideo.launchApp();
    });
  },


  //加载应用
  launchApp: function launchApp() {
    this.state = false;
    Xut.Application.LaunchApp();
  }
};

/**
 * 获取插件视频状态
 */
function getPlugVideoState() {
  return preloadVideo.state;
}

/**
 * 关闭插件视频
 */
function closePlugVideo() {
  preloadVideo.closeVideo();
}

/**
 * 播放视频插件
 */
function plugVideo() {
  preloadVideo.load();
}

/**
 *  创建播放器
 *  IOS，PC端执行
 */

/**
 * 回退按钮状态控制器
 * @param  {[type]} state [description]
 * @return {[type]}       [description]
 */
var controller = function controller(state) {
  //如果是子文档处理
  if (Xut.isRunSubDoc) {
    //通过Action动作激活的,需要到Action类中处理
    Xut.publish('subdoc:dropApp');
    return;
  }

  //home
  if (state === 'pause') {
    Xut.Application.Original();
  }

  //恢复
  if (state === 'resume') {
    Xut.Application.Activate();
  }

  //退出
  if (state === 'back') {
    window.GLOBALCONTEXT.navigator.notification.confirm('您确认要退出吗？', function (button) {
      if (1 == button) {
        Xut.Application.Suspend({
          processed: function processed() {
            window.GLOBALCONTEXT.navigator.app.exitApp();
          }
        });
      }
    }, '退出', '确定,取消');
  }
};

/**
 * 绑定安卓按钮
 * 回退键
 * @return {[type]} [description]
 */
function bindAndroidBack() {
  //如果是预加载视频
  if (getPlugVideoState()) {
    closePlugVideo();
  } else {
    controller('back');
  }
}

/**
 * 绑定安卓按钮
 * 暂停键
 * @return {[type]} [description]
 */
function bindAndroidPause() {
  controller('pause');
}

/**
 * 前台恢复
 * @return {[type]} [description]
 */
function bindAndroidResume() {
  controller('resume');
}

/**
 * 绑定安卓按钮
 * @return {[type]} [description]
 */
function bindAndroid() {
  if (Xut.plat.hasPlugin) {
    document.addEventListener("backbutton", bindAndroidBack, false);
    document.addEventListener("pause", bindAndroidPause, false);
    document.addEventListener("resume", bindAndroidResume, false);
  }
}

/**
 * 销毁安卓按钮
 * @return {[type]} [description]
 */
function clearAndroid() {
  if (Xut.plat.hasPlugin) {
    document.removeEventListener("backbutton", bindAndroidBack, false);
    document.removeEventListener("pause", bindAndroidPause, false);
    document.removeEventListener("resume", bindAndroidResume, false);
  }
}

/**
 * 判断是否支持webp模式
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 */
function supportWebP(callback) {
  var webP = new Image();
  webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
  webP.onload = webP.onerror = function () {
    callback(webP.height === 2);
  };
}

/**
 * 提前检测出异步的功能支持
 * @return {[type]} [description]
 */
function initAsyn(callback) {

  /**
   * 检测是否支持webp格式
   */
  supportWebP(function (state) {
    Xut.plat.supportWebp = state;
    callback();
  });
}

//动作标示
var HOT = 'hot'; //热点音频
var CONTENT = 'content'; //动画音频
var SEASON = 'season'; //节音频
var COLUMN = 'column'; //column流式布局

/**
 * 音频动作
 * @param  {[type]} global [description]
 * @return {[type]}        [description]
 */

//音频动作
//替换背景图
//指定动画
function Action(options) {

  var element = void 0,
      pageType = void 0;

  /*这里需要注意，浮动音频的情况，翻页DOM被重新创建，所以这里要每次要重新获取最新的*/
  var getAudioNode = function getAudioNode() {
    element = document.querySelector('#Audio_' + options.audioId);
  };

  var startImage = options.startImage && getFileFullPath(options.startImage, 'audio-action');
  var stopImage = options.stopImage && getFileFullPath(options.stopImage, 'audio-action');

  //切换背景
  var toggleImage = function toggleImage(fileName) {
    getAudioNode(); //每次都重新获取新的节点
    if (element) {
      element.style.backgroundImage = 'url(' + fileName + ')';
    }
  };

  getAudioNode();
  pageType = element.getAttribute('data-belong');

  stopImage && loadFigure(stopImage);

  return {
    play: function play() {
      stopImage && toggleImage(stopImage);
      if (options.startScript) {
        Xut.Assist.Run(pageType, options.startScript.split(','));
      }
    },
    pause: function pause() {
      startImage && toggleImage(startImage);
      if (options.stopScript) {
        Xut.Assist.Stop(pageType, options.stopScript.split(','));
      }
    },
    destroy: function destroy() {
      this.pause();
      element = null;
    }
  };
}

/**
 * 音频字幕
 * @param  {[type]} global [description]
 * @return {[type]}        [description]
 */

//字幕检测时间
var Interval = 50;

var getStyles = function getStyles(elem, name) {
  var styles = elem.ownerDocument.defaultView.getComputedStyle(elem, null);
  return styles.getPropertyValue(name);
};

/**
 * 字幕类
 *   音频实例
 * options 参数
 */
var Subtitle = function () {
  function Subtitle(options, controlDoms, getAudioTime) {
    classCallCheck(this, Subtitle);


    var visibility = void 0;
    var orgAncestorVisibility = void 0;

    //快速处理匹配数据
    var checkData = {};

    this.getAudioTime = getAudioTime;
    this.options = options;
    this.parents = controlDoms.parents;
    this.ancestors = controlDoms.ancestors;

    this.timer = 0;

    //缓存创建的div节点
    this.cacheCreateDivs = {};

    //保存原始的属性
    orgAncestorVisibility = this.orgAncestorVisibility = {};
    _.each(this.ancestors, function (node, contentId) {
      visibility = getStyles(node, 'visibility');
      if (visibility) {
        orgAncestorVisibility[contentId] = visibility;
      }
    });

    //去重记录
    this.recordRepart = {};

    //phonegap getCurrentPosition得到的音频播放位置不从0开始 记录起始位置
    this.changeValue = 0;
    _.each(options.subtitles, function (data) {
      checkData[data.start + '-start'] = data;
      checkData[data.end + '-end'] = data;
    });

    this._createSubtitle(checkData);
  }

  /**
   * 运行字幕
   * @return {[type]}
   */


  createClass(Subtitle, [{
    key: '_createSubtitle',
    value: function _createSubtitle(checkData) {
      var _this = this;

      this.timer = setTimeout(function () {
        _this.getAudioTime(function (audioTime) {
          var match = void 0;
          _.each(checkData, function (data, key) {
            match = key.split('-');
            _this._action(match[0], audioTime, match[1], data);
          });
          _this._createSubtitle(checkData);
        });
      }, Interval);
    }

    /**
     * 执行动作
     * 创建文本框
     * 显示/隐藏文本框
     */

  }, {
    key: '_action',
    value: function _action(currentTime, audioTime, action, data) {
      if (audioTime > currentTime - Interval && audioTime < currentTime + Interval) {
        //创建
        if (!this.recordRepart[data.start] && action === 'start') {
          this.recordRepart[data.start] = true;
          this._createDom(data);
        }
        //如果是一段字幕结束处理
        else if (!this.recordRepart[data.end] && action === 'end') {
            this.recordRepart[data.end] = true;
            var ancestorNode = this.ancestors[data.id];
            if (ancestorNode) {
              ancestorNode.style.visibility = "hidden";
            }
          }
      }
    }
  }, {
    key: '_createDom',
    value: function _createDom(data) {

      //屏幕分辨率
      var proportion = config.proportion;
      var proportionWidth = proportion.width;
      var proportionHeight = proportion.height;

      var contentId = data.id;
      var parentNode = this.parents[contentId];
      var ancestorNode = this.ancestors[contentId];
      var preDiv = this.cacheCreateDivs[contentId];
      var preP = preDiv && preDiv.children[0];

      //转换行高
      var sLineHeight = data.lineHeight ? data.lineHeight : '100%';

      /**
       * 设置父容器div 字体颜色，大小，类型，位置，文本水平、垂直居中
       */
      function createDivStyle(parent, data) {
        var value = setProportion({
          width: data.width,
          height: data.height,
          left: data.left,
          top: data.top
        });

        var cssText = 'position:absolute;\n                 display:table;\n                 vertical-align:center;\n                 width:' + value.width + 'px;\n                 height:' + value.height + 'px;\n                 top:' + value.top + 'px;\n                 left:' + value.left + 'px;';

        parent.style.cssText = String.styleFormat(cssText);
      }

      /**
       * 内容元素的样式
       */
      function createPStyle(p, data) {
        var cssText = 'text-align:center;\n                 display:table-cell;\n                 vertical-align :middle;\n                 color:' + data.fontColor + ';\n                 font-family:' + data.fontName + ';\n                 font-bold:' + data.fontBold + ';\n                 font-size:' + data.fontSize * proportionWidth + 'px;\n                 line-height:' + sLineHeight + '%';

        //设置字体间距
        p.style.cssText = String.styleFormat(cssText);

        //设置文字内容
        p.innerHTML = data.title;
      }

      /**
       * 创建内容
       */
      function createContent(parent, p, data) {
        createDivStyle(parent, data); //设置div
        createPStyle(p, data);
      }

      //公用同一个contengid,已经存在
      if (preDiv) {
        createContent(preDiv, preP, data);
      } else {
        //创建父元素与子元素
        var createDiv = document.createElement('div');
        var createP = document.createElement('p');
        //设置样式
        createContent(createDiv, createP, data);
        createDiv.appendChild(createP); //添加到指定的父元素
        parentNode.appendChild(createDiv);
        this.cacheCreateDivs[contentId] = createDiv; //保存引用
      }

      //操作最外层的content节点
      if (ancestorNode) {
        var ancestorNodeValue = getStyles(ancestorNode, 'visibility');
        if (ancestorNodeValue != 'visible') {
          ancestorNode.style.visibility = 'visible';
        }
      }
    }

    /**
     * 清理音频
     * @return {[type]}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var self = this;
      _.each(this.cacheCreateDivs, function (node) {
        node.parentNode.removeChild(node);
      });

      //恢复初始状态
      _.each(this.ancestors, function (node, id) {
        var orgValue = self.orgAncestorVisibility[id];
        var currValue = getStyles(node, 'visibility');
        if (currValue != orgValue) {
          node.style.visibility = orgValue;
        }
      });

      this.ancestors = null;
      this.cacheCreateDivs = null;
      this.changeValue = 0;
      this.parents = null;
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = 0;
      }
    }
  }]);
  return Subtitle;
}();

/**
 * 音频工厂类
 * @param {[type]} options [description]
 */

var AudioSuper = function () {
  function AudioSuper(options, controlDoms) {
    classCallCheck(this, AudioSuper);

    this.options = options;

    this.trackId = options.trackId;
    this.controlDoms = controlDoms;

    /*构建之前处理*/
    this._$$preRelated(options);
    /*初始化数据*/
    this._init();
    //相关数据
    this._$$afterRelated(options);
  }

  //=============================
  //    私有方法
  //=============================

  /**
   * 构建之前关数据
   * 2个回调处理
   *  1 内部manage
   *  2 外部content的行为音频
   *  二者只会同时存在一个
   */


  createClass(AudioSuper, [{
    key: '_$$preRelated',
    value: function _$$preRelated(options) {

      /*匹配URL地址*/
      this.$$url = config.getAudioPath() + options.url;

      //在manager中附加，播放一次后删除这个对象
      this.innerCallback = options.innerCallback;

      /*按钮的反弹点击触发，设置按钮的行为*/
      if (this.trackId == 9999 && options.complete) {
        this.outerCallback = options.complete;
      }
    }

    /**
     * 构建之后关数据
     */

  }, {
    key: '_$$afterRelated',
    value: function _$$afterRelated(options) {
      var _this = this;

      //音频重复播放次数
      if (options.data && options.data.repeat) {
        this.repeatNumber = Number(options.data.repeat);
      }
      //音频动作
      if (options.action) {
        this.acitonObj = Action(options);
      }
      //字幕对象
      if (options.subtitles && options.subtitles.length > 0) {
        this.subtitleObject = new Subtitle(options, this.controlDoms, function (cb) {
          return _this._getAudioTime(cb);
        });
      }
      //如果有外部回调处理
      if (this.outerCallback) {
        this.outerCallback.call(this);
      }
    }

    //=============================
    //    提供给子类方法
    //=============================


    /**
     * 运行成功失败后处理方法
     * phoengap会调用callbackProcess
     * state
     *   true 成功回调
     *   false 失败回调
     */

  }, {
    key: '_$$callbackProcess',
    value: function _$$callbackProcess(state) {

      /**************************
          处理content的反馈回调
      ***************************/
      if (this.outerCallback) {
        this.destroy();
      } else {

        /**************************
         内部播放的回调，manage的处理
        ***************************/
        /*播放失败*/
        if (!state) {
          this.innerCallback && this.innerCallback(this);
          return;
        }

        /*如果有需要重复的音频*/
        if (this.repeatNumber) {
          --this.repeatNumber;
          this.play();
        } else {
          /*如果不存在重复，那么播放完毕后，直接清理这个对象*/
          this.innerCallback && this.innerCallback(this);
        }
      }
    }

    /**
     * 获取微信播放对象
     * 2017.8.10
     * 妙妙学ios公众号问题
     * 如果嵌套了iframe必须要找parent的WeixinJSBridge
     */

  }, {
    key: '$$getWeixinJSBridgeContext',
    value: function $$getWeixinJSBridgeContext() {
      //必须是微信平台
      //2017.11.24
      //秒秒学在线打开
      //本地化资源后报错这个，强制判断必须是微信
      if (!Xut.plat.isWeiXin) {
        return;
      }

      if (window.WeixinJSBridge) {
        return window.WeixinJSBridge;
      }
      if (window.parent && window.parent.WeixinJSBridge) {
        return window.parent.WeixinJSBridge;
      }
    }

    //=============================
    //    提供外部接口，向上转型
    //=============================

  }, {
    key: 'getTrackId',
    value: function getTrackId() {
      return this.trackId;
    }

    /**
     * 播放
     * @return {[type]} [description]
     */

  }, {
    key: 'play',
    value: function play() {
      var _this2 = this;

      /*子类提供了播放*/
      if (this._play) {
        this._play();
      }

      this.status = 'playing';

      //flash模式不执行
      if (this.audio) {
        //支持自动播放,微信上单独处理
        var weixinJSBridge = this.$$getWeixinJSBridgeContext();
        if (weixinJSBridge) {
          weixinJSBridge.invoke('getNetworkType', {}, function (e) {
            if (_this2.audio) {
              Xut.$warn({
                type: 'weixinJSBridgeAudio',
                content: '+\u64AD\u653E\u97F3\u9891,audio\u7684id:' + _this2.options.audioId
              });
              _this2.audio.play();
            }
          });
        } else {
          //秒秒学提示play不存在
          if (this.audio.play) {
            Xut.$warn({
              type: 'html5Audio',
              content: '+\u64AD\u653E\u97F3\u9891,audio\u7684id:' + this.options.audioId
            });

            this.audio.play();
          }
        }
      }
      this.acitonObj && this.acitonObj.play();
    }

    /**
     * 停止
     * @return {[type]} [description]
     */

  }, {
    key: 'pause',
    value: function pause() {

      /*子类提供了暂停*/
      if (this._pause) {
        this._pause();
      }

      this.status = 'paused';
      this.audio && this.audio.pause && this.audio.pause();
      this.acitonObj && this.acitonObj.pause();
    }

    /**
     * 复位接口
     * @return {[type]} [description]
     */

  }, {
    key: 'reset',
    value: function reset() {
      /*子类提供了复位*/
      if (this._reset) {
        this._reset();
      }
      this.status = 'reseted';
    }

    /**
     * 销毁
     */

  }, {
    key: 'destroy',
    value: function destroy() {

      /*子类提供了销毁*/
      if (this._destroy) {
        this._destroy();
      }

      this.status = 'ended';

      //销毁字幕
      if (this.subtitleObject) {
        this.subtitleObject.destroy();
        this.subtitleObject = null;
      }

      //动作
      if (this.acitonObj) {
        this.acitonObj.destroy();
        this.acitonObj = null;
      }

      Xut.$warn({
        type: 'html5Audio',
        content: '-\u9500\u6BC1\u97F3\u9891,audio\u7684id:' + this.options.audioId
      });
    }
  }]);
  return AudioSuper;
}();

/**
 * 使用PhoneGap的Media播放
 */
var PhoneGapMedia = function (_AudioSuper) {
  inherits(PhoneGapMedia, _AudioSuper);

  function PhoneGapMedia(options, controlDoms) {
    classCallCheck(this, PhoneGapMedia);
    return possibleConstructorReturn(this, (PhoneGapMedia.__proto__ || Object.getPrototypeOf(PhoneGapMedia)).call(this, options, controlDoms));
  }

  createClass(PhoneGapMedia, [{
    key: "_init",
    value: function _init() {
      var self = this;

      //音频成功与失败调用
      var audio = new window.GLOBALCONTEXT.Media(self.$$url, function () {
        self._$$callbackProcess(true);
      }, function () {
        self._$$callbackProcess(false);
      });

      //autoplay
      this.audio = audio;
      this.play();
    }

    /**
     * 复位接口
     */

  }, {
    key: "_reset",
    value: function _reset() {
      this.audio.pause();
      this.audio.seekTo(0);
    }

    /**
     * Compatible with asynchronous
     * for subitile use
     * get audio
     * @return {[type]} [description]
     */

  }, {
    key: "_getAudioTime",
    value: function _getAudioTime(callback) {
      var _this2 = this;

      this.audio.getCurrentPosition(function (position) {
        var audioTime = void 0;
        position = position * 1000;
        if (!_this2.changeValue) {
          _this2.changeValue = position;
        }
        position -= _this2.changeValue;
        if (position > -1) {
          audioTime = Math.round(position);
        }
        callback(audioTime);
      }, function (e) {
        console.log("error:" + e);
        //出错继续检测
        callback();
      });
    }

    /**
     * 销毁
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      if (this.audio) {
        this.audio.release();
        this.audio = null;
      }
    }
  }]);
  return PhoneGapMedia;
}(AudioSuper);

var createPart = function createPart(length) {
  var uuidpart = "";
  var uuidchar = void 0;
  for (var i = 0; i < length; i++) {
    uuidchar = parseInt(Math.random() * 256, 10).toString(16);
    if (uuidchar.length == 1) {
      uuidchar = "0" + uuidchar;
    }
    uuidpart += uuidchar;
  }
  return uuidpart;
};

var createUUID = function createUUID() {
  return [4, 2, 2, 2, 6].map(createPart).join('-');
};

/**
 * 使用PhoneGap的 js直接调用 cordova Media播放
 */
var CordovaMedia = function (_AudioSuper) {
  inherits(CordovaMedia, _AudioSuper);

  function CordovaMedia(options, controlDoms) {
    classCallCheck(this, CordovaMedia);
    return possibleConstructorReturn(this, (CordovaMedia.__proto__ || Object.getPrototypeOf(CordovaMedia)).call(this, options, controlDoms));
  }

  createClass(CordovaMedia, [{
    key: "_init",
    value: function _init() {
      var self = this;
      this.id = createUUID();
      var audio = {
        startPlayingAudio: function startPlayingAudio() {
          window.audioHandler.startPlayingAudio(self.id, self.$$url);
        },
        pausePlayingAudio: function pausePlayingAudio() {
          window.audioHandler.pausePlayingAudio(self.id);
        },
        release: function release() {
          window.audioHandler.release(self.id);
        },
        /**
         * 扩充，获取位置
         * @return {[type]} [description]
         */
        expansionCurrentPosition: function expansionCurrentPosition() {
          return window.getCurrentPosition(self.id);
        }

        //autoplay
      };this.audio = audio;
      this.play();
    }

    /**
     * Compatible with asynchronous
     * for subitile use
     * get audio
     * @return {[type]} [description]
     */

  }, {
    key: "_getAudioTime",
    value: function _getAudioTime(callback) {
      callback(Math.round(this.audio.expansionCurrentPosition() * 1000));
    }

    //播放

  }, {
    key: "_play",
    value: function _play() {
      if (this.audio) {
        this.audio.startPlayingAudio();
      }
    }

    //停止

  }, {
    key: "_pause",
    value: function _pause() {
      this.audio && this.audio.pausePlayingAudio();
    }

    //结束

  }, {
    key: "_destroy",
    value: function _destroy() {
      if (this.audio) {
        this.audio.release();
        this.audio = null;
      }
    }
  }]);
  return CordovaMedia;
}(AudioSuper);

/**
 * audio对象下标
 * @type {Number}
 */
var index = 0;
var loop = 10;
var audioes = [];
//usable  可用状态
var status = '';

///////////////////////////////////////////////////////////////////
/// 2017.6.28
/// 安卓5以后 chrome浏览器单独的问题处理 需要绑定touchend事件
/// 如果用click那么需要处理swiper的hook 这里需要跳过preventDefault
///////////////////////////////////////////////////////////////////

/**
 * 修复audio
 * @param  {[type]} obj    [description]
 * @param  {[type]} key    [description]
 * @param  {[type]} access [description]
 * @return {[type]}        [description]
 */
function fixAudio(obj, key, access) {
  $on(document, {
    end: function end() {
      for (var i = 0; i < loop; i++) {
        var audio = new Audio();
        audio.play(); /*必须调用，自动播放的时候没有声音*/
        audioes.push(audio);
      }
      //修改为可用状态
      status = 'usable';
      //修复音频上下文对象
      resetAudioContext();
      $off(document);
    }
  });
}

/**
 * 销毁创建的video对象
 * @return {[type]} [description]
 */
function clearFixAudio() {
  for (var i = 0; i < audioes.length; i++) {
    audioes[i].destroy && audioes[i].destroy();
    audioes[i] = null;
  }
  audioes = null;
  status = '';
}

/**
 * 是否存在修复的音频对象
 * @return {Boolean} [description]
 */
function hasFixAudio() {
  return audioes.length;
}

/**
 * 获取音频对象
 * @return {[type]} [description]
 */
function getAudioContext() {
  if (status === 'usable') {
    var audio = audioes[index++];
    if (!audio) {
      index = 0;
      return getAudioContext();
    }
    return audio;
  }
}

/**
 * 使用html5的audio播放
 *
 *
 * html audio 在iPhone，ipd,safari浏览器不能播放是有原因滴
(在safri on ios里面明确指出等待用户的交互动作后才能播放media，也就是说如果你没有得到用户的action就播放的话就会被safri拦截)

 *
 * 1.移动端自动播放，需要调用2次play，但是通过getAudioContext的方法获取的上下文，每个context被自动play一次
 * 2.如果需要修复自动播放的情况下
 *   A. 音频的执行比hasFixAudio的处理快，那么需要resetContext正在播放的音频上下文
 *   B. 如果hasFixAudio有了后，在执行音频，正常播放
 * 3.不需要修复自动播放的情况，只有正常的1次play了
 */
var HTML5Audio = function (_AudioSuper) {
  inherits(HTML5Audio, _AudioSuper);

  function HTML5Audio(options, controlDoms) {
    classCallCheck(this, HTML5Audio);
    return possibleConstructorReturn(this, (HTML5Audio.__proto__ || Object.getPrototypeOf(HTML5Audio)).call(this, options, controlDoms));
  }

  /**
   * 初始化
   * @return {[type]} [description]
   */


  createClass(HTML5Audio, [{
    key: '_init',
    value: function _init() {
      var self = this;
      var trackId = this.trackId;

      if (Xut.plat.fixWebkitAutoAudio) {
        //webkit移动端....
        //不支持自动播放
        this._createContext();
      } else {
        //微信有接口
        //PC正常播放
        this.audio = new Audio(this.$$url);

        //通过微信自己的事件处理，支持自动播放了
        if (this.$$getWeixinJSBridgeContext()) {
          this.play();
        } else {
          this._initPlay();
        }
      }
    }

    /**
     * 创建音频上下文对象
     */

  }, {
    key: '_createContext',
    value: function _createContext() {
      var _this2 = this;

      this.audio = getAudioContext();
      if (!this.audio) {
        //还没有点击修复，并且已经运行的是自动
        //第一次进入页面才会存在
        this._needFix = true;
        return;
      }
      this._needFix = false;

      setTimeout(function () {
        if (_this2.audio) {
          //可能已经调动了销毁
          _this2.audio.src = _this2.$$url;
          _this2._initPlay();
        }
      }, 0);
    }

    /**
     * 清理定时器
     * @return {[type]} [description]
     */

  }, {
    key: '_clearTimer',
    value: function _clearTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }

    /**
     * 监听音频播放
       可以自动播放时正确的事件顺序是
    // loadstart
    // loadedmetadata
    // loadeddata
    // canplay
    // play
    // playing
    // 不能自动播放时触发的事件是
    // iPhone5  iOS 7.0.6 loadstart
    // iPhone6s iOS 9.1   loadstart -> loadedmetadata -> loadeddata -> canplay
     */

  }, {
    key: '_initPlay',
    value: function _initPlay() {
      var _this3 = this;

      this.audio.autoplay = 'autoplay';

      this._endBack = function () {
        _this3._clearTimer();
        _this3._$$callbackProcess(true);
      };

      this._errorBack = function () {
        _this3._clearTimer();
        _this3._$$callbackProcess(false);
      };

      this._startBack = function () {
        _this3.status = 'ready';
        /*延时150毫秒执行*/
        _this3.timer = setTimeout(function () {
          _this3._clearTimer();
          //必须保证状态正确，因为有翻页太快，状态被修改
          if (_this3.status === 'ready') {
            _this3.play();
          }
        }, 150);
      };

      this.audio.addEventListener('loadedmetadata', this._startBack(), false);
      this.audio.addEventListener('ended', this._endBack, false);
      this.audio.addEventListener('error', this._errorBack, false);
    }

    /**
     * Compatible with asynchronous
     * for subitile use
     * get audio
     * @return {[type]} [description]
     */

  }, {
    key: '_getAudioTime',
    value: function _getAudioTime(callback) {
      callback(Math.round(this.audio.currentTime * 1000));
    }

    /**
     * 复位接口
     */

  }, {
    key: '_reset',
    value: function _reset() {
      this.audio.pause();
      this.audio.currentTime = 0;
    }

    /**
     * 销毁方法
     * @return {[type]} [description]
     */

  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this.audio) {
        this.audio.pause();
        if (!window.WeixinJSBridge) {
          //微信通过自己API 没有绑定事件
          this.audio.removeEventListener('loadedmetadata', this._startBack, false);
          this.audio.removeEventListener('ended', this._endBack, false);
          this.audio.removeEventListener('error', this._errorBack, false);
        }
        this.audio = null;
      }
    }

    ///////////////////////////
    ///   对外接口，修复上下文
    //////////////////////////

    /**
     * 重设音频上下文
     * 因为自动音频播放的关系
     * 在点击后修复这个音频
     */

  }, {
    key: 'resetContext',
    value: function resetContext() {
      //不支持自动播放的情况下
      //又开始了自动播放
      //但是又没有点击动作
      //所以自动播放被阻止了
      //需要修复
      if (this._needFix) {

        Xut.$warn({
          type: 'html5Audio',
          content: '\u4FEE\u590D\u672A\u81EA\u52A8\u64AD\u653E\u5BF9\u8C61,audio\u7684id:' + this.options.audioId
        });
        this._createContext();
      }
    }
  }]);
  return HTML5Audio;
}(AudioSuper);

var AudioPlayer = void 0;

/*安卓客户端apk的情况下*/
if (Xut.plat.isAndroid && !Xut.plat.isBrowser) {
  AudioPlayer = PhoneGapMedia;
} else {
  /*妙妙学的 客户端浏览器模式*/
  if (window.MMXCONFIG && window.audioHandler) {
    AudioPlayer = CordovaMedia;
  } else {

    //需要修复音频
    if (Xut.plat.fixWebkitAutoAudio) {
      fixAudio();
    }

    /*其余所有情况都用原声的H5播放器*/
    AudioPlayer = HTML5Audio;
  }
}

/**
 * 音频说明：
 *  一个音频播放有2种情况：
 *       1、自动播放该音频（autoPlay == true）
 *       2、手动播放该音频（点击触发点）
 *
 *   一个音频被停止有3种情况：
 *       1、手动暂停（点击触发点）
 *       2、同轨道的其他音频开始播放
 *       3、0轨道的音频开始播放
 *   特殊情况：
 *       0轨道的音频播放时，可以停止所有其他轨道的音频
 *       其他轨道的音频播放时，可以停止0轨道的音频
 *
 *   基于上面的条件，补充提示：
 *       同轨道只允许有一个自动播放的音频
 *       如果0轨道音频为自动播放，则其他轨道不允许有自动播放音频
 *       反之亦然，其他轨道有自动播放音频，则0轨道不允许有自动播放音频
 *
 *    ===================================================================================================
 *   该版本说明：
 *   一个音频被打断之后，就被销毁，不会在后续恢复播放，而只会重头开始播放
 *
 *  2014.12.1 版本升级
 *  原来只有热点音频，现在多了动画音频和节音频，所以音频管理需要调整,
 *  有两个要注意的地方：
 *  1. 由于在IOS上,new Audio操作会产生新的进程，且不释放，所以同一个音轨只新建一个音频实例
 *     为了防止交互点击时音频播放混乱，要先清除同音轨的上一个音频
 *  2. 节音频可以跨节共用，如,1,2,3节共用一个音频，那么在这些节之间跳转时不打断
 *
 */

/**
 * 容器合集
 * playBox 播放中的热点音频集合
 */
var playBox = void 0;

var initBox = function initBox() {
  playBox = hash();
};

/**
 * 获取父容器
 * @return {[type]} [description]
 */
var getParentNode = function getParentNode(subtitles, pageId, queryId) {
  //字幕数据
  var parentDoms = hash();
  var ancestorDoms = hash();
  var contentsFragment;
  var dom;
  var pageIndex = pageId - 1;
  if (subtitles) {
    //获取文档节点
    contentsFragment = Xut.Contents.contentsFragment[pageId];

    //如果maskId大于9000默认为处理
    var isMask = pageId > 9000;
    if (isMask) {
      //指定页码编号
      pageIndex = Xut.Presentation.GetPageIndex();
    }

    //找到对应的节点
    _.each(subtitles, function (data) {
      //'Content_0_1' 规则 类型_页码（0开始）_id
      if (!parentDoms[data.id]) {
        dom = contentsFragment['Content_' + pageIndex + '_' + data.id];
        ancestorDoms[data.id] = dom;
        var $dom = $(dom);
        if ($dom.length) {
          var _div = $dom.find('div').last();
          if (_div.length) {
            parentDoms[data.id] = _div[0];
          }
        }
      }
    });
  }

  return {
    parents: parentDoms,
    ancestors: ancestorDoms
  };
};

/**
 * 组合数据结构
 */
var deployAudio = function deployAudio(sqlData, pageId, queryId, type, actionData, columnData) {
  //新的查询
  var videoData = {};

  /*************
  组成数据
  1 column
  2 ppt
  *************/
  if (columnData && columnData.isColumn) {
    _.extend(videoData, {
      'trackId': columnData.track, //音轨
      'url': columnData.fileName, //音频名字
      'audioId': queryId,
      'data': sqlData
    });

    /*如果flow数据有动作切换图片*/
    if (columnData.startImage || columnData.stopImage) {
      _.extend(videoData, {
        startImage: columnData.startImage,
        stopImage: columnData.stopImage,
        action: true
      });
    }
  } else {
    //有字幕处理
    var subtitles = sqlData.theTitle ? parseJSON(sqlData.theTitle) : null;
    _.extend(videoData, {
      'trackId': sqlData.track, //音轨
      'url': sqlData.md5, //音频名字
      'subtitles': subtitles,
      'audioId': queryId,
      'data': sqlData
    });

    //混入新的动作数据
    //2015.9.24
    //音频替换图片
    //触发动画
    if (actionData) {
      _.extend(videoData, actionData, {
        action: true //快速判断存在动作数据
      });
    }
  }
  return videoData;
};

/**
 * 装配音频数据
 * @param  {int} pageId    页面id或节的分组id
 * @param  {int} queryId   查询id,支持activityId,audioId
 * @param  {string} type   音频来源类型[动画音频,节音频,热点音频]
 */
var assemblyData = function assemblyData(pageId, queryId, type, actionData, columnData) {

  /************
    column数据组成
  ************/
  if (columnData.isColumn) {
    return deployAudio({}, pageId, queryId, type, null, columnData);
  }

  /************
    PPT数据组成
  ************/
  var data = getMediaData(type, queryId);
  if (data && data.md5) {
    return deployAudio(data, pageId, queryId, type, actionData);
  }
};

/**
 * 检查要打断的音频
 * 不打断返回true,否则返回false
 */
var checkBreakAudio = function checkBreakAudio(type, pageId, queryId, newAuidoData) {

  var oldPlayObj = playBox[type][pageId][queryId];
  var oldTrackId = oldPlayObj.getTrackId();
  var newTrackId = newAuidoData.trackId;

  /**
   * 打断音频,条件
   * 如果要用零音轨||零音轨有音乐在播||两音轨相同
   */
  if (newTrackId == 0 || oldTrackId == 0 || newTrackId == oldTrackId) {
    if (newAuidoData.stetObj && newAuidoData.stetObj === oldPlayObj) {
      // 预加载检测打断，因为当前对象在预加载种已经被加载过了
      // 所以在打断时候要剔除这个对象
      // 保留这个对象不删除
    } else {
      oldPlayObj.destroy();
      delete playBox[type][pageId][queryId];
    }
  }
  return false;
};

/**
 * 播放音频之前检查
 * @param  {int} pageId    [description]
 * @param  {int} queryId    查询id
 * @param  {string} type    决定video表按哪个字段查询
 * @return {object}         音频对象/不存在为nul
 * pageId, queryId, type
 */
var preCheck = function preCheck(auidoData) {
  var types = void 0,
      pageId = void 0,
      queryId = void 0;
  for (types in playBox) {
    for (pageId in playBox[types]) {
      for (queryId in playBox[types][pageId]) {
        checkBreakAudio(types, pageId, queryId, auidoData);
      }
    }
  }
};

/**
 * 填充box,构建播放列表
 * @param  {[type]} pageId [description]
 * @param  {[type]} type   [description]
 * @return {[type]}        [description]
 */
var fillBox = function fillBox(pageId, type) {
  if (!playBox[type]) {
    playBox[type] = hash();
  }
  if (!playBox[type][pageId]) {
    playBox[type][pageId] = hash();
  }
};

/**
 * 创建音频
 * @param  {[type]} pageId    [description]
 * @param  {[type]} queryId   [description]
 * @param  {[type]} type      [description]
 * @param  {[type]} audioData [description]
 * @return {[type]}           [description]
 */
var createAudio = function createAudio(pageId, queryId, type, audioData) {

  //检测是否打断
  preCheck(audioData);

  //构建播放列表
  fillBox(pageId, type);

  //假如有字幕信息
  //找到对应的文档对象
  var subtitleNode = void 0;
  if (audioData.subtitles) {
    subtitleNode = getParentNode(audioData.subtitles, pageId, queryId);
  }

  //播放一次的处理
  audioData.innerCallback = function (audio) {
    if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
      audio.destroy();
      delete playBox[type][pageId][queryId];
    }
  };

  playBox[type][pageId][queryId] = new AudioPlayer(audioData, subtitleNode);
};

/**
 * 交互点击
 * @param  {[type]} pageId    [description]
 * @param  {[type]} queryId   [description]
 * @param  {[type]} type      [description]
 * @param  {[type]} audioData [description]
 * @return {[type]}           [description]
 */
var tiggerAudio = function tiggerAudio(pageId, queryId, type, audioData) {
  var playObj = void 0,
      status = void 0;
  if (playBox[type] && playBox[type][pageId] && playBox[type][pageId][queryId]) {
    playObj = playBox[type][pageId][queryId];
    status = playObj.audio ? playObj.status : null;
  }
  switch (status) {
    case 'playing':
      playObj.pause();
      break;
    case 'paused':
      playObj.play();
      break;
    default:
      createAudio(pageId, queryId, type, audioData);
      break;
  }
};

/**
 * 加载音频对象
 */
var loadAudio = function loadAudio(_ref) {
  var pageId = _ref.pageId,
      queryId = _ref.queryId,
      type = _ref.type,
      action = _ref.action,
      data = _ref.data,
      _ref$columnData = _ref.columnData,
      columnData = _ref$columnData === undefined ? {} : _ref$columnData;


  ///////////////////////
  //  1.初始化、
  //  2.直接加载播放对象
  ////////////////////////

  /*column的参数是字符串类型*/
  if (!columnData.isColumn) {
    pageId = Number(pageId);
    queryId = Number(queryId);
  }

  var audioData = assemblyData(pageId, queryId, type, data, columnData);

  /*手动触发的热点,这种比较特别，手动点击可以切换状态*/
  if (type === 'hot' && action == 'trigger') {
    /*判断是否为点击动作*/
    audioData.isTrigger = true;
    tiggerAudio(pageId, queryId, type, audioData);
  } else {
    createAudio(pageId, queryId, type, audioData);
  }
};

function getPlayBox() {
  return playBox;
}

///////////////////
//1 独立音频处理, 音轨/跨页面 //
//2 动画音频,跟动画一起播放与销毁
///////////////////

/*代码初始化*/
function initAudio() {
  initBox();
}

////////////////////////
/// PPT 动画音频接口
/// 1 自动音频
/// 2 手动音频
///////////////////////


/*
 音频在创建dom的时候需要查下，这个hot对象是否已经被创建过
 如果创建过，那么图标状态需要处理
*/
function hasHotAudioPlay(pageId, queryId) {
  var playBox = getPlayBox();
  if (playBox[HOT] && playBox[HOT][pageId]) {
    var audioObj = playBox[HOT][pageId][queryId];
    if (audioObj && audioObj.status === 'playing') {
      return true;
    }
  }
}

/**
 * 自动播放触发接口
 */
function autoAudio(chapterId, activityId, data) {
  loadAudio({
    pageId: chapterId,
    queryId: activityId,
    type: HOT,
    action: 'auto',
    data: data
  });
}

/**
 * 手动触发
 */
function triggerAudio(_ref) {
  var data = _ref.data,
      columnData = _ref.columnData,
      activityId = _ref.activityId,
      chapterId = _ref.chapterId;

  loadAudio({
    data: data,
    columnData: columnData,
    pageId: chapterId,
    queryId: activityId,
    type: HOT,
    action: 'trigger'
  });
}

////////////////////////
/// 动画音频接口
/// 2 直接播放
/// 3 复位
/// 4 销毁
///////////////////////

/**
 * 动画音频触发接口
 */
function createContentAudio(pageId, audioId) {
  loadAudio({
    pageId: pageId,
    queryId: audioId,
    type: CONTENT
  });
}

var accessAudio = function accessAudio(pageId, queryId, callback) {
  var playBox = getPlayBox();
  if (playBox[CONTENT]) {
    var pagePlayObj = playBox[CONTENT][pageId];
    if (pagePlayObj) {
      var playObj = pagePlayObj[queryId];
      if (playObj) {
        callback(playObj, playBox);
      }
    }
  }
};

/**
 * 复位动画音频
 * 必须要存在content音频对象
 * 待用
 */


/**
 * 销毁动画音频
 * 1 清理页面中的content
 * 2 清理playBox中的content对象
 */
function destroyContentAudio(pageId, queryId) {

  /*如果只有pageId没有queryId就是全部清理*/
  if (pageId && queryId === undefined) {
    return;
  }

  /*单独清理*/
  accessAudio(pageId, queryId, function (playObj, playBox) {
    playObj.destroy();
    /*清理保存容器*/
    delete playBox[CONTENT][pageId][queryId];
    if (!Object.keys(playBox[CONTENT][pageId]).length) {
      delete playBox[CONTENT][pageId];
    }
  });
}

/**
 * 重置音频对象
 * 如果在不支持自动音频的情况下
 * 如果修复代码没有执行的时候，就运行自动音频
 * 那么音频是没有声音的
 * 所以等修复音频代码执行完毕后，手动调用
 * 然后让音频能支持自动播放
 * @return {[type]} [description]
 */
function resetAudioContext() {
  var playBox = getPlayBox();
  var t, p, a;
  for (t in playBox) {
    for (p in playBox[t]) {
      for (a in playBox[t][p]) {
        /*needFix：如果是需要修复的代码*/
        if (playBox[t][p][a].resetContext) {
          //mmx报错，加判断
          playBox[t][p][a].resetContext();
        }
      }
    }
  }
}

////////////////////////
/// Column音频接口
///////////////////////

/*
2017.5.8新增
每个column页面支持音频，所以翻页就删除
这里不需要页码区分，因为全删
 */
function clearColumnAudio() {
  var playBox = getPlayBox();
  /*清理视频*/
  if (playBox && playBox[HOT] && playBox[HOT][COLUMN]) {
    var playObjs = playBox[HOT][COLUMN];
    for (var player in playObjs) {
      playObjs[player].destroy();
      playObjs[player] = null;
    }
    delete playBox[HOT][COLUMN];
  }
}

/**
 * 获取媒体数据，视频音频
 */
function getMediaData(type, queryId) {
  if (type === CONTENT || type === SEASON) {
    return Xut.data.query('Video', queryId, true);
  } else {
    //如果普通音频数据
    return Xut.data.query('Video', queryId);
  }
}

/**
 * 挂起音频
 */
function hangUpAudio() {
  var playBox = getPlayBox();
  var t, p, a;
  for (t in playBox) {
    for (p in playBox[t]) {
      for (a in playBox[t][p]) {
        playBox[t][p][a].pause();
      }
    }
  }
}

///////////////////////////////
///
///   清理全部音频
///
///////////////////////////////


/**
 * 清理所有音频
 */
function clearAudio$1() {
  var playBox = getPlayBox();
  var t, p, a;
  for (t in playBox) {
    for (p in playBox[t]) {
      for (a in playBox[t][p]) {
        playBox[t][p][a].destroy();
      }
    }
  }
  initBox();
}

/**
 *   html5的video播放器
 *   API :
 *   play();播放
 *   stop();    //停止播放并隐藏界面
 *   destroy(); //清除元素节点及事件绑定
 *  demo :
 *  var video = new Video({url:'1.mp4',width:'320',...});
 *  video.play();
 */

var HTML5Player = function () {
  function HTML5Player(options) {
    classCallCheck(this, HTML5Player);
    var width = options.width,
        height = options.height,
        top = options.top,
        left = options.left,
        zIndex = options.zIndex,
        url = options.url;


    this.options = options;
    this.$container = getContainer(options);

    this._initWrap(width, height, top, left, zIndex, getFilePath(url));
    this._initEvent(options);

    //////////////////////////
    ///2016.6.23
    //移动端必须触发2次play
    //安卓ios需要直接调用play开始
    ////////////////////////
    if (Xut.plat.isIOS || Xut.plat.isAndroid) {
      this.play();
    }

    /**
     * 2017.5.23
     * 安卓手机播放视频，全屏的情况下，会强制横版
     * 导致了触发横竖切换关闭应用
     * @type {Boolean}
     */
    Xut.Application.PlayHTML5Video = true;
  }

  /*初始化容器*/


  createClass(HTML5Player, [{
    key: '_initWrap',
    value: function _initWrap(width, height, top, left, zIndex, src) {
      this.$videoWrap = createVideoWrap('video-h5', { width: width, height: height, top: top, left: left, zIndex: zIndex });
      this.video = document.createElement('video');

      this.$videoNode = $(this.video).css({ width: width, height: height, display: 'block' }).attr({
        src: src,
        'controls': 'controls',
        'autoplay': 'autoplay',
        'playsinline': 'playsinline'
      });

      //父容器
      this.$videoWrap.append(this.$videoNode);
      this.$container.append(this.$videoWrap);
    }

    /*初始化事件*/

  }, {
    key: '_initEvent',
    value: function _initEvent(options) {
      var _this = this;

      /*开始播放*/
      this._start = function () {
        _this.play();
        //防止播放错误时播放界面闪现
        _this.$videoWrap.css('visibility', 'visible');
      };

      /*如果是启动视频直接清理*/
      this._clear = function () {
        if (options.startBoot) {
          options.startBoot();
        }
        removeVideo(options.chapterId);
      };

      /*提示该视频已准备好开始播放：*/
      this.video.addEventListener('canplay', this._start, false);
      this.video.addEventListener('ended', this._clear, false);
      this.video.addEventListener('error', this._clear, false);
    }
  }, {
    key: 'play',
    value: function play() {
      //iphone手机上，系统接管后，点击完成
      //必须这样处理后，才能再次显示
      this.$videoWrap.show();
      this.video.play();
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.video.pause();
      //妙妙学只需要停止
      if (!window.MMXCONFIG) {
        this.$videoWrap.hide();
        //用于首页启动视频
        if (this.options.startBoot) {
          this.options.startBoot();
          this.destroy();
        }
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.stop();
      this.video.removeEventListener('canplay', this._start, false);
      this.video.removeEventListener('ended', this._clear, false);
      this.video.removeEventListener('error', this._clear, false);
      this.$videoWrap.remove();
      this.$videoNode = null;
      this.$videoWrap = null;
      this.$container = null;
      this.options.container = null;
      this.video = null;

      /*延时1000后改变，因为视频关闭后复位，会引发浏览器翻转事件*/
      setTimeout(function () {
        Xut.Application.PlayHTML5Video = false;
      }, 1000);
    }
  }]);
  return HTML5Player;
}();

var pixelRatio = window.devicePixelRatio;
var resolution = window.screen;

/**
 * 安卓phonegap播放器
 */

var PhoneGapMedia$1 = function () {
  function PhoneGapMedia(options) {
    classCallCheck(this, PhoneGapMedia);


    //如果是读库或者妙妙学
    var url = window.MMXCONFIG || window.DUKUCONFIG ? options.url
    //如果是纯apk模式
    : options.url.substring(0, options.url.lastIndexOf('.'));

    this.url = getFilePath(url);

    //如果是安卓平台，视频插件去的分辨率
    //所以这里要把 可以区尺寸，转成分辨率
    //读库强制全屏
    if (window.DUKUCONFIG) {
      this.width = resolution.width;
      this.height = resolution.height;
      this.top = 0;
      this.left = 0;
    } else {
      //正常的是按照屏幕尺寸的
      //这是安卓插件问题,按照分辨率计算
      this.width = options.width * pixelRatio;
      this.height = options.height * pixelRatio;
      this.left = options.left * pixelRatio || 0;
      this.top = options.top * pixelRatio || 0;
    }

    this.play();
  }

  createClass(PhoneGapMedia, [{
    key: 'play',
    value: function play() {
      Xut.Plugin.VideoPlayer.play(function () {
        console.log('success');
      }, function () {
        console.log('fail');
      }, this.url, 1, this.left, this.top, this.height, this.width);
    }
  }, {
    key: 'stop',
    value: function stop() {
      Xut.Plugin.VideoPlayer.close();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.stop();
    }
  }]);
  return PhoneGapMedia;
}();

/**
 * 网页
 * @param {[type]} options [description]
 */

var WebPage = function () {
  function WebPage(options) {
    classCallCheck(this, WebPage);


    var pageUrl = options.pageUrl;

    this.container = getContainer(options);

    //跳转app市场
    //普通网页是1
    //跳转app市场就是2
    if (options.hyperlink == 2) {
      //跳转到app市场
      window.open(pageUrl);
      //数据统计
      $.get('http://www.appcarrier.cn/index.php/adplugin/recordads?aid=16&esbId=ios');
    } else {

      var padding = options.padding || 0,
          width = options.width,
          height = options.height,
          videoId = options.videoId,
          left = options.left,
          top = options.top,
          eleWidth,
          eleHeight;

      if (padding) {
        eleWidth = width - 2 * padding;
        eleHeight = height - 2 * padding;
      } else {
        eleWidth = width;
        eleHeight = height;
      }

      this.$videoNode = $('<div id="videoWrap_' + videoId + '" style="position:absolute;left:' + left + 'px;top:' + top + 'px;width:' + width + 'px;height:' + height + 'px;z-index:' + Xut.zIndexlevel() + '">' + '<div style="position:absolute;left:' + padding + 'px;top:' + padding + 'px;width:' + eleWidth + 'px;height:' + eleHeight + 'px;">' + '<iframe src="' + pageUrl + '" style="position:absolute;left:0;top:0;width:100%;height:100%;"></iframe>' + '</div>' + '</div>');

      this.container.append(this.$videoNode);

      this.play();
    }
  }

  createClass(WebPage, [{
    key: 'play',
    value: function play() {
      this.$videoNode && this.$videoNode.show();
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.$videoNode && this.$videoNode.hide();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.$videoNode) {
        this.$videoNode.remove();
        this.$videoNode = null;
      }
      this.container = null;
    }
  }]);
  return WebPage;
}();

var VideoPlayer = void 0;

//浏览器平台
if (Xut.plat.isBrowser) {
  // 安卓手机浏览器全屏问题太多,默认全屏回去的时候会顶出来
  // 苹果手机初始化有一个白色的圆，控制条丢失
  if (Xut.plat.isIOS || Xut.plat.isAndroid) {
    VideoPlayer = FlarePlayer;
  } else {
    //pc播放器一律采用FlarePlayer
    //因为秒秒学的浮动工具栏的问题，导致默认播放器不能改控制条的高度
    //所以默认都用一个统一了
    VideoPlayer = FlarePlayer;
  }
} else {
  //apk ipa
  if (Xut.plat.isIOS || top.EduStoreClient) {
    //如果是ibooks模式
    if (Xut.IBooks.Enabled) {
      VideoPlayer = FlarePlayer;
    } else {
      //如果是ios或读酷pc版则使用html5播放
      VideoPlayer = FlarePlayer;
    }
  } else if (Xut.plat.isAndroid) {
    if (window.MMXCONFIG) {
      // 安卓妙妙学强制走h5
      // 由于原生H5控制条不显示的问题
      VideoPlayer = FlarePlayer;
    } else {
      //android平台
      VideoPlayer = PhoneGapMedia$1;
    }
  }
}

var VideoClass = function () {
  function VideoClass(options) {
    classCallCheck(this, VideoClass);

    switch (options.category) {
      case 'video':
        this.video = new VideoPlayer(options, removeVideo);
        break;
      case 'webpage':
        this.video = new WebPage(options, removeVideo);
        break;
      default:
        console.log('options.category must be video or webPage ');
        break;
    }
    Xut.View.Toolbar("hide");
  }

  createClass(VideoClass, [{
    key: 'play',
    value: function play() {
      Xut.View.Toolbar("hide");
      this.video.play();
    }
  }, {
    key: 'stop',
    value: function stop() {
      Xut.View.Toolbar("show");
      this.video.stop();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.video.destroy();
    }
  }]);
  return VideoClass;
}();

/*
    视频和远程网页管理模块
*/
var playBox$1 = void 0;

/*
初始化盒子
1 当前页面包含的视频数据
2 播放过的视频数据 （播放集合)
 */
var initBox$1 = function initBox() {
  playBox$1 = hash();
};

/**
 * 配置视频结构
 */
var deployVideo = function deployVideo(videoData, options, columnData) {
  var palyData = {};
  var chapterId = options.chapterId,
      activityId = options.activityId,
      pageIndex = options.pageIndex,
      pageType = options.pageType;


  if (columnData) {
    /*width, height, top, left, zIndex, url*/
    _.extend(palyData, {
      width: '100%',
      height: '100%',
      top: 0,
      left: 0,
      zIndex: 1,
      chapterId: chapterId,
      container: columnData.container,
      url: columnData.fileName,
      isColumn: columnData.isColumn,
      position: columnData.position,
      category: 'video'
    });
  } else {
    var getStyle = Xut.Presentation.GetPageStyle(pageIndex);
    var layerSize = setProportion({
      getStyle: getStyle,
      proportion: getStyle.pageProportion,
      width: videoData.width || config.visualSize.width,
      height: videoData.height || config.visualSize.height,
      left: videoData.left,
      top: videoData.top,
      padding: videoData.padding
    });
    _.extend(palyData, layerSize, {
      pageType: pageType,
      chapterId: chapterId,
      isfloat: videoData.isfloat, //是否浮动
      'videoId': activityId,
      'url': videoData.md5,
      'pageUrl': videoData.url,
      'zIndex': videoData.zIndex || 2147483647,
      'background': videoData.background,
      'category': videoData.category,
      'hyperlink': videoData.hyperlink
    });
  }

  return palyData;
};

/*
装配数据
 */
var assemblyData$1 = function assemblyData(options) {
  /*column处理*/
  if (options.columnData && options.columnData.isColumn) {
    return deployVideo({}, options, options.columnData);
  } else {
    //新的查询
    var videoData = Xut.data.query('Video', options.activityId);
    return deployVideo(videoData, options);
  }
};

/**
 * 加载视频
 */
var createVideo = function createVideo(options, videoData) {
  var chapterId = options.chapterId,
      activityId = options.activityId,
      rootNode = options.rootNode;

  /*如果已经存在，直接调用播放*/

  if (playBox$1[chapterId] && playBox$1[chapterId][activityId]) {
    playBox$1[chapterId][activityId].play();
  } else {
    if (!_.isObject(playBox$1[chapterId])) {
      playBox$1[chapterId] = {};
    }
    if (rootNode) {
      videoData.container = rootNode;
    }
    playBox$1[chapterId][activityId] = new VideoClass(videoData);
  }
};

/**
 * 初始化视频
 */
var initVideo$1 = function initVideo(options) {
  //解析数据
  var videoData = assemblyData$1(options);
  //调用播放
  createVideo(options, videoData);
};

/**
 * 是否有视频对象
 * @return {Boolean} [description]
 */
function hasVideoObj(chapterId, activityId) {
  if (playBox$1[chapterId]) {
    return playBox$1[chapterId][activityId];
  }
}

/*播放视频
1 存在实例
2 重新创建
{ chapterId, activityId, rootNode, pageIndex, pageType }
*/
function playVideo(options) {
  var videoObj = hasVideoObj(options.chapterId, options.activityId);
  if (videoObj) {
    videoObj.play();
  } else {
    initVideo$1(options);
  }
}

function getPlayBox$1() {
  return playBox$1;
}

/*
初始化视频
 */
function initVideo() {
  initBox$1();
}

/**
 * 自动播放
 */
function autoVideo() {
  playVideo.apply(undefined, arguments);
}

/**
 * 手动播放
 */
function triggerVideo() {
  playVideo.apply(undefined, arguments);
}

/**
 * 清理移除指定页的视频
 */
function removeVideo(chapterId) {
  var playBox = getPlayBox$1();
  //清理视频
  if (playBox && playBox[chapterId]) {
    for (var activityId in playBox[chapterId]) {
      playBox[chapterId][activityId].destroy();
      playBox[chapterId][activityId] = null;
    }
    delete playBox[chapterId];
  }
}

/**
 * 清理全部视频
 */
function clearVideo() {
  var playBox = getPlayBox$1();
  var flag = false; //记录是否处理过销毁状态
  for (var chapterId in playBox) {
    for (var activityId in playBox[chapterId]) {
      playBox[chapterId][activityId].destroy();
      flag = true;
    }
  }
  initBox$1();
  return flag;
}

/**
 * 抽象管理接口
 * @return {[type]} [description]
 */
var ManageSuper = function () {
  function ManageSuper() {
    classCallCheck(this, ManageSuper);

    //初始化容器
    this.pageBaseGroup = {};

    /*数据快速获取接口，首字母直接大写的快捷方式*/
    this.$$GetPageId = this.$$getPageId;
    this.$$GetPageNode = this.$$getPageNode;
    this.$$GetPageData = this.$$getPageData;
    this.$$GetPageBase = this.$$getPageBase;
  }

  //===============================
  //    提供给子子类使用的私有方法
  //===============================

  /**
   * 增加合集管理
   */


  createClass(ManageSuper, [{
    key: '_$$addBaseGroup',
    value: function _$$addBaseGroup(pageIndex, pageObj) {
      this.pageBaseGroup[pageIndex] = pageObj;
    }

    /**
     * 得到页面合集
     */

  }, {
    key: '_$$getBaseGroup',
    value: function _$$getBaseGroup() {
      return this.pageBaseGroup;
    }

    /**
     * 删除合集管理
     */

  }, {
    key: '_$$removeBaseGroup',
    value: function _$$removeBaseGroup(pageIndex) {
      delete this.pageBaseGroup[pageIndex];
    }

    /**
     * 销毁合集
     */

  }, {
    key: '_$$destroyBaseGroup',
    value: function _$$destroyBaseGroup() {
      var k = void 0,
          pageBaseGroup = this.pageBaseGroup;
      for (k in pageBaseGroup) {
        pageBaseGroup[k].baseDestroy();
      }
      this.pageBaseGroup = null;
    }

    //===============================
    //    提供外部调用方法
    //===============================

    /**
     * 合并处理
     */

  }, {
    key: 'assistPocess',
    value: function assistPocess(pageIndex, callback) {
      var pageObj;
      if (pageObj = this.$$getPageBase(pageIndex, this.pageType)) {
        if (callback) {
          callback(pageObj);
        } else {
          return pageObj;
        }
      }
    }

    /**
     * 执行辅助对象事件
     */

  }, {
    key: 'assistAppoint',
    value: function assistAppoint(activityId, currIndex, outCallBack, actionName, contentId) {
      var pageObj;
      if (pageObj = this.$$getPageBase(currIndex)) {
        return pageObj.baseAssistRun(activityId, outCallBack, actionName, contentId);
      }
    }

    //===============================
    //    提供外部调用与子类使用
    //===============================

    /////////////////////////////////
    //  "GetPageId",
    //  "GetPageNode",
    //  "GetPageData",
    //  "GetPageBase"
    //////////////////////////////////

    /**
     * 获取页面容器ID
     * chpaterID
     * masterID
     * @return {[type]} [description]
     */

  }, {
    key: '$$getPageId',
    value: function $$getPageId(pageIndex, pageType) {
      var key = pageType === 'page' ? '_id' : 'pptMaster';
      return this.$$getPageData(pageIndex, key, pageType);
    }

    /**
     * 得到页面的nodes数据
     */

  }, {
    key: '$$getPageNode',
    value: function $$getPageNode(pageIndex, pageType) {
      return this.$$getPageData(pageIndex, 'nodes', pageType);
    }

    /**
     * 找到页面对象
     * 1.页面直接pageIndex索引
     * 2.母版通过母版Id索引
     * @return {[type]} [description]
     */

  }, {
    key: '$$getPageBase',
    value: function $$getPageBase(pageIndex, pageType) {
      pageType = pageType || this.pageType;
      //模板传递的可能不是页码
      if (pageType === 'master') {
        //如果不是母版ID，只是页码
        if (!/-/.test(pageIndex)) {
          //转化成母版id
          pageIndex = this.converMasterId(pageIndex);
        }
      }
      return this.pageBaseGroup && this.pageBaseGroup[pageIndex];
    }

    /**
     * 获取页面数据
     */

  }, {
    key: '$$getPageData',
    value: function $$getPageData(pageIndex, key, pageType) {
      var pageObj;
      //如果传递key是 pageType
      if (!pageType && key == 'page' || key == 'master') {
        pageType = key;
        key = null;
      }
      if (pageObj = this.$$getPageBase(pageIndex, pageType)) {
        return key ? pageObj.chapterData[key] : pageObj.chapterData;
      }
    }
  }]);
  return ManageSuper;
}();

/**
 * 拖拽类
 */
var _class = function () {
  function _class(dragElement, dropElement, autoReturn, dragCallback, dropCallback, container, throwProps) {
    classCallCheck(this, _class);


    this.dragElement = dragElement;
    this.defaultPoint = null;
    this.dropElement = dropElement;
    this.autoReturn = autoReturn >= 1 ? true : false; //1:自动返回(true) 0:留在原地(false)
    this.dragCallback = typeof dragCallback == "function" ? dragCallback : null;
    this.dropCallback = typeof dropCallback == "function" ? dropCallback : null;
    this.throwProps = throwProps == false || this.autoReturn ? false : true;
    this.container = container;
    this.dragElement.attr("data-defaultindex", this.dragElement.css("z-index"));
    //this.dragObject = null; //创建的拖拽对象实例
    var isInit = this.dragElement.attr("data-DragDrop");
    if (isInit == null) {
      this.init();
      this.dragElement.attr("data-DragDrop", true);
    } else {
      console.log("This element has binding DragDropClass.");
    }
  }

  /**
   * 初始化拖拽
   * @return {[type]} [description]
   */


  createClass(_class, [{
    key: "init",
    value: function init() {
      if (this.dragObject != null) return;

      var self = this;

      //now make both boxes draggable.
      var dragObject = this.dragObject = Draggable.create(this.dragElement, {
        bounds: this.container,
        dragResistance: 0,
        edgeResistance: 0.8,
        type: "left,top", //rotation、scroll(x+y模式与PPT动画冲突)
        force3D: false, //是否启用硬件加速(left+top模式无需启用，启用后存在闪现问题)
        throwProps: this.throwProps,
        snap: {
          left: function left(endValue) {
            return endValue;
          },
          top: function top(endValue) {
            return endValue;
          }
        },
        onDragStart: function onDragStart(e) {
          //获取拖拽对象原始参数
          var defaultOffset = self.dragElement.offset();
          self.defaultPoint = {
            x: defaultOffset.left,
            y: defaultOffset.top,
            left: Number(self.dragElement.css("left").replace("px", "")),
            top: Number(self.dragElement.css("top").replace("px", ""))
          };
          if (self.dragCallback) self.dragCallback();
        },
        onDragEnd: function onDragEnd(e) {
          var dropElement = self.dropElement,
              isEnter = false; //是否进入目标

          //目标元素可见才可以拖拽成功
          if (dropElement && dropElement[0].style.visibility != "hidden") {
            //获取拖拽对象当前参数
            var fromOffset = self.dragElement.offset();
            var fromPoint = {
              x: fromOffset.left,
              y: fromOffset.top,
              w: self.dragElement.width(),
              h: self.dragElement.height()
              //获取目标对象参数
            };var toOffset = dropElement.offset();
            var toPoint = {
              x: toOffset.left,
              y: toOffset.top,
              w: dropElement.width(),
              h: dropElement.height()
            };
            //目标对象中心点
            var targetCenter = {
              pointerX: toPoint.x + toPoint.w / 2,
              pointerY: toPoint.y + toPoint.h / 2
            };
            //拖拽点位于目标框中或目标中心点位于拖拽框中视为拖拽成功
            if (dragObject.pointerX > toPoint.x && dragObject.pointerX < toPoint.x + toPoint.w && dragObject.pointerY > toPoint.y && dragObject.pointerY < toPoint.y + toPoint.h) {
              isEnter = true;
              dragObject.disable();
            } else if (targetCenter.pointerX > fromPoint.x && targetCenter.pointerX < fromPoint.x + fromPoint.w && targetCenter.pointerY > fromPoint.y && targetCenter.pointerY < fromPoint.y + fromPoint.h) {
              isEnter = true;
              dragObject.disable();
            }
            //拖拽成功
            if (isEnter == true) {
              //结束后恢复层级关系
              // self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));

              //拖拽对象与目标对象中心点差
              var moveX = targetCenter.pointerX - (self.defaultPoint.x + fromPoint.w / 2);
              var moveY = targetCenter.pointerY - (self.defaultPoint.y + fromPoint.h / 2);
              //拖拽对象最终停放位置
              var newLeft = self.defaultPoint.left + moveX;
              var newTop = self.defaultPoint.top + moveY;
              //自动拖拽到位
              TweenLite.to(self.dragElement, 0.30, {
                css: {
                  left: newLeft,
                  top: newTop
                },
                ease: Expo.easeOut
              });
            } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
              css: {
                left: self.defaultPoint.left,
                top: self.defaultPoint.top
              }
            });
          } else if (self.autoReturn) TweenLite.to(self.dragElement, 0.70, {
            css: {
              left: self.defaultPoint.left,
              top: self.defaultPoint.top
            }
          });
          //不管是否存在拖拽目标元素 拖拽成功与否最后还原成原来的z-index
          self.dragElement.css("z-index", self.dragElement.attr("data-defaultindex"));
          //调用结束事件
          if (self.dropCallback) self.dropCallback(isEnter);
        }
      })[0];
    }

    /**
     * 复位动画与状态
     * @return {[type]} [description]
     */

  }, {
    key: "reset",
    value: function reset() {
      var self = this;
      var dragObject;
      if (dragObject = this.dragObject) {
        dragObject.enable();
        if (self.defaultPoint) {
          self.dragElement.css("left", self.defaultPoint.left);
          self.dragElement.css("top", self.defaultPoint.top);
        }
        /*TweenLite.to(self.dragElement, 0, {
            css: {
                x: 0,
                y: 0
            }
        });*/
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      var dragObject;
      if (dragObject = this.dragObject) {
        dragObject.disable();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.dragObject && this.dragObject.kill();
      this.dropElement = null;
      this.dragElement = null;
      this.dragObject = null;
    }
  }]);
  return _class;
}();

/////////////////
/// tap click
/////////////////
/**
 * ie10下面mouse事件怪异
 * @return {Boolean} [description]
 */
var isIE10 = document.documentMode === 10;

/**
 * 针对canvas模式
 * 特殊的hack
 * 当前点击的元素是滑动元素
 * 处理元素的全局事件
 */
function setCanvasStart(supportSwipe) {
  Xut.Contents.Canvas.Reset();
  Xut.Contents.Canvas.SupportSwipe = supportSwipe;
  Xut.Contents.Canvas.isTap = true;
}

function setCanvasMove() {
  Xut.Contents.Canvas.isSwipe = true;
}

/**
 * 如果是简单的点击事件
 */
function simpleEvent(eventName, eventContext, eventHandle, supportSwipe) {

  //仅仅只是单击处理
  //IE10是不支持touch事件，直接绑定click事件
  var onlyClick = isIE10 || eventName === 'click';
  eventContext = eventContext[0];

  //是否触发
  var hasTap = false;
  //开始坐标
  var startPageX = void 0;

  hasTap = false;

  //这里单独绑定事件有个问题,单击move被触发
  //如果停止e.stopPropagation，那么默认行为就不会被触发
  //你绑定单击的情况下可以翻页
  //这里通过坐标的位置来判断
  var start = function start(e) {
    var point = $event(e);
    //记录开始坐标
    startPageX = point.pageX;
    //是否是tap事件
    hasTap = true;
    setCanvasStart(supportSwipe);
  };

  var move = function move(e) {
    if (!hasTap) {
      return;
    }
    var point = $event(e);
    var deltaX = point.pageX - startPageX;

    //如果有move事件，则取消tap事件
    /*三星S6上就算不移动也会给一个-0.6左右的值，所以这里强制加20PX的判断*/
    if (Math.abs(deltaX) > 5) {
      hasTap = false;
      setCanvasMove(supportSwipe);
    }
  };

  var end = function end() {
    hasTap && eventHandle();
  };

  if (eventName === 'tap') {
    $on(eventContext, {
      start: start,
      move: move,
      end: end,
      cancel: end
    });
  } else if (onlyClick) {
    hasTap = true;
    $on(eventContext, {
      end: end
    });
  }

  return {
    off: function off() {
      if (eventContext) {
        $off(eventContext);
        eventContext = null;
      }
    }
  };
}

/**
 * 优化hammer创建,生成必要配置文件
 * @return {[type]} [description]
 */
function createRecognizers(eventName) {
  var recognizers = [];
  switch (eventName) {
    //如果是swipe处理
    case 'swipeleft':
    case 'swiperight':
    case 'swipeup':
    case 'swipedown':
      var direction = Hammer.DIRECTION_HORIZONTAL;
      if (eventName === 'swipeup' || eventName === "swipedown") {
        direction = Hammer.DIRECTION_VERTICAL;
      }
      recognizers.push([Hammer.Swipe, { 'direction': direction, 'velocity': 0.01 }]);
      break;
    case 'doubletap':
      //双击
      recognizers.push([Hammer.Tap]);
      recognizers.push([Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]);
      break;
    case 'press':
      //长按
      recognizers.push([Hammer.Press]);
      return;
  }
  return recognizers;
}

/**
 * 创建hammer引用
 * @return {[type]}         [description]
 */
function createHammer(eventContext, eventName, supportSwipe) {
  var eventReference;
  var context = eventContext[0];
  var recognizer = createRecognizers(eventName);
  if (recognizer && recognizer.length) {
    eventReference = Hammer(context, {
      'recognizers': recognizer
    });
  } else {
    eventReference = Hammer(context);
  }
  return eventReference;
}

/**
 * 复杂的事件
 * @return {[type]} [description]
 */
function complexEvent(eventContext, eventName, eventHandler, supportSwipe) {
  var eventReference = createHammer(eventContext, eventName, supportSwipe);
  eventReference.on(eventName, function () {
    eventHandler();
  });
  return eventReference;
}

/**
 * ppt事件接口
 *
 * 允许用户自定义其行为
 *     1 支持14种操作行为
 *     2 默认对象都具有滑动翻页的特性
 *     3 翻页的特性在遇到特性的情况可以被覆盖
 *     比如
 *         行为1：用户定义该名字可以支持  click 点击行为， 那么该元素左右滑动能过翻页
 *         行为2：用户如果定义swipeLeft 行为，该元素左右滑动将不会翻页，因为默认翻页已经被覆盖
 *
 * 此接口函数有作用域隔离
 */
/**
 * 事件类型
 * @type {Array}
 * 0 null
 * 1 auto
 * 2 tap
 * 3 drag
 * 4 dragTag
 * .........
 */
var eventName = ['null', 'auto', 'tap', 'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown', 'doubletap', 'press', 'pinchout', 'pinchin', 'rotate', 'assist'];

/**
 * 重写默认事件
 *
 * Content对象默认具有左右翻页的特性
 * 根据过滤来选择是否覆盖重写这个特性
 * 比如 用户如果遇到 swipeLeft，swipeRight 这种本身与翻页行为冲突的
 * 将要覆盖这个行为
 * 过滤事件
 * 如果用户指定了如下操作行为,将覆盖默认的翻页行为
 **/
var filterEvent = ['drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'];

/**
 * 是否过滤
 * @param  {[type]} evtName [description]
 * @return {[type]}         [description]
 */
var isfilter = function isfilter(eventName) {
  return filterEvent.indexOf(eventName) === -1 ? true : false;
};

/**
 * 特性摘除
 * 1 ：无事件，默认可以翻页，还可以切换工具栏
 * 2 ：静态事件，默认可以翻页
 * 3 : 冲突事件，默认删除
 * 去除默认元素具有的翻页特性
 * @param  {[type]} evtName [事件名]
 * @return {[type]}         [description]
 */
var setDefaultBehavior = function setDefaultBehavior(supportSwipe, $contentNode) {
  if (supportSwipe) {
    //静态事件，默认可以翻页，还可以切换工具栏
    $contentNode.attr('data-behavior', 'swipe');
  } else {
    //如果事件存在
    $contentNode.attr('data-behavior', 'disable');
  }
};

/**
 * 针对软件培训的操作行为下光标状态需求
 */
var addCursor = function addCursor(eventName, $contentNode) {
  if ($contentNode) {
    if (!$contentNode.prop('setCursor')) {
      //只设置一次
      if (eventName === ('drag' || 'dragTag')) {
        $contentNode.css('cursor', 'Move');
      } else {
        $contentNode.css('cursor', 'Pointer');
      }
      $contentNode.prop('setCursor', 'true');
    }
  }
};

/**
 *  绑定事件
 * @param  {[type]} eventDrop [description]
 * @param  {[type]} data      [description]
 * @return {[type]}           [description]
 */
var _bind = function _bind(eventDrop, data) {
  var dragObj = void 0;
  var handler = void 0;
  var reference = void 0;
  var eventContext = data.eventContext;
  var eventName = data.eventName;
  var supportSwipe = data.supportSwipe;

  if (eventName === 'drag') {
    //拖动
    dragObj = new _class(eventContext, null, data.parameter, eventDrop.startRun, eventDrop.stopRun);
  } else if (eventName === 'dragTag') {
    //拖拽
    dragObj = new _class(eventContext, data.target, 1, eventDrop.startRun, eventDrop.stopRun);
  } else {
    handler = function handler() {
      data.eventRun.call(eventContext);
    };
    /////////////////
    /// tap click
    /////////////////
    if (eventName === 'tap' || eventName === 'click') {
      reference = simpleEvent(eventName, eventContext, handler, supportSwipe);
    }
    //复杂用hammer
    else {
        reference = complexEvent(eventContext, eventName, handler, supportSwipe);
      }
  }

  return {
    dragObj: dragObj,
    reference: reference,
    handler: handler
  };
};

/**
 * /匹配事件
 * parameter 参数
 * 1：对于自由拖动drag，para参数为0，表示松手后，停留在松手的地方
 *                    para参数为1，表示松手后，返回原来的位置
 * 2: 对于拖拽dragTag， para表示目标对象的target
 */
function distribute(data) {
  //针对软件培训的操作行为下光标状态需求
  Xut.plat.isBrowser && data.domMode && addCursor(data.eventName, data.eventContext);

  //绑定事件
  var eventDrop = data.eventDrop;

  //拖动,引用,回调
  var eventObj = _bind(eventDrop, data);

  //拖动,拖拽对象处理
  if (eventObj.dragObj && eventDrop.init) {
    eventDrop.init(eventObj.dragObj);
    return;
  }
  //其余事件
  data.eventHandler(eventObj.reference, eventObj.handler);
}

//数据库预定义14个事件接口
//提供给content文件
//用于过滤数据库字段指定的行为
//https://github.com/EightMedia/hammer.js/wiki/Getting-Started
//2014.3.18 新增assist 辅助对象事件
function conversionEventType(eventType) {
  return eventName[Number(eventType) - 1] || null;
}

/**
 * 增加默认行为
 */


/**
 * 注册自定义事件
 * this还是引用的当前实例的上下文
 *
 *   '$contentNode'   : 事件对象
 *   'target'    : 目标对象
 *   'parameter' : 拖动参数
 *   'evtName'   : 事件名,
 *
 *   callbackHook 回调函数 ,处理具体的事情
 */
function bindContentEvent(data) {
  //是否支持翻页
  var supportSwipe = data.supportSwipe = isfilter(data.eventName);
  //检测是否移除元素的默认行为,因为元素都具有翻页的特性
  if (data.domMode) {
    setDefaultBehavior(supportSwipe, data.eventContext);
  }
  distribute(data);
}

/**
 * 销毁对象事件
 */
function destroyContentEvent(eventRelated, eventName) {
  if (eventRelated.eventReference) {
    eventRelated.eventReference.off(eventName || eventRelated.eventName, eventRelated.eventHandler);
    eventRelated.eventReference = null;
    eventRelated.eventHandler = null;
  }
}

/**
 * 多事件模块
 */
/**
 * 获取对应的activity对象
 * @param  {[type]}   activityId [description]
 * @param  {Function} callback   [description]
 * @return {[type]}              [description]
 */
var getActivity = function getActivity(activityId, callback) {
  var activity;
  if (activity = this.activityGroup) {
    _.each(activity.get(), function (contentObj, index) {
      if (activityId == contentObj.activityId) {
        callback(contentObj);
        return;
      }
    }, this);
  }
};

/**
 * 制作一个处理绑定函数
 * @param  {[type]} pagebase [description]
 * @return {[type]}          [description]
 */
var makeRunBinding = function makeRunBinding(pagebase) {
  var registers = this.registers;
  var shift;
  return function () {
    var activityId = registers[0];
    getActivity.call(pagebase, activityId, function (activityObj) {
      activityObj.runAnimation(function () {
        shift = registers.shift();
        registers.push(shift);
      });
    });
  };
};

/**
 * 多事件处理
 * 每次通过同一个热点,触发不同的对象操作
 * @return {[type]} [description]
 */
var combineEvents = function combineEvents(pagebase, eventRelated) {
  var contentObj, eventName;
  //多条activty数据,一个对象上多事件
  _.each(eventRelated, function (edata) {
    _.each(edata, function (scope) {
      contentObj = pagebase.baseGetContentObject(scope.eventContentId);
      if (!contentObj) {
        // console.log('error', 'pagebase.js第' + pagebase.pageIndex + '页多事件处理出错!!!!')
        return;
      }
      eventName = conversionEventType(scope.eventType);
      //制动运行动作
      scope.runAnimation = makeRunBinding.call(scope, pagebase);
      //销毁方法
      scope.destroy = function () {
        destroyContentEvent(scope, eventName);
        scope.registers = null;
        scope.runAnimation = null;
      };

      //事件绑定
      bindContentEvent({
        'eventRun': function eventRun() {
          scope.runAnimation();
        },
        'eventHandler': function eventHandler(eventReference, _eventHandler) {
          scope.eventReference = eventReference;
          scope.eventHandler = _eventHandler;
        },
        'eventContext': contentObj.$contentNode,
        'eventName': eventName,
        'parameter': scope.dragdropPara,
        'target': null,
        'domMode': true
      });
    });

    //暴露引用
    pagebase.divertorHooks.registerEvent = eventRelated;
  });
};

function create(pagebase, eventRelated) {
  combineEvents(pagebase, eventRelated);
}

function destroy(pagebase) {
  var registerEvent = pagebase.divertorHooks.registerEvent;
  if (registerEvent) {
    _.each(registerEvent, function (edata) {
      _.each(edata, function (obj) {
        obj.destroy && obj.destroy();
      });
    });
    pagebase.divertorHooks.registerEvent = null;
  }
}

/**
 * 处理合集
 */
function Collection() {
  this.remove();
}

Collection.prototype = {

  /*加入合集*/
  add: function add(obj) {
    if (!this._group) {
      this._group = [obj];
    } else {
      this._group.push(obj);
    }
  },


  /*得到合集*/
  get: function get() {
    return this._group;
  },


  /**
   * 是否存在
   */
  isExist: function isExist() {
    return this._group.length;
  },

  /**
   * 得到一个指定的实例
   */
  specified: function specified(data) {
    var instance = void 0;
    var length = this._group.length;
    while (length) {
      length--;
      if (instance = this._group[length]) {
        if (instance.type === data.type && instance.id === data.id) {
          return instance;
        }
      }
    }
  },
  remove: function remove() {
    this._group = [];
  },
  reset: function reset() {
    this.remove();
  }
};

/**
 * 根据指定的chpaterId解析
 * @return {[type]} [description]
 */
function scenarioChapter(chapterId) {
  var chapterSection = Xut.data.chapterSection;
  var rang = chapterSection['seasonId->' + chapterId];
  return rang;
}

/**
 * 递归分解
 * chpater直接对应页面的ID编码，直接去下标即可
 * waitCreatePointer     需要分解的页面
 */
function parseChapter(createPointer) {

  var points = createPointer.length;
  var chapter = void 0,
      key = void 0;
  var dataChpater = Xut.data.Chapter;

  //如果是合集
  if (points) {
    var chapterDataset = [];
    while (points--) {
      key = createPointer[points];
      if (chapter = dataChpater.item(key)) {
        chapterDataset.unshift(chapter);
      }
    }
    return chapterDataset;
  } else {
    //独立的索引号
    return dataChpater.item(createPointer);
  }
}

/**
 * 解析视觉差的数据
 * @param  {[type]}   data     [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 */
function getMasterData(data, callback) {
  var pptMaster = data['pptMaster'];
  var masterData = Xut.data.query('Master', pptMaster);
  makeActivitys(masterData, function (activitys, autoData) {
    callback(masterData, activitys, autoData);
  });
}

/**
 * 解析出页面自动运行的数据
 * autoplay && !Content
 * @param  {[type]} activitys [description]
 * @return {[type]}           [description]
 */
function makeAuto(activityData) {

  if (!activityData || !activityData.length) return;

  var sub = void 0;
  //自动热点
  var collectAutoBuffers = [];

  activityData.forEach(function (target, b) {
    //如果是自动播放,并且满足自定义条件
    //并且不是content类型
    if (target.autoPlay && target.actType !== 'Content') {
      //增加note提示信息数据
      // id = target._id
      // key = target.actType ? target.actType + "_" + id : 'showNote_' + id
      sub = {
        'id': target._id,
        'actType': target.actType,
        'category': target.category,
        'autoPlay': target.autoPlay
      };
      collectAutoBuffers.push(sub);
    }
  });

  return collectAutoBuffers.length && collectAutoBuffers;
}

/**
 * 混入shownote
 * 组合showNote数据,弹出信息框,也看作一个热点
 * shownote是chater的信息，混入到activity列表中当作每页的对象处理
 * @return {[type]} [description]
 */
function mixShowNote(oneChapter, activityData) {
  if (oneChapter.note) {
    activityData.push(oneChapter);
  }
}

/**
 * 制作activity表的数据
 * chpaters = {
 *     pageIndex-12: Object
 *     pageIndex-13: Object
 *     pageIndex-14: Object
 *  }
 **/
function makeActivitys(chapterData, callback) {
  if (!chapterData) callback();

  var activitys = [];
  var chapterId = chapterData._id;

  Xut.data.query('Activity', chapterId, 'chapterId', function (item) {
    activitys.push(item);
  });

  //混入文本提示框
  mixShowNote(chapterData, activitys);

  //自动运行的数据
  //解析出每一页自动运行的 Widget,Action,Video数据
  var autoData = makeAuto(activitys);

  callback(activitys, autoData);
}

/**
 * 解析关联的Activity表数据
 * @param  {[type]}   pageData [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 */
function getActivitys(chapterData, callback) {
  makeActivitys(chapterData, function (activitys, autoData) {
    callback(chapterData, activitys, autoData);
  });
}

/**
 * 1 解析chapter页面数据
 * 2 解析对应的Activity数据
 * 3 解析出自动widget数据结构
 * @param  {[type]}   data     [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 */
function getPageData(data, callback) {
  var parsePointer = data.pageIndex;
  var chapterData = data.pageData;
  if (chapterData) {
    getActivitys(chapterData, callback);
  } else {
    //解析章节数据
    parseChapter(parsePointer, function (chapter) {
      //生成chapter数据
      getActivitys(chapter.length ? chapter[0] : chapter, callback);
    });
  }
}

/**
 * 查询接口
 * @param  {[type]}   tableName [description]
 * @param  {[type]}   options   [description]
 * @param  {Function} callback  [description]
 * @return {[type]}             [description]
 */
function query(tableName, options, callback) {
  switch (tableName) {
    case 'page':
      //得到页面关联的数据
      return getPageData(options, callback);
    case 'master':
      //得到母版关联的数据
      return getMasterData(options, callback);
    case 'chapter':
      //得到chapter表数据
      return parseChapter(options);
    case 'scenarioChapter':
      return scenarioChapter(options);
  }
}

/*
更新数据缓存
1 activitys
2 auto
3 activitys
 */
function syncCache(base, callback) {

  var pageType = base.pageType;

  /*缓存数据*/
  var cacheGruop = function cacheGruop(namespace, data) {
    var key = void 0;
    if (!base.dataActionGroup[namespace]) {
      base.dataActionGroup[namespace] = data;
    } else {
      for (key in data) {
        base.dataActionGroup[namespace][key] = data[key];
      }
    }
  };

  query(pageType, {
    'pageIndex': base.chapterIndex,
    'pageData': base.chapterData,
    'pptMaster': base.pptMaster
  }, function (data, activitys, autoData) {
    cacheGruop(pageType, data); //挂载页面容器数据
    cacheGruop('activitys', activitys); //挂载activitys数据
    cacheGruop('auto', autoData); //挂载自动运行数据
    callback(data);
  });
}

/**
 * 解析canvas配置
 * contentMode 分为  0 或者 1
 * 1 是dom模式
 * 0 是canvas模式
 * 以后如果其余的在增加
 * 针对页面chapter中的parameter写入 contentMode   值为 1
 * 针对每一个content中的parameter写入 contentMode 值为 1
 * 如果是canvas模式的时候，同时也是能够存在dom模式是
 * @return {[type]} [description]
 */
function parseChapterParameter(pageData, base) {
  var parameter = pageData.parameter;
  if (parameter) {
    try {
      parameter = JSON.parse(parameter);

      if (parameter) {

        //contentMode
        if (parameter.contentMode && parameter.contentMode == 1) {
          //非强制dom模式
          if (!config.debug.onlyDomMode) {
            //启动dom模式
            base.canvasRelated.enable = true;
          }
        }

        //秒秒学使用
        //lastPage如果是最后一页处理
        if (parameter.lastPage && base.pageType === 'page') {
          //运行应用运行时间
          base.runLastPageAction = function () {
            var runTime = Number(config.data.delayTime);
            var timeout = void 0;
            if (runTime) {
              timeout = setTimeout(function () {
                Xut.Application.Notify('complete');
              }, runTime * 1000); //转成秒
            }
            return function () {
              //返回停止方法
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
            };
          };
        }

        //页面属性
        //2017.11.23
        //页面属性
        //秒秒学使用 2017.11.29
        if (parameter.pageAttr) {
          base.pageAttr = parameter.pageAttr;
        }
      }
    } catch (e) {
      console.log('JSON错误,chpterId为', base.chapterId, parameter);
    }
  }
}

/**
 *  创建主容器任务片
 *  state状态
 *      0 未创建
 *      1 正常创建
 *      2 创建完毕
 *      3 创建失败
 */
var TaskContainer = function (base, pageData, taskCallback) {

  var $pageNode = void 0;
  var $pseudoElement = void 0;

  var prefix = Xut.View.GetPageNodeIdName(base.pageType, base.pageIndex, base.chapterId);
  var getStyle = base.getStyle;

  //iboosk编译
  //在执行的时候节点已经存在
  //不需要在创建
  if (Xut.IBooks.runMode()) {
    $pageNode = $("#" + prefix);
    taskCallback($pageNode, $pseudoElement);
    return;
  }

  //创建的li结构体
  $pageNode = createContainer(base, pageData, getStyle, prefix);

  Xut.nextTick({
    container: base.rootNode,
    content: $pageNode,
    position: getStyle.position === 'left' || getStyle.position === 'top' ? 'first' : 'last'
  }, function () {
    taskCallback($pageNode, $pseudoElement);
  });
};

/**
 * 创建页面容器li
 */
function createHTML(_ref) {
  var base = _ref.base,
      prefix = _ref.prefix,
      translate = _ref.translate,
      customStyle = _ref.customStyle,
      pageData = _ref.pageData,
      background = _ref.background;

  var getStyle = base.getStyle;

  //设置滑动的偏移量
  //双页面只有布局偏移量，没有滑动偏移量
  var setTranslate = translate ? Xut.style.transform + ':' + translate : '';

  //增加一个main-content放body内容
  //增加一个header-footer放溢出的页眉页脚
  return String.styleFormat('<li id="' + prefix + '"\n         data-type="' + base.pageType + '"\n         data-cix="' + base.chapterIndex + '"\n         data-container="true"\n         class="xut-flip preserve-3d"\n         style="width:' + getStyle.visualWidth + 'px;\n                height:' + getStyle.visualHeight + 'px;\n                left:' + getStyle.visualLeft + 'px;\n                top:' + getStyle.visualTop + 'px;\n                ' + setTranslate + ';\n                ' + background + '\n                ' + customStyle + '">\n        <div class="page-scale">\n            <div data-type="main-content"></div>\n            <div data-type="header-footer"></div>\n        </div>\n    </li>');
}

/**
 * 创建父容器li结构
 */
function createContainer(base, pageData, getStyle, prefix) {

  var background = '';

  //chpater有背景，不是svg格式
  if (!/.svg$/i.test(pageData.md5)) {
    background = 'background-image:url(' + getFileFullPath(pageData.md5, 'container-bg') + ');';
  }

  /**
   * 自定义配置了样式
   * 因为单页面跳槽层级的问题处理
   */
  var customStyle = '';
  var userStyle = getStyle.userStyle;
  if (userStyle !== undefined) {
    //解析自定义规则
    _.each(userStyle, function (value, key) {
      customStyle += key + ':' + value + ';';
    });
  }

  return $(createHTML({
    base: base,
    prefix: prefix,
    translate: getStyle.translate,
    customStyle: customStyle,
    pageData: pageData,
    background: background
  }));
}

/**
 *创建浮动相关的信息
 *1 activity
 *2 component
 */
function crateFloat(pageType, pipeData, divertor, baseFloatGroup, complete) {

  /*增加回调次数计算*/
  pipeData.taskCount++;

  var content = [];
  var getStyle = pipeData.getStyle;

  /*activity类型处理*/
  var makePrefix = void 0,
      fragment = void 0,
      zIndex = void 0;
  if (divertor.ids.length) {
    var zIndexs = divertor.zIndex;
    var prefix = 'Content_' + pipeData.chapterIndex + "_";
    //去重复
    divertor.ids = arrayUnique(divertor.ids);
    _.each(divertor.ids, function (id) {
      makePrefix = prefix + id;
      fragment = pipeData.contentsFragment[makePrefix];
      if (fragment) {
        zIndex = zIndexs[id];
        //保证层级关系
        // fragment.style.zIndex = (Number(zIndex) + Number(fragment.style.zIndex))
        content.push(fragment);
        delete pipeData.contentsFragment[makePrefix];
      }
    });
  }

  /*component类型处理*/
  if (divertor.html.length) {
    content = $(divertor.html.join(""));
  }

  //floatPage模式下面
  //如果是当前页面
  //因为会产生三页面并联
  //所以中间去最高层级
  if (pageType === 'page' && getStyle.offset === 0) {
    zIndex = 2001;
  } else {
    zIndex = 2000;
  }

  //浮动根节点
  //floatPage设置的content溢出后处理
  //在非视区增加overflow:hidden
  //可视区域overflow:''
  var overflow = 'overflow:hidden;';

  //如果是母板,排除
  if (pageType === 'master') {
    overflow = '';
  }

  /*浮动容器*/
  var container = void 0;
  if (baseFloatGroup) {
    /*
    在基础的baseFloatGroup中查找是否已经创建过
    容器存在，存在component，在component中已经创建了容器，所以需要复用
    */
    container = baseFloatGroup[pageType + 'Container'];
  }

  /*有可能在competent中已经创建,在content不需要重复创建*/
  if (!container) {
    var id = 'float-' + pageType + '-' + (pipeData.chapterIndex + 1);
    container = $(String.styleFormat('<ul id="' + id + '"\n         class="xut-float"\n         style="left:' + getStyle.visualLeft + 'px;\n                top:' + getStyle.visualTop + 'px;\n                ' + Xut.style.transform + ':' + getStyle.translate + ';\n                z-index:' + zIndex + ';' + overflow + '">\n       </ul>'));
    $(pipeData.rootNode).after(container);
  }

  /*绘制节点到页面*/
  nextTick({ container: container, content: content }, function () {
    complete(container);
  });
}

/**
 * 任务基类
 * 1 任务检测
 * 2 浮动层处理
 */

var TaskSuper = function () {
  function TaskSuper(detector) {
    classCallCheck(this, TaskSuper);

    //中断检测器
    this.$$detector = detector;
    /*中断队列*/
    this.$$suspendQueues = [];
    /*初始化浮动*/
    this._$$initFloat();
  }

  /*
  初始化浮动页面参数
  私有方法
   */


  createClass(TaskSuper, [{
    key: '_$$initFloat',
    value: function _$$initFloat() {
      var _this = this;

      /*
       1.浮动页面,母板事件引起的层级遮挡问题,用于提升最高
       2.浮动模板,用于实现模板上的事件
       */
      this.$$floatDivertor = {};
      _.each(['page', 'master'], function (type) {
        _this.$$floatDivertor[type] = {
          'ids': [], //content保存合集
          'html': [], //component组件触发点字符串
          'zIndex': {}, //保存索引
          'container': null //浮动容器
        };
      });
    }

    /*
    创建浮动
    1 页面浮动层
    2 母版浮动层
    baseFloatGroup: pagebase中的基础，用来处理是否容器已经创建
     */

  }, {
    key: '_$$createFloatLayer',
    value: function _$$createFloatLayer(complete, pipeData, baseFloatGroup) {
      var _this2 = this;

      var pageDivertor = this.$$floatDivertor.page;
      var masterDivertor = this.$$floatDivertor.master;

      /*结束后清理，因为componnet中的条件会影响activity中的条件判断*/
      var clearDivertor = function clearDivertor(divertor) {
        if (divertor.html.length) {
          divertor.html = null;
        }
      };

      //=====================================
      //  ids 是content的id
      //  html 是component的html字符
      //  2个中有一个存在就需要处理浮动
      //  但是需要注意component在content之前
      //  所以component处理完毕后，要清理html
      //  否则会影响content的判断
      //=====================================

      /*浮动页面对,浮动对象比任何层级都都要高,超过母版*/
      if (pageDivertor.ids.length || pageDivertor.html.length) {
        crateFloat('page', pipeData, pageDivertor, baseFloatGroup, function (container) {
          pageDivertor.container = container;
          _this2.pageBaseHooks.floatPages(pageDivertor);
          clearDivertor(pageDivertor);
          complete();
        });
      }

      /*如果存在母版浮动节点,在创建节点structure中过滤出来，根据参数的tipmost*/
      if (masterDivertor.ids.length || masterDivertor.html.length) {
        crateFloat('master', pipeData, masterDivertor, baseFloatGroup, function (container) {
          masterDivertor.container = container;
          _this2.pageBaseHooks.floatMasters(masterDivertor);
          clearDivertor(masterDivertor);
          complete();
        });
      }
    }

    /*
    检测是否可以运行下一个任务
    1 通过base.detectorTask做的监听，这里的this是pagebase的this
    2 如果检测可以运行直接运行nextTask
    3 如果检测不能运行就会运行suspend 断点
    interrupt 给content使用
     */

  }, {
    key: '_$$checkNextTask',
    value: function _$$checkNextTask(taskName, nextTask, interrupt) {
      var _this3 = this;

      //构建中断方法
      var suspendTask = function suspendTask() {
        _this3.$$suspendQueues.push(function () {
          nextTask();
        });
      };

      //外部检测
      this.$$detector && this.$$detector({
        suspendTask: suspendTask,
        nextTask: nextTask,
        interrupt: interrupt,
        taskName: taskName
      });
    }

    //============================
    //      外部接口
    //============================

    /**
     * 重新运行被阻断的线程任务
     */

  }, {
    key: 'rerunTask',
    value: function rerunTask() {
      if (this.$$suspendQueues && this.$$suspendQueues.length) {
        var task = void 0;
        if (task = this.$$suspendQueues.pop()) {
          task();
        }
        this.$$suspendQueues = [];
      }
    }

    /*
    销毁任务
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._destroy) {
        this._destroy();
      }
      this.$$detector = null;
      this.$$suspendQueues = null;
    }
  }]);
  return TaskSuper;
}();

var maskBoxImage = Xut.style.maskBoxImage;

/**
 * 修正尺寸
 * @return {[type]} [description]
 */
var setDataSize = function setDataSize(data) {
  //缩放比
  var proportion = config.proportion;

  if (data.imageWidth) {
    data.imageWidth = data.imageWidth * proportion.width;
  }
  if (data.imageHeight) {
    data.imageHeight = data.imageHeight * proportion.height;
  }
  if (data.imageLeft) {
    data.imageLeft = data.imageLeft * proportion.left;
  }
  if (data.imageTop) {
    data.imageTop = data.imageTop * proportion.top;
  }
};

/**
 * 计算出对页排版偏移值
 * @return {[type]} [description]
 */
var getOffset = function getOffset(pageSide) {
  var background = void 0;
  switch (Number(pageSide)) {
    case 1:
      background = 'background-position:0';
      break;
    case 2:
      background = 'background-position:' + config.screenSize.width + 'px';
      break;
  }
  return background;
};

/**
 * 创建分层背景图层
 * [createMaster description]
 * @param  {[type]} svgContent [description]
 * @param  {[type]} data       [description]
 * @return {[type]}            [description]
 */
function createBackground(svgContent, data) {

  var imageLayer,
      maskLayer,
      imageLayerData = data.imageLayer,
      //图片层
  imageMaskData = data.imageMask,
      //蒙版层
  backImageData = data.backImage,
      //真实图片层
  backMaskData = data.backMask,
      //真实蒙版层
  masterData = data.master,
      //母板
  backText = data.md5,
      //背景文字
  pptMaster = data.pptMaster; //母板PPTID

  /**
   * 未分层结构
   * 只有SVG数据，没有层次数据 ,不是视觉差
   * @return {[type]}          [description]
   */
  if (backText && !masterData && !pptMaster && !imageLayerData && !backImageData) {
    return svgContent ? String.styleFormat('<div data-multilayer ="true"class="multilayer"> ' + svgContent + ' </div>') : '';
  }

  /**
   * 分层结构
   * 1 分母板 文字层 背景 蒙版
   * 2 视觉差分层处理
   */

  /**
   * 修正尺寸
   */
  setDataSize(data);

  /**
   * 母版图
   * 如果有母板数据,如果不是视觉差
   * @return {[type]} [description]
   */
  var masterHTML = '';
  if (masterData && !pptMaster) {
    masterHTML = '<div class="multilayer-master" style="background-image:url(' + getFileFullPath(masterData, 'multilayer-master') + ')"></div>';
  }

  /**
   * 存在背景图
   * @return {[type]}
   */
  var maskHTML = '';
  if (imageLayerData) {
    //蒙版图（与背景图是组合关系）
    var _maskLayer = data.imageMask ? maskBoxImage + ":url(" + getFileFullPath(data.imageMask, 'multilayer-maskLayer') + ");" : "";
    var maskImage = getFileFullPath(imageLayerData, 'multilayer-maskImage');
    maskHTML = '<div class="multilayer-imageLayer"\n            style="width:' + data.imageWidth + 'px;\n                   height:' + data.imageHeight + 'px;\n                   top:' + data.imageTop + 'px;\n                   left:' + data.imageLeft + 'px;\n                   background-image:url(' + maskImage + ');' + _maskLayer + '">\n       </div>';
  }

  /**
   * 新增的 真实背景图 默认全屏
   * @return {[type]
   */
  var backImageHTML = '';
  if (backImageData) {
    //计算出对页排版偏移值
    var backImageOffset = getOffset(data.pageSide);
    var backImagePosition = backImageOffset ? backImageOffset : '';
    var newWidth = backImageOffset ? '200%' : '100%';
    var newBackImage = getFileFullPath(backImageData, 'multilayer-backImage');
    var newBackMask = getFileFullPath(backMaskData, 'multilayer-backMask');
    if (backMaskData) {
      //带蒙版
      if (maskBoxImage != undefined) {
        backImageHTML = '<div class="multilayer-backImage"\n                style="width:' + newWidth + ';\n                       background-image:url(' + newBackImage + ');\n                       ' + maskBoxImage + ':url(' + newBackMask + ');\n                       ' + backImagePosition + '">\n           </div>';
      } else {
        //无蒙版
        backImageHTML = '<canvas class="multilayer-backImage edges"\n                   height=' + document.body.clientHeight + '\n                   width=' + document.body.clientWidth + '\n                   src=' + newBackImage + '\n                   mask=' + newBackMask + '\n                   style="width:' + newWidth + ';\n                          opacity:0;\n                          ' + maskBoxImage + ':url(' + newBackImage + ');\n                          ' + backImagePosition + '">\n           </canvas>';
      }
    } else {
      //图片层
      backImageHTML = '<div class="multilayer-backImage"\n                            style="width:' + newWidth + ';\n                                   background-image:url(' + newBackImage + ');\n                                   ' + backImagePosition + '">\n                       </div>';
    }
  }

  /*存在svg文字*/
  var backTextHTML = backText ? '<div class="multilayer-word"> ' + svgContent + ' </div>' : '';

  /*组层背景图开始*/
  return String.styleFormat('<div data-multilayer ="true"\n          class="multilayer">\n        ' + masterHTML + '\n        ' + maskHTML + '\n        ' + backImageHTML + '\n        ' + backTextHTML + '\n    </div>');
}

/**
 * 解析背景内容
 */
var parseContent = function parseContent(content, callback) {
  //背景是svg文件
  if (/.svg$/i.test(content)) {
    readFileContent(content, function (svgContent) {
      callback(svgContent);
    });
  } else {
    callback('');
  }
};

/**
 * 构建背景类
 * @param {[type]} $containsNode         [根节点]
 * @param {[type]} data                 [数据]
 * @param {[type]} suspendCallback      [中断回调]
 * @param {[type]} successCallback      [description]
 */

var TaskBackground = function (_TaskSuper) {
  inherits(TaskBackground, _TaskSuper);

  function TaskBackground(data, $containsNode, success, detector) {
    classCallCheck(this, TaskBackground);

    var _this = possibleConstructorReturn(this, (TaskBackground.__proto__ || Object.getPrototypeOf(TaskBackground)).call(this, detector));

    var self = _this;
    var content = data.md5;

    _this.success = success;

    //iboosk节点预编译
    //在执行的时候节点已经存在
    //不需要在创建
    if (Xut.IBooks.runMode()) {
      //找到背景节点
      // var $element = $containsNode.find('.multilayer');
      success();
      return possibleConstructorReturn(_this);
    }

    //背景是否需要SVG解析
    parseContent(content, function (svgContent) {
      svgContent = replacePath(svgContent);
      var htmlstr = createBackground(svgContent, data);
      if (htmlstr) {
        svgContent = null;
        self._checkNextTask($(htmlstr), $containsNode);
      } else {
        success();
      }
    });
    return _this;
  }

  /**
   * 检测下一个任务
   */


  createClass(TaskBackground, [{
    key: '_checkNextTask',
    value: function _checkNextTask($background, $containsNode) {
      var _this2 = this;

      this._$$checkNextTask('内部background', function () {
        _this2._render($background, $containsNode);
      });
    }

    /*渲染页面*/

  }, {
    key: '_render',
    value: function _render(content, container) {
      var _this3 = this;

      Xut.nextTick({ content: content, container: container }, function () {
        _this3.destroy();
        _this3.success();
      });
    }
  }]);
  return TaskBackground;
}(TaskSuper);

/*****************
 文字特效
 https://tympanus.net/codrops/2016/10/18/inspiration-for-letter-effects/
******************/

var LetterEffect = function () {

  /**
   * 文本节点
   * 编号
   * @param  {[type]} node   [description]
   * @param  {[type]} serial [description]
   * @return {[type]}        [description]
   */
  function LetterEffect(contentId) {
    classCallCheck(this, LetterEffect);

    this.contentId = contentId;
    this.queueLength = 0;
    this.queueIndex = 0;
    this.fxQueue = [];
  }

  /**
   * 执行队列动画
   */


  createClass(LetterEffect, [{
    key: '_makeFn',
    value: function _makeFn(node, serial) {
      var text = new TextFx(node);
      return function (fn) {
        text.show('fx' + serial, fn);
      };
    }

    /**
     * 加入队列
     */

  }, {
    key: 'addQueue',
    value: function addQueue(node, serial) {
      this.queueLength++;
      this.fxQueue.push('fx' + serial, new TextFx(node));
    }
  }, {
    key: '_animate',
    value: function _animate(action) {
      var _this = this;

      var fxName = this.fxQueue[this.queueIndex];
      var fxObj = this.fxQueue[++this.queueIndex];
      if (fxName && fxObj) {
        fxObj[action](fxName, function () {
          ++_this.queueIndex;
          _this._animate(action);
        });
      }
    }

    /**
     * 运行动画
     * @return {[type]} [description]
     */

  }, {
    key: 'play',
    value: function play() {
      this.queueIndex = 0;
      this._animate('show');
    }

    /**
     * 停止动画
     * @return {[type]} [description]
     */

  }, {
    key: 'stop',
    value: function stop() {}

    /**
     * 销毁动画
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      // console.log(this)
    }
  }]);
  return LetterEffect;
}();

///////////////////////////
///    文本特效
//////////////////////////

function textFx(pipeData, textFx) {

  var uuid = 1;
  var content = void 0;
  var contentNode = void 0;
  var parentNodes = []; //收集父节点做比对
  var group = {};
  var textfxNodes = void 0;
  var parentNode = void 0;

  //文本特效对象
  var textFxObjs = {};

  while (content = textFx.shift()) {
    if (contentNode = pipeData.contentsFragment[content.texteffectId]) {
      (function () {
        var contentId = content._id;

        //初始化文本对象
        textFxObjs[contentId] = new LetterEffect(contentId);
        textfxNodes = contentNode.querySelectorAll('a[data-textfx]');

        if (textfxNodes.length) {
          textfxNodes.forEach(function (node) {
            //如果是共享了父节点
            parentNode = node.parentNode;
            if (-1 != parentNodes.indexOf(parentNode)) {
              group[parentNode.textFxId].push(node);
            } else {
              parentNode.textFxId = uuid;
              group[uuid] = [];
              group[uuid++].push(node);
            }
            parentNodes.push(parentNode);
            textFxObjs[contentId].addQueue(node, node.getAttribute('data-textfx'));
          });
        }
      })();
    }
  }

  return textFxObjs;
}

/**
 * 横版委托
 * 横版状态下，如果iscroll是Y轴滚动
 */


/**
 * 竖版委托
 * 上下滑动的时候，可以翻页
 * @return {[type]} [description]
 */
function delegateScrollY(node, options) {

  _.extend(options, {
    stopPropagation: true,
    preventDefault: false,
    bounce: false,
    probeType: 2
  });

  var iscroll = new iScroll(node, options);

  /*如果是边界翻页*/
  var hasBorderRun = false;
  iscroll.on('beforeScrollStart', function (e) {
    hasBorderRun = false;
  });

  /**
   * directionY
   *   1 向后
   *   -1 向前
   */
  iscroll.on('scroll', function (e) {
    /*探测下全局是否可以滑动了*/
    if (Xut.View.HasEnabledSwiper()) {
      if (iscroll.directionY === -1 && iscroll.startY === 0) {
        hasBorderRun = true;
        /*top*/
        Xut.View.SetSwiperMove({
          action: 'flipMove',
          direction: 'prev',
          distance: iscroll.distY - 10,
          speed: 0
        });
      } else if (iscroll.directionY === 1 && iscroll.startY === iscroll.maxScrollY) {
        /*down*/
        hasBorderRun = true;
        Xut.View.SetSwiperMove({
          action: 'flipMove',
          direction: 'next',
          distance: iscroll.distY + 10,
          speed: 0
        });
      } else {
        /**
         * 内部滑动
         */
        iscroll._execEvent('scrollContent', e);
      }
    }
  });

  iscroll.on('scrollEnd', function (e) {
    if (hasBorderRun) {
      var typeAction = Xut.View.GetSwiperActionType(0, iscroll.distY, iscroll.endTime - iscroll.startTime, 'v');
      if (typeAction === 'flipOver') {
        if (iscroll.directionY === 1) {
          Xut.View.GotoNextSlide();
          iscroll._execEvent('scrollExit', 'down');
        } else if (iscroll.directionY === -1) {
          Xut.View.GotoPrevSlide();
          iscroll._execEvent('scrollExit', 'up');
        }
      } else if (typeAction === 'flipRebound') {
        if (iscroll.directionY === 1) {
          Xut.View.SetSwiperMove({
            action: 'flipRebound',
            direction: 'next',
            distance: 0,
            speed: 300
          });
        } else if (iscroll.directionY === -1) {
          Xut.View.SetSwiperMove({
            action: 'flipRebound',
            direction: 'prev',
            distance: 0,
            speed: 300
          });
        }
      }
    }
  });

  return iscroll;
}

/*
 封装插件iScroll,代理委托页面滑动处理了
 1 横版模式下，竖版滑动iscroll 不处理，(上下滑动，左右全局翻页)
 2 竖版模式下，竖版滑动iscroll 需要处理，竖版边界要翻页
*/
function IScroll(node, options, delegate) {

  ///////////////////////////////
  /// 竖版禁止上下滑动的冒泡，并且不是强制的横屏滑动模式
  ///////////////////////////////
  if (delegate && config.launch.scrollMode === 'v') {
    /*如果是竖版滑动，那么就需要代理下，竖版滑动后，上下翻页*/
    if (!options.scrollX || options.scrollY) {
      return new delegateScrollY(node, options);
    }
  }

  ///////////////////////////////
  /// 启动委托
  /// 启动代码追踪swipe的情况下
  /// 那么停掉事件冒泡，否则滑动会触发
  ///////////////////////////////
  // if (delegate && config.launch.scrollMode === 'h') {
  /*默认参数：横版，上下滑动, 代理左右*/
  // if (options.scrollX === undefined && options.scrollY === undefined || options.scrollY === true) {
  // return new delegateScrollX(node, options)
  // }
  // }

  // if (config.hasTrackCode('swipe')) {
  //   /*启动事件追踪，需要禁止左右默认的左右翻页*/
  //   options.stopPropagation = true
  //   return new iScroll(node, options)
  // }

  return new iScroll(node, options);
}

/**
 * html文本框
 * @param  {[type]} ){} [description]
 * @return {[type]}       [description]
 */

var docElement = document.documentElement;

//默认字体
var defaultFontSize = void 0;

try {
  defaultFontSize = parseInt(getComputedStyle(docElement).fontSize);
} catch (er) {
  defaultFontSize = 16;
}

//新的字体大小
var newFontSize = void 0;

var whiteObject = {
  "rgb(255, 255, 255)": true,
  "#ffffff": true,
  "#FFFFFF": true,
  "#fff": true,
  "#FFF": true

  /**
   * 字体大小
   * @type {Array}
   */
};var sizeArray = ["1", "1.5", "2.0"];

var getFontSize = function getFontSize() {
  newFontSize = defaultFontSize * config.proportion.width;
  return [Math.floor(newFontSize * 1.5), Math.floor(newFontSize * 2.0), Math.floor(newFontSize * 2.5)];
};

/**
 * 工具栏布局
 * @return {[type]} [description]
 */
function toolBar(fontSize) {
  var baseValue1 = fontSize[0];
  var baseValue2 = fontSize[1];
  var baseValue3 = fontSize[2];
  var boxHTML = '<div class="htmlbox_close_container">\n            <a class="htmlbox_close"></a>\n        </div>\n        <ul class="htmlbox_fontsizeUl">\n            <li>\n                <a class="htmlbox_small"\n                   style="width:' + baseValue1 + 'px;height:' + baseValue1 + 'px;margin-top:-' + baseValue1 / 2 + 'px"></a>\n            </li>\n            <li>\n                <a class="htmlbox_middle"\n                   style="width:' + baseValue2 + 'px;height:' + baseValue2 + 'px;margin-top:-' + baseValue2 / 2 + 'px"></a></li>\n            <li>\n                <a class="htmlbox_big"\n                   style="width:' + baseValue3 + 'px;height:' + baseValue3 + 'px;margin-top:-' + baseValue3 / 2 + 'px"></a>\n            </li>\n        </ul>';

  return String.styleFormat(boxHTML);
}

/**
 * 创建盒子容器
 * @return {[type]} [description]
 */
function createWapper(boxHeight, context, iscrollName, textContent) {
  var wapper = '<div class="htmlbox-container">\n            <div class="htmlbox-toolbar" style="height:' + boxHeight + 'px;line-height:' + boxHeight + 'px;">' + context + '</div>\n            <div class="' + iscrollName + '" style="overflow:hidden;position:absolute;width:100%;height:92%;">\n                <ul>' + textContent + '</ul>\n            </div>\n        </div>';
  return String.styleFormat(wapper);
}

var HtmlBox = function () {
  function HtmlBox(contentId, $contentNode) {
    classCallCheck(this, HtmlBox);


    this.contentId = contentId;
    this.$contentNode = $contentNode;

    var self = this;

    //事件对象引用
    var eventHandler = function eventHandler(eventReference, _eventHandler) {
      self.eventReference = eventReference;
      self.eventHandler = _eventHandler;
    };

    //绑定点击事件
    bindContentEvent({
      'eventRun': function eventRun() {
        Xut.View.HideToolBar('pageNumber');
        self._init(contentId, $contentNode);
      },
      'eventHandler': eventHandler,
      'eventContext': $contentNode,
      'eventName': "tap",
      'domMode': true
    });
  }

  createClass(HtmlBox, [{
    key: '_init',
    value: function _init(contentId, $contentNode) {
      var self = this;

      self._adjustColor();

      //移除偏移量 存在偏移量造成文字被覆盖
      var textContent = $contentNode.find(">").html();
      textContent = textContent.replace(/translate\(0px, -\d+px\)/g, 'translate(0px,0px)');

      var iscrollName = "htmlbox-iscroll-" + contentId;

      //缓存名
      this.storageName = iscrollName + config.data.appId;

      var fontSize = getFontSize();

      //工具栏的高度必须大于最大的字体大小
      var boxHeight = fontSize[2] + 2;
      //关闭按钮的top值
      var closeTop = Math.floor(boxHeight / 2);

      //获取保存的字体值
      var initValue = $getStorage(this.storageName);
      if (initValue) {
        this._adjustSize(initValue);
      } else {
        //默认
        this._adjustSize(newFontSize);
      }

      /**
       * 创建容器
       * @type {[type]}
       */
      this.$htmlbox = $(createWapper(boxHeight, toolBar(fontSize), iscrollName, textContent));

      $contentNode.after(this.$htmlbox);

      //修改::before ::after伪元素top值 确保关闭按钮垂直居中
      document.styleSheets[0].addRule('.htmlbox_close::before', 'top:' + closeTop + 'px');
      document.styleSheets[0].insertRule('.htmlbox_close::before { top:' + closeTop + 'px }', 0);
      document.styleSheets[0].addRule('.htmlbox_close::after', 'top:' + closeTop + 'px');
      document.styleSheets[0].insertRule('.htmlbox_close::after { top:' + closeTop + 'px }', 0);

      //修正htmlbox位置
      this._relocateToolbar(iscrollName);
      //卷滚
      this._createIscroll(this.$htmlbox, iscrollName);

      /**
       * 绑定事件上下文呢
       * @type {[type]}
       */
      this.eventContext = this.$htmlbox.find('.htmlbox-toolbar')[0];

      /**
       * 改变字体与刷新卷滚
       * @param  {[type]} fontsize [description]
       * @return {[type]}          [description]
       */
      var change = function change(fontsize) {
        self._adjustSize(fontsize * newFontSize, true);
        self.iscroll && self.iscroll.refresh();
      };

      /**
       * 关闭
       * @return {[type]} [description]
       */
      var colse = function colse() {
        self._restoreColor();

        //还原跟字体大小
        self._adjustSize(defaultFontSize);
        self.removeBox();
        Xut.View.ShowToolBar('pageNumber');
      };

      //处理器
      var process = {
        htmlbox_close_container: colse,
        htmlbox_close: colse,
        htmlbox_small: function htmlbox_small() {
          change(sizeArray[0]);
        },
        htmlbox_middle: function htmlbox_middle() {
          change(sizeArray[1]);
        },
        htmlbox_big: function htmlbox_big() {
          change(sizeArray[2]);
        }
      };

      $on(this.eventContext, {
        start: function start(e) {
          var className = e.target.className;
          process[className] && process[className]();
        }
      });
    }

    /**
     * 遍历p span文字标签 调整字体颜色
     * @return {[type]} [description]
     */

  }, {
    key: '_adjustColor',
    value: function _adjustColor() {
      this.textLabelArray = ['p', 'span'];
      var self = this;
      _.each(self.textLabelArray, function (text) {
        _.each(self.$contentNode.find(text), function (el) {
          var formerColor = getComputedStyle(el).color;
          //若字体颜色为白色 调整为黑色
          if (whiteObject.hasOwnProperty(formerColor)) {
            el.hasFormerColor = true;
            el.style.color = "black";
          }
        });
      });
    }

    /**
     * 调整字体大小
     * @return {[type]} [description]
     */

  }, {
    key: '_adjustSize',
    value: function _adjustSize(value, save) {
      value = parseInt(value);
      docElement.style.fontSize = value + 'px';
      save && $setStorage(this.storageName, value);
    }

    /**
     * 恢复放大过的字体颜色
     * @return {[type]} [description]
     */

  }, {
    key: '_restoreColor',
    value: function _restoreColor() {
      var self = this;
      _.each(self.textLabelArray, function (text) {
        _.each(self.$contentNode.find(text), function (el) {
          //将字体由黑色恢复为白色
          if (el.hasFormerColor) {
            el.style.color = "white";
            el.hasFormerColor = false;
          }
        });
      });
    }

    /**
     * 修正htmlbox位置
     * @param  {[type]} iscrollName [description]
     * @return {[type]}             [description]
     */

  }, {
    key: '_relocateToolbar',
    value: function _relocateToolbar(iscrollName) {
      //修正模式2下屏幕溢出高度
      var visualSize = config.visualSize;
      var left = visualSize.overflowWidth && Math.abs(visualSize.left) || 0;
      var top = visualSize.overflowHeight && Math.abs(visualSize.top) || 0;
      this.$htmlbox[0].style.cssText += "margin-top:" + top + "px";

      //修正模式3下屏幕溢出宽度
      //1.修正关闭按钮::before ::after伪元素left值 确保关闭按钮水平居中
      //首先恢复到最开始的left:2%状态
      document.styleSheets[0].addRule('.htmlbox_close::before', 'left:2%');
      document.styleSheets[0].insertRule('.htmlbox_close::before { left:2% }', 0);
      document.styleSheets[0].addRule('.htmlbox_close::after', 'left:2%');
      document.styleSheets[0].insertRule('.htmlbox_close::after { left:2% }', 0);
      var formerLeft = window.getComputedStyle(this.$htmlbox.find('.htmlbox_close')[0], '::before').getPropertyValue('left');
      var currentLeft = parseInt(formerLeft) + left;

      //开始修正
      document.styleSheets[0].addRule('.htmlbox_close::before', 'left:' + currentLeft + 'px');
      document.styleSheets[0].insertRule('.htmlbox_close::before { left:' + currentLeft + 'px }', 0);
      document.styleSheets[0].addRule('.htmlbox_close::after', 'left:' + currentLeft + 'px');
      document.styleSheets[0].insertRule('.htmlbox_close::after { left:' + currentLeft + 'px }', 0);
      //2.修正字体放大ul按钮
      this.$htmlbox.find(".htmlbox_fontsizeUl")[0].style.cssText += "margin-right:" + left + "px";
      //3.修正文本框
      this.$htmlbox.find("." + iscrollName)[0].style.cssText += "margin-left:" + left + "px;";
      var formerScrollWidth = window.getComputedStyle(this.$htmlbox.find("." + iscrollName)[0]).getPropertyValue('width');

      var currentScrollWidth = parseInt(formerScrollWidth) - 2 * left;

      this.$htmlbox.find("." + iscrollName).width(currentScrollWidth);
    }

    /**
     * 卷滚
     * @param  {[type]} iscrollName [description]
     * @return {[type]}             [description]
     */

  }, {
    key: '_createIscroll',
    value: function _createIscroll($htmlbox, iscrollName) {
      var ulHeight = $htmlbox.find('.' + iscrollName + ' >ul').css('height');
      var htmlboxHeight = $htmlbox.find('.' + iscrollName).css('height');

      //溢出，增加卷滚
      if (parseInt(ulHeight) > parseInt(htmlboxHeight)) {
        this.iscroll = IScroll("." + iscrollName, {
          scrollbars: 'custom',
          fadeScrollbars: true
        });
      }
    }

    /**
     * 移除盒子
     * @return {[type]} [description]
     */

  }, {
    key: 'removeBox',
    value: function removeBox() {
      if (this.eventContext) {
        $off(this.eventContext);
        this.eventContext = null;
      }
      this.$htmlbox && this.$htmlbox.remove();
      if (this.iscroll) {
        this.iscroll.destroy();
        this.iscroll = null;
      }
    }

    /**
     * 销毁
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      _.each(this.eventReference, function (off) {
        off("tap");
      });
      this.removeBox();
    }
  }]);
  return HtmlBox;
}();

/**
 * 文本框
 */
var textBoxMixin = function (activitProto) {

  /**
   * 检测是HTML文本框处理
   * @return {[type]} [description]
   */
  activitProto._htmlTextBox = function () {
    var self = this;
    var dataRelated = this.dataRelated;
    var contentHtmlBoxIds = dataRelated.contentHtmlBoxIds;
    var contentId;
    var contentName;
    var $contentNode;
    //文本框实例对象
    //允许一个activity有多个
    this.htmlBoxInstance = [];

    //创建文本框对象
    if (contentHtmlBoxIds.length && dataRelated.contentDataset) {
      _.each(dataRelated.contentDataset, function (data) {
        if (~contentHtmlBoxIds.indexOf(data._id)) {
          contentId = data._id;
          contentName = self.makePrefix('Content', self.chapterIndex, contentId);
          //找到对应绑定事件的元素
          $contentNode = self.getContextNode(contentName);
          if (!$contentNode.attr("data-htmlbox")) {
            //构建html文本框对象
            self.htmlBoxInstance.push(new HtmlBox(contentId, $contentNode));
            //增加htmlbox标志去重
            //多个actictiy共享问题
            $contentNode.attr("data-htmlbox", "true");
          }
        }
      });
    }
  };
};

/**
 * 书签栏
 * 加入这个书签功能后，可以让用户自由选择哪页是需要保存记录的
 * @param options object
 * @example {parent:页面容器,pageId:chapterId,seasonId:seasionId}
 */
var icons = {
  hide: 'images/icons/arrowDown.svg'
};
var sLineHeiht = parseInt($('body').css('font-size')) || 16;
var BOOKCACHE; //书签缓存

function BookMark(options) {
  this.parent = options.parent;
  this.pageId = options.pageId;
  this.seasonId = options.seasonId;
  //是否已存储
  this.isStored = false;
  this.init();
}

/**
 * 初始化
 * @return {[type]} [description]
 */
BookMark.prototype.init = function () {
  var $bookMark = this.createBookMark(),
      that = this;

  this.parent.append($bookMark);
  this.bookMarkMenu = $bookMark.eq(0);
  //显示书签
  setTimeout(function () {
    that.restore();
  }, 20);
  //获取历史记录
  BOOKCACHE = this.getHistory();

  //邦定用户事件
  $on(this.parent, {
    end: this,
    cancel: this
  });
};

/**
 * 创建书签
 * @return {[object]} [jquery生成的dom对象]
 */
BookMark.prototype.createBookMark = function () {

  var sHeight = Xut.config.visualSize.height;

  var height = sLineHeiht * 3,
      // menu的高为3em
  box = '<div class="xut-bookmark-menu" style="width:100%;height:{0}px;left:0;top:{1}px;">' + '<div class="xut-bookmark-wrap">' + '<div class="xut-bookmark-add">加入书签</div>' + '<div class="xut-bookmark-off" style="background-image:url({2})"></div>' + '<div class="xut-bookmark-view">书签记录</div>' + '</div>' + '</div>' + '<div class="xut-bookmark-list" style="display:none;width:100%;height:{3}px;">' + '<ul class="xut-bookmark-head">' + '<li class="xut-bookmark-back">返回</li>' + '<li>书签</li>' + '</ul>' + '<ul class="xut-bookmark-body"></ul>' + '</div>';
  box = String.format(box, height, sHeight, icons.hide, sHeight);
  this.markHeight = height;
  return $(box);
};

/**
 * 生成书签列表
 * @return {[type]} [description]
 */
BookMark.prototype.createMarkList = function () {
  var tmp,
      seasonId,
      pageId,
      list = '',
      self = this;

  //取历史记录
  _.each(BOOKCACHE, function (mark) {
    tmp = mark.split('-');
    seasonId = tmp[0];
    pageId = tmp[1];
    mark = self.getMarkId(seasonId, pageId);
    list += '<li><a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">第' + pageId + '页</a><a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a></li>';
  });

  return list;
};

/**
 * 创建存储标签
 * 存储格式 seasonId-pageId
 * @return {string} [description]
 */
BookMark.prototype.getMarkId = function (seasonId, pageId) {
  return seasonId + '-' + pageId;
};

/**
 * 获取历史记录
 * @return {[type]} [description]
 */
BookMark.prototype.getHistory = function () {
  var mark = $getStorage('bookMark');
  if (mark) {
    return mark.split(',');
  }
  return [];
};

/**
 * 添加书签
 * @return {[type]} [description]
 */
BookMark.prototype.addBookMark = function () {
  var key;

  this.updatePageInfo();
  key = this.getMarkId(this.seasonId, this.pageId);

  //避免重复缓存
  if (BOOKCACHE.indexOf(key) > -1) {
    return;
  }
  BOOKCACHE.push(key);
  $setStorage('bookMark', BOOKCACHE);
};

/**
 * 更新页信息
 *  针对母板层上的书签
 */
BookMark.prototype.updatePageInfo = function () {
  var pageData = Xut.Presentation.GetPageData();
  this.pageId = pageData._id;
  this.seasonId = pageData.seasonId;
};

/**
 * 删除书签
 * @param {object} [key] [事件目标对象]
 * @return {[type]} [description]
 */
BookMark.prototype.delBookMark = function (target) {
  if (!target || !target.dataset) return;

  var key = target.dataset.mark,
      index = BOOKCACHE.indexOf(key);

  BOOKCACHE.splice(index, 1);
  $setStorage('bookMark', BOOKCACHE);

  if (BOOKCACHE.length == 0) {
    $removeStorage('bookMark');
  }

  //移除该行
  $(target).parent().remove();
};

/**
 * 显示书签
 * @param {object} [target] [事件目标对象]
 * @return {[type]} [description]
 */
BookMark.prototype.viewBookMark = function (target) {
  var $bookMarkList,
      list = this.createMarkList();

  if (this.bookMarkList) {
    $bookMarkList = this.bookMarkList;
  } else {
    $bookMarkList = $(target).parent().parent().next();
  }
  //更新书签内容
  $bookMarkList.find('.xut-bookmark-body').html(list);
  this.bookMarkList = $bookMarkList;
  $bookMarkList.fadeIn();
};

/**
 * 点击放大效果
 * @param  {[object]} target [事件目标对象]
 * @return {[type]}      [description]
 */
BookMark.prototype.iconManager = function (target) {
  var $icon = this.bookMarkIcon = $(target),
      restore = this.iconRestore;
  $icon.css({
    'transform': 'scale(1.2)',
    'transition-duration': '500ms'
  })[0].addEventListener(Xut.style.transitionEnd, restore.bind(this), false);
};

/**
 * 复原按钮
 * @return {[type]} [description]
 */
BookMark.prototype.iconRestore = function () {
  this.bookMarkIcon.css('transform', '');
};

/**
 * 跳转到书签页
 * @param  {[type]} target [description]
 * @return {[type]}        [description]
 */
BookMark.prototype.goBookMark = function (target) {
  if (!target || !target.dataset) return;

  var key = target.dataset.mark.split('-'),
      seasonId = Number(key[0]),
      pageId = Number(key[1]);

  this.updatePageInfo();
  //关闭书签列表
  this.backBookMark();

  //忽略当前页的跳转
  if (this.pageId == pageId && this.seasonId == seasonId) {
    return;
  }

  Xut.View.LoadScenario({
    'seasonId': seasonId,
    'chapterId': pageId
  });
};

/**
 * 书签回退键
 * @return {[type]} [description]
 */
BookMark.prototype.backBookMark = function () {
  this.bookMarkList.fadeOut();
};

/**
 * 邦定事件
 * @param  {[type]} evt [事件]
 * @return {[type]}     [description]
 */
BookMark.prototype.handleEvent = function (evt) {
  var target = evt.target;
  switch (target.className) {
    //加入书签
    case 'xut-bookmark-add':
      this.addBookMark();
      this.iconManager(target);
      break;
    //显示书签记录
    case 'xut-bookmark-view':
      this.viewBookMark(target);
      this.iconManager(target);
      break;
    //关闭书签
    case 'xut-bookmark-off':
      this.closeBookMark(target);
      break;
    //返回书签主菜单
    case 'xut-bookmark-back':
      this.backBookMark();
      break;
    //删除书签记录
    case 'xut-bookmark-del':
      this.delBookMark(target);
      break;
    //跳转到书签页
    case 'xut-bookmark-id':
      this.goBookMark(target);
      break;
    default:
      //console.log(target.className)
      break;
  }
};

/**
 * 关闭书签菜单
 * @return {[type]} [description]
 */
BookMark.prototype.closeBookMark = function () {

  Xut.style.setTranslate({
    node: this.bookMarkMenu,
    speed: 1000
  });
};

/**
 * 恢复书签菜单
 */
BookMark.prototype.restore = function () {
  Xut.style.setTranslate({
    y: -this.markHeight,
    node: this.bookMarkMenu,
    speed: 1000
  });
};

/**
 * 销毁书签
 * @return {[type]} [description]
 */
BookMark.prototype.destroy = function () {

  $off(this.parent);

  //菜单部分
  if (this.bookMarkMenu) {
    this.bookMarkMenu.remove();
    this.bookMarkMenu = null;
  }

  //列表部分
  if (this.bookMarkList) {
    this.bookMarkList.remove();
    this.bookMarkList = null;
  }

  //按钮效果
  if (this.bookMarkIcon) {
    this.bookMarkIcon[0].removeEventListener(Xut.plat.transitionEnd, this.iconRestore, false);
    this.bookMarkIcon = null;
  }

  this.parent = null;
};

//书签
/**
 * 创建书签
 * @return {[type]} [description]
 */
var bookMarkMixin = function (activitProto) {

  activitProto.createBookMark = function () {
    var node, seasonId, pageId, pageData;
    if (this.pageType === 'master') {
      //模板取对应的页面上的数据
      pageData = Xut.Presentation.GetPageData();
      node = this.dataRelated.floatMasterDivertor.container;
      pageId = pageData._id;
      seasonId = pageData.seasonId;
    } else {
      node = this.$containsNode;
      seasonId = this.dataRelated.seasonId;
      pageId = this.pageId;
    }
    var options = {
      parent: node,
      seasonId: seasonId,
      pageId: pageId
    };

    if (this.bookMark) {
      //如果上次只是隐藏则可以恢复
      this.bookMark.restore();
    } else {
      this.bookMark = new BookMark(options);
    }
  };
};

/**
 * 搜索栏
 * 方便用户更加便捷的找到所需要的信息
 *
 */

//图标
var icons$1 = {
  search: 'images/icons/search.svg',
  clear: 'images/icons/clear.svg',
  exit: 'images/icons/exit.svg'
};

function SearchBar(options) {
  //父容器
  this.parent = options.parent;
  //提示信息
  this.tips = options.tips;
  this.init();
}

/**
 * 初始化
 * @return {[type]} [description]
 */
SearchBar.prototype.init = function () {
  var $box = this.searchForm(),
      dom = this.parent[0];

  this.parent.append($box);
  this.searchBox = $box;
  this.resultBox = $box.find('.xut-search-result');
  this.input = $box.find('.xut-search-input');
  this.searchBtn = $box.find('.xut-search-btn');

  //用户操作事件邦定
  $on(dom, {
    end: this,
    cancel: this
  });

  //即时搜索
  dom.addEventListener('keyup', this, false);
};

/**
 * 创建搜索框
 * @return {[object]} [jquery生成的dom对象]
 */
SearchBar.prototype.searchForm = function () {
  var W = window.innerWidth * 0.3,
      H = window.innerHeight;
  var text = this.tips || '请在搜索框中输入要搜索的关键字';

  var box = '<div class="xut-form-search">' + '<div class="xut-form-search-wrap">' + '<div style="height:17%;">' + '<div style="height:20%"></div>' + '<div class="xut-search-row">' + '<input type="text" class="xut-search-input">' + '<div class="xut-search-btn" style="background-image: url(' + icons$1.search + ')"></div>' + '</div>' + '<p class="xut-search-tips" style="line-height:' + Math.round(H * 0.06) + 'px">' + text + '</p>' + '</div>' + '<div style="height:76%">' + '<ul class="xut-search-result"></ul>' + '</div>' + '<div style="height:7%">' + '<div class="xut-search-exit" style="background-image: url(' + icons$1.exit + ')"></div>' + '</div>' + '</div></div>';

  var $box = $(box);

  $box.css('width', W < 200 ? 200 : W);

  return $box;
};

/**
 * 搜索
 * @param {string} [keyword] [搜索关键字]
 */
SearchBar.prototype.search = function (keyword) {
  var data = Xut.data.Chapter,
      ln = data.length,
      list = '',
      rs,
      pageId,
      seasonId;

  if (!keyword) {
    this.resultBox.html('');
    return;
  }

  for (var i = 0; i < ln; i++) {
    rs = data.item(i);
    if (rs.chapterTitle.indexOf(keyword) > -1) {
      pageId = rs._id;
      seasonId = rs.seasonId;
      list += '<li><a class="xut-search-link" data-mark="' + seasonId + '-' + pageId + '" href="javascript:0">' + rs.chapterTitle + '</a></li>';
    }
  }

  this.resultBox.html(list);
};

/**
 * 切换搜索按钮图标
 * @param  {[type]} icon [图标路径]
 * @return {[type]}      [description]
 */
SearchBar.prototype.iconManager = function (icon) {
  if (this.isChange) {
    this.searchBtn.css('background-image', 'url(' + icon + ')');
  }
};

/**
 * 跳转到搜索结果页
 * @param  {[type]} target [description]
 * @return {[type]}        [description]
 */
SearchBar.prototype.searchLink = function (target) {
  if (!target || !target.dataset) return;
  var mark = target.dataset.mark.split('-'),
      seasonId = mark[0],
      pageId = mark[1];

  Xut.View.LoadScenario({
    'seasonId': seasonId,
    'chapterId': pageId
  });
};

/**
 * 邦定事件
 * @param  {[type]} evt [事件]
 * @return {[type]}     [description]
 */
SearchBar.prototype.handleEvent = function (evt) {
  var target = evt.target;
  switch (target.className) {
    case 'xut-search-btn':
      //点击搜索
      this.search(this.input.val());
      this.isChange = true;
      this.iconManager(icons$1.clear);
      break;
    case 'xut-search-input':
      //实时搜索
      this.search(target.value);
      //还原按钮图标
      this.iconManager(icons$1.search);
      this.isChange = false;
      break;
    case 'xut-search-exit':
      //关闭搜索框
      this.exit();
      break;
    case 'xut-search-link':
      //跳转
      this.searchLink(target);
      break;
    default:
      break;
  }
};

/**
 * 关闭搜索框
 * @return {[type]} [description]
 */
SearchBar.prototype.exit = function () {
  this.input.val('');
  this.resultBox.empty();
  this.searchBox.hide();
};

/**
 * 恢复搜索框
 */
SearchBar.prototype.restore = function () {
  var searchBox = this.searchBox;
  searchBox && searchBox.show();
};

/**
 * 销毁搜索框
 * @return {[type]} [description]
 */
SearchBar.prototype.destroy = function () {
  var dom = this.parent[0];

  $off(dom);
  dom.removeEventListener('keyup', this, false);

  this.searchBox.remove();
  this.searchBox = null;
  this.resultBox = null;
  this.searchBtn = null;
  this.input = null;
  this.parent = null;
};

//搜索
/**
 * 创建搜索框
 * @return {[type]} [description]
 */

var searchBarMixin = function (activitProto) {

  activitProto.createSearchBar = function () {
    var options = {
      parent: this.$containsNode
    };
    if (this.searchBar) {
      //如果上次只是隐藏则可以恢复
      this.searchBar.restore();
    } else {
      this.searchBar = new SearchBar(options);
    }
  };
};

var eventMixin = function (activitProto) {

  /**
   * 构建事件体系
   * 解析出事件类型
   */
  activitProto._initEvents = function () {
    this.eventRelated.eventName = conversionEventType(this.eventRelated.eventType);
  };

  /**
   * 找到事件上下文
   * @return {[type]} [description]
   */
  activitProto._findContentName = function (chapterIndex, contentId, eventId) {
    var _this = this;

    var contentName = void 0;
    var eventRelated = this.eventRelated;

    //dom
    //找到对应绑定事件的元素
    var parseDom = function parseDom() {
      contentName = _this.makePrefix('Content', chapterIndex, contentId);
      eventRelated.type = 'dom';
      eventRelated.canvasMode = false;
      eventRelated.domMode = true;
    };

    //canvas模式非常特别
    //canvas容器+内部pixi对象
    //所以事件绑定在最外面
    var parseCanavs = function parseCanavs() {
      contentName = _this.makePrefix('canvas', chapterIndex, contentId);
      eventRelated.type = 'canvas';
      eventRelated.canvasMode = true;
      eventRelated.domMode = false;
    };

    //canvas事件
    if (eventId && -1 !== this.canvasRelated.contentIdset.indexOf(eventId)) {
      parseCanavs();
    } else {
      //dom事件
      parseDom();
    }

    return contentName;
  };

  /**
   * 获取事件上下文
   * @return {[type]} [description]
   */
  activitProto._parseEventContext = function () {
    //事件上下文对象
    var eventRelated = this.eventRelated;
    var eventId = eventRelated.eventContentId;
    var eventContext = eventRelated.eventContext;

    if (eventId) {
      if (!eventContext) {
        //被重写过的事件
        var contentId = eventRelated.rewrite ? eventId : this.id;
        var contentName = this._findContentName(this.chapterIndex, contentId, eventId);
        eventContext = this.getContextNode(contentName);
        eventRelated.eventContext = eventContext;
      }
      if (eventContext) {
        //绑定事件加入到content钩子
        this.callbackRelated.contentsHooks(this.chapterIndex, eventId, {
          $contentNode: eventContext,
          //增加外部判断
          isBindEventHooks: true,
          type: eventRelated.type
        });
      } else {
        /**
         * 针对动态事件处理
         * 快捷方式引用到父对象
         */
        eventRelated.parent = this;
      }
    }

    return eventContext;
  };

  /**
   * 绑定事件行为
   * @return {[type]} [description]
   */
  activitProto._bindEvents = function (callback) {
    var self = this;
    var eventRelated = this.eventRelated;
    var eventName = eventRelated.eventName;
    var eventContext = this._parseEventContext();

    /**
     * 运行动画
     */
    function startRunAnim() {
      //当前事件对象没有动画的时候才能触发关联动作
      var animOffset = void 0;
      var boundary = 15; //边界值
      if (eventRelated.domMode && (animOffset = eventContext.prop('animOffset'))) {
        var originalLeft = animOffset.left;
        var originalTop = animOffset.top;
        var newOffset = eventContext.offset();
        var newLeft = newOffset.left;
        var newTop = newOffset.top;

        //在合理的动画范围是允许点击的
        //比如对象只是一个小范围的内的改变
        //正负30px的移动是允许接受的
        if (originalLeft > newLeft - boundary && originalLeft < newLeft + boundary || originalTop > newTop - boundary && originalTop < newTop + boundary) {
          self.runAnimation();
        }
      } else {
        self.runAnimation();
      }
    }

    /**
     * 设置按钮的行为
     * 音频
     * 反弹
     */
    function setBehavior(feedbackBehavior) {
      var behaviorSound = void 0;
      //音频地址
      if (behaviorSound = feedbackBehavior.behaviorSound) {
        //妙妙学客户端强制删除
        if (window.MMXCONFIG && window.audioHandler) {
          self.fixAudio.push(new AudioPlayer({
            url: behaviorSound,
            trackId: 9999,
            audioId: '一次性行点击',
            complete: function complete() {
              this.play();
            }
          }));
        } else {
          //其余平台,如果存在点击过的
          //这里主要是防止重复点击创建
          var audio = self.cacheBehaviorAudio[behaviorSound];
          if (audio) {
            audio.play();
          } else {
            //相同对象创建一次
            //以后取缓存
            audio = new AudioPlayer({
              url: behaviorSound,
              audioId: '一次性行点击'
            });
            self.cacheBehaviorAudio[behaviorSound] = audio;
          }
        }
      }

      //反弹效果
      if (feedbackBehavior.isButton) {
        //div通过css实现反弹
        if (eventRelated.domMode) {
          eventContext.addClass('xut-behavior');
          setTimeout(function () {
            eventContext.removeClass('xut-behavior');
            startRunAnim();
          }, 500);
        } else {
          console.log('feedbackBehavior');
        }
      } else {
        startRunAnim();
      }
    }

    /**
     * 事件引用钩子
     * 用户注册与执行
     */
    var eventDrop = {
      //保存引用,方便直接销毁
      init: function init(drag) {
        eventRelated.dragDrop = drag;
      },
      //拖拽开始的处理
      startRun: function startRun() {},
      //拖拽结束的处理
      stopRun: function stopRun(isEnter) {
        if (isEnter) {
          //为true表示拖拽进入目标对象区域
          self.runAnimation();
        }
      }

      /**
       * 正常动画执行
       * 除去拖动拖住外的所有事件
       * 点击,双击,滑动等等....
       */
    };function eventRun() {

      /*
      跟踪点击动作
      1. 必须配置config
      2. 而且content要有标记
      */
      var contentData = self.dataRelated.contentDataset[self.id];
      if (contentData && contentData.trackCode) {
        config.sendTrackCode('content', {
          pageId: self.pageId,
          id: self.id,
          type: self.type,
          eventName: eventRelated.eventName
        });
      }

      //脚本动画
      if (eventRelated.rewrite) {
        self.runAnimation();
        return;
      }
      //如果存在反馈动作
      //优先于动画执行
      var feedbackBehavior = eventRelated.feedbackBehavior[eventRelated.eventContentId];
      if (feedbackBehavior) {
        setBehavior(feedbackBehavior);
      } else {
        startRunAnim();
      }
    }

    /**
     * 事件对象引用
     */
    function eventHandler(eventReference, eventHandler) {
      eventRelated.eventReference = eventReference;
      eventRelated.eventHandler = eventHandler;
    }

    //绑定用户自定义事件
    if (eventContext && eventName) {
      //如果是翻页委托启动了
      //这里处理swiperight与swipeleft
      if (config.launch.swipeDelegate && (eventName === 'swiperight' || eventName === 'swipeleft')) {
        self.callbackRelated.swipeDelegateContents(eventName, function (callback) {
          self.runAnimation(callback);
        });
      }
      //给独立对象绑定事件
      else {

          var domName = void 0;
          var target = void 0;
          var dragdropPara = void 0;

          dragdropPara = eventRelated.dragdropPara;

          //获取拖拽目标对象
          if (eventName === 'dragTag') {
            domName = this.makePrefix('Content', this.chapterIndex, dragdropPara);
            target = this.getContextNode(domName);
          }

          //增加事件绑定标示
          //针对动态加载节点事件的行为过滤
          eventRelated.isBind = true;

          bindContentEvent({
            target: target,
            eventName: eventName,
            eventRun: eventRun,
            eventDrop: eventDrop,
            eventHandler: eventHandler,
            eventContext: eventContext,
            'parameter': dragdropPara,
            'domMode': eventRelated.domMode
          });
        }
    }
  };
};

/**
 * 2017.7.25
 * 1.高级精灵动画
 *   提供给widget使用
 *
 * 2.复杂精灵动画
 *   提供给普通转化高级使用
 */
/*
1 高级精灵动画 =>  替换一张张图片
2 简单精灵强制转换复杂精灵动画
options.type
  1 seniorSprite
  2 autoSprite
 */

var _class$1 = function () {
  function _class(data, options) {
    classCallCheck(this, _class);

    this.data = data;

    //高级精灵动画
    if (options.type == 'seniorSprite') {
      this.contentPrefix = options.contentPrefix;
      this.obj = $("#" + this.contentPrefix + this.data.framId);
      this.resourcePath = options.resourcePath;
    }

    //简单精灵强制转换复杂精灵动画
    if (options.type === 'autoSprite') {
      this.contentId = options.contentId;
      this.obj = $(options.ele);
      this.resourcePath = getFileFullPath(options.resourcePath, 'autoSprite') + "/";
    }

    this.curFPS = 0;

    /*默认值循环一次*/
    this.loop = 1;
    this.resetCount = 0;

    var params = this.data.params;
    var action = this.action = params["actList"].split(",")[0];
    var pa = params[action];
    this.FPS = parseInt(pa.fps);
    this.playerType = pa.playerType;

    //isSports:0非运动状态 isSports:1运动状态
    this.isSports = parseInt(pa.isSports);
    this.originalImageList = pa.ImageList;

    /**webp图片的后缀*/
    var brModeType = config.launch.brModeType;
    if (brModeType) {
      _.each(this.originalImageList, function (imageData) {
        if (imageData.name) {
          imageData.name = imageData.name.replace(/.png|.jpg/, brModeType);
        }
      });
    }

    this.totalFPS = this.originalImageList.length;
    this._imgArray = [];
    this.sprObj = null;

    /*
      默认值播放一次
      如果设置了循环就直接循环处理
     */
    if (this.playerType == "loop") {
      this.loop = 'loop';
    }

    this._init();
  }

  /**
   * 初始化
   * @return {[type]} [description]
   */


  createClass(_class, [{
    key: '_init',
    value: function _init() {
      this._initImage();

      //判断是否运动状态
      if (this.isSports) {
        //初始化位置信息
        this._initPosition();
      }
      //初始化结构
      this._initStructure();
    }

    /**
     * 检查是否可以运行
     * 第一次预加载必须先结束
     * @return {[type]} [description]
     */

  }, {
    key: '_checkNextAction',
    value: function _checkNextAction(task) {
      if (this._initImageState) {
        task();
      } else {
        this._waitTask = [];
        this._waitTask.push(task);
      }
    }

    /**
     * 初始化位置信息
     * @return {[type]} [description]
     */

  }, {
    key: '_initPosition',
    value: function _initPosition() {
      var obj = this.obj;
      var params = this.data.params;
      var action = this.action;
      this.startPoint = {
        x: this.originalImageList[0].X,
        y: this.originalImageList[0].Y,
        w: parseInt(params[action].width),
        h: parseInt(params[action].height)
      };
      this.xRote = parseInt(obj.css("width")) / this.startPoint.w;
      this.yRote = parseInt(obj.css("height")) / this.startPoint.h;
      this.startLeft = parseInt(obj.css("left"));
      this.startTop = parseInt(obj.css("top"));
    }

    /**
     * 初始化qualified张图片
     * @return {[type]} [description]
     */

  }, {
    key: '_initImage',
    value: function _initImage() {
      var _this = this;

      var i = 0;
      var qualified = 10;
      var count = this.qualified = this.totalFPS >= qualified ? qualified : this.totalFPS;
      var collect = function () {
        return function () {
          if (count == 1) {
            _this._initImageState = true;
            if (_this._waitTask && _this._waitTask.length) {
              _this._waitTask.pop()();
            }
          } else {
            count--;
          }
        };
      }();

      for (i; i < this.qualified; i++) {
        this._preloadImage(i, collect);
      }
    }

    /**
     * 初始化结构
     * @return {[type]} [description]
     */

  }, {
    key: '_initStructure',
    value: function _initStructure() {
      var src = this.resourcePath + this.originalImageList[0].name;
      var html = '<img src="' + src + '" style="width:100%;height:100%;"/>';
      var $sprObj = $(String.styleFormat(html));
      this.sprObj = $sprObj[0];
      this.obj.html(this.sprObj);
    }

    /**
     * 获取文件名
     * @param  {[type]} name [description]
     * @return {[type]}      [description]
     */

  }, {
    key: '_getFilename',
    value: function _getFilename(name) {
      return name.substr(0, name.indexOf('.'));
    }

    /**
     * 图片预加载
     * 1 png
     * 2 jpg mask
     * @return {[type]} [description]
     */

  }, {
    key: '_preloadImage',
    value: function _preloadImage(index, callback) {
      if (index >= this.totalFPS) {
        return;
      }
      var self = this;
      var imageList = this.originalImageList;
      var resourcePath = this.resourcePath;
      loadFigure(resourcePath + imageList[index].name, function () {
        self._imgArray && self._imgArray.push(this);
        callback && callback();
      });
    }

    /**
     * 改变图片位置
     * @return {[type]} [description]
     */

  }, {
    key: '_changePosition',
    value: function _changePosition() {
      var imageList = this.originalImageList;
      var curFPS = imageList[this.curFPS];
      var x = curFPS.X - this.startPoint.x;
      var y = curFPS.Y - this.startPoint.y;
      this.obj.css({
        left: this.startLeft + x * this.xRote,
        top: this.startTop + y * this.yRote
      });
    }

    /**
     * 改变图片url 与 变化的位置
     * @return {[type]} [description]
     */

  }, {
    key: '_changeImage',
    value: function _changeImage() {
      var imageList = this.originalImageList;
      var curFPS = imageList[this.curFPS];
      var resourcePath = this.resourcePath;

      /*第一次循环才加载图片*/
      if (this.resetCount === 0) {
        this._preloadImage(this.curFPS + this.qualified);
      }

      /*如果图片需要运动，改变地址*/
      if (this.isSports) {
        this._changePosition();
      }

      /*改变图片*/
      this.sprObj.setAttribute('src', resourcePath + curFPS.name);
    }

    /**
     * 运行动画
     * @return {[type]} [description]
     */

  }, {
    key: '_change',
    value: function _change() {
      if (!this.originalImageList) {
        return;
      }
      /*切换图片*/
      this._changeImage();
    }
  }, {
    key: '_time',
    value: function _time() {
      var _this2 = this;

      this.timer = setTimeout(function () {
        clearTimeout(_this2.timer);
        _this2.timer = null;
        _this2._change();
        _this2.curFPS++;
        _this2._set();
      }, 1000 / this.FPS);
    }

    /**
     * 设置动画运行状态
     * look 0  循环
     * lokk 1~n 指定次数
     */

  }, {
    key: '_set',
    value: function _set() {
      var _this3 = this;

      //循环复位
      if (this.curFPS >= this.totalFPS) {
        this.curFPS = 0;
        this.resetCount++;
      }

      if (this.loop !== 'loop' && this.loop == this.resetCount) {
        this._stop();
        return;
      }

      this._checkNextAction(function () {
        _this3._time();
      });
    }
  }, {
    key: '_stop',
    value: function _stop() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this.curFPS = 0;
      this.resetCount = 0;
    }

    /**
     * 开始运行动画
     * loop
     *   1 零件高级动画 loop => N / loop
     *   1 普通转高级动画 loop => N / loop
     */

  }, {
    key: 'play',
    value: function play(action, loop) {
      this.action = action;
      if (!this.data.params[action]) {
        console.log(" Function changeSwitchAni  parameters " + action + " error");
        return;
      }
      if (loop) {
        this.loop = loop;
      }
      this._stop();
      this._set();
    }

    /**
     * 停止
     * @return {[type]} [description]
     */

  }, {
    key: 'stop',
    value: function stop() {
      this._stop();
    }

    /**
     * 销毁
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this._stop();
      this.obj = null;
      this.sprObj = null;
      this.data.params = null;
      this.data = null;
      this._imgArray.forEach(function (img) {
        img = null;
      });
      this.originalImageList = null;
      this._imgArray = null;
    }
  }]);
  return _class;
}();

var spiritObjs = {};

// $("body").on("dblclick",function(){
//   console.log(spiritObjs)
// })

/**
 * get data
 * @param  {[type]} inputPara [description]
 * @param  {[type]} contents  [description]
 * @return {[type]}           [description]
 */
var getData = function getData(inputPara, contents) {
  var option = void 0;
  var resourcePath = config.getWidgetPath() + "gallery/" + inputPara.id + "/";
  var xhr = new XMLHttpRequest();
  xhr.open('GET', resourcePath + 'app.json', false);
  xhr.send(null);
  try {
    option = parseJSON(xhr.responseText);
  } catch (e) {
    console.log("app.json get error:" + e);
  }
  return option;
};

var moveContent = function moveContent(contentPrefix, id, parentId) {
  var obj = $("#" + contentPrefix + id);
  var parentObj = $("#" + contentPrefix + parentId);
  var $parent = $("#spirit_parent_" + parentId);
  if ($parent.length == 0) {
    parentObj.append("<div style='position:absolute; width:100%; height:100%'  id='spirit_parent_" + parentId + "'></div>");
  }
  $parent.append(obj);
};

var getId = function getId(inputPara, contentPrefix) {
  var id = '';
  if (_.isObject(inputPara)) {
    id = contentPrefix + inputPara.framId;
  } else {
    id = inputPara;
  }
  return id;
};

function updateAction(id, params) {
  var loop = 1;
  var obj = void 0;
  if (params.playerType == "loop") {
    loop = 'loop';
  }

  if (obj = spiritObjs[id]) {
    obj.play(params.actList, loop);
  } else {
    console.log('error');
  }
}

var AdvSprite = function (inputPara, contents) {
  var option = getData(inputPara, contents);
  var ResourcePath = config.getWidgetPath() + "gallery/" + inputPara.id + "/";
  var contentPrefix = inputPara.contentPrefix;
  var ids = [];
  var options = {};
  options.contentPrefix = contentPrefix;
  options.resourcePath = ResourcePath;
  options.type = 'seniorSprite';

  if (option.spiritList) {
    for (var i = 0; i < option.spiritList.length; i++) {
      var spiritList = option.spiritList[i];
      var id = getId(spiritList, contentPrefix);
      var framId = spiritList.framId;
      var parentId = spiritList.parentId;
      if (_.isObject(inputPara)) {
        if (parentId != "0") {
          moveContent(contentPrefix, framId, parentId);
        }
        spiritObjs[id] = new _class$1(spiritList, options);
        ids.push(id);
      } else {
        console.log("inputPara undefine Spirit");
      }
    }
  } else {
    console.log('没有高级精灵动画数据');
  }

  return {
    stop: function stop() {
      ids.forEach(function (key) {
        spiritObjs[key].stop();
      });
    },
    destroy: function destroy() {
      ids.forEach(function (key) {
        if (spiritObjs[key]) {
          spiritObjs[key].destroy();
          spiritObjs[key] = null;
          delete spiritObjs[key];
        }
      });
    }
  };
};

/**
 * 代码过滤器
 * 针对代码脚本做处理
 * Xut.Assist.RecordPlay(1)
 * =>   Xut.Assist.RecordPlay(1,function(){
           createContentAudio(2, 7)
        })
 */
function injectCode(code, parameter, parentContext) {
  //如果有音频，并且包含了RecordPlay接口的脚本
  //找到对应的脚本，需要针对这个脚本注入新的代码
  if (code) {

    //扩展录音脚本
    //往前缀加载重复回调的处理
    //开始录音脚本处理
    if (~code.indexOf('Xut.Assist.RecordStart')) {
      var inject = 'Xut.Assist.RecordStart(function(){\n        Xut.Assist.Run(' + parentContext.activityId + ')\n      },';
      code = code.replace('Xut.Assist.RecordStart(', inject);
    }

    //扩展播放录音脚本处理
    //如果没有用户录音，就取自身的音频
    if (parameter.videoId && ~code.indexOf('Xut.Assist.RecordPlay')) {
      var recordREG = code.match(/Xut.Assist.RecordPlay\((\w+)\)/);
      if (recordREG.length) {
        var full = recordREG[0];
        var id = recordREG[1];
        var _inject = 'Xut.Assist.RecordPlay(' + id + ',function(){\n           Xut.Assist.ContentAudioCreate(' + parameter.chapterId + ', ' + parameter.videoId + ')\n        })';
        //重新组合新的脚本代码
        code = code.replace(full, _inject);
        //如果遇到对应的脚本
        //那么就清理音频
        parameter.videoId = null;
      }
    }
    return makeJsonPack(code);
  }
}

var filter$1 = Xut.style.filter;

/**
 * 淡入淡出动画
 * @param  {[type]} animproto [description]
 * @return {[type]}           [description]
 */
function fade(animproto) {

  //出现/消失
  animproto.getEffectAppear = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    if (isExit == false) t1.to(object, 0.001, {
      autoAlpha: 1
    });else t1.to(object, 0.001, {
      css: {
        visibility: "hidden"
      }
    });
    return t1;
  };

  //淡出
  animproto.getEffectFade = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        autoAlpha: 0,
        ease: parameter.tweenEase,
        immediateRender: false
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        ease: parameter.tweenEase
      });
    }
    return t1;
  };

  //闪烁(一次)
  animproto.getEffectFlashOnce = function (parameter, object, duration, delay, repeat) {
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var time = duration / 3;
    t1.to(object, 0.001, {
      css: {
        visibility: "hidden"
      }
    }).to(object, time * 2, {}).to(object, time, {
      css: {
        visibility: "visible"
      }
    });
    return t1;
  };

  //不饱和
  animproto.getEffectDesaturate = function (parameter, object, duration, delay, repeat) {
    if (!(filter$1 in object[0].style)) return new TimelineMax();
    var saturation = parameter.saturation ? parameter.saturation : 0.5; //饱和度
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object, {
        filter: "none"
      }]
    });
    t1.to(object, duration, {
      onUpdate: updateSaturate
    });
    return t1;

    function updateSaturate() {
      var progress = t1.progress();
      var percent = progress <= 0.5 ? progress * 2 : 1;
      var val = 1 + (saturation - 1) * percent;
      object.css(filter$1, "saturate(" + val + ")");
    }
  };

  //加深
  animproto.getEffectDarken = function (parameter, object, duration, delay, repeat) {
    if (!(filter$1 in object[0].style)) return new TimelineMax();
    var brightness = parameter.brightness && parameter.brightness < 1 ? brightness.saturation : 0.5; //亮度
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object, {
        filter: "none"
      }]
    });
    t1.to(object, duration, {
      onUpdate: updateBrightness
    });
    return t1;

    function updateBrightness() {
      var progress = t1.progress();
      var percent = progress <= 0.5 ? progress * 2 : 1;
      var val = 1 + (brightness - 1) * percent;
      object.css(filter$1, "brightness(" + val + ")");
    }
  };

  //变淡
  animproto.getEffectLighten = function (parameter, object, duration, delay, repeat) {
    if (!(filter$1 in object[0].style)) return new TimelineMax();
    var brightness = parameter.brightness && parameter.brightness > 1 ? parameter.brightness : 1.5; //亮度
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object, {
        filter: "none"
      }]
    });
    t1.to(object, duration, {
      onUpdate: updateBrightness
    });
    return t1;

    function updateBrightness() {
      var progress = t1.progress();
      var percent = progress <= 0.5 ? progress * 2 : 1;
      var val = 1 + (brightness - 1) * percent;
      object.css(filter$1, "brightness(" + val + ")");
    }
  };

  //透明
  animproto.getEffectTransparency = function (parameter, object, duration, delay, repeat) {
    var opacity = parameter.amount ? parameter.amount : 0.5; //透明度
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    t1.to(object, duration, {
      autoAlpha: opacity,
      ease: parameter.tweenEase
    });
    return t1;
  };
}

/**
 * 飞入飞出动画
 * @param  {[type]} animproto [description]
 * @return {[type]}           [description]
 */
function fly(animproto) {

  //飞入效果
  animproto.getEffectFly = function (parameter, object, duration, delay, repeat, isExit) {
    var direction = parameter.direction; //方向(上、下、左、右、左上、左下、右上、右下)
    var t1 = null;
    var objInfo = this._getObjectInfo(object);
    var easeString = Expo.easeOut;
    var x, y;

    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (parameter.smoothStart == 1 || parameter.smoothEnd == 1 || parameter.bounceEnd == 1) {
      if (isExit == true) easeString = Power4.easeOut;else easeString = Elastic.easeOut;
    }

    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object, {
          visibility: "visible"
        }],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          visibility: "visible"
        }]
      });
      switch (direction) {
        case "DirectionDown":
          y = Math.abs(objInfo.offsetBottom + objInfo.height);
          t1.from(object, duration, {
            y: y,
            ease: easeString,
            immediateRender: false
          });
          break;
        case "DirectionLeft":
          x = -Math.abs(objInfo.offsetLeft + objInfo.width);
          t1.from(object, duration, {
            x: x,
            ease: easeString,
            immediateRender: false
          });
          break;
        case "DirectionUp":
          y = -Math.abs(objInfo.offsetTop + objInfo.height);
          t1.from(object, duration, {
            y: y,
            ease: easeString,
            immediateRender: false
          });
          break;
        case "DirectionRight":
          x = Math.abs(objInfo.offsetRight + objInfo.width);
          t1.from(object, duration, {
            x: x,
            ease: easeString,
            immediateRender: false
          });
          break;
        case "DirectionDownLeft":
          x = -Math.abs(objInfo.offsetLeft + objInfo.width);
          y = objInfo.offsetBottom + objInfo.height;
          t1.from(object, duration, {
            x: x,
            y: y,
            ease: easeString,
            immediateRender: false
          });
          break;
        case "DirectionDownRight":
          x = Math.abs(objInfo.offsetRight + objInfo.width);
          y = Math.abs(objInfo.offsetBottom + objInfo.height);
          t1.from(object, duration, {
            x: x,
            y: y,
            ease: easeString,
            immediateRender: false
          });
          break;
        case "DirectionUpLeft":
          x = -Math.abs(objInfo.offsetLeft + objInfo.width);
          y = -Math.abs(objInfo.offsetTop + objInfo.height);
          t1.from(object, duration, {
            x: x,
            y: y,
            ease: easeString,
            immediateRender: false
          });
          break;
        case "DirectionUpRight":
          x = Math.abs(objInfo.offsetRight + objInfo.width);
          y = -Math.abs(objInfo.offsetTop + objInfo.height);
          t1.from(object, duration, {
            x: x,
            y: y,
            ease: easeString,
            immediateRender: false
          });
          break;
        default:
          console.log("getEffectFly:parameter error.");
          break;
      }
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          x: 0,
          y: 0,
          visibility: "hidden" //clearProps功能(对象被还原)必须隐藏对象
        }]
      });
      switch (direction) {
        case "DirectionDown":
          y = Math.abs(objInfo.offsetBottom + objInfo.height);
          t1.to(object, duration, {
            y: y,
            //clearProps: "y",
            ease: easeString
          });
          break;
        case "DirectionLeft":
          x = -Math.abs(objInfo.offsetLeft + objInfo.width);
          t1.to(object, duration, {
            x: x,
            //clearProps: "x",
            ease: easeString
          });
          break;
        case "DirectionUp":
          y = -Math.abs(objInfo.offsetTop + objInfo.height);
          t1.to(object, duration, {
            y: y,
            //clearProps: "y",
            ease: easeString
          });
          break;
        case "DirectionRight":
          x = Math.abs(objInfo.offsetRight + objInfo.width);
          t1.to(object, duration, {
            x: x,
            //clearProps: "x",
            ease: easeString
          });
          break;
        case "DirectionDownLeft":
          x = -Math.abs(objInfo.offsetLeft + objInfo.width);
          y = objInfo.offsetBottom + objInfo.height;
          t1.to(object, duration, {
            x: x,
            y: y,
            //clearProps: "x,y",
            ease: easeString
          });
          break;
        case "DirectionDownRight":
          x = Math.abs(objInfo.offsetRight + objInfo.width);
          y = Math.abs(objInfo.offsetBottom + objInfo.height);
          t1.to(object, duration, {
            x: x,
            y: y,
            //clearProps: "x,y",
            ease: easeString
          });
          break;
        case "DirectionUpLeft":
          x = -Math.abs(objInfo.offsetLeft + objInfo.width);
          y = -Math.abs(objInfo.offsetTop + objInfo.height);
          t1.to(object, duration, {
            x: x,
            y: y,
            //clearProps: "x,y",
            ease: easeString
          });
          break;
        case "DirectionUpRight":
          x = Math.abs(objInfo.offsetRight + objInfo.width);
          y = -Math.abs(objInfo.offsetTop + objInfo.height);
          t1.to(object, duration, {
            x: x,
            y: y,
            //clearProps: "x,y",
            ease: easeString
          });
          break;
        default:
          console.log("getEffectFly:parameter error.");
          break;
      }
    }
    return t1;
  };

  //浮入/浮出(下方)
  animproto.getEffectAscend = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      //t1.to(object, 0.001, {opacity: 0, y: 100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
      t1.from(object, duration, {
        autoAlpha: 0,
        y: 100,
        ease: parameter.tweenEase,
        immediateRender: false
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1,
          y: 0
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        y: 100,
        //clearProps: "y", //己失效
        ease: parameter.tweenEase
      });
    }
    return t1;
  };

  //浮入/浮出(上方)
  animproto.getEffectDescend = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      //t1.to(object, 0.001, {y: -100}).to(object, duration - 0.001, {autoAlpha: 1, y: 0, ease: parameter.tweenEase});
      t1.from(object, duration, {
        autoAlpha: 0,
        y: -100,
        ease: parameter.tweenEase,
        immediateRender: false
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        y: -100,
        ease: parameter.tweenEase,
        clearProps: "y"
      });
    }
    return t1;
  };

  //切入/出
  animproto.getEffectPeek = function (parameter, object, duration, delay, repeat, isExit) {
    var direction = parameter.direction; //方向(上下左右)
    var t1 = null;
    var objInfo = this._getObjectInfo(object);
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object, {
          visibility: "visible"
        }],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      switch (direction) {
        case "DirectionUp":
          t1.from(object, duration, {
            y: -objInfo.height,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
          });
          break;
        case "DirectionDown":
          t1.from(object, duration, {
            y: objInfo.height,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
          });
          break;
        case "DirectionLeft":
          t1.from(object, duration, {
            x: -objInfo.width,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
          });
          break;
        case "DirectionRight":
          t1.from(object, duration, {
            x: objInfo.width,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
          });
          break;
        default:
          console.log("getEffectPeek:parameter error.");
          break;
      }
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      switch (direction) {
        case "DirectionUp":
          t1.to(object, duration, {
            y: -objInfo.height,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionUp", objInfo]
          });
          break;
        case "DirectionDown":
          t1.to(object, duration, {
            y: objInfo.height,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionDown", objInfo]
          });
          break;
        case "DirectionLeft":
          t1.to(object, duration, {
            x: -objInfo.width,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionLeft", objInfo]
          });
          break;
        case "DirectionRight":
          t1.to(object, duration, {
            x: objInfo.width,
            ease: Linear.easeNone,
            onUpdate: this._updateClipRect,
            onUpdateParams: [t1, object, isExit, "DirectionRight", objInfo]
          });
          break;
        default:
          console.log("getEffectPeek:parameter error.");
          break;
      }
    }
    return t1;
  };

  //螺旋飞入/出
  animproto.getEffectSpiral = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var easeString = Power1.easeInOut;
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (isExit == false) {
      t1.from(object, duration, {
        scale: 0,
        bezier: {
          type: "cubic",
          values: [{
            x: 0,
            y: 0
          }, {
            x: 200,
            y: -200
          }, {
            x: 0,
            y: -400
          }, {
            x: -500,
            y: -600
          }]
        },
        ease: easeString
      });
    } else {
      t1.to(object, duration, {
        scale: 0,
        bezier: {
          type: "cubic",
          values: [{
            x: 0,
            y: 0
          }, {
            x: 200,
            y: -200
          }, {
            x: 0,
            y: -400
          }, {
            x: -500,
            y: -600
          }]
        },
        ease: easeString
      });
    }
    return t1;
  };

  //曲线向上/下
  animproto.getEffectArcUp = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    var easeString = Power1.easeInOut;
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        autoAlpha: 0,
        scale: 2,
        bezier: {
          type: "cubic",
          values: [{
            x: 0,
            y: 0
          }, {
            x: 200,
            y: 200
          }, {
            x: 0,
            y: 400
          }, {
            x: -500,
            y: 600
          }]
        },
        ease: easeString
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1,
          scale: 1
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        scale: 2,
        bezier: {
          type: "cubic",
          values: [{
            x: 0,
            y: 0
          }, {
            x: 200,
            y: 200
          }, {
            x: 0,
            y: 400
          }, {
            x: -500,
            y: 600
          }]
        },
        ease: easeString,
        clearProps: "x,y"
      });
    }
    return t1;
  };

  //升起/下沉
  animproto.getEffectRiseUp = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    var objInfo = this._getObjectInfo(object);
    var y = objInfo.offsetBottom + objInfo.height;
    var easeString = Back.easeInOut;
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        autoAlpha: 0,
        y: y,
        ease: easeString
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        y: y,
        ease: easeString
      });
    }
    return t1;
  };
}

var ceil = Math.ceil;
var pow = Math.pow;
var regexpHex = /^#[0-9a-fA-F]{3,6}$/; //Hex

/**
 * 计算两点直线距离
 */
function calculateDistance(currentPoint, historyPoint) {
  var xdiff = currentPoint.x - historyPoint.x;
  var ydiff = currentPoint.y - historyPoint.y;
  return ceil(pow(xdiff * xdiff + ydiff * ydiff, 0.5));
}

/**
 * 区间计算
 */
function calculateDirection(currentPoint, historyPoint) {
  var quadrant = ""; //象限
  if (currentPoint.y == historyPoint.y && currentPoint.x > historyPoint.x) quadrant = "+x"; //水平正方向
  else if (currentPoint.y == historyPoint.y && currentPoint.x < historyPoint.x) quadrant = "-x"; //水平负方向
    else if (currentPoint.x == historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "+y"; //垂直正方向
      else if (currentPoint.x == historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "-y"; //垂直负方向
        else if (currentPoint.x > historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "1"; //第一象限
          else if (currentPoint.x > historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "2"; //第二象限
            else if (currentPoint.x < historyPoint.x && currentPoint.y > historyPoint.y) quadrant = "3"; //第三象限
              else if (currentPoint.x < historyPoint.x && currentPoint.y < historyPoint.y) quadrant = "4"; //第四象限
  return quadrant;
}

/**
 * 十六进制颜色转换为RGB颜色
 * @param color 要转换的十六进制颜色
 * @return RGB颜色
 */
function colorHexToRGB(color, opacity) {
  color = color.toUpperCase();
  if (regexpHex.test(color)) {
    var hexArray = new Array();
    var count = 1;
    for (var i = 1; i <= 3; i++) {
      if (color.length - 2 * i > 3 - i) {
        hexArray.push(Number("0x" + color.substring(count, count + 2)));
        count += 2;
      } else {
        hexArray.push(Number("0x" + color.charAt(count) + color.charAt(count)));
        count += 1;
      }
    }
    if (opacity && opacity > 0) return "RGBA(" + hexArray.join(",") + "," + opacity + ")";else return "RGB(" + hexArray.join(",") + ")";
  } else {
    console.error("Hex Color string(" + color + ") format conversion error.");
    return color;
  }
}

/**
 * RGB颜色转换为十六进制颜色
 * @param color 要转换的RGB颜色
 * @return 十六进制颜色
 */

/*基本动画类鼠标响应事件*/

var hasTouch$2 = Xut.plat.hasTouch;

var MoveMent = function () {
  function MoveMent(pageType, parentId, objectId, startCallback, moveCallback, endCallback) {
    classCallCheck(this, MoveMent);

    this.hasTouch = hasTouch$2;
    this.parent = document.getElementById(parentId);
    this.scroller = document.getElementById(objectId);
    this.startCallback = startCallback;
    this.moveCallback = moveCallback;
    this.endCallback = endCallback;
    if (this.scroller == null) {
      console.error("The control area of the object is empty.");
      return;
    }

    //取消默认翻页行为
    if (Xut.Contents.ResetDefaultControl) {
      Xut.Contents.ResetDefaultControl(pageType, parentId);
    }

    //注销重复事件
    if (this.scroller["bindMoveMent"]) {
      this.scroller["bindMoveMent"].destroy();
    }

    $on(this.scroller, {
      start: this
    });

    this.scroller["bindMoveMent"] = this; //实例化对象绑定到元素，便于后期调用
  }

  createClass(MoveMent, [{
    key: "handleEvent",
    value: function handleEvent(e) {
      $handle({
        start: function start(e) {
          this._start(e);
        },
        move: function move(e) {
          this._move(e);
        },
        end: function end(e) {
          this._end(e);
        },
        cancel: function cancel(e) {
          this._end(e);
        }
      }, this, e);
    }
  }, {
    key: "_start",
    value: function _start(e) {
      e.preventDefault();
      if (typeof this.startCallback == "function") this.startCallback(e);
      $on(this.scroller, {
        move: this,
        end: this,
        cancel: this
      });
    }
  }, {
    key: "_move",
    value: function _move(e) {
      if (typeof this.moveCallback == "function") this.moveCallback(e);
    }
  }, {
    key: "_end",
    value: function _end(e) {
      $off(this.scroller);
      if (typeof this.endCallback == "function") this.endCallback(e);
    }
  }, {
    key: "destroy",
    value: function destroy(type, el, bubble) {
      $off(this.scroller);
      this.scroller = null;
    }
  }]);
  return MoveMent;
}();

var hasTouch$1 = Xut.plat.hasTouch;

/**
 * 路径动画
 * @param  {[type]} animproto [description]
 * @return {[type]}           [description]
 */
function path$1(animproto) {

  //路径动画
  animproto.getPathAnimation = function (parameter, object, duration, delay, repeat) {
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var path = parameter.path ? parameter.path : ""; //路径
    if (!path || path == "") return t1;

    var autoReverse = parameter.autoReverse == 1 ? true : false; //自动翻转(系统自带,实为沿路径返回)
    var subRepeat = autoReverse == true ? 1 : 0; //如果autoReverse为真而子动画必须为1，否则默认为0
    var autoRotate = parameter.objFollow == 1 ? true : false; //是否跟随路径旋转对象(Z轴)
    var autoTurn = parameter.objFollow == 2 ? true : false; //反向运动时自动翻转对象(Y轴)
    //连续行为参数处理
    var axis = 0;
    var degree = 0; //旋转角度
    var scaleFactor = null; //缩放比例(未设置时必须为null才能不影响其它动画效果)

    // var motionScript = ""; //连续脚本
    if (parameter.attrAlongPath) {
      axis = parameter.attrAlongPath.axis ? parameter.attrAlongPath.axis : 0;
      degree = Math.abs(parameter.attrAlongPath.degree) > 0 ? Number(parameter.attrAlongPath.degree) : 0;
      scaleFactor = parameter.attrAlongPath.scaleFactor > 0 ? parameter.attrAlongPath.scaleFactor : null;
      // motionScript = parameter.attrAlongPath.motionScript;
    }

    var currentFrame = 0; //当前帧
    var currentDegree = 0; //当前翻转角度
    var currentOffset = object.offset(); //对象当前位置
    var turnState = ""; //当前运动状态(左/右)
    //对象原点坐标（相对页面原点）
    var objInfo = {
      top: currentOffset.top,
      left: currentOffset.left,
      oX: currentOffset.left + object.width() / 2, //计算object的中心点x坐标
      oY: currentOffset.top + object.height() / 2 //计算object的中心点有y坐标
    };
    //移动起点坐标（默认为对象原点0,0）
    var x0 = 0,
        y0 = 0;
    //对象当前坐标
    var cx = 0,
        cy = 0;

    function resetStartPoint(x, y) {
      //如果路径动画为：EffectPathStairsDown向下阶梯、EffectPathBounceLeft向左弹跳、EffectPathBounceRight 向右弹跳，则需要重置起点坐标(此问题待验证,暂取消)
      /*if (parameter.animationName == "EffectPathStairsDown" || parameter.animationName == "EffectPathBounceLeft" || parameter.animationName == "EffectPathBounceRight") {
          x0 = x;
          y0 = y;
      }*/
      //更新当前坐标
      cx = x;
      cy = y;
    }
    var isCurve = path.indexOf("C") < 0 && path.indexOf("c") < 0; //是否为曲线路径
    var ArrPath = path.split(' ');
    var svgPath = ''; //VML路径转SVG路径(测试)
    var quArr = [];
    var x, y;
    for (var k = 0; k < ArrPath.length; k++) {
      var str = ArrPath[k];
      switch (str) {
        case "M": //移动（开始）
        case "m":
          x = Math.round(ArrPath[k + 1] * this.visualWidth);
          y = Math.round(ArrPath[k + 2] * this.visualHeight);
          /*t1.add(TweenMax.to(object, 0.001, {
              x: x,
              y: y
          }));*/
          quArr.push({
            x: x,
            y: y
          });
          k = k + 2;
          resetStartPoint(x, y);
          svgPath += 'M ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
          break;
        case "C": //曲线
        case "c":
          var x1 = x0 + Math.round(ArrPath[k + 1] * this.visualWidth);
          var y1 = y0 + Math.round(ArrPath[k + 2] * this.visualHeight);
          var x2 = x0 + Math.round(ArrPath[k + 3] * this.visualWidth);
          var y2 = y0 + Math.round(ArrPath[k + 4] * this.visualHeight);
          var x3 = x0 + Math.round(ArrPath[k + 5] * this.visualWidth);
          var y3 = y0 + Math.round(ArrPath[k + 6] * this.visualHeight);
          quArr.push({
            x: x1,
            y: y1
          }, {
            x: x2,
            y: y2
          }, {
            x: x3,
            y: y3
          });
          k = k + 6;
          resetStartPoint(x3, y3);
          svgPath += ' C ' + (objInfo.oX + x1) + ' ' + (objInfo.oY + y1) + ' ' + (objInfo.oX + x2) + ' ' + (objInfo.oY + y2) + ' ' + (objInfo.oX + x3) + ' ' + (objInfo.oY + y3);
          break;
        case "L": //直线
        case "l":
          x = x0 + Math.round(ArrPath[k + 1] * this.visualWidth);
          y = y0 + Math.round(ArrPath[k + 2] * this.visualHeight);
          if (x == cx && y == cy) {
            k = k + 2;
            break;
          }
          quArr.push({
            x: x,
            y: y
          });
          k = k + 2;
          resetStartPoint(x, y);
          svgPath += ' L ' + (objInfo.oX + x) + ' ' + (objInfo.oY + y);
          break;
        case "Z":
          //闭合
          if (quArr[0].x != quArr[quArr.length - 1].x || quArr[0].y != quArr[quArr.length - 1].y) {
            quArr.push({
              x: quArr[0].x,
              y: quArr[0].y
            });
          }
          svgPath += ' Z';
          break;
        case "E":
          //结束
          break;
      }
    }

    //启用手势
    if (parameter.gesture) {
      t1 = new TimelineMax({
        paused: true,
        useFrames: true
      });
      parameter.tweenEase = "Linear.easeNone"; //手势控制必须为匀速运动

      //创建SVG路径(用于测试)
      /*if (isDesktop) {
          if ($("#svgPathContainer").length == 0)
              this.container.append('<div id="svgPathContainer" style="position:absolute;width:100%;height:100%;"><svg width="100%" height="100%"  xmlns="http://www.w3.org/2000/svg" version="1.1"></svg></div>');
          var svgDocument = $("#svgPathContainer").find("svg")[0];
          //创建当前路径
          var p = makeShape("Path", {
              id: "Path_" + object[0].id,
              d: svgPath
          });
          svgDocument.appendChild(p);
      }*/

      //创建手势控制区域
      var controlId = object[0].id; //控制区ID
      if (parameter.gesture.controlType == 1) {
        if (parameter.pathContent > 0) {
          controlId = controlId.replace(/\d+$/, parameter.pathContent);
        } else {
          controlId = "Cont_" + object[0].id;
          // var expandArea = 20; //最小可触摸尺寸(扩展外框)
          //     var rect = p.getBoundingClientRect();
          //     this.container.append('<div id="' + controlId + '" style="z-index:9999;position:absolute;left:' + (rect.left - expandArea) + 'px;top:' + (rect.top - expandArea) + 'px;width:' + (rect.width + expandArea * 2) + 'px;height:' + (rect.height + expandArea * 2) + 'px;"></div>');
        }
      }
      //计算路径距离
      var distance = 0;
      //distance = p.getTotalLength(); //SVG路径获取长度
      var sprotInfo = [];
      for (var m = 1; m < quArr.length; m++) {
        //获取距离
        distance += calculateDistance(quArr[m], quArr[m - 1]);
        sprotInfo.push({
          start: 0,
          end: distance,
          quadrant: calculateDirection(quArr[m], quArr[m - 1])
        });
      }
      //修改时间为帧数(距离转换为帧)
      duration = Math.floor(distance);
      //触发点列表
      var cuePoints = [];
      if (parameter.gesture.cuePoints) {
        for (var i = 0; i < parameter.gesture.cuePoints.length; i++) {
          cuePoints.push({
            cueStart: Math.floor(parameter.gesture.cuePoints[i].cueStart * duration),
            cueEnd: Math.floor(parameter.gesture.cuePoints[i].cueEnd * duration),
            valueStart: parameter.gesture.cuePoints[i].valueStart,
            valueEnd: parameter.gesture.cuePoints[i].valueEnd,
            mouseEnter: false,
            mouseLeave: false
          });
        }
      }

      //绑定手势事件
      var historyPoint = null;

      var startEvent = function startEvent(e) {
        historyPoint = {
          x: hasTouch$1 ? e.changedTouches[0].pageX : e.clientX,
          y: hasTouch$1 ? e.changedTouches[0].pageY : e.clientY
        };
      };

      var moveEnd = function moveEnd() {
        historyPoint = null;
        //松手后行为(辅助对象ID)
        if (parameter.gesture.afterTouch > 0) Xut.Assist.Run(parameter.pageType, parameter.gesture.afterTouch, null);
      };

      var moveEvent = function moveEvent(e) {
        var i;
        var currentPoint = {
          x: hasTouch$1 ? e.changedTouches[0].pageX : e.clientX,
          y: hasTouch$1 ? e.changedTouches[0].pageY : e.clientY
        };
        var d = calculateDistance(currentPoint, historyPoint); //鼠示移动距离
        var quadrant1 = 0; //对象移动方向
        for (i = 0; i < sprotInfo.length; i++) {
          if (currentFrame <= sprotInfo[i].end) {
            quadrant1 = sprotInfo[i].quadrant;
            break;
          }
        }
        var quadrant2 = calculateDirection(currentPoint, historyPoint); //鼠标移动方向
        switch (quadrant1) {
          case "1":
          case "2":
            if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame + d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame + (currentPoint.x - historyPoint.x);else if (quadrant1 == "1" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame - (currentPoint.y - historyPoint.y);else if (quadrant1 == "2" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
            break;
          case "3":
          case "4":
            if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame - (currentPoint.x - historyPoint.x);else if (quadrant1 == "3" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame + (currentPoint.y - historyPoint.y);else if (quadrant1 == "4" && (quadrant2 == "+y" || quadrant2 == "-y")) currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
            break;
          case "+x":
            if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame + d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame + (currentPoint.x - historyPoint.x);
            break;
          case "-x":
            if (quadrant2 == "1" || quadrant2 == "2") currentFrame = currentFrame - d;else if (quadrant2 == "3" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "+x" || quadrant2 == "-x") currentFrame = currentFrame - (currentPoint.x - historyPoint.x);
            break;
          case "+y":
            if (quadrant2 == "1" || quadrant2 == "4") currentFrame = currentFrame - d;else if (quadrant2 == "2" || quadrant2 == "3") currentFrame = currentFrame + d;else if (quadrant2 == "+y" || quadrant2 == "-y") currentFrame = currentFrame + (currentPoint.y - historyPoint.y);
            break;
          case "-y":
            if (quadrant2 == "1" || quadrant2 == "4") currentFrame = currentFrame + d;else if (quadrant2 == "2" || quadrant2 == "3") currentFrame = currentFrame - d;else if (quadrant2 == "+y" || quadrant2 == "-y") currentFrame = currentFrame - (currentPoint.y - historyPoint.y);
            break;
        }
        if (currentFrame <= 0) currentFrame = 0;
        if (currentFrame >= duration) currentFrame = duration;
        t1.seek(currentFrame);
        updateTurnState();
        historyPoint = currentPoint;
        //处理触发点列表
        for (i = 0; i < cuePoints.length; i++) {
          if (cuePoints[i].mouseEnter == false && currentFrame >= cuePoints[i].cueStart && currentFrame <= cuePoints[i].cueEnd) {
            cuePoints[i].mouseEnter = true;
            cuePoints[i].mouseLeave = false;
            if (cuePoints[i].valueStart > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueStart, null);
            break;
          } else if (cuePoints[i].mouseEnter == true && cuePoints[i].mouseLeave == false && (currentFrame < cuePoints[i].cueStart || currentFrame > cuePoints[i].cueEnd)) {
            cuePoints[i].mouseEnter = false;
            cuePoints[i].mouseLeave = true;
            if (cuePoints[i].valueEnd > 0) Xut.Assist.Run(parameter.pageType, cuePoints[i].valueEnd, null);
            break;
          }
        }
      };

      var objectId = object[0].id;
      if (parameter.gesture.controlType == 1) {
        objectId = controlId;
      }

      new MoveMent(parameter.pageType, controlId, objectId, startEvent, moveEvent, moveEnd);
    }
    //贝赛尔曲线参数构造
    var bezierObj = {
      type: "soft",
      values: quArr,
      autoRotate: autoRotate
    };
    if (isCurve == true) {
      bezierObj = {
        curviness: 0, //curviness圆滑度(数字越大越圆滑),默认为1,0是直线运动
        values: quArr,
        autoRotate: autoRotate
      };
    }
    //实例化动画参数
    if (degree == 0) {
      t1.to(object, duration, {
        scale: scaleFactor,
        bezier: bezierObj,
        repeat: subRepeat,
        yoyo: autoReverse,
        onUpdate: updateTurnState,
        ease: parameter.tweenEase
      });
    } else {
      switch (axis) {
        default:
        case 0:
          //Z轴
          t1.to(object, duration, {
            scale: scaleFactor,
            rotation: degree + "deg",
            bezier: bezierObj,
            repeat: subRepeat,
            yoyo: autoReverse,
            onUpdate: updateTurnState,
            ease: parameter.tweenEase
          });
          break;
        case 1:
          //X轴
          t1.to(object, duration, {
            scale: scaleFactor,
            rotationX: degree + "deg",
            bezier: bezierObj,
            repeat: subRepeat,
            yoyo: autoReverse,
            onUpdate: updateTurnState,
            ease: parameter.tweenEase
          });
          break;
        case 2:
          //Y轴
          t1.to(object, duration, {
            scale: scaleFactor,
            rotationY: degree + "deg",
            bezier: bezierObj,
            repeat: subRepeat,
            yoyo: autoReverse,
            onUpdate: updateTurnState,
            ease: parameter.tweenEase
          });
          break;
      }
    }

    //初始化定位(百分比)
    if (parameter.gesture && parameter.gesture.initPos > 0) {
      currentFrame = duration * parameter.gesture.initPos;
      t1.seek(currentFrame);
    }

    return t1;

    function updateTurnState() {
      /*var sel=object[0]
      sel.style.display = 'none';
      sel.offsetHeight;
      sel.style.display = 'block';*/
      if (autoTurn == false) return;
      var oldOffset = currentOffset;
      currentOffset = object.offset();
      if (turnState == "") {
        if (currentOffset.left > oldOffset.left) {
          turnState = "left";
        } else if (currentOffset.left < oldOffset.left) {
          turnState = "right";
        }
      } else {
        if (currentOffset.left > oldOffset.left) {
          if (turnState == "right") {
            if (currentDegree == 0) currentDegree = 180;else currentDegree = 0;
            TweenLite.set(object.children(), {
              rotationY: currentDegree
            });
            turnState = "left";
          }
        } else if (currentOffset.left < oldOffset.left) {
          if (turnState == "left") {
            if (currentDegree == 0) currentDegree = 180;else currentDegree = 0;
            TweenLite.set(object.children(), {
              rotationY: currentDegree
            });
            turnState = "right";
          }
        }
      }
    }
  };
}

var transformOrigin = Xut.style.transformOrigin;

/**
 * 旋转类动画
 * @param  {[type]} animproto [description]
 * @return {[type]}           [description]
 */
function rotate(animproto) {

  //基本旋转
  animproto.getEffectSwivel = function (parameter, object, duration, delay, repeat, isExit) {
    var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical
    var t1 = null;
    var easeString = Linear.easeNone;
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object, {
          visibility: "visible"
        }],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      switch (direction) {
        case "DirectionHorizontal":
          t1.from(object, duration, {
            rotationY: "480deg",
            ease: easeString
          });
          break;
        case "DirectionVertical":
          t1.from(object, duration, {
            rotationX: "480deg",
            ease: easeString
          });
          break;
        default:
          console.log("getEffectSwivel:parameter error.");
          break;
      }
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          visibility: "hidden"
        }]
      });
      switch (direction) {
        case "DirectionHorizontal":
          t1.to(object, duration, {
            rotationY: "480deg",
            ease: easeString
          });
          break;
        case "DirectionVertical":
          t1.to(object, duration, {
            rotationX: "480deg",
            ease: easeString
          });
          break;
        default:
          console.log("getEffectSwivel:parameter error.");
          break;
      }
    }
    return t1;
  };

  //陀螺旋转
  animproto.getEffectSpin = function (parameter, object, duration, delay, repeat) {
    var degree = parameter.amount ? parameter.amount : 360; //陀螺旋转角度
    if (Math.abs(parameter.degree) > 0) degree = parameter.degree;
    if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转

    switch (parameter.centerPos) {
      case 1:
        //左上角
        object.css(transformOrigin, "left top");
        break;
      case 2:
        //上边中心
        object.css(transformOrigin, "center top");
        break;
      case 3:
        //右上角
        object.css(transformOrigin, "right top");
        break;
      case 4:
        //左边中心
        object.css(transformOrigin, "left cneter");
        break;
      case 5:
        //右边中心
        object.css(transformOrigin, "right center");
        break;
      case 6:
        //左下角
        object.css(transformOrigin, "left bottom");
        break;
      case 7:
        //下边中心
        object.css(transformOrigin, "center bottom");
        break;
      case 8:
        //右下角
        object.css(transformOrigin, "right bottom");
        break;
      case 0:
      default:
        //默认中心0
        object.css(transformOrigin, "center");
        break;
    }

    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    //t1.to(object, duration, {rotation:degree+"deg",ease:parameter.tweenEase});
    switch (parameter.axis) {
      case 1:
        //X轴
        t1.to(object, duration, {
          rotationX: "+=" + degree + "deg",
          ease: parameter.tweenEase
        });
        break;
      case 2:
        //Y轴
        t1.to(object, duration, {
          rotationY: "+=" + degree + "deg",
          ease: parameter.tweenEase
        });
        break;
      case 0: //Z轴
      default:
        t1.to(object, duration, {
          rotation: "+=" + degree + "deg",
          ease: parameter.tweenEase
        });
        break;
    }
    return t1;
  };

  //飞旋
  animproto.getEffectBoomerang = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    var time = duration / 3;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.add(TweenMax.to(object, 0.01, {
        x: 300,
        y: -200,
        rotation: "-60deg"
      }), "first");
      t1.add(TweenMax.to(object, time, {
        autoAlpha: 1,
        x: 0,
        y: 0,
        rotation: "0deg"
      }), "second");
      t1.add(TweenMax.to(object, time, {
        rotationY: "-80deg"
      }), "second");
      t1.add(TweenMax.to(object, time, {
        rotationY: "0deg"
      }));
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1,
          x: 0,
          y: 0,
          rotation: "0deg"
        }]
      });
      t1.add(TweenMax.to(object, time, {
        rotationY: "-80deg"
      }), "frist");
      t1.add(TweenMax.to(object, time, {
        autoAlpha: 0,
        x: 300,
        y: -200,
        rotation: "-60deg"
      }), "second");
      t1.add(TweenMax.to(object, time, {
        rotationY: "0deg"
      }), "second");
    }
    return t1;
  };

  //中心旋转
  animproto.getEffectCenterRevolve = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    var easeString = Power1.easeInOut;
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object, {
          visibility: "visible"
        }],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        bezier: {
          type: "cubic",
          values: [{
            x: 0,
            y: 0
          }, {
            x: 200,
            y: 100
          }, {
            x: 200,
            y: 200
          }, {
            x: 0,
            y: 300
          }]
        },
        ease: easeString
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          visibility: "hidden"
        }]
      });
      t1.to(object, duration, {
        bezier: {
          type: "cubic",
          values: [{
            x: 0,
            y: 0
          }, {
            x: 200,
            y: 100
          }, {
            x: 200,
            y: 200
          }, {
            x: 0,
            y: 300
          }]
        },
        ease: easeString
      });
    }
    return t1;
  };

  //回旋
  animproto.getEffectSpinner = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    var easeString = Expo.easeOut;
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object, {
          visibility: "visible"
        }],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        scale: 0,
        rotation: "180deg",
        ease: easeString
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          visibility: "hidden",
          scale: 1,
          rotation: "0deg"
        }]
      });
      t1.to(object, duration, {
        scale: 0,
        rotation: "180deg",
        ease: easeString
      });
    }
    return t1;
  };

  //旋转(淡出式回旋)
  animproto.getEffectFadedSwivel = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    var easeString = Linear.easeNone;
    var degree = Math.abs(parameter.degree) > 0 ? Number(parameter.degree) : 90;
    if (parameter.clockWise == 0) degree = 0 - degree; //逆时针旋转
    switch (parameter.centerPos) {
      case 1:
        //左上角
        object.css(transformOrigin, "left top");
        break;
      case 2:
        //上边中心
        object.css(transformOrigin, "center top");
        break;
      case 3:
        //右上角
        object.css(transformOrigin, "right top");
        break;
      case 4:
        //左边中心
        object.css(transformOrigin, "left cneter");
        break;
      case 5:
        //右边中心
        object.css(transformOrigin, "right center");
        break;
      case 6:
        //左下角
        object.css(transformOrigin, "left bottom");
        break;
      case 7:
        //下边中心
        object.css(transformOrigin, "center bottom");
        break;
      case 8:
        //右下角
        object.css(transformOrigin, "right bottom");
        break;
      case 0:
      default:
        //默认中心0
        object.css(transformOrigin, "center");
        break;
    }
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      //t1.from(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
      switch (parameter.axis) {
        case 0:
          //Z轴
          t1.from(object, duration, {
            autoAlpha: 0,
            rotation: degree + "deg",
            ease: easeString,
            immediateRender: false
          });
          break;
        case 1:
          //X轴
          t1.from(object, duration, {
            autoAlpha: 0,
            rotationX: degree + "deg",
            ease: easeString,
            immediateRender: false
          });
          break;
        case 2: //Y轴
        default:
          t1.from(object, duration, {
            autoAlpha: 0,
            rotationY: degree + "deg",
            ease: easeString,
            immediateRender: false
          });
          break;
      }
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1
        }]
      });
      //t1.to(object,duration,{autoAlpha:0,rotationY:"540deg",ease:Linear.easeNone}); //PPT默认效果
      switch (parameter.axis) {
        case 0:
          //Z轴
          t1.to(object, duration, {
            autoAlpha: 0,
            rotation: degree + "deg",
            ease: easeString
          });
          break;
        case 1:
          //X轴
          t1.to(object, duration, {
            autoAlpha: 0,
            rotationX: degree + "deg",
            ease: easeString
          });
          break;
        case 2: //Y轴
        default:
          t1.to(object, duration, {
            autoAlpha: 0,
            rotationY: degree + "deg",
            ease: easeString
          });
          break;
      }
    }
    return t1;
  };
}

var filter$2 = Xut.style.filter;

function special(animproto) {

  //文字动画
  animproto.getTextAnimation = function (parameter, object, duration, delay, repeat) {
    if (delay == 0) delay = 0.1; //子对象间延时不能为0
    var type = parameter.effectType ? parameter.effectType : "text1";
    var color = parameter.startColor ? parameter.startColor : "";
    var svgElement = object.find("svg").children();
    var t1 = new TimelineMax({
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    switch (type) {
      default:
      case "text5": //文字逐行蹦出(以行为单位)
      case "text1":
        //文字逐个蹦出(以字为单位)
        t1.staggerFrom(svgElement.children(), duration, {
          css: {
            'opacity': 0
          }
        }, delay);
        break;
      case "text2":
        //文字放大出现(以字为单位)
        t1.staggerFrom(svgElement.children(), duration, {
          css: {
            'opacity': 0,
            "font-size": 120
          },
          ease: "Strong.easeOut"
        }, delay);
        break;
      case "text3":
        //文字缩小出现(以字为单位)
        t1.staggerFrom(svgElement.children(), duration, {
          css: {
            'opacity': 0,
            "font-size": 0
          },
          ease: "Power1.easeIn"
        }, delay);
        break;
      case "text4":
        //文字渐变出现(以字为单位)
        t1.staggerFrom(svgElement.children(), duration, {
          css: {
            'opacity': 0,
            "fill": color
          },
          ease: "Power1.easeIn"
        }, delay);
        break;
    }
    return t1;
  };

  //脉冲
  animproto.getEffectFlashBulb = function (parameter, object, duration, delay, repeat) {
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var range = Number(parameter.range) ? parameter.range : 0.1;
    var time = duration / 2;
    t1.to(object, time, {
      autoAlpha: 0.5,
      scale: "+=" + range
    }).to(object, time, {
      autoAlpha: 1,
      scale: "-=" + range
    });
    return t1;
  };

  //百叶窗
  animproto.getEffectBlinds = function (parameter, object, duration, delay, repeat, isExit) {
    if (this.useMask == false) return this.getEffectAppear(parameter, object, duration, delay, repeat, isExit);

    var direction = parameter.direction; //方向（水平：DirectionHorizontal、垂直：DirectionVertical）
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    t1.to(object, duration, {
      onUpdate: updateEffectBlinds
    });
    return t1;

    function updateEffectBlinds() {
      var num = 6; //分成N等份
      var progress = t1.progress();
      var percent = progress / num;
      var avg = 1 / num;
      var temp = 0.01; //渐变的过渡区
      var str = "";
      if (isExit == false) {
        switch (direction) {
          case "DirectionHorizontal":
            //水平
            str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + percent + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
            for (var i = 1; i < num; i++) {
              str += ",color-stop(" + i * avg + ",rgba(0,0,0,0))" + ",color-stop(" + (i * avg + temp) + ",rgba(0,0,0,1))";
              str += ",color-stop(" + (i * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (i * avg + percent + temp) + ",rgba(0,0,0,0))";
            }
            str += ")";
            break;
          case "DirectionVertical":
            //垂直
            str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + percent + ",rgba(0,0,0,1))" + ",color-stop(" + (percent + temp) + ",rgba(0,0,0,0))";
            for (var j = 1; j < num; j++) {
              str += ",color-stop(" + j * avg + ",rgba(0,0,0,0))" + ",color-stop(" + (j * avg + temp) + ",rgba(0,0,0,1))";
              str += ",color-stop(" + (j * avg + percent) + ",rgba(0,0,0,1))" + ",color-stop(" + (j * avg + percent + temp) + ",rgba(0,0,0,0))";
            }
            str += ")";
            break;
          default:
            console.log("getEffectBlinds:parameter error.");
            break;
        }
        object.css("-webkit-mask", str);
        if (percent >= avg - temp) object.css("-webkit-mask", "none");
      } else {
        switch (direction) {
          case "DirectionHorizontal":
            //水平
            str = "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
            for (var n = 1; n < num; n++) {
              str += ",color-stop(" + n * avg + ",rgba(0,0,0,1))" + ",color-stop(" + (n * avg - temp) + ",rgba(0,0,0,0))";
              str += ",color-stop(" + (n * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (n * avg - percent - temp) + ",rgba(0,0,0,1))";
            }
            str += ")";
            break;
          case "DirectionVertical":
            //垂直
            str = "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,0))" + ",color-stop(" + (1 - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (1 - percent - temp) + ",rgba(0,0,0,1))";
            for (var k = 1; k < num; k++) {
              str += ",color-stop(" + k * avg + ",rgba(0,0,0,1))" + ",color-stop(" + (k * avg - temp) + ",rgba(0,0,0,0))";
              str += ",color-stop(" + (k * avg - percent) + ",rgba(0,0,0,0))" + ",color-stop(" + (k * avg - percent - temp) + ",rgba(0,0,0,1))";
            }
            str += ")";
            break;
          default:
            console.log("getEffectBlinds:parameter error.");
            break;
        }
        object.css("-webkit-mask", str);
        if (percent >= avg - temp) {
          //object.css("opacity","0");
          object.css("visibility", "hidden");
          object.css("-webkit-mask", "none");
        }
      }
    }
  };

  //劈裂
  animproto.getEffectSplit = function (parameter, object, duration, delay, repeat, isExit) {
    if (this.useMask == false) return this.getEffectAppear(parameter, object, duration, delay, repeat, isExit);

    var direction = parameter.direction; //方向(DirectionVerticalIn、DirectionHorizontalIn、DirectionHorizontalOut、DirectionVerticalOut)
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    t1.to(object, duration, {
      onUpdate: updateEffectSplit
    });
    return t1;

    function updateEffectSplit() {
      var progress = t1.progress();
      var percent = progress / 2;
      if (isExit == false) {
        if (progress > 0.9) {
          //跳过最后10%（解决iPad的闪问题）
          object.css("-webkit-mask", "none");
          return;
        }
        switch (direction) {
          case "DirectionVerticalIn":
            //左右向中间收
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
            break;
          case "DirectionHorizontalIn":
            //上下向中间收
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,0)),color-stop(" + (1 - percent) + ",rgba(0,0,0,0)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,1)))");
            break;
          case "DirectionHorizontalOut":
            //中间向上下展开
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
            break;
          case "DirectionVerticalOut":
            //中间向左右展开
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,0)))");
            break;
          default:
            console.log("getEffectSplit:parameter error.");
            break;
        }
        //if (percent >= 0.5) object.css("-webkit-mask", "none");
      } else {
        if (progress < 0.1) return; //跳过前面10%（解决iPad的闪问题）
        switch (direction) {
          case "DirectionVerticalIn":
            //左右向中间收
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
            break;
          case "DirectionHorizontalIn":
            //上下向中间收
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0)),color-stop(" + (percent - 0.05) + ",rgba(0,0,0,0)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent + 0.05) + ",rgba(0,0,0,0)))");
            break;
          case "DirectionHorizontalOut":
            //中间向上下展开
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
            break;
          case "DirectionVerticalOut":
            //中间向左右展开
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.55 - percent) + ",rgba(0,0,0,0)),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,0)),color-stop(" + (percent + 0.55) + ",rgba(0,0,0,1)))");
            break;
          default:
            console.log("getEffectSplit:parameter error.");
            break;
        }
        if (percent >= 0.5) {
          //object.css("opacity","0");
          object.css("visibility", "hidden");
          object.css("-webkit-mask", "none");
        }
      }
    }
  };

  //擦除
  animproto.getEffectWipe = function (parameter, object, duration, delay, repeat, isExit) {
    var direction = parameter.direction; //方向(上下左右)
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var objInfo = this._getObjectInfo(object);
    if (isExit == false) {
      //t1.to(object,duration,{onStart:this._startHandler,onStartParams:[object],onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
      t1.to(object, duration, {
        onUpdate: this._updateClipRect,
        onUpdateParams: [t1, object, isExit, direction, objInfo]
      });
    } else {
      //t1.to(object,duration,{onUpdate:this.updateLineGradient,onUpdateParams:[t1,object,isExit,direction]});
      t1.to(object, duration, {
        onUpdate: this._updateClipRect,
        onUpdateParams: [t1, object, isExit, direction, objInfo]
      });
    }
    return t1;
  };

  //翻转式由远及近
  animproto.getEffectGrowAndTurn = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        autoAlpha: 0,
        scale: 0,
        rotation: "90deg",
        ease: parameter.tweenEase,
        clearProps: "scale,rotation"
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1,
          scale: 1,
          rotation: "0deg"
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        scale: 0,
        rotation: "90deg",
        ease: parameter.tweenEase
      });
    }
    return t1;
  };

  //玩具风车
  animproto.getEffectPinwheel = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        autoAlpha: 0,
        scale: 0,
        rotation: "540deg",
        ease: parameter.tweenEase
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1,
          scale: 1,
          rotation: "0deg"
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        scale: 0,
        rotation: "540deg",
        ease: parameter.tweenEase
      });
    }
    return t1;
  };

  //展开/收缩
  animproto.getEffectExpand = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        autoAlpha: 0,
        rotationY: "45deg",
        ease: parameter.tweenEase
      });
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1,
          rotationY: "0deg"
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        rotationY: "45deg",
        ease: parameter.tweenEase
      });
    }
    return t1;
  };

  //浮动
  animproto.getEffectFloat = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = null;
    var objInfo = this._getObjectInfo(object);
    var x, y;
    if (isExit == false) {
      x = objInfo.offsetRight + objInfo.width;
      y = 0 - (objInfo.offsetTop + objInfo.height);
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      t1.from(object, duration, {
        autoAlpha: 0,
        rotation: "-45deg",
        x: x,
        y: y,
        ease: parameter.tweenEase
      });
    } else {
      x = objInfo.offsetRight + objInfo.width;
      y = 0 - (objInfo.offsetTop + objInfo.height);
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1
        }]
      });
      t1.to(object, duration, {
        autoAlpha: 0,
        rotation: "-45deg",
        x: x,
        y: y,
        ease: parameter.tweenEase
      });
    }
    return t1;
  };

  //字幕式
  animproto.getEffectCredits = function (parameter, object, duration, delay, repeat, isExit) {
    var objInfo = this._getObjectInfo(object);
    var y = 0,
        top = 0;
    if (isExit == false) {
      //从下往上移
      y = 0 - (this.visualHeight + objInfo.height);
      top = objInfo.top + objInfo.offsetBottom + objInfo.height;
    } else {
      //从上往下移
      y = this.visualHeight + objInfo.height;
      top = objInfo.top - (objInfo.offsetTop + objInfo.height);
    }
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible",
        top: top + "px"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    t1.to(object, duration, {
      y: y,
      ease: parameter.tweenEase
    });
    return t1;
  };

  //弹跳
  animproto.getEffectBounce = function (parameter, object, duration, delay, repeat, isExit) {
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var objInfo = this._getObjectInfo(object);

    var time2, time3, time4, time5, y1, y2, y3, y4, lastY, height, time1, total, width;

    if (isExit == false) {
      total = duration;
      time1 = total / 5;
      time2 = total / 10;
      time3 = total / 20;
      time4 = total / 40;
      time5 = total / 80;
      width = 50 + 20 + 10 + 5 + 2.5 + 1 + 0.5 + 0.2 + 0.1;
      height = this.visualHeight / 4;
      y1 = height / 2;
      y2 = height / 4;
      y3 = height / 8;
      y4 = height / 16;
      lastY = objInfo.offsetBottom - height + objInfo.height;

      t1.to(object, 0.01, {
        x: -width,
        y: -height
      }).to(object, time1, {
        x: "+=50",
        y: "+=" + height,
        ease: Circ.easeIn
      }) //慢到快
      .to(object, time1, {
        x: "+=20",
        y: "-=" + y1,
        scaleY: 0.8,
        ease: Circ.easeOut
      }) //快到慢
      .to(object, time1, {
        x: "+=10",
        y: "+=" + y1,
        scaleY: 1,
        ease: Circ.easeIn
      }).to(object, time2, {
        x: "+=5",
        y: "-=" + y2,
        scaleY: 0.85,
        ease: Circ.easeOut
      }).to(object, time2, {
        x: "+=2.5",
        y: "+=" + y2,
        scaleY: 1,
        ease: Circ.easeIn
      }).to(object, time3, {
        x: "+=1",
        y: "-=" + y3,
        scaleY: 0.9,
        ease: Circ.easeOut
      }).to(object, time3, {
        x: "+=0.5",
        y: "+=" + y3,
        scaleY: 1,
        ease: Circ.easeIn
      }).to(object, time4, {
        x: "+=0.2",
        y: "-=" + y4,
        scaleY: 0.95,
        ease: Circ.easeOut
      }).to(object, time4, {
        x: "+=0.1",
        y: "+=" + y4,
        scaleY: 1,
        ease: Circ.easeIn,
        clearProps: "x,y"
      });
      return t1;
    } else {
      total = duration;
      time1 = total / 5;
      time2 = total / 10;
      time3 = total / 20;
      time4 = total / 40;
      time5 = total / 80;
      height = this.visualHeight / 4;
      y1 = height / 2;
      y2 = height / 4;
      y3 = height / 8;
      y4 = height / 16;
      lastY = objInfo.offsetBottom - height + objInfo.height;
      t1.to(object, time1, {
        x: "+=50",
        y: "+=" + height,
        ease: Circ.easeIn
      }) //慢到快
      .to(object, time1, {
        x: "+=20",
        y: "-=" + y1,
        scaleY: 0.8,
        ease: Circ.easeOut
      }) //快到慢
      .to(object, time1, {
        x: "+=10",
        y: "+=" + y1,
        scaleY: 1,
        ease: Circ.easeIn
      }).to(object, time2, {
        x: "+=5",
        y: "-=" + y2,
        scaleY: 0.85,
        ease: Circ.easeOut
      }).to(object, time2, {
        x: "+=2.5",
        y: "+=" + y2,
        scaleY: 1,
        ease: Circ.easeIn
      }).to(object, time3, {
        x: "+=1",
        y: "-=" + y3,
        scaleY: 0.9,
        ease: Circ.easeOut
      }).to(object, time3, {
        x: "+=0.5",
        y: "+=" + y3,
        scaleY: 1,
        ease: Circ.easeIn
      }).to(object, time4, {
        x: "+=0.2",
        y: "-=" + y4,
        scaleY: 0.95,
        ease: Circ.easeOut
      }).to(object, time4, {
        x: "+=0.1",
        y: "+=" + y4,
        scaleY: 1,
        ease: Circ.easeIn
      }).to(object, time5, {
        x: "+=0.1",
        y: "+=" + lastY,
        ease: Circ.easeIn
      });
    }
    return t1;
  };

  //彩色脉冲
  animproto.getEffectFlicker = function (parameter, object, duration, delay, repeat) {
    if (!(filter$2 in object[0].style)) return new TimelineMax();
    //if (repeat < 2) repeat = 2; //默认三次
    var color2 = parameter.color2 ? parameter.color2 : "#fff"; //颜色
    var maxGlowSize = parameter.maxGlowSize ? parameter.maxGlowSize : 0.1; //光晕最大尺寸(百分比)
    var minGlowSize = parameter.minGlowSize ? parameter.minGlowSize : 0.05; //光晕最小尺寸(百分比)
    var size = object.width() > object.height() ? object.height() : object.width();
    var maxSize = maxGlowSize * size;
    var minSize = minGlowSize * size;
    var opacity = Number(parameter.opacity) ? parameter.opcity : 0.75; //不透明度
    var distance = Number(parameter.distance) ? parameter.distance * size : 0; //距离
    var color = colorHexToRGB(color2, opacity);
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object, {
        //"box-shadow": "none"
        filter: "none"
      }]
    });
    t1.to(object, duration, {
      onUpdate: updateEffectFlicker
    });
    return t1;

    function updateEffectFlicker() {
      var progress = t1.progress();
      var percent = parseInt(progress * (maxSize - minSize));
      if (progress > 0.5) percent = parseInt((1 - progress) * (maxSize - minSize));
      //object.css("box-shadow", distance + "px " + distance + "px " + minSize + "px " + (minSize + percent) + "px " + color);
      object.css(filter$2, "drop-shadow(" + color + " " + distance + "px " + distance + "px " + (minSize + percent) + "px)");
    }
  };

  //跷跷板
  animproto.getEffectTeeter = function (parameter, object, duration, delay, repeat) {
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    // var mode = parameter.mode;
    var range = Number(parameter.range) ? parameter.range : 0.02;
    var time = duration / 8; //计算指定动画时间内每次运动时间(总时长不变，循环除外)
    switch (parameter.mode) {
      case 1:
        //左右移动
        range = range * object.width();
        t1.to(object, time, {
          x: -range
        }).to(object, time * 2, {
          x: range
        });
        //for (var i = 1; i < repeat; i++) {
        t1.to(object, time * 2, {
          x: -range
        });
        t1.to(object, time * 2, {
          x: range
        });
        //}
        t1.to(object, time, {
          x: 0
        });
        break;
      case 2:
        //上下移动
        range = range * object.height();
        t1.to(object, time, {
          y: -range
        }).to(object, time * 2, {
          y: range
        });
        //for (var i = 1; i < repeat; i++) {
        t1.to(object, time * 2, {
          y: -range
        });
        t1.to(object, time * 2, {
          y: range
        });
        //}
        t1.to(object, time, {
          y: 0
        });
        break;
      case 3:
        //左右挤压
        t1.to(object, time, {
          scaleX: 1 + range
        }).to(object, time * 2, {
          scaleX: 1 - range
        });
        //for (var i = 1; i < repeat; i++) {
        t1.to(object, time * 2, {
          scaleX: 1 + range
        });
        t1.to(object, time * 2, {
          scaleX: 1 - range
        });
        //}
        t1.to(object, time, {
          scaleX: 1
        });
        break;
      case 4:
        //上下挤压
        t1.to(object, time, {
          scaleY: 1 + range
        }).to(object, time * 2, {
          scaleY: 1 - range
        });
        //for (var i = 1; i < repeat; i++) {
        t1.to(object, time * 2, {
          scaleY: 1 + range
        });
        t1.to(object, time * 2, {
          scaleY: 1 - range
        });
        //}
        t1.to(object, time, {
          scaleY: 1
        });
        break;
      case 0: //左右晃晃
      default:
        range = range * 100;
        t1.to(object, time, {
          rotation: range + "deg"
        }).to(object, time * 2, {
          rotation: -range + "deg"
        });
        //for (var i = 1; i < repeat; i++) {
        t1.to(object, time * 2, {
          rotation: range + "deg"
        });
        t1.to(object, time * 2, {
          rotation: -range + "deg"
        });
        //}
        t1.to(object, time, {
          rotation: "0deg"
        });
        break;
    }
    return t1;
  };

  //补色
  animproto.getEffectComplementaryColor = function (parameter, object, duration, delay, repeat) {
    var zIndex = Number(object.css("z-index"));
    if (isNaN(zIndex)) {
      zIndex = 10;
      console.log("The Z-index property for this object to get error.");
    }
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        "z-Index": zIndex + 100
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object, {
        "z-Index": zIndex
      }]
    });
    t1.to(object, duration, {
      autoAlpha: 1
    });
    return t1;
  };

  //rect切割效果更新
  animproto._updateClipRect = function (t1, object, isExit, direction, objInfo) {
    var progress = t1.progress();
    var len = progress;
    var width, left, top, height;
    if (isExit == false) {
      top = objInfo.height * (1 - len);
      height = objInfo.height - top;
      left = objInfo.width * (1 - len);
      width = objInfo.width - left;
      switch (direction) {
        case "DirectionUp":
          object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
          break;
        case "DirectionDown":
          object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
          break;
        case "DirectionLeft":
          object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
          break;
        case "DirectionRight":
          object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
          break;
        default:
          console.log("_updateClipRect:parameter error.");
          break;
      }
    } else {
      top = objInfo.height * len;
      height = objInfo.height - top;
      left = objInfo.width * len;
      width = objInfo.width - left;
      switch (direction) {
        case "DirectionUp":
          object.css("clip", "rect(" + top + "px " + objInfo.width + "px " + objInfo.height + "px 0px)");
          break;
        case "DirectionDown":
          object.css("clip", "rect(0px " + objInfo.width + "px " + height + "px 0px)");
          break;
        case "DirectionLeft":
          object.css("clip", "rect(0px " + objInfo.width + "px " + objInfo.height + "px " + left + "px)");
          break;
        case "DirectionRight":
          object.css("clip", "rect(0px " + width + "px " + objInfo.height + "px 0px)");
          break;
        default:
          console.log("_updateClipRect:parameter error.");
          break;
      }
    }
  };
}

/**
 * 缩放类动画
 * @param  {[type]} animproto [description]
 * @return {[type]}           [description]
 */
function zoom(animproto) {

  //基本缩放
  animproto.getEffectZoom = function (parameter, object, duration, delay, repeat, isExit) {
    var direction = parameter.direction; //方向(放大:DirectionIn、屏幕中心放大:DirectionInCenter、轻微放大:DirectionInSlightly、缩小:DirectionOut、屏幕底部缩小:DirectionOutBottom、轻微缩小:DirectionOutSlightly)
    var t1 = null;
    var result;
    object.css(Xut.style.transformOrigin, "center"); //设置缩放基点(默认是正中心点)
    if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object, {
          visibility: "visible"
        }],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      switch (direction) {
        case "DirectionIn":
          t1.from(object, duration, {
            scale: 0,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionInCenter":
          result = this._getDirectionInCenter(object);
          t1.from(object, duration, {
            scale: 0,
            x: result.x,
            y: result.y,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionInSlightly":
          t1.from(object, duration, {
            scale: 0.7,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionOut":
          t1.from(object, duration, {
            scale: 3,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionOutBottom":
          //屏幕底部缩小(理解为底部的中间开始)
          t1.from(object, duration, {
            scale: 2,
            top: this.visualWidth + "px",
            ease: parameter.tweenEase
          });
          break;
        case "DirectionOutSlightly":
          t1.from(object, duration, {
            scale: 1.5,
            ease: parameter.tweenEase
          });
          break;
        default:
          console.log("getEffectZoom:parameter error.");
          break;
      }
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          visibility: "hidden"
        }]
      });
      switch (direction) {
        case "DirectionIn":
          t1.to(object, duration, {
            scale: 0,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionInCenter":
          result = this._getDirectionInCenter(object);
          t1.to(object, duration, {
            scale: 0,
            x: result.x,
            y: result.y,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionInSlightly":
          t1.to(object, duration, {
            scale: 0.7,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionOut":
          t1.to(object, duration, {
            scale: 3,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionOutBottom":
          t1.to(object, duration, {
            scale: 2,
            top: this.visualHeight + "px",
            ease: parameter.tweenEase
          });
          break;
        case "DirectionOutSlightly":
          t1.to(object, duration, {
            scale: 1.5,
            ease: parameter.tweenEase
          });
          break;
        default:
          console.log("getEffectZoom:parameter error.");
          break;
      }
    }
    return t1;
  };

  //缩放 淡出式缩放
  animproto.getEffectFadedZoom = function (parameter, object, duration, delay, repeat, isExit) {
    var direction = parameter.direction; //方向(对象中心DirectionIn、幻灯片中心DirectionInCenter)
    var t1 = null;
    object.css(Xut.style.transformOrigin, "center"); //设置缩放基点(默认是正中心点)
    var svgElement = object.find("svg"); //获取SVG对象
    //解决SVG文字错乱问题
    if (svgElement) {
      Xut.style.setTranslate({
        node: svgElement,
        x: 0,
        y: 0
      });
    }

    var keepRatio = parameter.keepRatio == 0 ? false : true; //保持长宽比
    var fullScreen = parameter.fullScreen == 1 ? true : false; //缩放到全屏
    var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
    var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
    var result;
    if (fullScreen == true) {
      //计算比例
      var xScale = this.visualWidth / object.width();
      var yScale = this.visualHeight / object.height();
      var scaleValue = xScale;
      if (xScale > yScale) scaleValue = yScale;
      result = this._getDirectionInCenter(object);
      if (isExit == false) {
        t1 = new TimelineMax({
          delay: delay,
          repeat: repeat,
          onStart: this._startHandler,
          onStartParams: [parameter, object, {
            opacity: 0
          }],
          onComplete: this._completeHandler,
          onCompleteParams: [parameter, object]
        });
        t1.to(object, duration, {
          x: result.x,
          y: result.y,
          autoAlpha: 1,
          scale: scaleValue,
          ease: parameter.tweenEase
        });
      } else {
        t1 = new TimelineMax({
          delay: delay,
          repeat: repeat,
          onStart: this._startHandler,
          onStartParams: [parameter, object],
          onComplete: this._completeHandler,
          onCompleteParams: [parameter, object]
        });
        t1.to(object, duration, {
          x: result.x,
          y: result.y,
          autoAlpha: 0,
          scale: scaleValue,
          ease: parameter.tweenEase
        });
      }
    } else if (isExit == false) {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object]
      });
      switch (direction) {
        case "DirectionIn":
          if (keepRatio == true) t1.from(object, duration, {
            autoAlpha: 0,
            scale: 0,
            ease: parameter.tweenEase
          });else {
            t1.from(object, duration, {
              autoAlpha: 0,
              scaleX: scaleX,
              scaleY: scaleY,
              ease: parameter.tweenEase
            });
          }
          break;
        case "DirectionInCenter":
          result = this._getDirectionInCenter(object);
          if (keepRatio == true) t1.from(object, duration, {
            x: result.x,
            y: result.y,
            autoAlpha: 0,
            scale: 0,
            ease: parameter.tweenEase
          });else t1.from(object, duration, {
            x: result.x,
            y: result.y,
            autoAlpha: 0,
            scaleX: scaleX,
            scaleY: scaleY,
            ease: parameter.tweenEase
          });
          break;
        default:
          console.log("getEffectFadedZoom:parameter error.");
          break;
      }
    } else {
      t1 = new TimelineMax({
        delay: delay,
        repeat: repeat,
        onStart: this._startHandler,
        onStartParams: [parameter, object],
        onComplete: this._completeHandler,
        onCompleteParams: [parameter, object, {
          opacity: 1
        }]
      });
      switch (direction) {
        case "DirectionOut":
          if (keepRatio == true) t1.to(object, duration, {
            autoAlpha: 0,
            scale: 0,
            ease: parameter.tweenEase,
            clearProps: "scale"
          });else t1.to(object, duration, {
            autoAlpha: 0,
            scaleX: scaleX,
            scaleY: scaleY,
            ease: parameter.tweenEase
          });
          break;
        case "DirectionOutCenter":
          result = this._getDirectionInCenter(object);
          if (keepRatio == true) t1.to(object, duration, {
            x: result.x,
            y: result.y,
            autoAlpha: 0,
            scale: 0,
            ease: parameter.tweenEase
          });else t1.to(object, duration, {
            x: result.x,
            y: result.y,
            autoAlpha: 0,
            scaleX: scaleX,
            scaleY: scaleY,
            ease: parameter.tweenEase
          });
          break;
        default:
          console.log("getEffectFadedZoom:parameter error.");
          break;
      }
    }
    return t1;
  };

  //放大/缩小
  animproto.getEffectGrowShrink = function (parameter, object, duration, delay, repeat) {
    var scaleX = parameter.scaleX ? parameter.scaleX : 1; //横向缩放比例
    var scaleY = parameter.scaleY ? parameter.scaleY : 1; //纵向缩放比例
    // var keepRatio = (parameter.keepRatio == 0) ? false : true; //保持长宽比
    var fullScreen = parameter.fullScreen == 1 ? true : false; //缩放到全屏
    var resetSize = parameter.resetSize == 1 ? true : false; //恢复默认尺寸
    var easeString = Linear.easeNone; //Elastic.easeOut
    if (parameter.tweenEase && parameter.tweenEase.length > 0) easeString = parameter.tweenEase;
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    if (fullScreen == true) {
      //计算比例
      var xScale = this.visualWidth / object.width();
      var yScale = this.visualHeight / object.height();
      var scaleValue = xScale;
      if (xScale > yScale) scaleValue = yScale;
      var result = this._getDirectionInCenter(object);
      t1.to(object, duration, {
        x: result.x,
        y: result.y,
        scale: scaleValue,
        ease: parameter.tweenEase
      });
    } else if (resetSize == true) {
      t1.to(object, duration, {
        scaleX: 1,
        scaleY: 1,
        ease: easeString
      });
    } else t1.to(object, duration, {
      scaleX: scaleX,
      scaleY: scaleY,
      ease: easeString
    });
    return t1;
  };

  /**
   * 获取对象至屏幕中心的距离
   * @param  {[type]} object [description]
   * @return {[type]}        [description]
   */
  animproto._getDirectionInCenter = function (object) {
    var objInfo = this._getObjectInfo(object);
    var x = Math.round(this.visualWidth / 2 - objInfo.offsetLeft - objInfo.width / 2);
    var y = Math.round(this.visualHeight / 2 - objInfo.offsetTop - objInfo.height / 2);
    return {
      x: x,
      y: y
    };
  };
}

/**
 * 形状动画
 * @param  {[type]} animproto [description]
 * @return {[type]}           [description]
 */
function shape(animproto) {

  //形状一(圆)
  animproto.getEffectCircle = function (parameter, object, duration, delay, repeat, isExit) {
    if (this.useMask == false) return this.getEffectAppear(parameter, object, duration, delay, repeat, isExit);

    var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var result = this._getObjectInfo(object);
    var radius = Math.ceil(Math.sqrt(result.width * result.width / 4 + result.height * result.height / 4));
    switch (direction) {
      case "DirectionIn": //放大
      case "DirectionOut":
        //缩小
        if (isExit == false) {
          t1.to(object, duration, {
            onUpdate: updateCircleGradient
          });
        } else {
          t1.to(object, duration, {
            onUpdate: updateCircleGradient
          });
        }
        break;
      default:
        console.log("getEffectCircle:parameter error.");
        break;
    }
    return t1;

    function updateCircleGradient() {
      var progress = t1.progress();
      var len = parseInt(progress * radius);
      if (isExit == false) switch (direction) {
        case "DirectionIn":
          //DirectionIn放大
          object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,1)),to(rgba(0,0,0,0)),color-stop(10%,rgba(0,0,0,0)))");
          if (len == radius) object.css("-webkit-mask", "none");
          break;
        case "DirectionOut":
          //DirectionOut缩小
          object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,1)), to(rgba(0,0,0,0)), color-stop(90%, rgba(0,0,0,1)))");
          if (len == radius) object.css("-webkit-mask", "none");
          break;
      } else {
        switch (direction) {
          case "DirectionIn":
            //DirectionIn放大
            object.css("-webkit-mask", "-webkit-gradient(radial,center center," + (radius - len) + ",center center,0,from(rgba(0,0,0,0)),to(rgba(0,0,0,1)),color-stop(10%,rgba(0,0,0,1)))");
            if (len == radius) {
              //object.css("opacity","0");
              object.css("visibility", "hidden");
              object.css("-webkit-mask", "none");
            }
            break;
          case "DirectionOut":
            //DirectionOut缩小
            object.css("-webkit-mask", "-webkit-gradient(radial,center center,0,center center, " + len + ",from(rgba(0,0,0,0)), to(rgba(0,0,0,1)), color-stop(90%, rgba(0,0,0,0)))");
            if (len == radius) {
              //object.css("opacity","0");
              object.css("visibility", "hidden");
              object.css("-webkit-mask", "none");
            }
            break;
        }
      }
    }
  };

  //形状二(方框)
  animproto.getEffectBox = function (parameter, object, duration, delay, repeat, isExit) {
    var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
    if (this.useMask == false) direction = "DirectionOut";

    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    var objInfo = this._getObjectInfo(object);
    t1.to(object, duration, {
      onUpdate: updateEffectBox
    });
    return t1;

    function updateEffectBox() {
      var width, height, left, top;
      var progress = t1.progress();
      var percent = progress / 2;
      if (isExit == false) {
        switch (direction) {
          case "DirectionIn":
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
            break;
          case "DirectionOut":
            top = objInfo.height * (0.5 - percent);
            height = objInfo.height - top;
            left = objInfo.width * (0.5 - percent);
            width = objInfo.width - left;
            object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
            break;
          default:
            console.log("getEffectBox:parameter error.");
            break;
        }
        if (percent >= 0.5) object.css("-webkit-mask", "none");
      } else {
        switch (direction) {
          case "DirectionIn":
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
            break;
          case "DirectionOut":
            top = objInfo.height * percent;
            height = objInfo.height - top;
            left = objInfo.width * percent;
            width = objInfo.width - left;
            object.css("clip", "rect(" + top + "px " + width + "px " + height + "px " + left + "px)");
            break;
          default:
            console.log("getEffectBox:parameter error.");
            break;
        }
        if (percent >= 0.5) {
          //object.css("opacity","0");
          object.css("visibility", "hidden");
          object.css("-webkit-mask", "none");
        }
      }
    }
  };

  //形状三(菱形)
  animproto.getEffectDiamond = function (parameter, object, duration, delay, repeat, isExit) {
    if (this.useMask == false) return this.getEffectAppear(parameter, object, duration, delay, repeat, isExit);

    var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    // var objInfo = this._getObjectInfo(object);
    t1.to(object, duration, {
      onUpdate: updateEffectBox
    });
    return t1;

    function updateEffectBox() {
      var progress = t1.progress();
      var percent = progress / 2;
      if (isExit == false) {
        switch (direction) {
          case "DirectionOut":
          case "DirectionIn":
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + percent + ",rgba(0,0,0,1)),color-stop(" + percent + ",transparent),color-stop(" + (1 - percent) + ",transparent),color-stop(" + (1 - percent) + ",rgba(0,0,0,1)))");
            break;
          default:
            console.log("getEffectBox:parameter error.");
            break;
        }
        if (percent >= 0.5) object.css("-webkit-mask", "none");
      } else {
        switch (direction) {
          case "DirectionOut":
          case "DirectionIn":
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 100% 100%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1))),-webkit-gradient(linear,0% 100%, 100% 0%, from(rgba(0,0,0,1)), to(rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 + percent) + ",transparent),color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)))");
            break;
          default:
            console.log("getEffectBox:parameter error.");
            break;
        }
        if (percent >= 0.5) {
          //object.css("opacity","0");
          object.css("visibility", "hidden");
          object.css("-webkit-mask", "none");
        }
      }
    }
  };

  //形状四(加号)
  animproto.getEffectPlus = function (parameter, object, duration, delay, repeat, isExit) {
    if (this.useMask == false) return this.getEffectAppear(parameter, object, duration, delay, repeat, isExit);

    var direction = parameter.direction; //方向(DirectionIn、DirectionOut)
    var t1 = new TimelineMax({
      delay: delay,
      repeat: repeat,
      onStart: this._startHandler,
      onStartParams: [parameter, object, {
        visibility: "visible"
      }],
      onComplete: this._completeHandler,
      onCompleteParams: [parameter, object]
    });
    t1.to(object, duration, {
      onUpdate: updateEffectPlus
    });
    return t1;

    function updateEffectPlus() {
      var progress = t1.progress();
      var percent = progress / 2;
      if (isExit == false) {
        switch (direction) {
          case "DirectionIn":
          case "DirectionOut":
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + (0.5 - percent) + ",transparent),color-stop(" + (0.5 - percent) + ",rgba(0,0,0,1))," + "color-stop(" + (0.5 + percent) + ",rgba(0,0,0,1)),color-stop(" + (0.5 + percent) + ",transparent))");
            break;
          default:
            console.log("getEffectPlus:parameter error.");
            break;
        }
        if (percent >= 0.5) object.css("-webkit-mask", "none");
      } else {
        switch (direction) {
          case "DirectionIn":
          case "DirectionOut":
            object.css("-webkit-mask", "-webkit-gradient(linear,0% 0%, 0% 100%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + percent + ",transparent),color-stop(" + percent + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))," + "-webkit-gradient(linear,0% 0%, 100% 0%, from(rgba(0,0,0,0)), to(rgba(0,0,0,0))," + "color-stop(" + percent + ",transparent),color-stop(" + percent + ",rgba(0,0,0,1))," + "color-stop(" + (1 - percent) + ",rgba(0,0,0,1)),color-stop(" + (1 - percent) + ",transparent))");
            break;
          default:
            console.log("getEffectPlus:parameter error.");
            break;
        }
        if (percent >= 0.5) {
          //object.css("opacity","0");
          object.css("visibility", "hidden");
          object.css("-webkit-mask", "none");
        }
      }
    }
  };
}

var ROUND = Math.round;
var CEIL$2 = Math.ceil;
var isMacOS = Xut.plat.isMacOS;
var isDesktop = Xut.plat.isDesktop;

/**
 * 子动画回调中
 * 设置参数
 */
function setParams(object, params) {
  for (var item in params) {
    switch (item) {
      case "x":
        TweenLite.set(object, {
          x: params[item]
        });
        break;
      case "y":
        TweenLite.set(object, {
          y: params[item]
        });
        break;
      case "rotation":
        TweenLite.set(object, {
          rotation: params[item]
        });
        break;
      case "rotationX":
        TweenLite.set(object, {
          rotationX: params[item]
        });
        break;
      case "rotationY":
        TweenLite.set(object, {
          rotationY: params[item]
        });
        break;
      case "scale":
        TweenLite.set(object, {
          scale: params[item]
        });
        break;
      default:
        object.css(item, params[item]);
        break;
    }
  }
}

/**
 * 获取默认的状态
 * false:进入 true:消失
 * @return {[type]} [description]
 */
function getExit(parameter) {
  return parameter.exit ? parameter.exit.toLowerCase() == "true" : false;
}

/**
 * 参数说明
 * pageType: 页面类型
 * chapterId: 当前页ID
 * element: 动画对象
 * parameter: 动画参数数组
 * container: 父容器
 * hasLoop: 是否循环动画
 * startEvent: 整个动画开始事件
 * completeEvent: 整个动画结束事件
 **/

var Powepoint = function () {
  function Powepoint(pageIndex, pageType, chapterId, element, parameter, container, getStyle, contentId, activityId) {
    classCallCheck(this, Powepoint);


    if (_.isArray(parameter) && parameter.length) {
      this.options = parameter;
    } else {
      console.log("Animation options error is not Array.");
      return;
    }

    this.visualWidth = getStyle.visualWidth;
    this.visualHeight = getStyle.visualHeight;
    this.container = container || $(document.body); //父容器(主要用于手势控制路径动画)
    this.pageIndex = pageIndex;
    this.pageType = pageType;
    this.chapterId = chapterId;
    this.element = element;
    this.contentId = contentId;
    this.activityId = activityId;

    //动画对象默认样式
    this.elementStyle = '';
    //初始化后对象状态
    this.elementVisibility = 'visible';
    //是否使用CSS渐变效果
    this.useMask = isDesktop || isMacOS ? true : false;
    //第一个动画参数（默认支持多个动画作用于一个对象）
    this.parameter0 = null;
    //第一个动画类型（进入/退出）
    this.isExit0 = false;
    //是否完全执行过(用于解决重复执行问题)
    this.isCompleted = false;
    //初始对象状态:opacity(visibility)
    this._initElement();
  }

  /**
   * 根据数据库的设置
   * 对象初始化(visibility)
   */


  createClass(Powepoint, [{
    key: '_initElement',
    value: function _initElement() {

      //合集动画参数
      //取第一个作为默认设置
      var data = this.options[0];

      //为高级动画修改增加
      //2016.3.16
      this.parameter0 = parseJSON(data.parameter);
      this.parameter0.pageType = this.pageType;
      this.parameter0.pageIndex = this.pageIndex;
      this.isExit0 = getExit(this.parameter0);

      //给元素增加ppt属性标记
      if (!this.element.attr("data-pptAnimation")) {
        var animationName = data.animationName;

        //路径动画对象默认显示
        if (animationName.indexOf("EffectPath") == 0 || animationName == "EffectCustom") {
          this.element.css("visibility", "visible");
        } else {
          switch (animationName) {
            //强调动画默认显示
            case "EffectFlashBulb": //脉冲
            // //脉冲只显示
            // if (this.isExit0 || this.isExit0 === undefined) {
            //   this.element.css("visibility", "visible");
            // } else {
            //   this.element.css("visibility", "hidden");
            // }
            // break;
            case "EffectFlicker": //彩色脉冲
            case "EffectTeeter": //跷跷板
            case "EffectSpin": //陀螺旋转
            case "EffectGrowShrink": //放大/缩小
            case "EffectDesaturate": //不饱和
            case "EffectDarken": //加深
            case "EffectLighten": //变淡
            case "EffectTransparency": //透明
            case "EffectColorBlend": //对象颜色
            case "EffectComplementaryColor": //补色
            case "EffectChangeLineColor": //线条颜色
            case "EffectChangeFillColor": //填允颜色
            case "EffectFlashOnce":
              //闪烁(一次)
              this.element.css("visibility", "visible");
              break;
            case "EffectCredits":
              //字幕式特殊处理
              this.element.css("visibility", "hidden");
              break;
            default:
              if (this.isExit0) {
                this.element.css("visibility", "visible"); //退出动画默认显示
              } else {
                this.element.css("visibility", "hidden"); //进入动画默认隐藏
              }
              break;
          }
        }

        //标识初始化状态
        this.element.attr("data-pptAnimation", true);
        this.elementStyle = this.element[0].style.cssText;
        this.elementVisibility = this.element.css("visibility");
      }
    }

    /**
     * 获取对象相关信息
     */

  }, {
    key: '_getObjectInfo',
    value: function _getObjectInfo(object) {
      var width = ROUND(object.width()); //四舍五入取整
      var height = ROUND(object.height());
      var top = ROUND(parseInt(object.css("top")));
      var left = ROUND(parseInt(object.css("left")));
      var offsetTop = ROUND(object.offset().top);

      if (object.attr("offsetTop")) {
        offsetTop = parseInt(object.attr("offsetTop"));
      } else {
        object.attr("offsetTop", offsetTop);
      }

      var offsetBottom = CEIL$2(this.visualHeight - offsetTop - height);
      var offsetLeft = ROUND(object.offset().left);
      if (object.attr("offsetLeft")) {
        offsetLeft = parseInt(object.attr("offsetLeft"));
      } else {
        object.attr("offsetLeft", offsetLeft);
      }
      var offsetRight = CEIL$2(this.visualWidth - offsetLeft - width);

      return {
        width: width,
        height: height,
        top: top,
        left: left,
        offsetTop: offsetTop,
        offsetLeft: offsetLeft,
        offsetBottom: offsetBottom,
        offsetRight: offsetRight
      };
    }

    /**
     * 子动画通用开始事件
     */

  }, {
    key: '_startHandler',
    value: function _startHandler(parameter, object, params) {

      //设置参数
      setParams(object, params);

      //ppt动画音频
      if (parameter.videoId) {
        createContentAudio(parameter.chapterId, parameter.videoId);
      }

      //ppt动画扩展处理
      var pptanimation = parameter.pptanimation;
      if (pptanimation && pptanimation.pptapi) {
        var _params = pptanimation.parameters ? pptanimation.parameters : {};
        if (pptanimation.pptapi === 'bonesWidget') {
          //骨骼动画
          bonesWidget.updateAction(object.attr("id"), _params.actList);
        } else if (pptanimation.pptapi === 'spiritWidget') {
          //零件，高级精灵
          updateAction(object.attr("id"), _params);
        }
      }

      //////////////////
      ///开始脚本动画
      ///1 保持父引用的操作
      //////////////////
      var preCode = parameter.preCode;
      if (preCode && _.isFunction(preCode)) {
        parameter.parent.animation.pause();
        var result = false;
        try {
          result = preCode();
        } catch (error) {
          console.log("Run preCode is error in startHandler:" + error);
        }
        if (result == true) parameter.parent.animation.resume();else {
          //如果遇到停止了
          //动画直接退出
          //调用外部通知接口
          parameter.parent.animation.stop();
          parameter.completeAction();
        }
      }
    }

    /**
     * 子动画通用结束事件
     */

  }, {
    key: '_completeHandler',
    value: function _completeHandler(parameter, object, params) {

      //设置参数
      setParams(object, params);

      //延迟执行postCode代码
      var postCode = parameter.postCode;
      if (postCode) {
        try {
          //简单判断是函数可执行
          if (_.isFunction(postCode)) {
            var codeDelay = parameter.codeDelay;
            if (codeDelay > 0) {
              setTimeout(postCode, codeDelay);
            } else {
              postCode();
            }
          }
        } catch (error) {
          console.log("Run postCode is error in completeHandler:" + error);
        }
      }
    }

    /**
     * 返回动画对象
     */

  }, {
    key: '_getTimeline',
    value: function _getTimeline(data, index, completeAction, parentContext) {
      var object = this.element;
      var parameter = this.parameter0;
      var isExit = this.isExit0;

      ////////////////////////
      /// 如果有多个动画序列参数
      /// 从第二个开始取新数据
      ///////////////////////
      if (index > 0 || this.parameter0 == null) {
        parameter = parseJSON(data.parameter);
        isExit = getExit(parameter);
        //有多个动画，并且后面的动画序列没有参数设置
        //采用默认的第一个
        if (index == 0) {
          this.parameter0 = parameter;
          this.isExit0 = isExit;
        }
      }
      var duration = data.speed / 1000; //执行时间
      var delay = data.delay / 1000; //延时时间
      if (navigator.epubReadingSystem) {
        //如果是epub阅读器则动画延时0.15秒
        delay += 0.15;
      }
      var repeat = data.repeat >= 0 ? data.repeat - 1 : 0; //重复次数
      parameter.pageType = this.pageType;
      parameter.chapterId = this.chapterId;
      parameter.animationName = data.animationName;
      //赋给动画音频Id
      parameter.videoId = data.videoId;
      //子动画中如果遇到停止了
      //就直接调用退出通知
      parameter.completeAction = completeAction;

      ////////////////////////////////////
      /// 赋予脚本处理代码
      /// 每个对象数据都可以带脚本代码
      /// 所以需要把脚本匹配到每一个子动画中
      ///////////////////////////////////
      //获取动画前脚本
      parameter.preCode = injectCode(data.preCode, parameter, parentContext);
      //获取动画后脚本
      parameter.postCode = injectCode(data.postCode, parameter, parentContext);
      //获取延时时间
      parameter.codeDelay = data.codeDelay;
      //赋予父对象的引用
      parameter.parent = this;

      var animationName = parameter.animationName;
      var args = [parameter, object, duration, delay, repeat, isExit];

      //文字动画
      if (animationName === "xxtTextEffect") {
        return this.getTextAnimation.apply(this, args);
      }

      //路径动画
      if (animationName.indexOf("EffectPath") == 0 || animationName == "EffectCustom") {
        return this.getPathAnimation.apply(this, args);
      }

      switch (animationName) {
        case "EffectFade":
          //淡出
          return this.getEffectFade.apply(this, args);
        case "EffectFly":
          //飞入/飞出
          return this.getEffectFly.apply(this, args);
        case "EffectAscend":
          //浮入/浮出(上升)
          return this.getEffectAscend.apply(this, args);
        case "EffectDescend":
          //浮入/浮出(下降)
          return this.getEffectDescend.apply(this, args);
        case "EffectSplit":
          //劈裂(分割)
          return this.getEffectSplit.apply(this, args);
        case "EffectWipe":
          //擦除
          return this.getEffectWipe.apply(this, args);
        case "EffectCircle":
          //形状一(圆)
          return this.getEffectCircle.apply(this, args);
        case "EffectBox":
          //形状二(方框)
          return this.getEffectBox.apply(this, args);
        case "EffectDiamond":
          //形状三(菱形)
          return this.getEffectDiamond.apply(this, args);
        case "EffectPlus":
          //形状四(加号)
          return this.getEffectPlus.apply(this, args);
        case "EffectGrowAndTurn":
          //翻转式由远及近
          return this.getEffectGrowAndTurn.apply(this, args);
        case "EffectZoom":
          //基本缩放
          return this.getEffectZoom.apply(this, args);
        case "EffectFadedZoom":
          //淡出式缩放
          return this.getEffectFadedZoom.apply(this, args);
        case "EffectSwivel":
          //基本旋转
          return this.getEffectSwivel.apply(this, args);
        case "EffectFadedSwivel":
          //旋转(淡出式回旋)
          return this.getEffectFadedSwivel.apply(this, args);
        case "EffectBounce":
          //弹跳
          return this.getEffectBounce.apply(this, args);
        case "EffectBlinds":
          //百叶窗
          return this.getEffectBlinds.apply(this, args);
        case "EffectPeek":
          //切入/出
          return this.getEffectPeek.apply(this, args);
        case "EffectExpand":
          //展开/收缩
          return this.getEffectExpand.apply(this, args);
        case "EffectRiseUp":
          //升起/下沉
          return this.getEffectRiseUp.apply(this, args);
        case "EffectCenterRevolve":
          //中心旋转
          return this.getEffectCenterRevolve.apply(this, args);
        case "EffectSpinner":
          //回旋
          return this.getEffectSpinner.apply(this, args);
        case "EffectFloat":
          //浮动
          return this.getEffectFloat.apply(this, args);
        case "EffectSpiral":
          //螺旋飞入/出
          return this.getEffectSpiral.apply(this, args);
        case "EffectPinwheel":
          //玩具风车
          return this.getEffectPinwheel.apply(this, args);
        case "EffectCredits":
          //字幕式
          return this.getEffectCredits.apply(this, args);
        case "EffectBoomerang":
          //飞旋
          return this.getEffectBoomerang.apply(this, args);
        case "EffectArcUp":
          //曲线向上/下
          return this.getEffectArcUp.apply(this, args);
        case "EffectFlashBulb":
          //脉冲
          return this.getEffectFlashBulb.apply(this, args);
        case "EffectFlicker":
          //彩色脉冲
          return this.getEffectFlicker.apply(this, args);
        case "EffectTeeter":
          //跷跷板
          return this.getEffectTeeter.apply(this, args);
        case "EffectSpin":
          //陀螺旋转
          return this.getEffectSpin.apply(this, args);
        case "EffectGrowShrink":
          //放大/缩小
          return this.getEffectGrowShrink.apply(this, args);
        case "EffectDesaturate":
          //不饱和
          return this.getEffectDesaturate.apply(this, args);
        case "EffectDarken":
          //加深
          return this.getEffectDarken.apply(this, args);
        case "EffectLighten":
          //变淡
          return this.getEffectLighten.apply(this, args);
        case "EffectTransparency":
          //透明
          return this.getEffectTransparency.apply(this, args);
        case "EffectColorBlend":
          //对象颜色
          return new TimelineMax();
        case "EffectComplementaryColor":
          //补色
          return this.getEffectComplementaryColor.apply(this, args);
        case "EffectChangeLineColor":
          //线条颜色
          return new TimelineMax();
        case "EffectChangeFillColor":
          //填允颜色
          return new TimelineMax();
        case "EffectFlashOnce":
          //闪烁(一次)
          return this.getEffectFlashOnce.apply(this, args);
        //进入退出动画
        default:
        case "EffectAppear":
          //出现/消失
          return this.getEffectAppear.apply(this, args);
      }
    }

    /**
     * 初始化
     */

  }, {
    key: '_initAnimation',
    value: function _initAnimation(callback) {
      var self = this;

      /**
       * 整个动画完成事件(动画不需继续执行视为执行完成)
       * 1 子动画中，有任意的脚本遇到停止，那么就提前调用完成
       * 2 全部动画完成户调用此接口
       */
      function completeAction() {
        if (callback && _.isFunction(callback)) {
          callback();
        }
      }

      var tl = new TimelineLite({
        paused: true,
        //动画全部完成
        onComplete: function onComplete() {
          self.isCompleted = true;
          completeAction();
        }
      });

      for (var i = 0; i < this.options.length; i++) {
        if (i == 0) {
          tl.add(this._getTimeline(this.options[i], i, completeAction, this), "shape0");
        } else {
          var invokeMode = this.options[i].invokeMode;
          if (invokeMode == 2) {
            tl.add(this._getTimeline(this.options[i], i, completeAction, this));
          } else {
            //"shape"+(i-1)
            tl.add(this._getTimeline(this.options[i], i, completeAction, this), "shape0");
          }
        }
      }
      return tl;
    }

    /**
     * 执行动画
     * @param  {[type]} scopeComplete [description]
     * @return {[type]}               [description]
     */

  }, {
    key: 'play',
    value: function play(animComplete) {
      if (this.isCompleted) {
        this.reset();
      }
      this.stop();
      this.animation = this._initAnimation(animComplete);
      this.animation.play();
    }

    /**
     * 停止动画
     * @return {[type]} [description]
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this.animation) {
        this.animation.stop();
        this.animation.kill();
        this.animation.clear();
        this.animation.vars = null;
        this.animation = null;
      }
    }

    /**
     * 隐藏接口
     * @return {[type]} [description]
     */

  }, {
    key: 'hide',
    value: function hide() {
      this.stop();
      if (this.element) {
        this.element.css('visibility', 'hidden');
      }
    }

    /**
     * 复位动画
     * @return {[type]} [description]
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.animation && this.stop();
      if (this.elementStyle && this.elementStyle.length) {
        var origin = this.element.css(Xut.style.transformOrigin);
        //卷滚区域里的对象不需要还原
        if (this.element.attr("data-iscroll") == null) {
          this.element[0].style.cssText = this.elementStyle;
        }
        this.element.css(Xut.style.transformOrigin, origin);
        this.element.css("visibility", this.elementVisibility);
        this.element.css(Xut.style.transform, "none");
        this.element[0]["_gsTransform"] = null; //清理对象上绑定的动画属性
      }
      this.isCompleted = false;
    }

    /**
     * 销毁动画
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.stop();
      this.container = null;
      this.options = null;
      this.element = null;
    }
  }]);
  return Powepoint;
}();

fade(Powepoint.prototype);
fly(Powepoint.prototype);
path$1(Powepoint.prototype);
rotate(Powepoint.prototype);
special(Powepoint.prototype);
zoom(Powepoint.prototype);
shape(Powepoint.prototype);

/**
 * 普通精灵动画
 * dom版本
 * css3模式
 */
var style = Xut.style;
var keyframes = style.keyframes;
var animationEnd = style.animationEnd;
var playState = style.animationPlayState;
var prefixAnims = style.animation;

var styleElement = null;

/**
 * [ description]动态插入一条样式规则
 * @param  {[type]} rule [样式规则]
 * @return {[type]}      [description]
 */
function insertCSSRule(rule) {
  var number, sheet, cssRules;
  //如果有全局的style样式文件
  if (styleElement) {
    number = 0;
    try {
      sheet = styleElement.sheet;
      cssRules = sheet.cssRules;
      number = cssRules.length;
      sheet.insertRule(rule, number);
    } catch (e) {
      console.log(e);
    }
  } else {
    //创建样式文件
    styleElement = document.createElement("style");
    styleElement.type = 'text/css';
    styleElement.innerHTML = rule;
    styleElement.uuid = 'aaron';
    document.head.appendChild(styleElement);
  }
}

/**
 * [ description]删除一条样式规则
 * @param  {[type]} ruleName [样式名]
 * @return {[type]}          [description]
 */
function deleteCSSRule(ruleName) {
  if (styleElement) {
    var sheet = styleElement.sheet,
        cssRules = sheet.rules || sheet.cssRules,
        //取得规则列表
    i = 0,
        n = cssRules.length,
        rule;
    for (i; i < n; i++) {
      rule = cssRules[i];
      if (rule.name === ruleName) {
        //删除单个规则
        sheet.deleteRule(i);
        break;
      }
    }
    //删除style样式
    if (cssRules.length == 0) {
      document.head.removeChild(styleElement);
      styleElement = null;
    }
  }
}

/**
 * css3模式
 * 单图
 * 矩形图
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
function css3(options) {

  var matrix = void 0,
      parameter = void 0,
      rule1 = void 0,
      rule2 = void 0,
      timer = void 0;

  var $spriteNode = options.$contentNode.find('.sprite');
  var data = options.data;
  var callback = options.callback || function () {};
  var aniName = 'sprite_' + options.id;
  var count = data.thecount;
  var fps = data.fps;
  var time = Math.round(1 / fps * count * 10) / 10;
  var width = Math.ceil(data.scaleWidth * count);
  var loop = data.loop ? 'infinite' : 1;

  //如果是矩形图
  if (data.parameter) {
    parameter = parseJSON(data.parameter);
    if (parameter && parameter.matrix) {
      matrix = parameter.matrix.split("-");
    }
  }

  /**
   * 设置精灵动画位置
   * @param {[type]} aniName [description]
   * @param {[type]} x       [description]
   */
  function setPostion(aniName, x) {
    //矩阵生成step的处理
    //  0 1 2
    //  3 4 5
    //  6 7 8
    if (matrix) {
      var frames = [];
      var base = 100 / count;
      var col = Number(matrix[0]); //列数
      //首次
      frames.push(0 + '% { background-position:0% 0%}');
      for (var i = 0; i < count; i++) {
        // var currRow = Math.ceil((i + 1) / col); //当前行数
        var currCol = Math.floor(i / col); //当前列数
        var period = currCol * col; //每段数量
        x = 100 * (i - period);
        var y = 100 * currCol;
        x = x == 0 ? x : "-" + x;
        y = y == 0 ? y : "-" + y;
        frames.push((i + 1) * base + '% { background-position: ' + x + '% ' + y + '%}');
      }
      return aniName + '{' + frames.join("") + '}';
    } else {
      var rule = '{0} {from { background-position:0 0; } to { background-position: -{1}px 0px}}';
      return String.format(rule, aniName, Math.round(x));
    }
  }

  /**
   * 格式化样式表达式
   * 2016.7.15 add paused control
   * @param {[type]}   [description]
   */
  function setStep(aniName, time, count, loop) {
    var rule;
    if (matrix) {
      rule = '{0} {1}s step-start {2}';
      return String.format(rule, aniName, time, loop);
    } else {
      rule = '{0} {1}s steps({2}, end) {3}';
      return String.format(rule, aniName, time, count, loop);
    }
  }

  /**
   * 设置动画样式
   * @param {[type]} rule     [description]
   */
  function initStyle(rule) {
    prefixAnims && $spriteNode.css(prefixAnims, rule).css(playState, 'paused');
  }

  /**
   * 添加到样式规则中
   * @param {[type]} rule [description]
   */
  function setKeyframes(rule) {
    if (keyframes) {
      insertCSSRule(keyframes + rule);
    }
  }

  //动画css关键帧规则
  rule1 = setStep(aniName, time, count, loop);
  rule2 = setPostion(aniName, width);

  initStyle(rule1);
  setKeyframes(rule2);
  $spriteNode.on(animationEnd, callback);

  var clearTimer = function clearTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };

  return {
    play: function play() {
      //添加定时器 解决设备卡顿时普通精灵动画不播放的问题
      timer = setTimeout(function () {
        clearTimer();
        $spriteNode.css(playState, 'running');
      }, 0);
    },
    stop: function stop() {
      clearTimer();
      $spriteNode.css(playState, 'paused');
    },
    destroy: function destroy() {
      //停止精灵动画
      deleteCSSRule(aniName);
      $spriteNode.off(animationEnd, callback);
      clearTimer();
      $spriteNode = null;
    }
  };
}

/**
 * 帧模式-多图
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
function keyframe(options) {
  var matrix = void 0,
      parameter = void 0,
      timer = void 0,
      x = void 0,
      y = void 0;

  var arrays = [];
  var t = 0;
  var $spriteNode = options.$contentNode.find('.sprite');
  var data = options.data;
  var callback = options.callback || function () {};

  var count = data.thecount;
  var fps = data.fps;
  var loop = data.loop;
  var width = data.scaleWidth;
  var height = data.scaleHeight;

  //如果是矩形图
  if (data.parameter) {
    parameter = parseJSON(data.parameter);
    if (parameter && parameter.matrix) {
      matrix = parameter.matrix.split("-");
    }
  }

  getCoordinate();
  //得到坐标：矩阵图：X Y坐标 普通：X坐标
  function getCoordinate() {
    //矩阵图
    if (matrix) {
      var cols = matrix[0];
      var rows = matrix[1];
      for (var i = 0; i < rows; i++) {
        y = -height * i + 'px';
        for (var k = 0; k < cols; k++) {
          x = -width * k + 'px';

          arrays.push(x, y);
        }
      }
      //数组长度大于给定的数量时 删除数组中多余的数据
      if (arrays.length / 2 > count) {
        var temp = arrays.length / 2 - count;
        for (var f = 2 * temp; f > 0; f--) {
          arrays.pop();
        }
      }
    } else {
      for (var i = 0; i < count; i++) {
        x = -width * i + 'px';
        arrays.push(x);
      }
    }
  }

  function start() {
    if (matrix) {
      if (t > arrays.length / 2 - 1) {
        if (loop > 0) {
          t = 0;
          time();
        } else {
          return;
        }
      } else {
        time();
      }
    } else {
      if (t > count - 1) {
        if (loop > 0) {
          t = 0;
          time();
        } else {
          return;
        }
      } else {
        time();
      }
    }
  }

  function time() {
    timer = setTimeout(function () {
      if (matrix) {
        x = arrays[2 * t];
        y = arrays[2 * t + 1];
        $spriteNode.css('backgroundPositionX', x);
        $spriteNode.css('backgroundPositionY', y);
      } else {
        x = arrays[t];
        $spriteNode.css('backgroundPositionX', x);
      }
      t++;
      start();
    }, 1000 / fps);
  }

  return {
    play: function play() {
      start();
    },

    stop: function stop() {
      clearTimeout(timer);
    },

    destroy: function destroy() {
      //停止精灵动画
      this.stop();
      t = 0;
      $spriteNode = null;
      data = null;
      arrays = null;
    }

  };
}

//判断是否支持css3属性
var animationPlayState = Xut.style.animationPlayState;

/**
 * css3动画
 * 1 帧动画
 * 2 定时器动画
 * @param {[type]} options [description]
 */
var ComSprite = function (options) {
  //timer,css
  var mode = options.mode || 'css';
  return mode === 'css' && animationPlayState ? css3(options) : keyframe(options);
};

/**
 * 2016.7.10
 * if comsprites is too large，
 * The client will comsprite become the advsprite  by default
 */
var moveContent$1 = function moveContent(contentPrefix, id, parentId) {
  var obj = $("#" + contentPrefix + id);
  var parentObj = $("#" + contentPrefix + parentId);
  var $parent = $("#spirit_parent_" + parentId);
  if ($parent.length == 0) {
    parentObj.append("<div style='position:absolute; width:100%; height:100%'  id='spirit_parent_" + parentId + "'></div>");
  }
  $parent.append(obj);
};

var _class$2 = function () {
  function _class(options) {
    classCallCheck(this, _class);

    this.options = options;
    this.ids = [];
  }

  createClass(_class, [{
    key: "play",
    value: function play() {

      var data = this.options.data;
      var resource = data.resource;

      var id = void 0,
          action = void 0,
          spiritList = void 0,
          framId = void 0,
          parentId = void 0,
          params = void 0;
      var option = {};
      this.spiritObjs = {};

      option.contentId = this.options.id;
      option.ele = this.options.$contentNode;
      option.resourcePath = data.md5;
      option.type = "autoSprite";

      /*
        data.loop
         循环 1
         不循环 0
       */
      var hasLoop = 0;
      if (data.loop) {
        hasLoop = 'loop';
      }

      for (var i = 0; i < resource.spiritList.length; i++) {
        spiritList = resource.spiritList[i];
        id = data.containerName;
        framId = spiritList.framId;
        parentId = spiritList.parentId;
        this.ids.push(id);
        if (parentId != "0") {
          var tempArray = id.split('_');
          var contentPrefix = tempArray[0] + '_' + tempArray[1];
          moveContent$1(contentPrefix, framId, parentId);
        }
        this.spiritObjs[id] = new _class$1(spiritList, option);
        params = spiritList.params;
        action = params["actList"].split(",")[0];

        //0 循环播放 1播放一次
        this.spiritObjs[id].play(action, hasLoop);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this = this;

      this.ids.forEach(function (key) {
        _this.spiritObjs[key].stop();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.stop();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.ids.forEach(function (key) {
        if (_this2.spiritObjs[key]) {
          _this2.spiritObjs[key].destroy();
          _this2.spiritObjs[key] = null;
          delete _this2.spiritObjs[key];
        }
      });
      this.options.data = null;
      this.options.$contentNode = null;
      this.options = null;
      this.ids = null;
    }
  }]);
  return _class;
}();

/*********************************************************************
 *
 * content的动画类对象
 * 1 ppt 动画
 * 2 精灵动画
 * 3 show/hide接口
 * 4 canvas动画
 * @return {[type]} [description]
 *
 ********************************************************************/
//2016.7.15废弃
//pixi暂时不使用
var pixiSpirit = {};
var pixiSpecial = {};

// import { Sprite as pixiSpirit } from '../pixi/sprite/index'
// import { specialSprite as pixiSpecial } from '../pixi/special/index'

/**
 * 1.复位音频
 * 2.销毁音频
 */
var audioHandle = function audioHandle(context, options, chapterId) {
  options && _.each(options, function (data) {
    //如果存在对象音频
    if (data.videoId) {
      context(chapterId, data.videoId);
    }
  });
};

/**
 * 4种扩展对象
 * @type {Array}
 */
var OBJNAME = ['pptObj', 'pixiObj', 'comSpriteObj', 'autoSpriteObj'];

/**
 * Traverse each value of OBJNAME
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 */
var access$1 = function access(callback) {
  OBJNAME.forEach(function (key) {
    callback(key);
  });
};

/**
 * 动画效果
 * @param {[type]} options [description]
 */

var Animation = function () {
  function Animation(options) {
    classCallCheck(this, Animation);

    _.extend(this, options);
  }

  /**
   * Build the canvas of animation
   * 比较复杂
   * 1 普通与ppt组合
   * 2 高级与ppt组合
   * 3 ppt独立
   * 4 普通精灵动画
   * 8  其中 高级精灵动画是widget创建，需要等待
   * @return {[type]} [description]
   */


  createClass(Animation, [{
    key: '_createCanvas',
    value: function _createCanvas(id, parameter, category, callback) {
      var _this = this;

      var initstate = void 0;

      //动作类型
      //可能是组合动画
      var actionTypes = this.contentData.actionTypes;
      var makeOpts = {
        data: this.contentData,
        renderer: this.$contentNode,
        pageIndex: this.pageIndex

        //创建pixi上下文的ppt对象
      };var createPixiPPT = function createPixiPPT() {
        //parameter存在就是ppt动画
        if ((parameter || actionTypes.pptId) && _this.$contentNode.view) {
          _this.pptObj = callback(Powepoint, $(_this.$contentNode.view));
          _this.pptObj.contentId = id;
        }
      };

      var $veiw = this.$contentNode.view;
      if ($veiw) {
        initstate = $veiw.getAttribute('data-init');
      }

      var setState = function setState() {
        $veiw.setAttribute('data-init', true);
      };

      //多个canvas对应多个ppt
      //容器不需要重复创建
      //精灵动画
      if (actionTypes.spiritId) {
        if (initstate) {
          createPixiPPT();
        } else {
          //加入任务队列
          this.nextTask.context.add(id);
          this.pixiObj = new pixiSpirit(makeOpts);
          //防止多条一样的数据绑多个动画
          //构建精灵动画完毕后
          //构建ppt对象
          this.pixiObj.$$once('load', function () {
            //ppt动画
            createPixiPPT();

            //任务完成
            _this.nextTask.context.remove(id);
          });
          setState();
        }
      }

      //特殊高级动画
      //必须是ppt与pixi绑定的
      if (actionTypes.compSpriteId) {
        // console.log(this,this.id,this.contentData.initpixi)
        //这个dom已经创建了pixi了
        if (initstate) {
          createPixiPPT();
        } else {
          this.pixiObj = new pixiSpecial(makeOpts);
          setState();

          //ppt动画
          createPixiPPT();
        }
      }
    }

    /**
     * Build the dom of animation
     * @return {[type]} [description]
     */

  }, {
    key: '_createDom',
    value: function _createDom(category, callback) {
      if (category) {
        var data = {
          id: this.id,
          data: this.contentData,
          $contentNode: this.$contentNode
        };
        switch (category) {
          //普通精灵动画
          case "Sprite":
            this.comSpriteObj = ComSprite(data);
            break;
          //普通转复杂精灵动画
          case "AutoCompSprite":
            this.autoSpriteObj = new _class$2(data);
            break;
        }
      }

      //ppt动画
      this.pptObj = callback(Powepoint);
    }

    /**
     * 绑定动画
     * 为了向上兼容API
     *  1 dom动画
     *  2 canvas动画
     */

  }, {
    key: 'init',
    value: function init(contentId, $contentNode, $containsNode, chapterId, parameter, pageType, activityId) {
      var _this2 = this;

      var category = this.contentData.category;
      var pageIndex = this.pageIndex;
      var create = function create(constr, newContext) {
        var element = newContext || $contentNode;
        if (element.length) {
          return new constr(pageIndex, pageType, chapterId, element, parameter, $containsNode, _this2.getStyle, contentId, activityId);
        } else {
          console.log('\u521B\u5EFA:' + constr + '\u5931\u8D25');
        }
      };
      this.domMode ? this._createDom(category, create) : this._createCanvas(contentId, parameter, category, create);
    }

    /**
     * 运行动画
     * @param  {[type]} scopeComplete   [动画回调]
     * @param  {[type]} canvasContainer [description]
     * @return {[type]}                 [description]
     */

  }, {
    key: 'play',
    value: function play(playComplete) {
      var _this3 = this;

      var $contentNode = this.$contentNode;

      //canvas
      if ($contentNode && $contentNode.view) {
        $contentNode = this.$contentNode.view;
      }

      access$1(function (key) {
        if (_this3[key]) {
          if (key === 'pptObj') {
            //优化处理,只针对互斥的情况下
            //处理层级关系
            if ($contentNode.prop && $contentNode.prop("mutex")) {
              $contentNode.css({ //强制提升层级
                'display': 'block'
              });
            }
          }

          if (_this3.useDynamicDiagram) {
            //如果是一次性动画
            //如果存在重复点击的情况
            //重新给img的src赋值
            //解决闪动问题
            if (_this3.$contentNode) {
              setImage$1(_this3.$contentNode, _this3.contentData.resourcePath);
            }
            if (_this3[key]) {
              _this3[key].play && _this3[key].play(playComplete);
            }
          } else {
            _this3[key].play && _this3[key].play(playComplete);
          }
        }
      });
    }

    /**
     * 停止动画
     * @param  {[type]} chapterId [description]
     * @return {[type]}           [description]
     */

  }, {
    key: 'stop',
    value: function stop(chapterId) {
      var _this4 = this;

      access$1(function (key) {
        if (_this4[key]) {
          if (key === 'pptObj') {
            audioHandle(destroyContentAudio, _this4[key].options, chapterId);
          }
          if (_this4[key].stop) {
            _this4[key].stop();
          }
        }
      });
    }

    /**
     * 隐藏动画
     * @param  {[type]} chapterId [description]
     * @return {[type]}           [description]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this5 = this;

      access$1(function (key) {
        if (_this5[key]) {
          if (_this5[key].hide) {
            _this5[key].hide();
          }
        }
      });
    }

    /**
     * 翻页结束，复位上一页动画
     * @return {[type]} [description]
     */

  }, {
    key: 'reset',
    value: function reset() {
      var _this6 = this;

      access$1(function (key) {
        if (_this6[key]) {
          //如果是一次性动画，需要动态处理
          if (_this6.useDynamicDiagram) {
            cleanImage(_this6.$contentNode);
          }
          _this6[key].reset && _this6[key].reset();
        }
      });
    }

    /**
     * 销毁动画
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy(chapterId) {
      var _this7 = this;

      access$1(function (key) {
        _this7[key] && _this7[key].destroy && _this7[key].destroy();
      });

      //销毁renderer = new PIXI.WebGLRenderer
      if (this.canvasMode) {
        this.$contentNode.view && this.$contentNode.destroy();
      }

      //销毁每一个数据上的canvas上下文引用
      if (this.contentData.$contentNode) {
        this.contentData.$contentNode = null;
      }

      access$1(function (key) {
        _this7[key] = null;
      });

      this.$contentNode = null;
      this.getParameter = null;
    }
  }]);
  return Animation;
}();

/**
 * 预处理脚本
 * 1 动画直接显示与隐藏设置
 * 2 动画脚本与处理（跳转）
 */
function fastPipe(data, base) {
  var id = data.id,
      canvasMode = data.canvasMode,
      $contentNode = data.$contentNode,
      prepTag = data.prepTag,
      prepVisible = data.prepVisible,
      prepScript = data.prepScript;

  /////////////////////////////
  ///如果是被预处理截断，跳过动画创建
  ///重写原事件的相关数据
  ///改动脚本auto为click事件
  /////////////////////////////

  if (prepScript) {
    base.eventRelated.rewrite = true;
    base.eventRelated.eventName = 'click';
    base.eventRelated.eventContentId = id;
  }

  /////////////////////////////
  //创建a标签跳转
  /////////////////////////////
  var preCode = void 0;
  if (prepTag) {
    try {
      makeJsonPack(prepTag)();
    } catch (err) {
      console.log('\u9884\u5904\u7406\u622A\u65AD\u6267\u884C\u811A\u672C\u5931\u8D25');
    }
    preCode = window.XXTAPI.PreCode;

    if (preCode) {
      var contentNode = base.getContextNode(base._findContentName(base.chapterIndex, id));
      var imgContext = contentNode.find('img');
      if (imgContext.length) {
        var href = void 0;
        if (_.isString(preCode)) {
          //如果只有一个参数并且是字符串，那么就是URL
          href = preCode;
        } else if (_.isArray(preCode)) {
          //数组
          href = preCode[0];
        }

        //替换img为div>a
        imgContext.replaceWith(String.styleFormat('<div class="inherit-size fullscreen-background fix-miaomiaoxue-img"\n                style="background-image:url(' + imgContext.attr('src') + ');">\n              <a  data-id="' + id + '"\n                  data-page-id="' + base.pageId + '"\n                  data-type="hyperlink"\n                  href="' + href + '"\n                  class="inherit-size"\n                  style="display:block;"/>\n              </a>\n          </div>'));
        window.XXTAPI.PreCode = null;

        //如果有回调，就绑定事件
        if (preCode[1] && _.isFunction(preCode[1])) {
          base.eventRelated.eventContext = contentNode.find('a');
          base.eventRelated.rewrite = true;
          base.eventRelated.eventName = 'tap';
          base.eventRelated.eventContentId = id;
        } else {
          //清空auto动作
          base.eventRelated.eventName = '';
        }
      }
    }
  }

  /**
   * 显示预处理,直接越过动画
   */
  var setPrepVisible = function setPrepVisible() {
    //创建的无行为content
    var partContentRelated = base.dataRelated.partContentRelated;
    //针对空跳过处理
    if (partContentRelated && partContentRelated.length && -1 !== partContentRelated.indexOf(id)) {} else {
      if (canvasMode) {
        console.log('canvsa prepVisible');
        return;
      }
      //因为执行的顺序问题，动画与页面零件,isscroll标记控制
      if ($contentNode && !$contentNode.attr('data-iscroll')) {
        //必须是设定值与原始值不一致才修改,苹果上闪屏问题
        if ($contentNode.css('visibility') != prepVisible) {
          $contentNode.css({
            'visibility': prepVisible
          });
        }
      }
    }
  };

  return _.extend(data, {

    constructor: 'fastPipe',

    init: function init() {
      //预显示跳过动画创建
      prepVisible && $contentNode.css({ 'visibility': prepVisible });
    },
    play: function play(callback) {

      //处理显示动画
      if (prepVisible) {
        setPrepVisible(callback);
      }

      //a标签附带的脚本函数
      if (preCode && preCode[1]) {
        try {
          preCode[1]();
        } catch (err) {
          console.log('\u5FEB\u901F\u5904\u7406\u811A\u672C\u51FD\u6570\u6267\u884C\u5931\u8D25');
        }
      }

      //如果是被预处理截断
      //执行脚本
      if (prepScript) {
        try {
          makeJsonPack(prepScript)();
        } catch (err) {
          console.log('\u5FEB\u901F\u5904\u7406\u6267\u884C\u811A\u672C\u5931\u8D25');
        }
      }

      callback && callback();
    },
    destroy: function destroy() {
      preCode = null;
      $contentNode = null;
      prepTag = null;
    }
  });
}

var transitionDuration = Xut.style.transitionDuration;
var transform = Xut.style.transform;
var setTranslateZ = Xut.style.setTranslateZ;
var round = Math.round;

/**
 * 获取视觉差parallax配置
 * @return {[type]} [description]
 */
function setStyle(_ref) {
  var $contentNode = _ref.$contentNode,
      action = _ref.action,
      property = _ref.property,
      pageIndex = _ref.pageIndex,
      _ref$targetProperty = _ref.targetProperty,
      targetProperty = _ref$targetProperty === undefined ? {} : _ref$targetProperty,
      interaction = _ref.interaction,
      _ref$speed = _ref.speed,
      speed = _ref$speed === undefined ? 0 : _ref$speed,
      _ref$pageOffset = _ref.pageOffset,
      pageOffset = _ref$pageOffset === undefined ? 0 : _ref$pageOffset,
      _ref$opacityStart = _ref.opacityStart,
      opacityStart = _ref$opacityStart === undefined ? 0 : _ref$opacityStart;

  var style = {};
  var transformProperty = {};
  var x = 0;
  var y = 0;
  var z = 0;
  var translateZ = void 0;

  if (action === 'init') {
    //如果有special属性
    //提取出第一个对象的设置，混入到special
    var special = property.special;
    if (special && special[1]) {
      _.extend(property, special[1]);
    }
  }

  var specialProperty = void 0; //特殊属性值
  var lastProperty = void 0;
  if (action === 'master') {
    var _special = targetProperty.special;
    if (_special) {
      specialProperty = _special[pageIndex];
      if (!specialProperty) {
        //上一个属性
        lastProperty = _special.lastProperty;
      }
    }
  }

  //视觉差对象初始化偏移量
  var parallaxOffset = pageOffset;

  //===========
  //  平移
  //===========
  var hasTranslateX = property.translateX !== undefined;
  var hasTranslateY = property.translateY !== undefined;
  var hasTranslateZ = property.translateZ !== undefined;
  if (hasTranslateX) {
    x = round(property.translateX) || 0;
    parallaxOffset += x;
    transformProperty.translateX = 'translateX(' + parallaxOffset + 'px)';
  }
  if (hasTranslateY) {
    y = round(property.translateY) || 0;
    transformProperty.translateY = 'translateY(' + y + 'px)';
  }
  if (hasTranslateX || hasTranslateY || hasTranslateZ) {
    z = round(property.translateZ) || 0;
    transformProperty.translateZ = setTranslateZ(0);
  }

  //===========
  //  旋转
  //===========
  if (property.rotateX !== undefined) {
    transformProperty.rotateX = 'rotateX(' + round(property.rotateX) + 'deg)';
  }
  if (property.rotateY !== undefined) {
    transformProperty.rotateY = 'rotateY(' + round(property.rotateY) + 'deg)';
  }
  if (property.rotateZ !== undefined) {
    transformProperty.rotateZ = 'rotateZ(' + round(property.rotateZ) + 'deg)';
  }

  //===========
  //  缩放
  //===========
  var hasScaleX = property.scaleX !== undefined;
  var hasScaleY = property.scaleY !== undefined;
  var hasScaleZ = property.scaleZ !== undefined;
  if (hasScaleX) {
    x = round(property.scaleX * 100) / 100;
    transformProperty.scaleX = 'scaleX(' + x + ')';
  }
  if (hasScaleY) {
    y = round(property.scaleY * 100) / 100;
    transformProperty.scaleY = 'scaleY(' + y + ')';
  }
  if (hasScaleZ) {
    z = round(property.scaleZ * 100) / 100;
    transformProperty.scaleZ = 'scaleZ(' + z + ')';
  }
  //如果设了XY的缩放，默认增加Z处理
  if (!hasScaleZ && (hasScaleX || hasScaleY)) {
    transformProperty.scaleZ = 'scaleZ(1)'; //默认打开3D，如不指定iphone闪屏
  }

  //===========
  //  透明度
  //===========
  var hasOpacity = false;
  if (property.opacity !== undefined) {
    if (action === 'init') {
      style.opacity = round((property.opacityStart + property.opacity) * 100) / 100;
      hasOpacity = true;
    }
    if (action === 'master') {
      style.opacity = round(property.opacity * 100) / 100 + opacityStart;
      hasOpacity = true;
    }
  }

  //=================================
  // style可以单独设置opacity属性
  //=================================
  if (transformProperty || hasOpacity) {
    if (transformProperty) {

      if (lastProperty) {
        _.extend(transformProperty, lastProperty);
      }

      style[transitionDuration] = speed + 'ms';
      var tempProperty = '';
      for (var key in transformProperty) {
        tempProperty += transformProperty[key];
      }
      if (tempProperty) {
        style[transform] = tempProperty;
      }
    }
    //拿到属性的最终值
    if ($contentNode) {
      $contentNode.css(style);
      //翻页做上一个完成记录
      if (interaction === 'flipOver' && specialProperty) {
        for (var _key in specialProperty) {
          var speciaValue = specialProperty[_key];
          var result = transformProperty[_key];
          if (result) {
            //保存特殊的值
            targetProperty.special.lastProperty[_key] = result;
          }
        }
      }
    }
  }

  return parallaxOffset;
}

/**
 * 初始化元素属性
 */
function getInitProperty(property, nodeOffset, specialProperty, getStyle) {
  var results = {};
  var width = -getStyle.visualWidth;
  var height = -getStyle.visualHeight;

  for (var key in property) {
    //special使用
    //给属性打上标记，用于翻页的时候过滤
    //因为采用动态滑动视觉差
    //可能在某些页面设置属性，某些页面跳过
    if (specialProperty) {
      specialProperty.special[key] = true;
    }

    switch (key) {
      case 'special':
        //特殊属性
        results[key] = {};
        for (var i in property[key]) {
          //因为是独立设置，所以nodeOffset的比值不需要了
          //nodeOffset = 1
          var props = getInitProperty(property[key][i], 1, property);
          results[key][i] = props;
        }
        break;
      case 'scaleX':
      case 'scaleY':
      case 'scaleZ':
        //缩放是从1开始
        //变化值是property[key] - 1
        //然后用nodeOffset处理，算出比值
        results[key] = 1 + (property[key] - 1) * nodeOffset;
        break;
      case 'translateX':
      case 'translateZ':
        results[key] = property[key] * nodeOffset * width;
        break;
      case 'translateY':
        results[key] = property[key] * nodeOffset * height;
        break;
      case 'opacityStart':
        results[key] = property[key];
        break;
      default:
        results[key] = property[key] * nodeOffset;
    }
  }
  return results;
}

/**
 * 获取属性单步变化的比值
 */
function getStepProperty(_ref2) {
  var nodes = _ref2.nodes,
      isColumn = _ref2.isColumn,
      distance = _ref2.distance,
      pageIndex = _ref2.pageIndex,
      lastProperty = _ref2.lastProperty,
      targetProperty = _ref2.targetProperty;

  var temp = {};
  var property = targetProperty; //浅复制
  var lastSpecialProperty = void 0; //上一个特殊的对象属性

  //动态属性页面
  var specialProperty = void 0;
  var nextSpecialProperty = void 0;
  if (targetProperty.special) {
    specialProperty = targetProperty.special[pageIndex];
    nextSpecialProperty = targetProperty.special[pageIndex + 1];
    if (specialProperty) {
      //深复制，这样修改的目的是混入了specialProperty后，不会改变targetProperty原对象
      property = _.extend({}, targetProperty, specialProperty);
    }
  }

  //这里有页面模式的配置处理
  //获取的页面翻页的区域值不一样
  var size = isColumn ? config.screenSize : config.visualSize;
  var width = size.width;
  var height = size.height;

  for (var key in property) {
    switch (key) {
      case 'scaleX':
      case 'scaleY':
      case 'scaleZ':
        //特殊属性的计算
        //没有中间值，直接就 = 百分比*变化区间
        if (specialProperty[key]) {
          var percentage = -distance / width;
          if (nextSpecialProperty[key]) {
            var changeProperty = nextSpecialProperty[key] - specialProperty[key];
            if (changeProperty) {
              temp[key] = percentage * changeProperty;
            }
          }
        } else {
          temp[key] = -1 * distance / width * (property[key] - 1) * nodes;
        }
        break;
      case 'translateX':
      case 'translateZ':
        temp[key] = distance * nodes * property[key];
        break;
      case 'translateY':
        temp[key] = distance * (height / width) * nodes * property[key];
        break;
      case 'opacityStart':
        temp[key] = property.opacityStart;
        break;
      default:
        //乘以-1是为了向右翻页时取值为正,位移不需这样做
        temp[key] = -1 * distance / width * property[key] * nodes;
    }
  }
  return temp;
}

/**
 * 移动叠加值
 */
function flipMove(stepProperty, lastProperty) {
  var temp = {};
  var start = stepProperty.opacityStart;
  for (var i in stepProperty) {
    //叠加值
    temp[i] = stepProperty[i] + lastProperty[i];
  }
  if (start > -1) {
    temp.opacityStart = start;
  }
  return temp;
}

/**
 * 翻页结束
 */
function flipOver() {
  return flipMove.apply(undefined, arguments);
}

/**
 * 反弹
 */
function flipRebound(stepProperty, lastProperty) {
  var temp = {};
  for (var i in stepProperty) {
    temp[i] = lastProperty[i] || stepProperty[i];
  }
  return temp;
}

/**
 * 结束后缓存上一个记录
 */
function cacheProperty(stepProperty, lastProperty) {
  for (var i in stepProperty) {
    lastProperty[i] = stepProperty[i];
  }
}

/**
 * 视觉差对象初始化操作
 */
/**
 * 变化节点的css3transform属性
 * @param  {[type]} $contentNode   [description]
 * @param  {[type]} property   [description]
 * @param  {[type]} pageOffset [description]
 * @return {[type]}            [description]
 */
var setTransformNodes = function setTransformNodes($contentNode, property, pageOffset) {
  return setStyle({ //return parallaxOffset
    $contentNode: $contentNode,
    action: 'init',
    property: property,
    pageOffset: pageOffset
  });
};

/**
 * 转换属性
 * @param  {[type]} parameters [description]
 * @return {[type]}            [description]
 */
var converProperty = function converProperty(property) {
  if (property.opacityStart > -1) {
    property.opacity = (property.opacityEnd || 1) - property.opacityStart;
    delete property.opacityEnd;
  }
  return property;
};

/**
 * 如果母版依赖的页面是flow页面
 * 需要获取到具体的页面长度
 * @return {[type]} [description]
 */
var getFlowFange = function getFlowFange(pageIndex) {
  var relyPageObj = Xut.Presentation.GetPageBase('page', pageIndex);
  if (relyPageObj && relyPageObj.chapterData.note === 'flow') {
    var seasonId = relyPageObj.chapterData.seasonId;
    var chapterId = relyPageObj.chapterId;
    var range = getColumnCount$1(seasonId, chapterId); //分页总数
    return range;
  }
};

function index$1(data, dataRelated, getStyle) {

  //转化所有css特效的参数的比例
  var targetProperty = parseJSON(data.getParameter()[0]['parameter']);
  if (!targetProperty) {
    return;
  }

  targetProperty = converProperty(targetProperty);

  var chapterIndex = data.chapterIndex;

  //首位分割点
  var currPageOffset = void 0;

  //如果是flow页面，拿到分页数
  var pageRange = hasColumn() && getFlowFange(data.pageIndex);
  if (pageRange) {
    var visualIndex = Xut.Presentation.GetPageIndex();
    if (data.pageIndex == visualIndex || data.pageIndex > visualIndex) {
      currPageOffset = 1;
    } else {
      currPageOffset = pageRange;
    }
  } else {
    //页面偏移量
    //["3", "6", "4"]
    //表示第4次采用了这个母板，中间有其他模板间隔开了的情况
    var pageOffset = dataRelated.pageOffset && dataRelated.pageOffset.split("-");
    //开始的nodes值
    currPageOffset = parseInt(pageOffset[0]);
    //范围区域
    pageRange = parseInt(pageOffset[1]);
  }

  //非匀速视觉差，初始化一些参数
  //增加特殊记录历史记录
  if (targetProperty.special) {
    //筛选出所有属性最大的值
    var maxProperty = {};
    var specialProperty = targetProperty.special;
    for (var key in specialProperty) {
      for (var name in specialProperty[key]) {
        if (maxProperty[name]) {
          if (maxProperty[name] < specialProperty[key][name]) {
            maxProperty[name] = specialProperty[key][name];
          }
        } else {
          maxProperty[name] = specialProperty[key][name];
        }
      }
    }
    targetProperty.special.maxProperty = maxProperty;
    targetProperty.special.lastProperty = {};
  }

  //页面偏移比例
  var nodeOffset = (currPageOffset - 1) / (pageRange - 1) || 0;

  //计算出新的新的值
  var lastProperty = getInitProperty(targetProperty, nodeOffset, '', getStyle);

  //页面分割比
  var nodeRatio = 1 / (pageRange - 1);

  //初始化视觉差对象的坐标偏移量
  var transformOffset = dataRelated.getTransformOffset(data.id);
  var parallaxOffset = setTransformNodes(data.$contentNode, lastProperty, transformOffset);

  /**
   * 为了兼容动画，把视觉差当作一种行为处理
   * 合并data数据
   * @type {Object}
   */
  data.parallax = {
    $contentNode: data.$contentNode,
    /**
     * 计算页码结束边界值,用于跳转过滤
     */
    calculateRangePage: function calculateRangePage() {
      return {
        'start': chapterIndex - currPageOffset + 1,
        'end': pageRange - currPageOffset + chapterIndex
      };
    },

    /**
     * 目标属性
     */
    targetProperty: targetProperty,
    /**
     * 最后一个属性值
     */
    lastProperty: lastProperty,
    /**
     * 比值
     */
    nodeRatio: nodeRatio,
    /**
     * 经过视觉差修正后的偏移量
     */
    parallaxOffset: parallaxOffset
  };

  return data;
}

/////////////////////////////////
///  预处理
///  1.动画直接改变显示隐藏状态
///  2.动画直接执行脚本
/////////////////////////////////

function pretreatment(data, eventName) {
  var parameter = data.getParameter();

  ///////////////////////////////////////////////////////////////
  //如果是apng、webp、gif的图片
  //在线性模式，由于预加载一页的原理，会让apng提前在非可视区运行
  //所以规定
  //1 如果是显示动画中绑定了apng、webp、gif的资源，那么就需要动态处理
  //2 在dom阶段创建了所有的img.src 在ppt动画阶段需要判断，删除后动态处理
  ///////////////////////////////////////////////////////////////
  var fileName = data.contentData.md5;
  if (fileName && /^apng_|gif$/i.test(fileName)) {
    data.useDynamicDiagram = true; //标记动画图片动画
  }

  //过滤预生成动画
  if (parameter && parameter.length === 1) {
    var category = data.contentData.category;
    var para = parameter[0];

    if (para.animationName === 'EffectAppear' && //出现动画
    data.domMode && //并且只有dom模式才可以，canvas排除
    eventName === 'auto' && //自动运行
    !para.videoId && //没有音频
    !para.delay && //没有延时
    category !== 'Sprite' && //不是精灵
    category !== 'AutoCompSprite' && //不是自动精灵
    !/"inapp"/i.test(para.parameter)) {
      //并且不能是收费处理


      ///////////////////////////////////////////////////////////////
      //针对预处理动作,并且没有卷滚的不注册，满足是静态动画，true是显示,false隐藏
      ///////////////////////////////////////////////////////////////
      if (!para.preCode && !para.postCode) {
        return data.prepVisible = /"exit":"False"/i.test(para.parameter) === true ? 'visible' : 'hidden';
      }

      ///////////////////////////////////////////////////////////////
      //如果有脚本，可能是针对迷你杂志跳转的数据
      //需要通过onclick绑定，那么就截断这个数据
      /////////////////////////////////////////////////////////////////
      if (para.preCode) {

        //方式一
        //通过创建a标签的处理跳转
        // window.XXTAPI.PreCode = [url, function() {
        //   if (plat === 'iOS') {
        //     $.post("http://www.kidreadcool.com/downloads.php", {
        //       esp: "mios",
        //       url: "mindex1"
        //     }, null, "json");
        //   }
        // }]
        if (-1 !== para.preCode.indexOf('XXTAPI.PreCode')) {
          return data.prepTag = para.preCode;
        }

        //方式二
        
        ['window.location.href', 'window.open'].forEach(function (url) {
          if (-1 !== para.preCode.indexOf(url)) {
            return data.prepScript = para.preCode;
          }
        });
        if (data.prepScript) {
          return data.prepScript;
        }
      }
    }
  }
}

/**
 * 创建执行对象
 * 1 动画作用域
 * 2 视觉差作用域
 * @type {Array}
 */
//2016.7.15废弃
//pixi暂时不使用
// import { Context } from '../pixi/context'


/**
 * 构建动画
 * @return {[type]} [description]
 */
var createScope = function createScope(base, contentId, chapterIndex, actName, parameter, hasParallax) {

  //默认启动dom模式
  var data = {
    type: 'dom',
    canvasMode: false,
    domMode: true
  };
  var $contentNode;
  var pageType = base.pageType;
  var contentName;
  var canvasDom;
  var contentData = base.dataRelated.contentDataset[contentId];

  //如果启动了canvas模式
  //改成作用域的一些数据
  if (base.canvasRelated.enable) {
    //如果找到对应的canvas对象
    if (-1 !== base.canvasRelated.contentIdset.indexOf(contentId)) {
      contentName = "canvas_" + chapterIndex + "_" + contentId;
      canvasDom = base.getContextNode(contentName)[0];

      //创建上下文pixi
      if (contentData.$contentNode) {
        $contentNode = contentData.$contentNode;
      } else {
        // $contentNode = Context(contentData, canvasDom, base.pageIndex)
        //保存canvas pixi的上下文引用
        // base.dataRelated.contentDataset[contentId].$contentNode = $contentNode
      }
      data.type = 'canvas';
      data.canvasMode = true;
      data.domMode = false;
    }
  }

  //如果是dom模式
  if (!$contentNode) {
    /**
     * 确保节点存在
     * @type {[type]}
     */
    if (!($contentNode = base.getContextNode(actName))) {
      return;
    }
  }

  /**
   * 制作公共数据
   * @type {Object}
   */
  _.extend(data, {
    base: base,
    id: contentId,
    actName: actName,
    contentData: contentData,
    $contentNode: $contentNode,
    pageType: pageType,
    canvasDom: canvasDom,
    chapterIndex: chapterIndex,
    pageIndex: base.pageIndex,
    canvasRelated: base.canvasRelated,
    nextTask: base.nextTask
  });

  /**
   * 如果是母版层理,视觉差处理
   * processType 三种情况
   *          parallax
   *          animation
   *          both(parallax,animation)
   * @type {[type]}
   */
  if (hasParallax && pageType === 'master') {
    data.processType = 'parallax';
  } else {
    data.processType = 'animation';
  }

  /**
   * 生成查询方法
   */
  data.getParameter = function () {
    //分区母版与页面的数据结构
    //parameter-master-parallax
    //parameter-master-animation
    //parameter-page-animation
    var fix = 'parameter-' + pageType + '-' + data.processType;
    data[fix] = parameter;
    return function () {
      return data[fix];
    };
  }();

  //生成视觉差对象
  if (data.processType === 'parallax') {
    return index$1(data, base.dataRelated, base.getStyle);
  }

  //数据预处理
  var hasPipe = pretreatment(data, base.eventRelated.eventName);
  if (hasPipe) {
    return fastPipe(data, base);
  } else {
    //生成子作用域对象，用于抽象处理动画,行为
    data.getStyle = base.getStyle;
    return new Animation(data);
  }
};

/**
 * 分解每个子作用域
 * 1 生成临时占位作用域,用于分段动画
 * 2 生成所有动画子作用域
 * @param  {[type]} parameter [description]
 * @return {[type]}           [description]
 */
var createHandlers = function createHandlers(base, parameter) {
  var para = parameter[0];
  var contentId = para['contentId']; //可能有多个动画数据 [Object,Object,Object]
  var chapterIndex = base.chapterIndex;
  var actName = base.makePrefix('Content', chapterIndex, contentId);
  return createScope(base, contentId, chapterIndex, actName, parameter, para.masterId);
};

/**
 * 构建作用域
 * @return {[type]} [description]
 */
var fnCreate = function fnCreate(base) {
  return function (data, callback) {
    var para, handlers;
    if (data && data.length) {
      //生成动画作用域对象
      while (para = data.shift()) {
        if (handlers = createHandlers(base, para)) {
          callback(handlers);
        }
      }
    }
  };
};

/**
 * 源对象复制到目标对象
 */
var innerExtend = function innerExtend(target, source) {
  var property;
  for (property in source) {
    if (target[property] === undefined) {
      target[property] = source[property];
    }
  }
};

//处理itemArray绑定的动画对象
//注入动画
//绑定用户事件
var createContent = function (base) {

  var animation = base.dataset.animation,
      parallax = base.dataset.parallax,

  //抽出content对象
  contentGroup = [],

  //创建引用
  batcheCreate = fnCreate(base);

  switch (base.pageType) {
    case 'page':
      batcheCreate(animation, function (handlers) {
        contentGroup.push(handlers);
      });
      break;
    case 'master':
      //母版层的处理
      var tempParallaxScope = {},
          tempAnimationScope = {},
          tempAssistContents = [];
      //视觉差处理
      batcheCreate(parallax, function (handlers) {
        tempParallaxScope[handlers.id] = handlers;
      });

      batcheCreate(animation, function (handlers) {
        tempAnimationScope[handlers.id] = handlers;
      });

      var hasParallax = _.keys(tempParallaxScope).length,
          hasAnimation = _.keys(tempAnimationScope).length;

      //动画为主
      //合并，同一个对象可能具有动画+视觉差行为
      if (hasParallax && hasAnimation) {
        _.each(tempAnimationScope, function (target) {
          var id = target.id;
          var source = tempParallaxScope[id];
          if (source) {
            //如果能找到就需要合并
            innerExtend(target, source); //复制方法
            target.processType = 'both'; //标记新组合
            delete tempParallaxScope[id]; //删除引用
          }
        });
        //剩余的处理
        if (_.keys(tempParallaxScope).length) {
          _.extend(tempAnimationScope, tempParallaxScope);
        }
        tempParallaxScope = null;
      }
      //转化成数组
      _.each(hasAnimation ? tempAnimationScope : tempParallaxScope, function (target) {
        tempAssistContents.push(target);
      });
      contentGroup = tempAssistContents;
      break;
  }

  batcheCreate = null;

  return contentGroup;
};

/**
 * 2016.4.11
 * 因为canvas模式导致
 * 任务必须等待context上下创建
 * 完成后执行
 * 1 事件
 * 2 预执行
 * @type {Array}
 */
var createTask = function (callback) {
  return {
    context: {
      /**
       * 状态表示
       */

      /**
       * 是否等待创建
       * @type {Boolean}
       */
      wait: false,

      /**
       * 是否完成创建
       * @type {Boolean}
       */
      statas: false,

      /**
       * id合集
       * @type {Array}
       */
      _ids: [],

      /**
       * 事件
       * @type {Array}
       */
      event: [],

      /**
       * 预执行
       * @type {Object}
       */
      pre: {}, //预执行


      /**
       * 检测是否完成
       * @return {[type]} [description]
       */
      check: function check() {
        var total = this.length();
        if (!total.length) {
          //完成创建
          this.statas = true;
        }
        //如果已经等待
        if (this.wait) {
          callback && callback();
          return;
        }
        // //创建比流程先执行完毕
        // //一般几乎不存在
        // //但是不排除
        // if (!this.wait && this.statas) {
        //     this.wait = true;
        //     return;
        // }
      },
      add: function add(id) {
        if (-1 === this._ids.indexOf(id)) {
          this._ids.push(id);
        }
      },
      remove: function remove(id) {
        if (!id) {
          return;
        }
        var index = this._ids.indexOf(id);
        var val = this._ids.splice(index, 1);
        this.check(val);
        return val;
      },
      length: function length() {
        return this._ids.length;
      }
    }
  };
};

/*******************************************
 *   文本类
 *     处理:
 *       1 异步转同步deferred处理
 *       2 dom结循环创建
 *       创建的四种行为
 *          1 默认创建结构绑定事件
 *          2 用于预先创建activityMode模式,分发动画与事件
 *          3 递归创建,关联子热点
 *          4 ppt文字动画,不创建主体结构,递归子热点
 *                  A 递归处理PPT动画
 *                  B 处理同步音频
 *                                      *
 ******************************************/
/**
 * 处理拖动对象
 * @return {[type]} [description]
 */
function accessDrop(eventRelated, callback) {
  if (eventRelated && eventRelated.dragDrop) {
    callback(eventRelated.dragDrop);
  }
}

var Activity = function () {

  /**
   * activity触发器类
   * @param  {[type]} data [description]
   * @return {[type]}      [description]
   */
  function Activity(data) {
    classCallCheck(this, Activity);


    _.extend(this, data);

    /**
     * 2016.4.11
     * 检测是所有的子任务必须完成
     * 因为canvas模式导致
     * 任务必须等待context上下创建
     * context就是pixi的直接对象，精灵..都是异步的
     */
    this.nextTask = createTask(this.noticeComplete);

    /**
     * 初始化事件
     * 需要先解析
     * createContent需要依赖
     */
    this._initEvents();

    /**
     * 保存子对象content
     */
    this.contentGroup = createContent(this);

    /**
     * 处理html文本框
     * 2016.1.6
     */
    this._htmlTextBox();

    /**
     * 绑定事件
     */
    this._bindEvents();

    /**
     * 初始化content行为
     */
    this._initContents();

    /**
     * 2016.2.26
     * 修复妙妙学
     * 妙妙客户端处理
     * 点击效果的音频处理
     * @type {Array}
     */
    this.fixAudio = [];

    /**
     * 2016.11.2
     * 缓存点击的音频对象
     * 这样用于优化重复点击按钮的时候触发音频
     * @type {Array}
     */
    this.cacheBehaviorAudio = {};

    /**
     * 如果存在content
     * 等待创建执行
     * @param  {[type]} this.nextTask.context.length()
     * @return {[type]}
     */
    if (this.nextTask.context.length()) {
      this.nextTask.context.wait = true;
      return this;
    }

    /**
     * 如果没有pixi的异步创建
     * 同步代码直接完成
     */
    this.noticeComplete();
  }

  /**
   * 初始化content行为
   * @return {[type]} [description]
   */


  createClass(Activity, [{
    key: '_initContents',
    value: function _initContents() {
      var _this = this;

      var pageId = this.dataRelated.pageId;
      var $containsNode = this.$containsNode;
      var collectorHooks = this.callbackRelated.contentsHooks;
      var pageType = this.pageType;
      var activityId = this.activityId;

      this.eachAssistContents(function (scope) {
        //针对必须创建
        var contentId = scope.id;
        var $contentNode = scope.$contentNode;

        //如果是视觉差对象，也需要实现收集器
        if (scope.processType === 'parallax') {
          collectorHooks(scope.chapterIndex, contentId, scope);
          return;
        }

        //初始化动画
        scope.init(contentId, $contentNode, $containsNode, pageId, scope.getParameter(), pageType, activityId);
        _this._toRepeatBind(contentId, $contentNode, scope, collectorHooks);
      });
    }

    /**
     * dom节点去重绑定
     * 在每一次构建activity对象中，不重复处理content一些特性
     * 1 翻页特性
     * 2 注册钩子
     * @return {[type]} [description]
     */

  }, {
    key: '_toRepeatBind',
    value: function _toRepeatBind(contentId, $contentNode, scope, collectorHooks) {
      var dataRelated = this.dataRelated;
      var indexOf = dataRelated.createContentIds.indexOf(contentId);

      //过滤重复关系
      //每个元素只绑定一次
      if (-1 !== indexOf) {
        dataRelated.createContentIds.splice(indexOf, 1); //删除,去重
        collectorHooks(scope.chapterIndex, contentId, scope); //收集每一个content注册
        this._iscrollBind(scope, $contentNode); //增加翻页特性
      }
    }

    /**
     * 增加翻页特性
     * 可能有多个引用关系
     * @return {[type]}         [description]
     */

  }, {
    key: '_iscrollBind',
    value: function _iscrollBind(scope, $contentNode) {
      var _this2 = this;

      var self = this;
      var contentData = scope.contentData;

      var linkFunction = function linkFunction(scrollNode) {

        //滚动文本的互斥不显示做一个补丁处理
        //如果是隐藏的,需要强制显示,待邦定滚动之后再还原
        //如果是显示的,则不需要处理,
        var $parentNode = self.getContextNode(self.makePrefix('Content', scope.chapterIndex, scope.id));
        var visible = $parentNode.css('visibility');
        var resetStyle = function resetStyle() {};

        //元素隐藏状态下，绑定iScroll获取高度是有问题
        //所以这里需要补丁方式修正一下
        //让其不可见，但是可以获取高度
        if (visible == 'hidden') {
          var opacity = $parentNode.css('opacity');
          var setStyle = function setStyle(key, value) {
            arguments.length > 1 ? $parentNode.css(key, value) : $parentNode.css(key);
          };

          //如果设置了不透明,则简单设为可见的
          //否则先设为不透明,再设为可见
          if (opacity == 0) {
            setStyle('visibility', 'visible');
            resetStyle = function resetStyle() {
              return setStyle('visibility', visible);
            };
          } else {
            setStyle({
              'opacity': 0,
              'visibility': 'visible'
            });
            resetStyle = function resetStyle() {
              return setStyle({
                'opacity': opacity,
                'visibility': visible
              });
            };
          }
        }

        return function () {

          var option = {
            scrollbars: 'custom',
            fadeScrollbars: true

            /*迷你平台，工具栏不消失*/
          };if (config.launch.platform === 'mini') {
            option.fadeScrollbars = false;
          }

          self.iscroll = IScroll(scrollNode, option, 'delegate');

          //增加标记
          //在PPT动画中reset不还原
          scrollNode.setAttribute("data-iscroll", "true");

          resetStyle();
          resetStyle = null;
          $parentNode = null;
          scrollNode = null;
        };
      };

      var bind = function bind() {
        $contentNode.css('overflow', 'hidden'); //增加元素溢出隐藏处理
        $contentNode.children().css('height', ''); //去掉子元素高度，因为有滚动文本框
        _this2.callbackRelated.iscrollHooks.push(linkFunction($contentNode[0]));
      };

      //增加卷滚条标记
      //但是svg如果没有内容除外
      if (contentData.isScroll) {
        var hasSVG = $contentNode.find('svg');
        if (hasSVG) {
          //必须保证svg有数据
          if (hasSVG.text()) {
            bind();
          }
        } else {
          //如果不是svg数据，直接绑定
          bind();
        }
      }

      //如果是图片则补尝允许范围内的高度
      if (!contentData.mask || !contentData.isGif) {
        $contentNode.find && $contentNode.find('img').css({
          'height': contentData.scaleHeight
        });
      }
    }

    /**
     * 制作一个查找标示
     * @return {[type]}
     */

  }, {
    key: 'makePrefix',
    value: function makePrefix(name, index, id) {
      return name + "_" + index + "_" + id;
    }

    /**
     * 从文档碎片中找到对应的dom节点
     * 查找的范围
     * 1 文档根节点
     * 2 文档容器节点
     * @param  {[type]} prefix [description]
     * @return {[type]}        [description]
     */

  }, {
    key: 'getContextNode',
    value: function getContextNode(prefix, type) {
      var node = void 0,
          $node = void 0,
          containerPrefix = void 0,
          contentsFragment = void 0;

      //dom模式
      contentsFragment = this.dataRelated.contentsFragment;
      if (node = contentsFragment[prefix]) {
        $node = $(node);
      } else {
        //容器处理
        if (containerPrefix = this.dataRelated.containerPrefix) {
          _.each(containerPrefix, function (containerName) {
            node = contentsFragment[containerName];
            $node = $(node).find('#' + prefix);
            if ($node.length) {
              return;
            }
          });
        }
      }
      return $node;
    }

    /**
     * 复位独立动画
     * 提供快速翻页复用
     * @return {[type]} [description]
     */

  }, {
    key: '_resetAloneAnim',
    value: function _resetAloneAnim() {
      //复位拖动对象
      accessDrop(this.eventRelated, function (drop) {
        drop.reset();
      });
    }

    /**
     * 动画运行之后
     * 1 创建一个新场景
     * 2 执行跳转到收费提示页面
     * 3 触发搜索工具栏
     * @return {[type]} [description]
     */

  }, {
    key: '_relevantOperation',
    value: function _relevantOperation() {

      var scenarioInfo, eventContentId;

      //触发事件的content id
      if (this.eventRelated) {
        eventContentId = this.eventRelated.eventContentId;
      }

      if (eventContentId) {

        //查找出当前节的所有信息
        if (scenarioInfo = this.dataRelated.seasonRelated[eventContentId]) {

          //如果存在搜索栏触发
          if (scenarioInfo.SearchBar) {
            this.createSearchBar();
            return;
          }

          //如果存在书签
          if (scenarioInfo.BookMarks) {
            this.createBookMark();
            return;
          }

          //处理新的场景
          if (scenarioInfo.seasonId || scenarioInfo.chapterId) {
            setTimeout(function () {
              Xut.View.LoadScenario({
                'seasonId': scenarioInfo.seasonId,
                'chapterId': scenarioInfo.chapterId
              });
            }, hasFixAudio() ? 500 : 0);
            return;
          }
        }
      }
    }

    /**
     * 保证正确遍历
     * @return {[type]} [description]
     */

  }, {
    key: 'eachAssistContents',
    value: function eachAssistContents(callback) {
      _.each(this.contentGroup, function (scope) {
        callback.call(this, scope);
      }, this);
    }

    /**
     * 运行动画
     * @param  {[type]} outComplete [动画回调]
     * @return {[type]}             [description]
     * evenyClick 每次都算有效点击
     * onlyRunContentId 仅仅运行指定contentId的对象
     */

  }, {
    key: 'runAnimation',
    value: function runAnimation(outComplete, evenyClick, onlyRunContentId) {

      var self = this;
      var pageId = this.dataRelated.pageId;

      if (evenyClick) {
        this.preventRepeat = false;
      }

      //防止重复点击
      if (this.preventRepeat) {
        return false;
      }

      this.preventRepeat = true;

      //如果没有运行动画
      if (!this.dataset.animation) {
        this.preventRepeat = false;
        this._relevantOperation();
        return;
      }

      //监控执行动画的长度
      //如果onlyRunContentId存在则只需要检测一次
      //否就是默认activityId下的所有content对象
      var watchCompleteCount = 0;
      if (onlyRunContentId) {
        watchCompleteCount = 1;
      } else {
        if (this.contentGroup) {
          watchCompleteCount = this.contentGroup.length;
        }
      }

      //制作作用于内动画完成
      //等待动画完毕后执行动作or场景切换
      var captureAnimComplete = this.captureAnimComplete = function (counts) {
        return function (scope) {
          //动画结束,删除这个hack
          scope && scope.$contentNode && scope.$contentNode.removeProp && scope.$contentNode.removeProp('animOffset');

          //2017.10.12修复
          //母版上的回调
          //不能通过这个判断
          //否则动画不执行
          //
          //暂时没处理母版上的快速动画问题
          //只处理页面级的
          var closeAnim = void 0;
          if (self.pageType === 'page') {
            //如果快速翻页，运行动画的时候，发现不是可视页面，需要关闭这些动画
            closeAnim = pageId != Xut.Presentation.GetPageId();
          }

          if (closeAnim && scope) {
            scope.stop && scope.stop(pageId);
            scope.reset && scope.reset();
          }

          //捕获动画状态
          if (counts === 1 || counts === 0) {
            if (closeAnim) {
              //复位动画
              self._resetAloneAnim();
            }
            self.preventRepeat = false;
            self._relevantOperation();
            outComplete && outComplete();
            self.captureAnimComplete = null;
          } else {
            --counts;
          }
        };
      }(watchCompleteCount);

      function runScope(scope) {
        //标记动画正在运行，标记初始化坐标
        scope.$contentNode && scope.$contentNode.prop && scope.$contentNode.prop({
          'animOffset': scope.$contentNode.offset()
        });
        scope.play(function () {
          captureAnimComplete(scope);
        });
      }

      //执行动画
      this.eachAssistContents(function (scope) {
        if (onlyRunContentId) {
          //只执行指定的编号
          if (onlyRunContentId === scope.id) {
            runScope(scope);
          }
        } else {
          runScope(scope);
        }
      });

      this.runState = true;
    }

    /**
     * 停止动画
     * @return {[type]} [description]
     */

  }, {
    key: 'stopAnimation',
    value: function stopAnimation(outComplete) {
      var pageId = this.dataRelated.pageId;
      this.runState = false;
      this.eachAssistContents(function (scope) {
        scope.stop && scope.stop(pageId);
      });
      outComplete && outComplete();
    }

    /**
     * 隐藏动画元素
     * @return {[type]} [description]
     */

  }, {
    key: 'hideAnimation',
    value: function hideAnimation(outComplete) {
      this.stopAnimation(); //先停止，再隐藏
      this.eachAssistContents(function (scope) {
        scope.hide && scope.hide();
      });
      outComplete && outComplete();
    }

    /**
     * 销毁动画
     * @param  {[type]} elementCallback [description]
     * @return {[type]}                 [description]
     */

  }, {
    key: '_destroyAnimation',
    value: function _destroyAnimation(elementCallback) {
      var _this3 = this;

      //销毁拖动对象
      accessDrop(this.eventRelated, function (drop) {
        drop.destroy();
      });
      this.eachAssistContents(function (scope) {
        scope.destroy && scope.destroy(_this3.dataRelated.pageId);
        elementCallback && elementCallback(scope);
      });
    }

    /**
     * 自动运行
     * @param  {[type]} outComplete [description]
     * @return {[type]}             [description]
     */

  }, {
    key: 'autoPlay',
    value: function autoPlay(outComplete) {
      var eventRelated = this.eventRelated;
      if (eventRelated && eventRelated.eventName === 'auto') {
        this.runAnimation(outComplete);
      } else {
        outComplete();
      }
    }

    /**
     * 复位状态
     * @return {[type]} [description]
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.eachAssistContents(function (scope) {
        scope.reset && scope.reset(); //ppt动画
      });
      this._resetAloneAnim();
    }

    /**
     * 停止动作
     * @return {[type]} [description]
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this.runState) {
        this.stopAnimation();
      }
      this.preventRepeat = false;

      //复位盒子
      if (this.htmlBoxInstance.length) {
        _.each(this.htmlBoxInstance, function (instance) {
          instance.removeBox();
        });
      }

      //修复妙妙客户端
      //没有点击音频结束的回调
      //最多允许播放5秒
      if (this.fixAudio.length) {
        _.each(this.fixAudio, function (instance) {
          setTimeout(function () {
            instance.destroy();
          }, 5000);
        });
        this.fixAudio = [];
      }
    }

    //销毁
    //提供一个删除回调
    //用于处理浮动对象的销毁

  }, {
    key: 'destroy',
    value: function destroy(elementCallback) {

      //销毁绑定事件
      if (this.eventRelated.eventContext) {
        destroyContentEvent(this.eventRelated);
        this.eventRelated.eventContext = null;
      }

      //2016.1.7
      //如果有文本框事件
      //一个activity允许有多个文本框
      //所以是数组索引
      if (this.htmlBoxInstance.length) {
        _.each(this.htmlBoxInstance, function (instance) {
          instance.destroy();
        });
        this.htmlBoxInstance = null;
      }

      //销毁动画
      this._destroyAnimation(elementCallback);
      this.contentGroup = null;

      //iscroll销毁
      if (this.iscroll) {
        this.iscroll.destroy();
        this.iscroll = null;
      }

      //销毁搜索框
      if (this.searchBar) {
        this.searchBar.destroy();
        this.searchBar = null;
      }

      //销毁书签
      if (this.bookMark) {
        this.bookMark.destroy();
        this.bookMark = null;
      }

      //如果有点击音频
      if (Object.keys(this.cacheBehaviorAudio).length) {
        for (var key in this.cacheBehaviorAudio) {
          var audio = this.cacheBehaviorAudio[key];
          if (audio) {
            audio.destroy();
            this.cacheBehaviorAudio[key] = null;
          }
        }
      }

      this.$containsNode = null;
    }
  }]);
  return Activity;
}();

var activitProto = Activity.prototype;

textBoxMixin(activitProto);
bookMarkMixin(activitProto);
searchBarMixin(activitProto);
eventMixin(activitProto);

/** 配置ID
 * @return {[type]} [description]
 */
function autoUUID() {
  return 'autoRun-' + Math.random().toString(36).substring(2, 15);
}

/**
 * 给所有content节点绑定对应的事件与动画
 * 1 动画
 * 2 事件
 * 3 视觉差
 * 4 动画音频
 * 5 canvas动画
 * @return {[type]} [description]
 */
function compileActivity(callback, pipeData, contentDataset, $$floatDivertor) {
  var compiler,
      $containsNode = pipeData.$containsNode,
      eventRelated = pipeData.eventRelated,
      //合集事件
  chapterIndex = pipeData.chapterIndex,
      createActivitys = pipeData.createActivitys,
      feedbackBehavior = pipeData.feedbackBehavior,
      //反馈数据,跟事件相关
  pageBaseHooks = pipeData.pageBaseHooks,
      pageId = pipeData.chapterId;

  var floatMasterDivertor = $$floatDivertor.master;

  //如果有浮动对象,才需要计算偏移量
  //母版里面可能存在浮动或者不浮动的对象
  //那么在布局的时候想对点不一样
  //如果在浮动区域就取浮动初始值
  //否则就是默认的想对点0
  var getTransformOffset = function (ids, initTransformOffset) {
    return function (id) {
      //匹配是不是属于浮动对象
      if (ids.length && ids[id]) {
        //初始化容器布局的坐标
        return initTransformOffset;
      }
      return 0;
    };
  }(floatMasterDivertor.ids, pipeData.getStyle.offset);

  //相关回调
  var callbackRelated = {
    /*绑定卷滚条钩子*/
    'iscrollHooks': [],
    /*contetn钩子回调*/
    'contentsHooks': pageBaseHooks.contents,
    /**
     * 收集滑动事件
     * 针对mini
     * 2016.11.8
     */
    'swipeDelegateContents': pageBaseHooks.swipeDelegateContents

    //相关数据
  };var dataRelated = {
    floatMasterDivertor: floatMasterDivertor,
    'activityId': pipeData.chpaterData._id,
    'seasonId': pipeData.chpaterData.seasonId,
    'pageId': pageId,
    'contentDataset': contentDataset, //所有的content数据合集
    'container': pipeData.liRootNode,
    'seasonRelated': pipeData.seasonRelated,
    'containerPrefix': pipeData.containerPrefix,
    'nodes': pipeData.nodes,
    'pageOffset': pipeData.pageOffset,
    'createContentIds': pipeData.createContentIds,
    'partContentRelated': pipeData.partContentRelated,
    'getTransformOffset': getTransformOffset,
    'contentsFragment': pipeData.contentsFragment,
    'contentHtmlBoxIds': pipeData.contentHtmlBoxIds

    /**
     * 继续下一个任务
     * @return {[type]} [description]
     */
  };var nextTask = function nextTask() {
    //多事件合集处理pagebase
    if (eventRelated) {
      pageBaseHooks.eventBinding && pageBaseHooks.eventBinding(eventRelated);
    }
    //删除钩子
    delete callbackRelated.contentsHooks;
    callback(callbackRelated);
  };

  /**
   * 生成activty控制对象
   * @type {[type]}
   */
  var makeActivity = function makeActivity(compiler) {
    return function (callback) {
      var filters = void 0;
      var imageId = compiler.imageIds; //父id
      var activity = compiler.activity;
      var eventType = activity.eventType;
      var dragdropPara = activity.para1;
      var eventContentId = imageId;
      var activityId = activity._id;

      //如果存在关闭按钮
      //秒秒学
      //2017.11.30
      dataRelated.hasForumClose = false;
      if (pipeData.forumCloses && pipeData.forumCloses[activityId]) {
        dataRelated.hasForumClose = true;
      }

      /**
       * 多事件数据过滤
       * 为了防止数据写入错误数据
       * 如果当前对象上有多事件的行为
       * 则默认的事件去掉
       * @type {[type]}
       */
      if (filters = eventRelated['eventContentId->' + imageId]) {
        _.each(filters, function (edata) {
          //id不需要
          //eventContentId = void 0;
          if (edata.eventType == activity.eventType) {
            //写入的是伪数据,此行为让多事件抽象接管
            eventType = dragdropPara = undefined;
          }
        });
      }

      //注册引用
      pageBaseHooks.cacheActivity(new Activity({
        'noticeComplete': callback, //监听完成
        'pageIndex': pipeData.pageIndex,
        'id': imageId || autoUUID(),
        "type": 'Content',
        'pageId': pageId,
        'getStyle': pipeData.getStyle,
        'activityId': activityId,
        '$containsNode': $containsNode,
        'pageType': compiler.pageType, //构建类型 page/master
        'dataset': compiler.dataset, //动画表数据 or 视觉差表数据
        "chapterIndex": chapterIndex, //页码
        /*需要绑定事件的数据*/
        'eventRelated': { eventContentId: eventContentId, eventType: eventType, dragdropPara: dragdropPara, feedbackBehavior: feedbackBehavior },
        'dataRelated': dataRelated, //相关数据,所有子作用域Activity对象共享
        'canvasRelated': pipeData.canvasRelated, //父类引用
        'callbackRelated': callbackRelated //相关回调
      }));
    };
  };

  //制作curry Activity闭包
  var fnsActivity = [];
  while (compiler = createActivitys.shift()) {
    fnsActivity.push(makeActivity(compiler));
  }

  // 递归解析 activitys
  var recursiveParse = function recursiveParse() {
    if (!fnsActivity.length) {
      nextTask();
      return;
    }
    var first = fnsActivity.shift();
    first(function () {
      recursiveParse();
    });
  };
  recursiveParse();
}

/**
 * 关闭按钮
 * @param  {[type]} right [description]
 * @param  {[type]} top   [description]
 * @return {[type]}       [description]
 */
var createCloseIcon = function createCloseIcon(right, top) {
  var html = void 0;
  var screenSize = Xut.config.screenSize;
  var width = screenSize.width;
  var height = screenSize.height;
  if (width > height) {
    html = "<div class=\"page-scale-close\" style=\"position: absolute;right:" + right + "px;top:" + top + "px;\">\n           <div class=\"si-icon Flaticon xut-flaticon-error\" style=\"font-size:5.3vw;border-radius:50%;right:0\">\n           </div>\n        </div>";
  } else {
    html = "<div class=\"page-scale-close\" style=\"position: absolute;right:" + right + "px;top:" + top + "px;\">\n             <div class=\"si-icon Flaticon xut-flaticon-error\" style=\"font-size:5.3vh;border-radius:50%;right:0;\"></div>\n        </div>";
  }
  return $(String.styleFormat(html));
};

/**
 * 创建关闭按钮
 * @return {[type]} [description]
 */
function closeButton(callback) {
  var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var $closeNode = createCloseIcon(right + 4, top + 8);
  $closeNode.on("touchend mouseup", function () {
    callback();
  });
  return $closeNode;
}

var START_X = 0;
var START_Y = 0;

/**
 * 缩放、平移操作
 */
var ScalePan = function () {
  function ScalePan(_ref) {
    var rootNode = _ref.rootNode,
        _ref$hasButton = _ref.hasButton,
        hasButton = _ref$hasButton === undefined ? true : _ref$hasButton,
        updateHook = _ref.updateHook,
        _ref$tapClose = _ref.tapClose,
        tapClose = _ref$tapClose === undefined ? false : _ref$tapClose,
        tapCallabck = _ref.tapCallabck;
    classCallCheck(this, ScalePan);


    this.hasButton = hasButton;
    this.updateHook = updateHook;
    this.tapClose = tapClose;
    this.tapCallabck = tapCallabck;

    this.rootNode = rootNode instanceof $ ? rootNode[0] : rootNode;
    this._offsetWidth = this.rootNode.offsetWidth;
    this._offsetHeight = this.rootNode.offsetHeight;

    //初始化状态
    this._initState();

    //初始化事件
    this._initEvent();
  }

  createClass(ScalePan, [{
    key: '_initState',
    value: function _initState() {

      /**
       * 最大缩放值
       * @type {Number}
       */
      this.maxScale = config.launch.salePictureMultiples || 4;

      /**
       * 允许溢出值
       * @type {Number}
       */
      this.overflowValue = 0.3;

      /**
       * 已经缩放
       * @type {Boolean}
       */
      this.hasZoom = false;

      /**
       * 缩放中
       * @type {Boolean}
       */
      this.scaleing = false;

      /**
       * 最后一个缩放值
       * @type {Number}
       */
      this.lastScale = 1;

      /**
       * 是否更新中
       * @type {Boolean}
       */
      this.ticking = false;

      this.currentX = START_X;
      this.currentY = START_Y;

      /**
       * 需要更新的数据
       * @type {Object}
       */
      this.data = {
        translate: {
          x: START_X,
          y: START_Y
        },
        scale: 1
      };

      this._buttonHide();
    }

    /**
     * 初始化事件
     * @return {[type]} [description]
     */

  }, {
    key: '_initEvent',
    value: function _initEvent() {
      var _this = this;

      this.hammer = new Hammer.Manager(this.rootNode);
      this.hammer.add(new Hammer.Pan({ threshold: 0, pointers: 0, enable: false }));
      this.hammer.add(new Hammer.Pinch({ threshold: 0 })).recognizeWith(this.hammer.get('pan'));

      //配置双击影响
      // if(!this.doubletapBan) {
      //     this.hammer.add(new Hammer.Tap({ event: 'doubletap', taps: 2, posThreshold: 30 }))
      // }

      this.hammer.add(new Hammer.Tap());

      var bindHash = {
        'pinchstart': '_onPinchStart',
        'pinchmove': '_onPinchMove',
        'pinchend': '_onPinchEnd',
        'panstart panmove': '_onPan',
        'panend': '_onPanEnd',
        'pinchcancel': '_onPinchEnd'

        //如果单击关闭存在，就增加
        //否则不能阻止外部的事件关闭
      };if (this.tapClose) {
        bindHash['tap'] = '_onTap';
      }

      _.each(bindHash, function (value, key) {
        _this.hammer.on(key, function (e) {
          e.preventDefault();
          e.srcEvent.stopPropagation();
          _this[value](e);
        });
      });
    }

    /**
     * 如果启动了单击关闭
       并且有缩放
     * @return {[type]} [description]
     */

  }, {
    key: '_onTap',
    value: function _onTap() {
      if (this.tapCallabck) {
        this.tapCallabck();
      } else {
        if (this.tapClose && this.data.scale != 1) {
          this.reset();
        }
      }
    }
  }, {
    key: '_onDoubletap',
    value: function _onDoubletap() {
      this.reset();
    }
  }, {
    key: '_onPinchStart',
    value: function _onPinchStart(ev) {
      this.lastScale = this.data.scale || 1;
    }

    /**
     * 缩放移动
     * @param  {[type]} ev [description]
     * @return {[type]}    [description]
     */

  }, {
    key: '_onPinchMove',
    value: function _onPinchMove(ev) {

      //允许溢出值
      if (!this.scaleing) {
        if (ev.scale < this.overflowValue + 1) {
          return;
        }
        this.scaleing = true;
      }

      var scale = ev.scale - this.overflowValue;
      scale = this.lastScale * scale;

      //限定缩放的倍数
      if (scale > this.maxScale) {
        return;
      }

      //新的缩放值
      this.data.scale = scale;

      this._buttonShow();
      this._isBoundry();
      this._updateNodeStyle();
    }

    /**
     * 缩放松手
     * @return {[type]} [description]
     */

  }, {
    key: '_onPinchEnd',
    value: function _onPinchEnd(ev) {
      var _this2 = this;

      if (this.data.scale <= 1) {
        Xut.nextTick(function () {
          _this2._initState();
          _this2._updateNodeStyle(500);
        });
      } else {
        this.overflowValue = 0;
      }
    }

    /**
     * 平移
     * @param  {[type]} ev [description]
     * @return {[type]}    [description]
     */

  }, {
    key: '_onPan',
    value: function _onPan(ev) {
      if (this._isRunning) {
        if (this.currentX != START_X || this.currentY != START_Y) {
          this.data.translate = {
            x: this.currentX + ev.deltaX,
            y: this.currentY + ev.deltaY
          };
        } else {
          this.data.translate = {
            x: START_X + ev.deltaX,
            y: START_Y + ev.deltaY
          };
        }
        this._isBoundry();
        this._updateNodeStyle();
      }
    }

    /**
     * 平移松手
     * @return {[type]} [description]
     */

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd() {
      this.currentX = this.data.translate.x;
      this.currentY = this.data.translate.y;
    }

    /**
     * 边界反弹
     * @return {Boolean} [description]
     */

  }, {
    key: '_isBoundry',
    value: function _isBoundry() {
      if (this._isRunning) {
        var horizontalBoundry = (this.data.scale - 1) / 2 * this._offsetWidth;
        var verticalBoundry = (this.data.scale - 1) / 2 * this._offsetHeight;

        //左边界
        if (this.data.translate.x >= horizontalBoundry) {
          this.data.translate.x = horizontalBoundry;
        }
        //右边界
        if (this.data.translate.x <= -horizontalBoundry) {
          this.data.translate.x = -horizontalBoundry;
        }
        //上边界
        if (this.data.translate.y >= verticalBoundry) {
          this.data.translate.y = verticalBoundry;
        }
        //下边界
        if (this.data.translate.y <= -verticalBoundry) {
          this.data.translate.y = -verticalBoundry;
        }
      } else {
        this.data.scale = 1;
        this.data.translate.x = START_X;
        this.data.translate.y = START_Y;
      }
    }

    /**
     * 更新节点样式
     * @return {[type]} [description]
     */

  }, {
    key: '_updateNodeStyle',
    value: function _updateNodeStyle() {
      var _this3 = this;

      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (!this.ticking) {
        Xut.nextTick(function () {
          var data = _this3.data;
          var transform = {
            translate: {
              x: data.translate.x,
              y: data.translate.y
            },
            scale: {
              x: data.scale,
              y: data.scale
            }
          };

          Xut.style.setTransform({
            speed: speed,
            translate: transform.translate,
            scale: transform.scale,
            node: _this3.rootNode
          });
          _this3.updateHook && _this3.updateHook(transform, speed);
          _this3.ticking = false;
        });
        this.ticking = true;
      }
    }

    /**
     * 还原
     * @return {[type]} [description]
     */

  }, {
    key: 'reset',
    value: function reset() {
      this._initState();
      this._updateNodeStyle(500);
    }

    /**
     * 创建按钮
     * @return {[type]} [description]
     */

  }, {
    key: '_createPinchButton',
    value: function _createPinchButton() {
      var _this4 = this;

      var visualSize = config.visualSize;
      var left = visualSize.overflowWidth && Math.abs(visualSize.left) || 0;
      var top = visualSize.overflowHeight && Math.abs(visualSize.top) || 0;
      var $node = closeButton(function () {
        _this4.reset();
      }, left, top);
      $(this.rootNode).after($node);
      return $node;
    }

    /**
     * 按钮显示
     * @return {[type]} [description]
     */

  }, {
    key: '_buttonShow',
    value: function _buttonShow() {
      var _this5 = this;

      //to heavy
      if (this._isRunning) return;
      if (this.data.scale > 1) {
        //必须启动配置
        if (this.hasButton) {
          if (this.$buttonNode) {
            Xut.nextTick(function () {
              _this5.$buttonNode.show();
            });
          } else {
            this.$buttonNode = this._createPinchButton();
          }
        }
        Xut.View.SetSwiperDisable(); //禁止全局滑动
        this._isRunning = true;
        this.hammer.get('pan').set({ enable: true });
      }
    }

    /**
     * 按钮隐藏
     * @return {[type]} [description]
     */

  }, {
    key: '_buttonHide',
    value: function _buttonHide() {
      if (!this._isRunning) return;
      this.hasButton && this.$buttonNode.hide();
      this._isRunning = false;
      Xut.View.SetSwiperEnable(); //全局滑动
      this.hammer.get('pan').set({ enable: false });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.$buttonNode) {
        this.$buttonNode.off();
        this.$buttonNode = null;
      }
      if (this.hammer) {
        this.hammer.destroy();
        this.hammer = null;
      }
      if (this.$buttonNode) {
        this.$buttonNode.off();
      }
      this.update = null;
      this.rootNode = null;
    }
  }]);
  return ScalePan;
}();

/**
 * 场景控制器
 * 场景对象之间的顺序处理
 * @return {[type]} [description]
 */

//场景层级控制
var zIndex = 999999;

//场景合集
//主场景
//副场景
var sceneCollection = {
  //场景顺序
  scenarioStack: [],
  //场景链表
  scenarioChain: []
};

var sceneController = {

  /**
   * 场景层级控制
   * @return {[type]} [description]
   */
  createIndex: function createIndex() {
    return --zIndex;
  },


  /**
   * 设置一个新场景
   * @param {[type]} seasonId [description]
   * @param {[type]} relevant   [description]
   * @param {[type]} sceneObj   [description]
   */
  add: function add(seasonId, chapterId, sceneObj) {
    if (seasonId) {
      seasonId = Number(seasonId);
    }
    if (chapterId) {
      chapterId = Number(chapterId);
    }
    sceneCollection.scenarioStack.push(seasonId);
    sceneCollection['seasonId->' + seasonId] = sceneObj;
    //场景链表,拥挤记录场景的加载上一页
    sceneCollection.scenarioChain.push({ seasonId: seasonId, chapterId: chapterId });
    return sceneObj;
  },


  /**
   * 取出上一个场景链
   * @return {[type]} [description]
   */
  takeOutPrevChainId: function takeOutPrevChainId() {
    var pre = sceneCollection.scenarioChain.pop();
    if (sceneCollection.scenarioChain.length > 1) {
      return sceneCollection.scenarioChain.pop();
    } else {
      return sceneCollection.scenarioChain[0];
    }
  },


  /**
   * 检测重复
   * @param  {[type]} seasonId [description]
   * @return {[type]}          [description]
   */
  checkToRepeat: function checkToRepeat(seasonId) {
    var last,
        len = sceneCollection.scenarioChain.length;
    if (len > 1) {
      last = sceneCollection.scenarioChain[len - 2];
    } else {
      last = sceneCollection.scenarioChain[len - 1];
    }

    //往回跳一级
    if (last['seasonId'] == seasonId) {
      this.takeOutPrevChainId();
    }

    //直接会跳到主场景
    if (sceneCollection.scenarioStack[0] == seasonId) {
      var scenarioChain = sceneCollection.scenarioChain.shift();
      sceneCollection.scenarioChain.length = 0;
      sceneCollection.scenarioChain.push(scenarioChain);
    }
  },


  /**
   * 返回活动对象
   * @return {[type]} [description]
   */
  containerObj: function containerObj(seasonId) {
    if (seasonId === 'current') {
      var scenarioStack = sceneCollection.scenarioStack;
      seasonId = scenarioStack[scenarioStack.length - 1];
    }
    return sceneCollection['seasonId->' + seasonId];
  },


  /**
   * 找到索引位置的Id
   * @param  {[type]} seasonId [description]
   * @return {[type]}            [description]
   */
  findIndexOfId: function findIndexOfId(seasonId) {
    return sceneCollection.scenarioStack.lastIndexOf(seasonId);
  },


  /**
   * 删除指定场景引用
   * @param  {[type]} seasonId [description]
   * @return {[type]}            [description]
   */
  remove: function remove(seasonId) {
    var indexOf = this.findIndexOfId(seasonId);

    //删除索引
    sceneCollection.scenarioStack.splice(indexOf, 1);

    //删除场景对象区域
    delete sceneCollection['seasonId->' + seasonId];
  },


  /**
   * 销毁所有场景
   * @return {[type]} [description]
   */
  destroyAllScene: function destroyAllScene() {
    var cache = _.clone(sceneCollection.scenarioStack);
    _.each(cache, function (seasonId) {
      sceneCollection['seasonId->' + seasonId].destroy();
    });
    sceneCollection.scenarioChain = [];
  },


  /**
   * 重写场景的顺序编号
   * 用于记录最后一次跳转的问题
   * @return {[type]} [description]
   */
  rewrite: function rewrite(seasonId, chapterId) {
    _.each(sceneCollection.scenarioChain, function (scenarioChain) {
      if (scenarioChain.seasonId == seasonId) {
        scenarioChain.chapterId = chapterId;
      }
    });
  },


  /**
   * 暴露接口
   * @return {[type]} [description]
   */
  expose: function expose() {
    return sceneCollection;
  },


  /**
   * 解析序列
   * @param  {[type]} seasonId    [description]
   * @param  {[type]} currPageIndex [description]
   * @return {[type]}               [description]
   */
  sequence: function sequence(seasonId, currPageIndex) {
    var chains = sceneCollection.scenarioChain;
    //有多个场景关系,需要记录
    if (chains.length > 1) {
      var history = [];
      //只刷新当前场景的页面
      _.each(chains, function (chain) {
        if (chain.seasonId == seasonId) {
          history.push(chain.seasonId + '-' + chain.chapterId + '-' + currPageIndex);
        } else {
          history.push(chain.seasonId + '-' + chain.chapterId);
        }
      });
      return history;
    }
  },


  /**
   * 反解析
   * @param  {[type]} chains [description]
   * @return {[type]}        [description]
   */
  seqReverse: function seqReverse(chains) {
    var chains = chains.split(",");
    var chainsNum = chains.length;

    if (chainsNum === 1) {
      return false;
    }

    //如果只有2层
    if (chainsNum === 2) {
      return chains[1];
    }

    //拼接作用域链
    //排除首页(已存在)
    //尾页(新创建)
    _.each(chains, function (chain, index) {
      if (index >= 1 && index < chainsNum - 1) {
        //从1开始吸入,排除最后一个
        var chain = chain.split('-');
        sceneCollection.scenarioChain.push({
          'seasonId': chain[0],
          'chapterId': chain[1],
          'pageIndex': chain[2]
        });
      }
    });
    return chains[chainsNum - 1];
  }
};

/**
 * given the wrapper's width and height,
 * calculates the final width, height, left and top for the image to fit inside
 * @param  {[type]} imageSize   [description]
 * @param  {[type]} wrapperSize [description]
 * @return {[type]}             [description]
 */
function getFinalSizePosition(imageSize, wrapperSize) {

  // image size
  var imgW = imageSize.width,
      imgH = imageSize.height,

  // container size
  wrapperW = wrapperSize.width,
      wrapperH = wrapperSize.height,
      finalW,
      finalH,
      finalL,
      finalT,

  // flag to indicate we could check for another source (smaller) for the image
  checksource = false,
      ratio;

  //宽度100% 自适应高度
  var widthFullAdaptiveHeight = function widthFullAdaptiveHeight() {
    finalW = wrapperW;
    // calculate the height given the finalW
    ratio = imgW / wrapperW;
    finalH = imgH / ratio;
    if (finalH > wrapperH) {
      checksource = true;
      ratio = finalH / wrapperH;
      finalW /= ratio;
      finalH = wrapperH;
    }
  };

  //高度100% 自适应宽度
  var heightFullAdaptiveWidth = function heightFullAdaptiveWidth() {
    finalH = wrapperH;
    // calculate the width given the finalH
    ratio = imgH / wrapperH;
    finalW = imgW / ratio;
    checksource = true;
    if (finalW > wrapperW) {
      checksource = false;
      ratio = finalW / wrapperW;
      finalW = wrapperW;
      finalH /= ratio;
    }
  };

  // check which image side is bigger
  //横屏图片
  if (imgW > imgH) {
    widthFullAdaptiveHeight();
  } else {
    //竖屏图片
    //竖版显示
    if (wrapperH > wrapperW) {
      widthFullAdaptiveHeight();
    }
    //横版显示
    else {
        heightFullAdaptiveWidth();
      }
  }

  return {
    width: finalW,
    height: finalH,
    left: (wrapperW - finalW) / 2 - wrapperSize.left,
    top: (wrapperH - finalH) / 2,
    checksource: checksource
  };
}

/**
 * 随机生成0-30之间的不重复的数字作为li的id
 * @return {[type]} [description]
 */


/**
 * the single view will include the image
 * navigation buttons and close, play, and pause buttons
 * @return {[type]} [description]
 */
function createContainerView(imgContainer) {
  var html = void 0;
  var visualSize = config.visualSize;
  var right = visualSize.overflowWidth && Math.abs(visualSize.right) || 0;
  var top = visualSize.overflowHeight && Math.abs(visualSize.top) || 0;
  var rightCopy = right + 4;
  var rightCopy2 = right + 3.5;
  var topCopy = top + 4;

  var zoomImg = '<img class="xut-zoom-fly"\n                      src="' + imgContainer.originSrc + '"\n                      style="width:' + imgContainer.width + 'px;\n                             height:' + imgContainer.height + 'px;\n                             top:' + imgContainer.top + 'px;\n                             left:' + imgContainer.left + 'px;" />';

  if (config.screenHorizontal) {
    html = '<div class="xut-zoom-view">\n                <div class="xut-zoom-overlay"></div>\n                <div class="xut-zoom-close" style="right:' + rightCopy + 'px;top:' + topCopy + 'px;">\n                    <div class="si-icon Flaticon xut-flaticon-error" style="font-size:5vw;border-radius:50%;right:0">\n                    </div>\n                </div>\n                ' + zoomImg + '\n            </div>';
  } else {
    //竖屏
    html = '<div class="xut-zoom-view">\n                <div class="xut-zoom-overlay"></div>\n                <div class="xut-zoom-close" style=";right:' + rightCopy + 'px;top:' + topCopy + 'px;">\n                    <div class="si-icon Flaticon xut-flaticon-error" style="font-size:5vh;border-radius:50%;right:0">\n                    </div>\n                </div>\n                ' + zoomImg + '\n            </div>';
  }

  return String.styleFormat(html);
}

/**
 * choose a source based on the item's size and on the configuration
 * set by the user in the initial HTML
 */
function chooseImgSource(sources, w) {
  if (w <= 0) w = 1;
  for (var i = 0, len = sources.length; i < len; ++i) {
    var source = sources[i];
    if (w > source.width) return source;
  }
}

/**
 * 执行动画
 */
function execAnimation(_ref) {
  var element = _ref.element,
      style = _ref.style,
      _ref$speed = _ref.speed,
      speed = _ref$speed === undefined ? 100 : _ref$speed;
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  if (!element) return;
  setTimeout(function () {
    element.stop().transition(style, speed, 'linear', callback);
  }, 0);
}

function getImgConfig(properties) {
  var imgMaxW = 0;
  var imgMaxH = 0;
  var sources = properties.sources;
  var source = chooseImgSource(sources, properties.wrapper.width);

  // calculate final size and position of image
  var finalSizePosition = getFinalSizePosition(properties.image, properties.wrapper);

  // we still need to check one more detail:
  // if the source is the largest one provided in the html rules,
  // then we need to check if the final width/height are eventually bigger
  // than the original image sizes. If so, we will show the image
  // with its original size, avoiding like this that the image gets pixelated
  if (source.pos === 0 && (imgMaxW !== 0 && finalSizePosition.width > imgMaxW || imgMaxH !== 0 && finalSizePosition.height > imgMaxH)) {
    if (imgMaxW !== 0 && finalSizePosition.width > imgMaxW) {
      var ratio = finalSizePosition.width / imgMaxW;
      finalSizePosition.width = imgMaxW;
      finalSizePosition.height /= ratio;
    } else if (imgMaxH !== 0 && finalSizePosition.height > imgMaxH) {
      var ratio = finalSizePosition.height / imgMaxH;
      finalSizePosition.height = imgMaxH;
      finalSizePosition.width /= ratio;
    }
    finalSizePosition.left = properties.wrapper.width / 2 - finalSizePosition.width / 2;
    finalSizePosition.top = properties.wrapper.height / 2 - finalSizePosition.height / 2;
  }
  return {
    source: source,
    position: finalSizePosition
  };
}

/**
 * gets the position and sizes of the image given its container properties
 */

/**
 * 图片缩放功能
 * 2016.12.5
 */
var ScalePicture = function () {
  function ScalePicture(_ref) {
    var element = _ref.element,
        originalSrc = _ref.originalSrc,
        hdSrc = _ref.hdSrc,
        _ref$hasButton = _ref.hasButton,
        hasButton = _ref$hasButton === undefined ? false : _ref$hasButton;
    classCallCheck(this, ScalePicture);


    var current = sceneController.containerObj('current');
    if (current) {
      this.$container = current.getSceneNode();
    }
    if (!this.$container.length) {
      $warn({
        type: 'scale',
        content: '图片缩放依赖的容器不存在'
      });
      return;
    }

    //因为取的是xut-main-scene的坐标参考
    //所以坐标的算法是有区别了
    var containerLeft = 0;
    var containerTop = 0;
    var visualSize = config.visualSize;
    if (visualSize.left) {
      containerLeft = visualSize.left;
      containerTop = visualSize.top;
    }

    this.$imgNode = element;
    this.originSrc = originalSrc;
    this.hdSrc = hdSrc;
    this.hasButton = hasButton;

    //获取图片的可视区的绝对布局尺寸
    this.originImgWidth = element.width();
    this.originImgHeight = element.height();

    var offset = element.offset();
    this.originImgLeft = offset.left - containerLeft;
    this.originImgTop = offset.top - containerTop - config.launch.visualTop;

    //关闭动画中执行中
    this.isCloseAniming = false;

    this.source = [{
      pos: 0,
      src: hdSrc ? hdSrc : originalSrc,
      width: 200
    }];

    this._init();
  }

  /**
   * 初始化
   * @return {[type]} [description]
   */


  createClass(ScalePicture, [{
    key: '_init',
    value: function _init() {
      this._initSingleView();
      this._bindTapClose();
      if (!this.targetSize) {
        this.targetSize = this._getData();
      }
      this._startZoom();
    }
  }, {
    key: '_initSingleView',
    value: function _initSingleView() {
      var _this = this;

      this.$singleView = $(createContainerView({
        width: this.originImgWidth,
        height: this.originImgHeight,
        left: this.originImgLeft,
        top: this.originImgTop,
        originSrc: this.originSrc
      }));
      this.$overlay = this.$singleView.find('.xut-zoom-overlay');
      this.$flyNode = this.$singleView.find('.xut-zoom-fly');

      //关闭按钮
      if (this.hasButton) {
        this.$closeButton = this.$singleView.find('.xut-zoom-close');
        this.callbackEnd = function () {
          _this._closeSingleView();
        };
        $on(this.$closeButton, {
          end: this.callbackEnd,
          cancel: this.callbackEnd
        });
        this.$closeButton.show();
      }

      this.$singleView.appendTo(this.$container);
    }

    /**
     * 初始化缩放数据
     * @return {[type]} [description]
     */

  }, {
    key: '_getData',
    value: function _getData() {

      var view = config.screenSize;
      var overflowLeft = 0;

      //如果有宽度溢出
      //就是说用了窗口指定模式
      if (config.visualSize.left) {
        view = config.visualSize;
      }

      //虚拟模拟3下，宽度可能溢出，所以需要取屏幕宽度
      if (config.launch.visualMode === 3) {
        view = config.screenSize;
        overflowLeft = config.visualSize.left;
      }

      return getImgConfig({
        sources: this.source,
        wrapper: {
          width: view.width,
          height: view.height,
          left: overflowLeft //模式3下溢出的left
        },
        image: {
          width: this.originImgWidth,
          height: this.originImgHeight
        }
      });
    }

    /**
     * 执行缩放
     * @return {[type]} [description]
     */

  }, {
    key: '_startZoom',
    value: function _startZoom() {
      var _this2 = this;

      var source = this.targetSize.source;
      var position = this.targetSize.position;

      // 克隆的原图放大动画
      execAnimation({
        element: this.$flyNode,
        style: {
          width: position.width,
          height: position.height,
          left: position.left,
          top: position.top
        },
        speed: 300
      }, function () {
        _this2._replaceHQIMG(position, source.src);
      });

      //白背景
      execAnimation({
        element: this.$overlay,
        style: { opacity: 1 },
        speed: 300
      });
    }

    /**
     * 创建高清图
     * 这里存在网络是2G下载非常慢的情况
     * 会导致高清图的加载会引起卡死的现象
     * 所以针对这样的情况做了处理
     */

  }, {
    key: '_createHQIMG',
    value: function _createHQIMG(position, src, success, fail) {

      //如果高清图已经存在
      if (this.$hQNode) {
        this.$hQNode.show();
        success();
        return;
      }

      //如果创建
      //创建的时候图片太大，网络太慢需要优化
      var img = new Image();

      //保证失败回调只处理一次
      var hasFail = false;
      var self = this;

      //图片失败处理
      function isFail() {
        if (hasFail) {
          return;
        }
        hasFail = true;
        img = null;
        fail();
      }

      img.onload = function () {
        //关闭动画正在执行中
        //这里要强制退出
        if (self.isCloseAniming) {
          isFail();
          return;
        }
        self.$hQNode = $(img);
        self.$hQNode.css({
          width: position.width,
          height: position.height,
          left: position.left,
          top: position.top
        }).addClass('xut-zoom-hd').appendTo(self.$singleView);
        img = null;
        success(500);
      };
      img.onerror = function () {
        isFail();
      };
      img.src = src;
    }

    /*绑定滑动*/

  }, {
    key: '_bindPan',
    value: function _bindPan($imgNode) {
      var _this3 = this;

      if (!this.slideObj && Xut.plat.hasTouch && config.launch.salePicture) {
        var tapCallabck = function tapCallabck() {
          return _this3._closeSingleView();
        };
        this.slideObj = new ScalePan({
          hasButton: false,
          rootNode: $imgNode,
          tapClose: true,
          tapCallabck: tapCallabck
        });
      }
    }

    /**
     * 是否启动图片缩放
     */

  }, {
    key: '_addPinchPan',
    value: function _addPinchPan() {
      //高清图
      if (this.$hQNode) {
        //如果高清图存在
        //因为高清可能是加载有延时
        //所以可能存在fly图先加载过的情况，这里需要直接清理
        if (this._hasBindFlyPan) {
          this._hasBindFlyPan = false;
          this._destroyRelated();
        }
        this._bindPan(this.$hQNode);
      }
      //普通图
      else if (this.$flyNode) {
          this._hasBindFlyPan = true;
          this._bindPan(this.$flyNode);
        }
    }
  }, {
    key: '_stopDefault',
    value: function _stopDefault(e) {
      e.stopPropagation && e.stopPropagation();
      e.preventDefault && e.preventDefault();
    }

    /**
     * 绑定单击关闭
     * @return {[type]} [description]
     */

  }, {
    key: '_bindTapClose',
    value: function _bindTapClose($imgNode) {
      var _this4 = this;

      var isMove = false;
      var start = function start(e) {
        _this4._stopDefault(e);
        isMove = false;
      };
      var move = function move(e) {
        _this4._stopDefault(e);
        isMove = true;
      };
      var end = function end(e) {
        _this4._stopDefault(e);
        if (!isMove) {
          if (_this4.slideObj) {
            //如果有zoom对象后，关闭由zoom接管
            //因为缩放的情况下，如果没有移动页面，会默认关闭
            //这个逻辑是不对的，只能让zoom自己检测
          } else {
            _this4._closeSingleView();
          }
        }
      };

      /********************************
       * 设置全局容器捕获处理
       ********************************/
      $on(this.$singleView, {
        start: start,
        move: move,
        end: end,
        cancel: end
      });
    }

    /**
     * 替换成高清图
     */

  }, {
    key: '_replaceHQIMG',
    value: function _replaceHQIMG(position, src) {
      var _this5 = this;

      //高清图
      if (this.hdSrc) {
        this._createHQIMG(position, src, function () {
          var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;

          //第一次高清图切换
          execAnimation({
            element: _this5.$flyNode,
            style: { 'opacity': 0 },
            speed: speed
          }, function () {
            //删除飞入图片
            //用高清图替代了
            _this5.$flyNode.hide();
            _this5._addPinchPan();
          });
        }, function () {
          _this5._addPinchPan();
        });
      }
      //普通图
      else {
          this._addPinchPan();
        }
    }

    /**
     * 复位
     * 便于第二次play
     * @return {[type]} [description]
     */

  }, {
    key: '_reset',
    value: function _reset() {
      this.$flyNode.css({
        width: this.originImgWidth,
        height: this.originImgHeight,
        left: this.originImgLeft,
        top: this.originImgTop,
        opacity: 1,
        display: 'block'
      });

      if (this.$hQNode) {
        var position = this.targetSize.position;
        this.$hQNode.css({
          width: position.width,
          height: position.height,
          left: position.left,
          top: position.top,
          display: 'none'
        });
      }

      if (this.hasButton) {
        this.$closeButton.show();
      }

      this.$overlay.css('opacity', 0);

      if (this.slideObj) {
        this.slideObj.reset();
      }
    }

    /**
     * 关闭放大高清图
     * @return {[type]} [description]
     */

  }, {
    key: '_closeSingleView',
    value: function _closeSingleView() {
      var _this6 = this;

      if (this.isCloseAniming) {
        return;
      }
      this.isCloseAniming = true;
      var $imgNode = this.$hQNode ? this.$hQNode : this.$flyNode;

      if (this.hasButton) {
        this.$closeButton.hide();
      }

      execAnimation({
        element: $imgNode,
        style: {
          width: this.originImgWidth,
          height: this.originImgHeight,
          left: this.originImgLeft,
          top: this.originImgTop
        },
        speed: 300
      }, function () {
        _this6.$singleView.hide();
        _this6._reset();
        _this6.isCloseAniming = false;
      });

      //消失背景
      execAnimation({
        element: this.$overlay,
        style: { opacity: 0 },
        speed: 200
      });
    }

    /**
     * 对外接口
     * 播放
     * @return {[type]} [description]
     */

  }, {
    key: 'play',
    value: function play() {
      this.$singleView.show();
      this._startZoom();
    }

    /**
     * 销毁相关的一些数据
     */

  }, {
    key: '_destroyRelated',
    value: function _destroyRelated() {
      if (this.slideObj) {
        this.slideObj.destroy();
        this.slideObj = null;
      }
    }

    /**
     * 对外接口
     * 销毁
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {

      this._destroyRelated();

      $off(this.$singleView);

      //关闭按钮
      if (this.hasButton) {
        $off(this.$closeButton);
        this.$closeButton = null;
      }

      this.$hQNode = null;
      this.$overlay = null;
      this.$container = null;
      this.$flyNode = null;
      this.$imgNode = null;

      this.$singleView.remove();
      this.$singleView = null;
    }
  }]);
  return ScalePicture;
}();

///////////////////////////
///    缩放提示图片
//////////////////////////
/*图片*/
function createHTML$1() {
  var size = config.screenSize.width > config.screenSize.height ? '2vw' : '2vh';
  return '<div class="xut-icon-maximize"style="font-size:' + size + ';position:absolute;right:0;"></div>';
}

function zoomPicture(pipeData) {
  var zoomObjs = {};
  var behaviorData = void 0;
  _.each(pipeData.contentsFragment, function (node) {
    var behaviorData = void 0;
    if (behaviorData = pipeData.zoomBehavior[node.id]) {
      /*缩放提示图片*/
      behaviorData.prompt && $(node).append(createHTML$1());

      var hasMove = false;
      $on(node, {
        start: function start() {
          hasMove = false;
        },
        move: function move() {
          hasMove = true;
        },
        end: function end() {
          if (hasMove) return;
          var $node = $(node);
          var $imgNode = $node.find('img');
          if (!$imgNode.length) {
            return;
          }

          /*存在*/
          var src = $imgNode[0].src;
          if (zoomObjs[src]) {
            return zoomObjs[src].play();
          }

          /*创建*/
          var analysisName = converUrlName(src);
          zoomObjs[src] = new ScalePicture({
            element: $imgNode,
            originalSrc: getFileFullPath(analysisName.suffix, 'pagebase-zoom'),
            hdSrc: getFileFullPath(analysisName.hdName, 'getHDFilePath')
          });
        }
      });

      /*销毁*/
      behaviorData.off = function () {
        $off(node);
        node = null;
      };
    }
  });

  return zoomObjs;
}

/********************************************************
 **
 ** 数据过滤,去重算法
 **  content数据解析息息相关的方法
 **
 *********************************************************/

//零件类型,快速判断
//新增content卷滚区域,所有JS零件content
//类型选择,content有扩充的子类型
//针对零件类型在category字段中的子分类
var widgetType = {};
_.each("jsWidget content svgWidget canvasWidget path".split(" "), function (key, name) {
  widgetType[key] = true;
});

/**
 * 类型统一
 * 满足条件统一为零件类型
 */
function unifyType(activity) {
  return widgetType[activity.category] ? "JsWidget" : activity.actType;
}

/**
 * 配合出item中相关信息
 * 1.场景信息
 * 2.收费信息
 * @param  {[type]} tokens [description]
 * @return {[type]}        [description]
 */
var itemTokens = ['seasonId', 'Inapp', 'SearchBar', 'BookMarks'];

function relatedTokens(relateds, activitys, tokens) {
  var tokenNumber = Object.keys(tokens);

  //快速过滤，如果仅仅只是Animation
  if (tokenNumber.length === 1 && ~tokenNumber.indexOf('Animation')) {
    return;
  }

  var eventId = activitys.imageId;

  /*创建事件容器*/
  var createEventContainer = function createEventContainer() {
    if (!relateds.seasonRelated[eventId]) {
      relateds.seasonRelated[eventId] = {};
    }
  };

  itemTokens.forEach(function (type) {
    var values = tokens[type];
    var chapterId = void 0;
    if (values !== undefined) {
      createEventContainer(); //创建容器
      switch (type) {
        case 'seasonId':
          //跳转新场景信息
          chapterId = tokens['chapterId'] || tokens['chapter'];
          relateds.seasonRelated[eventId] = {
            seasonId: values[0],
            chapterId: chapterId ? chapterId[0] : ''
          };
          break;
        case 'Inapp':
          //收费信息,给事件上绑定收费接口,0 收费 1 已收费
          relateds.seasonRelated[eventId]['Inapp'] = values[0];
          break;
        default:
          //搜索栏,书签
          relateds.seasonRelated[eventId][type] = eventId;
          break;
      }
    }
  });
}

/**
 * 分组
 * @return {[type]} [description]
 */
function tokenGroup(tableName, contentIds) {
  var k = void 0,
      keyName = void 0,
      data = void 0,
      contentId = void 0,
      temp = {},
      dataset = [],
      //数据合集
  idset = []; //id合集

  var query = Xut.data.query;

  _.each(contentIds, function (id) {
    if (data = query(tableName, id)) {
      contentId = data.contentId;
      if (-1 === idset.indexOf(contentId)) {
        idset.push(contentId);
      }
      //合并同个contentId多条动画数据的情况
      keyName = "contentId-" + contentId;
      if (temp[keyName]) {
        temp[keyName].push(data);
      } else {
        temp[keyName] = [data];
      }
    }
  });

  //转成数组格式
  for (k in temp) {
    dataset.push(temp[k]);
  }

  return { dataset: dataset, idset: idset };
}

/**
 * 解析基本数据
 * Animation
 * Parallax
 */
function parseBaseTokens(tableName, tokenIds) {
  var tokenId = void 0;
  var result = {};
  _.each(tableName, function (name) {
    if (tokenId = tokenIds[name]) {
      if (result[name]) {
        $warn({
          type: 'pagebase',
          content: '未处理解析同一个表'
        });
      } else {
        result[name] = tokenGroup(name, tokenId);
      }
    }
  });
  return result;
}

/**
 * 解析itemArray序列,得到对应的id
   需要分解的contentIds合集
     1 动画表数据    Animation
     2 视觉差数据    Parallax
     3 超链接        seasonId
     4 收费          Inapp
     return token = {
        Animation:[1,2,3......]
        Parallax:[4,5,6.....]
        seasonId:[1,2...]
     }
 */
function parseItems(itemArray) {
  if (!itemArray) return;
  var actType = void 0;
  var tokens = {};
  itemArray = parseJSON(itemArray);
  if (itemArray.length) {
    _.each(itemArray, function (item) {
      actType = item.actType;
      if (!tokens[actType]) {
        tokens[actType] = [];
      }
      tokens[actType].push(item.id);
    });
  } else {
    actType = itemArray.actType;
    //actType: "Animation", id: 14
    //actType: "Inapp", value: 0
    tokens[actType] = [itemArray.id || itemArray.value];
  }
  return tokens;
}

/**
 * 分组Content表中对应的多个
 *  1：Animation表
 *  2: Parallax表
 *  3: seed种子合集 就是解析1：Animation表，Parallax表得到的数据
 */
function coreParser(callback, activity, pageType, chapterIndex) {
  var contentIdset,
      parallaxContentIdset,
      seedParallaxs,
      parallaxDataset,
      seedAnimations,
      contentDataset = '',
      eventId = activity.imageId,
      tokens = parseItems(activity['itemArray']) || [],

  /*
    解析Animations,Parallaxs数据
    seed {
        Animation:[dataset,Idset]
        Parallax:[dataset,Idset]
    }
   */
  seed = callback(tokens),


  //判断类型
  type = Object.keys(seed)[0];

  /**
   * 去重事件ID
   * original  原ID合集
   * detection 需要检测去重的ID
   *
   */
  function toRepeatContents(original) {
    if (original && eventId) {
      var indexOf = original.indexOf(eventId);
      if (-1 !== indexOf) {
        original.splice(indexOf, 1);
      }
    }
  }

  switch (type) {
    case 'Container':
      //容器
      contentIdset = seed.Container;
      toRepeatContents(contentIdset);
      break;
    case 'Contents':
      //多事件处理
      return seed.Contents;
    default:

      ////////////////////////////////////////
      ///       如果是对象处理，              //
      ///       针对动画表，视觉差表,行为的处理 //
      ////////////////////////////////////////

      /*需要创建的content合集*/
      if (_.keys(seed).length) {

        var _seedAnimations = seed.Animation;
        var _seedParallaxs = seed.Parallax;

        //页面模式
        if (pageType === 'page') {
          if (_seedAnimations) {
            contentIdset = _seedAnimations.idset;
            contentDataset = _seedAnimations.dataset;
          }
        } else {
          //视觉差存在视觉差表处理
          // console.log(1111,seedAnimations, seedParallaxs)
          //母版的动画数据
          if (_seedAnimations) {
            contentIdset = _seedAnimations.idset;
            contentDataset = _seedAnimations.dataset;
          }
          //母版的视察数据
          if (_seedParallaxs) {
            parallaxContentIdset = _seedParallaxs.idset;
            parallaxDataset = _seedParallaxs.dataset;
          }
        }

        //如果id都存在
        //合并
        if (contentIdset && parallaxContentIdset) {
          contentIdset = contentIdset.concat(parallaxContentIdset);
        }

        //只存在视察
        if (!contentIdset && parallaxContentIdset) {
          contentIdset = parallaxContentIdset;
        }
        toRepeatContents(contentIdset);
      }
      break;
  }

  //创建对象是层次关系
  return {
    'pageType': pageType,
    'activity': activity,
    'imageIds': eventId,
    //data
    'dataset': {
      'animation': contentDataset,
      'parallax': parallaxDataset
    },
    //id
    'idset': {
      'content': contentIdset,
      'parallax': parallaxContentIdset
    }
  };
}

/**
 * 合并,过滤需要处理的content
 *  combineImageIds  可以创建的imageId合集，也就是content的合集,用来绑定自定义事件
 *  createContentIds 可以创建的content合集,过滤合并重复
 */
function toRepeatCombineGroup(compilerActivitys, mixFilterRelated, pageType) {
  var idset,
      contentIds,
      needCreateContentIds,
      imageIds,
      activityRelated,
      parallaxId,
      combineItemIds = [],
      combineImageIds = [],
      i = compilerActivitys.length;

  function pushCache(target, original, callback) {
    var id,
        i = original.length;
    while (i--) {
      id = Number(original[i]);
      target.push(id);
      callback && callback(id);
    }
  }

  while (i--) {
    //开始执行过滤操作
    activityRelated = compilerActivitys[i];
    idset = activityRelated.idset;
    contentIds = idset.content;
    parallaxId = idset.parallax; //浮动类型的对象
    imageIds = activityRelated.imageIds;

    //针对普通content对象
    if (contentIds && contentIds.length) {
      //如果不为空
      pushCache(combineItemIds, contentIds);
    }

    //视察对象
    if (parallaxId && parallaxId.length) {
      //如果不为空
      pushCache(combineItemIds, parallaxId);
    }

    //事件合集
    if (imageIds) {
      combineImageIds.push(Number(imageIds));
    }
  }

  //混入外部合并了逻辑
  if (mixFilterRelated && mixFilterRelated.length) {
    _.each(mixFilterRelated, function (data) {
      if (data) {
        combineItemIds = combineItemIds.concat(data);
      }
    });
  }

  //过滤合并多个content数据
  if (combineImageIds.length) {
    needCreateContentIds = arrayUnique(combineItemIds.concat(combineImageIds));
  } else {
    needCreateContentIds = arrayUnique(combineItemIds);
  }

  //排序
  needCreateContentIds = needCreateContentIds.sort(function (a, b) {
    return a - b;
  });

  /**
   * 合并创建信息
   * 需要创建的事件
   * 需要创建的所有对象
   */
  return [combineImageIds, needCreateContentIds];
}

/**
 * 解析解析每一条 Activitys 对应的数据结构
 * @param  {[type]} compileActivitys [description]
 * @param  {[type]} data             [description]
 * @return {[type]}                  [description]
 */
function contentParser(compileActivitys, pipeData) {

  var activity = void 0,
      hookType = void 0,
      //结果合集
  i = compileActivitys.length,
      pageType = pipeData.pageType,
      chapterIndex = pipeData.chapterIndex,


  /*相关数据合集*/
  activityRelated = [],
      //Activit合集相关数据信息
  tempRelated = [],
      //临时数据

  /*解析出来的相关信息*/
  relateds = {
    seasonRelated: {}, //节信息
    containerRelated: [], //容器合集相关数据信息
    eventRelated: {}, //多事件容器合集
    partContentRelated: [] //卷滚conten只创建,不处理行为


    /*创建解析*/
  };var createResolve = function createResolve(callback) {
    return coreParser(function (tokens) {
      return callback(tokens);
    }, activity, pageType, chapterIndex);
  };

  /*类型处理器，除去动画的其余处理类型*/
  var hookResolve = {

    /*单独处理容器类型*/
    Container: function Container() {
      relateds.containerRelated.push(createResolve(function (tokens) {
        return {
          'Container': tokens['Content']
        };
      }));
    },


    /*多事件*/
    Contents: function Contents() {
      var item;
      if (item = createResolve(function (tokens) {
        return {
          'Contents': [tokens]
        };
      })[0]) {
        //给content注册多个绑定事件
        var eventId = activity.imageId;
        var eventData = {
          'eventContentId': eventId,
          'activityId': activity._id,
          'registers': item['activity'],
          'eventType': activity.eventType,
          'dragdropPara': activity.para1 //拖拽对象
        };
        var isEvt = relateds.eventRelated['eventContentId->' + eventId];
        if (isEvt) {
          isEvt.push(eventData);
        } else {
          relateds.eventRelated['eventContentId->' + eventId] = [eventData];
        }
      }
    },


    /*所有js零件*/
    JsWidget: function JsWidget() {
      var scrollContents = parseJSON(activity.itemArray);
      if (_.isArray(scrollContents)) {
        _.each(scrollContents, function (content) {
          relateds.partContentRelated.push(content.id);
        });
      } else {
        relateds.partContentRelated.push(scrollContents.id);
      }
    }
  };

  /**
   * 解析出当前页面的所有的Activit表
   * 1个chpater页面 可以对应多个Activit表中的数据
   * 1 Container 容器类型
   * 2 page 类型
   * 3 parallax 类型
   * 4 Scenario 类型
   * 5 content合集 contents处理
   */
  while (activity = compileActivitys.shift()) {
    //统一类型
    hookType = unifyType(activity);

    /*如果有钩子匹配就先处理钩子*/
    if (!hookResolve[hookType] || hookResolve[hookType] && hookResolve[hookType](relateds)) {
      /*如果是动画表,视觉差表关联的content类型 ,tokens => itemArray分类数据*/
      var results = createResolve(function (tokens) {
        //解析其余tokens
        relatedTokens(relateds, activity, tokens);
        //母版是可能带视觉差的，所以除了Animation还有Parallax
        if (pageType === 'page') {
          return parseBaseTokens(['Animation'], tokens);
        } else if (pageType === 'master') {
          return parseBaseTokens(['Animation', 'Parallax'], tokens);
        }
      });

      //如果有手动触发器,置于最后
      if (activity.imageId) {
        tempRelated.push(results);
      } else {
        activityRelated.push(results);
      }
    }
  }

  //合并排序
  if (tempRelated.length) {
    activityRelated = activityRelated.concat(tempRelated);
    tempRelated = null;
  }

  /**
   *  过滤出与创建相关的content合集ID
   *      createEventIds  主content列表 (用来绑定eventType事件)
   *      createContentIds 合并所有content操作后,过滤掉重复的content,得到可以创建的content的ID合集
   */
  var createRelevant = toRepeatCombineGroup(activityRelated, relateds.partContentRelated, pageType);
  var createEventIds = createRelevant[0];
  var createContentIds = createRelevant[1];

  //如果存在过滤器
  if (Xut.CreateFilter.size()) {
    var filterEach = Xut.CreateFilter.each(pipeData.chapterId);
    if (filterEach) {
      filterEach(createEventIds, function (indexOf) {
        createEventIds.splice(indexOf, 1);
      });
      filterEach(createContentIds, function (indexOf) {
        createContentIds.splice(indexOf, 1);
      });
      filterEach = null;
    }
  }

  return _.extend(pipeData, relateds, {
    'createEventIds': createEventIds, //事件ID数
    'createContentIds': createContentIds, //创建的content总ID数
    'createActivitys': activityRelated
  });
}

/**
 * 行为反馈
 *  content id = {
 *      弹动
 *      音频URl
 *  }
 *  2016.12.6
 *     增加，点击放大 zoom
 */
function parseParameter(pipeData) {
  var parameter = void 0;
  var soundSrc = void 0;
  var contentId = void 0;
  var isButton = void 0;
  var feedbackBehavior = pipeData.feedbackBehavior = {}; //点击行为
  var zoomBehavior = pipeData.zoomBehavior = {}; //缩放行为
  var hasZoom = void 0;
  var chapterIndex = pipeData.chapterIndex;
  var prefix = void 0;
  var id = void 0;

  _.each(pipeData.activitys, function (activitys) {
    if (activitys.parameter && (parameter = parseJSON(activitys.parameter))) {
      contentId = activitys.imageId;

      //如果这个是讨论区的关闭事件activity组
      if (parameter['forum'] === 'close') {
        if (!pipeData['forumCloses']) {
          pipeData['forumCloses'] = {};
        }
        //收集关闭合集
        pipeData['forumCloses'][activitys._id] = true;
      }

      //视觉反馈
      if (isButton = parameter['isButton']) {
        if (isButton != 0) {
          //过滤数据的字符串类型
          createFn(feedbackBehavior, contentId, function () {
            this['isButton'] = true;
          });
        }
      }

      //音频行为
      if (soundSrc = parameter['behaviorSound']) {
        if (soundSrc != 0) {
          createFn(feedbackBehavior, contentId, function () {
            this['behaviorSound'] = soundSrc;
          });
        }
      }

      //点击图片放大
      if (hasZoom = parameter['zoom']) {
        if (hasZoom.length) {
          _.each(hasZoom, function (zoomData) {
            id = zoomData.content;
            if (id) {
              //保存于节点node命名一致，方便快速查找
              prefix = "Content_" + chapterIndex + "_" + id;
              createFn(zoomBehavior, prefix, function () {
                //缩放提示图片
                this['prompt'] = zoomData.prompt ? true : false;
              });
            }
          });
        }
      }
    }
  });
}

/*解析出需要构建的Activity数据*/
function activityParser(pipeData) {
  var actType = void 0;
  var activitys = [];
  _.each(pipeData.activitys, function (activity) {
    actType = activity.actType || activity.animation;
    //特殊类型 showNote
    if (!actType && activity.note) {
      activity['actType'] = actType = "ShowNote";
    }
    /*匹配content处理相关类型*/
    if (activity.itemArray || activity.autoPlay !== 2) {
      switch (actType) {
        case 'Container':
        case 'Content':
        case 'Parallax':
        case 'Contents':
          activitys.push(activity);
          break;
      }
    }
  });
  return activitys;
}

var maskBoxImage$1 = Xut.style.maskBoxImage;
var FLOOR$2 = Math.floor;

/**
 * 蒙版动画
 */
var maskContent = function maskContent(data, wrapObj) {

  //如果有蒙版图
  var isMaskImg = data.mask ? maskBoxImage$1 + ":url(" + getFileFullPath(data.mask, 'content-mask') + ");" : "";
  var resourcePath = wrapObj.resourcePath;
  var restr = "";

  function getImgSrc() {
    return 'src="' + resourcePath + '"\n            onerror="fixNodeError(\'image\',this,\'' + wrapObj.chapterIndex + '\',\'' + resourcePath + '\')"\n            style="' + isMaskImg + '"';
  }

  //蒙板图
  if (data.mask || wrapObj.isGif) {
    //蒙版图
    if (maskBoxImage$1 != undefined) {
      restr += String.styleFormat('<img data-type="' + (data.qrCode ? 'qrcode' : 'mask') + '"\n              class="inherit-size fullscreen-background edges"\n              ' + getImgSrc() + '/>');
    } else {
      //canvas
      restr += String.styleFormat('<canvas class="inherit-size fullscreen-background edges"\n                 src="' + resourcePath + '"\n                 mask="' + isMaskImg + '"\n                 width="' + data.scaleWidth + '"\n                 height="' + data.scaleHeight + '"\n                 style="opacity:0;' + (config.data.pathAddress.replace(/\//g, "\/") + data.mask) + '"/>');
    }

    //精灵图
  } else if (data.category == 'Sprite') {

    var matrixX = 100 * data.thecount;
    var matrixY = 100;

    //如果有参数
    //精灵图是矩阵图
    if (data.parameter) {
      var parameter = parseJSON(data.parameter);
      if (parameter && parameter.matrix) {
        var matrix = parameter.matrix.split("-");
        matrixX = 100 * Number(matrix[0]);
        matrixY = 100 * Number(matrix[1]);
      }
    }
    restr += String.styleFormat('<div data-type="sprite-images"\n            class="sprite"\n            style="height:' + data.scaleHeight + 'px;\n                   background-image:url(' + resourcePath + ');\n                   background-size:' + matrixX + '% ' + matrixY + '%;">\n      </div>');
  } else {
    //普通图片
    restr += String.styleFormat('<img data-type="' + (data.qrCode ? 'qrcode' : 'ordinary') + '"\n            class="inherit-size fullscreen-background fix-miaomiaoxue-img"\n            ' + getImgSrc() + '/>');
  }

  return restr;
};

/**
 * 纯文本内容
 * @param  {[type]} data [description]
 * @return {[type]}      [description]
 */
var textContent = function textContent(data) {
  return String.styleFormat('<div id="' + data['_id'] + '"\n          style="background-size:100% 100%;height:auto">\n          ' + data.content + '\n    </div>');
};

/**
 * 如果是.js结尾的
 * 新增的html文件
 * @param  {[type]} data    [description]
 * @param  {[type]} wrapObj [description]
 * @return {[type]}         [description]
 */
var jsContent = function jsContent(data, wrapObj) {
  return replacePath(wrapObj.htmlstr);
};

/**
 * 如果内容是svg
 * @param  {[type]} data    [description]
 * @param  {[type]} wrapObj [description]
 * @return {[type]}         [description]
 */
var svgContent = function svgContent(data, wrapObj) {
  var restr = "";
  var svgstr = wrapObj.svgstr;
  var scaleWidth = data.scaleWidth;

  //从SVG文件中，读取Viewport的值
  if (svgstr != undefined) {

    //替换svg内部读取文件地址
    svgstr = replacePath(svgstr);

    var startPos = svgstr.search('viewBox="');
    var searchTmp = svgstr.substring(startPos, startPos + 64).replace('viewBox="', '').replace('0 0 ', '');
    var endPos = searchTmp.search('"');
    var temp = searchTmp.substring(0, endPos);
    var sptArray = temp.split(" ");
    var svgwidth = sptArray[0];
    var svgheight = sptArray[1];

    //svg内容宽度:svg内容高度 = viewBox宽:viewBox高
    //svg内容高度 = svg内容宽度 * viewBox高 / viewBox宽
    var svgRealHeight = FLOOR$2(scaleWidth * svgheight / svgwidth);
    //如果svg内容高度大于布局高度则添加滚动条
    if (svgRealHeight > data.scaleHeight + 1) {
      var svgRealWidth = FLOOR$2(scaleWidth);
      //if there do need scrollbar, then restore text to its original prop
      //布局位置
      var marginleft = wrapObj.backMode ? data.scaleLeft - data.scaleBackLeft : 0;
      var margintop = wrapObj.backMode ? data.scaleTop - data.scaleBackTop : 0;

      if (data.isScroll) {
        restr = String.styleFormat('<div data-type="svg"\n                style="width:' + svgRealWidth + 'px;\n                       height:' + svgRealHeight + 'px;\n                       margin-left:' + marginleft + 'px;\n                       margin-top:' + margintop + 'px;">\n                ' + svgstr + '\n          </div>');
      } else {
        restr = String.styleFormat('<div data-type="svg"\n                class="inherit-size"\n                style="margin-left:' + marginleft + 'px;\n                       margin-top:' + margintop + 'px;">\n              ' + svgstr + '\n          </div>');
      }
    } else {
      restr += svgstr;
    }
  }
  return restr;
};

/**
 * 填充content内容
 * @param  {[type]} data    [description]
 * @param  {[type]} wrapObj [description]
 * @return {[type]}         [description]
 */
var fillContent = function fillContent(data, wrapObj) {
  var restr = '';
  //如果内容是图片
  //如果是svg或者html
  if (wrapObj.fileName) {
    //如果是SVG
    if (wrapObj.isSvg) {
      restr += svgContent(data, wrapObj);
    }
    //如果是.js结构的html文件
    else if (wrapObj.isJs) {
        restr += jsContent(data, wrapObj);
      }
      //如果是蒙板，或者是gif类型的动画，给高度
      else {
          restr += maskContent(data, wrapObj);
        }
  }
  //纯文本文字
  else {
      restr += textContent(data, wrapObj);
    }
  return restr;
};

/**
 * 创建包含容器content
 * @param  {[type]} data    [description]
 * @param  {[type]} wrapObj [description]
 * @return {[type]}         [description]
 */
var createContainer$1 = function createContainer(data, wrapObj) {
  var wapper = void 0;
  var backwidth = void 0,
      backheight = void 0,
      backleft = void 0,
      backtop = void 0;
  var zIndex = data.zIndex;
  var id = data._id;

  //Content_23_37
  //Content_23_38
  //Content_23_39
  var containerName = wrapObj.containerName;

  //背景尺寸优先
  if (data.scaleBackWidth && data.scaleBackHeight) {
    backwidth = data.scaleBackWidth;
    backheight = data.scaleBackHeight;
    backleft = data.scaleBackLeft;
    backtop = data.scaleBackTop;
    wrapObj.backMode = true; //背景图模式
  } else {
    backwidth = data.scaleWidth;
    backheight = data.scaleHeight;
    backleft = data.scaleLeft;
    backtop = data.scaleTop;
  }

  //content默认是显示的数据的
  //content.visible = 0
  //如果为1 就隐藏改成hidden
  //05.1.14
  var visibility = 'visible';
  if (data.visible) {
    visibility = 'hidden';
  }

  /*css3 滤镜效果 2017.5.12支持,filterNames数组形式*/
  var filterName = data.filterNames ? data.filterNames.join(' ') : '';

  // var isHtml = "";
  //2015.12.29
  //如果是html内容
  if (wrapObj.isJs) {
    wapper = '<div id="' + containerName + '"\n                   data-behavior="click-swipe"\n                   class="fullscreen-background ' + filterName + '"\n                   style="width:' + backwidth + 'px;\n                          height:' + backheight + 'px;\n                          top:' + backtop + 'px;\n                          left:' + backleft + 'px;\n                          position:absolute;\n                          z-index:' + zIndex + ';\n                          visibility:' + visibility + ';\n                          {10}">\n               <div data-type="scroller"\n                    style="width:' + backwidth + 'px;\n                           position:absolute;">';
    return String.styleFormat(wapper);
  } else {
    //scroller:=> absolute 因为别的元素有依赖
    var background = data.background ? 'background-image: url(' + getFileFullPath(data.background, 'content-container') + ');' : '';

    //正常content类型
    //如果是scroller需要绝对的尺寸，所以替换100% 不可以
    wapper = '<div id="' + containerName + '"\n                   data-behavior="click-swipe"\n                   class="' + filterName + '"\n                   style="width:' + backwidth + 'px;\n                          height:' + backheight + 'px;\n                          top:' + backtop + 'px;\n                          left:' + backleft + 'px;\n                          position:absolute;\n                          z-index:' + zIndex + ';\n                          visibility:' + visibility + '">\n              <div data-type="scroller"\n                   class="fullscreen-background "\n                   style="width:' + backwidth + 'px;\n                          height:' + backheight + 'px;\n                          position:absolute;\n                          ' + background + '">';

    return String.styleFormat(wapper);
  }
};

/**
 * 组成HTML结构
 * @param  {[type]} argument [description]
 * @return {[type]}          [description]
 */
function createDom(data, wrapObj) {
  var restr = '';

  //创建包装容器content节点
  restr += createContainer$1(data, wrapObj);

  //创建内容
  restr += fillContent(data, wrapObj);
  restr += "</div></div>";

  return restr;
}

/**
 * 组成HTML结构
 * @param  {[type]} argument [description]
 * @return {[type]}          [description]
 */
function createCanvas(data, wrapObj) {

  var mark = '';
  if (data.category) {
    var cats = data.category.split(",");
    var len = cats.length;
    if (len) {
      while (len--) {
        mark += cats[len];
      }
    }
  }

  var temp = '<canvas id="{0}"' + ' data-ctype={1}' + ' width="{2}"' + ' height="{3}">' + '</canvas>';

  var str = String.format(temp, wrapObj.makeId('canvas'), mark.toLocaleLowerCase(), data.scaleWidth, data.scaleHeight);

  return str;
}

/**
 * 解析序列中需要的数据
 * @param  {[type]}   contentIds [description]
 * @param  {Function} callback   [description]
 * @return {[type]}              [description]
 */
function parseContentData(contentIds, callback) {
  var data,
      temp = [];
  contentIds.forEach(function (contentId, index) {
    data = Xut.data.query('Content', contentId);
    temp.unshift(data);
    callback && callback(data, contentId);
  });
  return temp;
}

/**
 * 针对容器类型的处理
 * @param  {[type]} containerName [description]
 * @param  {[type]} contentId     [description]
 * @param  {[type]} chapterIndex     [description]
 * @return {[type]}               [description]
 */
var createContainerWrap = function createContainerWrap(containerName, contentId, chapterIndex, getStyle) {
  var contentResult = parseContentData([contentId]);
  var data = reviseSize({
    results: contentResult[0],
    proportion: getStyle.pageProportion
  });
  var wapper = '<div  id="' + containerName + '"\n               data-behavior="click-swipe"\n               style="width:' + data.scaleWidth + 'px;\n                      height:' + data.scaleHeight + 'px;\n                      top:' + data.scaleTop + 'px;\n                      left:' + data.scaleLeft + 'px;\n                      position:absolute;\n                      z-index:' + data.zIndex + ';">';

  return String.styleFormat(wapper);
};

function createContainer$2(containerRelated, chapterIndex, getStyle) {
  var itemIds,
      uuid,
      contentId,
      containerName,
      containerObj = {
    createUUID: [],
    containerName: []
  };

  containerRelated.forEach(function (data, index) {
    contentId = data.imageIds;
    containerName = "Container_" + chapterIndex + "_" + contentId;
    uuid = "aaron" + Math.random();
    containerObj[uuid] = {
      'start': [createContainerWrap(containerName, contentId, chapterIndex, getStyle)],
      'end': '</div>'
    };
    containerObj.createUUID.push(uuid);
    containerObj.containerName.push(containerName);
    data.itemIds.forEach(function (id) {
      containerObj[id] = uuid;
    });
  });
  return containerObj;
}

/**
 * 设置canvas数据
 */
var createCanvasData = function createCanvasData(type, opts) {

  var data = opts.data;
  var contentId = opts.contentId;
  var conData = opts.conData;

  //content收集id标记
  //cid =>content=> 普通动画 ppt
  //wid =>widget=>高级动画
  if (data.canvasRelated[type].indexOf(contentId) == -1) {
    data.canvasRelated[type].push(contentId);
    conData.actionTypes[type] = true;
  }

  if (data.canvasRelated.contentIdset.indexOf(contentId) == -1) {
    data.canvasRelated.contentIdset.push(contentId);
  }

  //给content数据增加直接判断标示
  conData.canvasMode = true;

  //拿到最高层级
  if (conData.zIndex) {
    if (conData.zIndex > data.canvasRelated.containerIndex) {
      data.canvasRelated.containerIndex = conData.zIndex;
    }
  }
};

/**
 * canvas pixi.js类型处理转化
 * 填充cid, wid
 * @type {Object}
 */
var pixiType = {
  //普通精灵动画
  "Sprite": function Sprite(opts, data) {
    if (data.canvasRelated.enable) {
      //启动精灵模式
      //在动画处理的时候给initAnimations快速调用
      createCanvasData('spiritId', opts);
    }
  },
  //ppt=》pixi动画
  "PPT": function PPT(opts, data) {
    //双重判断
    //必须启动cnavas模式
    //必须数据是canvs模式
    //因为ppt只支持 高级与复杂精灵
    if (data.canvasRelated.enable && opts.conData.canvasMode) {
      createCanvasData('pptId', opts);
    }
  },
  //高级精灵动画
  //widget
  "SeniorSprite": function SeniorSprite(opts, data) {
    if (data.canvasRelated.enable) {
      createCanvasData('widgetId', opts);
    }
  },
  //复杂精灵动画
  //可以在dom模式与canvas混合使用
  //所以dom下还要强制开始canvasMode
  "CompSprite": function CompSprite(opts) {
    var data = opts.data;
    var conData = opts.conData;
    if (/\./i.test(opts.conData.md5)) {
      console.log('复杂精灵动画数据错误');
      return;
    }

    //特殊判断，见canvas.js
    //如果没有启动canvas也能走进这个程序
    //给上特殊标示
    if (!data.canvasRelated.enable && !data.canvasRelated.onlyCompSprite) {
      //仅仅只是满足特殊动画
      //特殊模式，可能chapter表中没有启动canvas模式
      data.canvasRelated.onlyCompSprite = true;
    }
    createCanvasData('compSpriteId', opts);
  }

  /**
   * 解析参数
   */
};function callResolveArgs(category, opts) {
  var cate;
  var val;
  var data = opts.data;
  var cates = category.split(",");
  var length = cates.length;
  var i = 0;
  //判断ppt是不是数组中最后一个
  //如果不是，需要对调位置
  var pptindex = cates.indexOf('PPT');

  //如果是首位
  if (pptindex == 0) {
    //ppt永远最后一个
    cates = cates.concat(cates.splice(pptindex, 1));
  }

  if (length) {
    for (var i = 0; i < length; i++) {
      cate = cates[i];
      //匹配数据类型
      pixiType[cate] && pixiType[cate](opts, data);
    }
  }
}

/**
 * 解析canvas数据
 *
 */
function parseCanvas(contentId, category, conData, data) {

  //类型转化
  //双数据类型转行单个类型
  if (Xut.config.debug.onlyDomMode) {
    if (category) {
      var cat;
      var cats = category.split(",");
      var len = cats.length;
      if (len > 1) {
        //删除ppt
        var pptindex = cats.indexOf('PPT');
        if (-1 != pptindex) {
          cats.splice(pptindex, 1);
        }
      }
      conData.category = cats[0];
    }
    return;
  }

  //动作类型
  //用于动画判断
  conData.actionTypes = {};

  //下一个数据
  var opts = {
    contentId: contentId,
    conData: conData,
    data: data

    //转成canvas标记
    //如果有pixi的处理类型
    //2016.2.25
    //SeniorSprite,PPT
    //Sprite,PPT
    //SeniorSprite
    //Sprite
    //PPT
    //CompSprite
    //多种处理方式
    //可以组合
  };category && callResolveArgs(category, opts);
}

/**
 * 编译content的容器
 * 2013.10.12
 * 1 为处理重复content数据引用问题,增加
 *            createScopeWarpObj方法,用于隔绝content数据的引用关系，导致重复数据被修正的问题
 * 2 多个页面引用同一个content的处理，Conetnt_0_1 ,类型+页码+ID的标示
 * @return {[type]} [description]
 */

/**
 * 制作包装对象
 * 用于隔绝content数据的引用关系
 * 导致重复数据被修正的问题
 * @return {[type]}             [description]
 */
function createScopeWarpObj(contentId, content, pageType, chapterIndex) {
  //唯一标示符
  var prefix = "_" + chapterIndex + "_" + contentId;
  var fileName = content.md5;

  return {
    pageType: pageType,
    contentId: contentId,
    isJs: /.js$/i.test(fileName), //html类型
    isSvg: /.svg$/i.test(fileName), //svg类型
    contentData: content,
    chapterIndex: chapterIndex,
    containerName: 'Content' + prefix,
    makeId: function makeId(name) {
      return name + prefix;
    }
  };
}

/**
 * 创建图片地址
 * @return {[type]}         [description]
 */
var analysisPath = function analysisPath(wrapObj, conData) {

  var resourcePath = void 0; //资源路径,png/jpg/svg..
  var fileName = conData.md5;
  var isGif = /.gif$/i.test(fileName);

  /*是自动精灵动画*/
  if (conData.category === "AutoCompSprite") {
    try {
      resourcePath = getFileFullPath(fileName, 'content-autoCompSprite', isGif);
      var results = getResources(resourcePath + '/app.json');
      var spiritList = results.spiritList[0];
      var actListName = spiritList.params.actList;
      var name = spiritList.params[actListName].ImageList[0].name;
      resourcePath += '/' + name;
      conData.resource = results;
      conData.containerName = wrapObj.containerName;
    } catch (err) {
      console.log('AutoCompSprite获取数据失败');
    }
  } else {

    var fileFullPath = getFileFullPath(fileName, 'content', isGif);

    /*如果启动了预加载，去掉随机后缀*/
    if (config.launch.preload) {
      resourcePath = fileFullPath;
    } else {
      //如果没有启动preload，需要随机，保证不缓存
      resourcePath = isGif ? createRandomImg(fileFullPath) : fileFullPath;
    }
  }

  wrapObj.fileName = fileName;
  wrapObj.isGif = isGif;
  wrapObj.resourcePath = resourcePath;
};

/**
 * content
 *  svg数据
 *  html数据
 * 解析外部文件
 * @param  {[type]} wrapObj     [description]
 * @param  {[type]} svgCallback [description]
 * @return {[type]}             [description]
 */
var externalFile = function externalFile(wrapObj, svgCallback) {
  //svg零件不创建解析具体内容
  if (wrapObj.isSvg) {
    readFileContent(wrapObj.contentData.md5, function (svgdata) {
      wrapObj.svgstr = svgdata;
      svgCallback(wrapObj);
    });
  } else if (wrapObj.isJs) {
    //如果是.js的svg文件
    readFileContent(wrapObj.contentData.md5, function (htmldata) {
      wrapObj.htmlstr = htmldata;
      svgCallback(wrapObj);
    }, "js");
  } else {
    svgCallback(wrapObj);
  }
};

/**
 * 分配缩放比
 * @return {[type]} [description]
 */
var allotRatio = function allotRatio(fixRadio, headerFooterMode) {
  if (fixRadio && headerFooterMode) {
    $warn({
      type: 'pagebase',
      content: 'content缩放模式fixRadio与headerFooterMode重叠,优先选择headerFooterMode模式'
    });
  }
  //页眉页脚模式
  if (headerFooterMode) {
    return headerFooterMode;
  }
  //设置图片缩放模式1
  if (fixRadio) {
    return 3;
  }
};

//=====================================================
//
//  构建content的序列tokens
//  createImageIds,
//  createContentIds
//  pageType,
//  dydCreate //重要判断,动态创建
//
//=======================================================
function contentStructure(pipeData, $$floatDivertor, callback) {

  var content = void 0,
      contentId = void 0,
      wrapObj = void 0,
      containerObj = void 0,
      sizeResults = void 0,
      contentCollection = void 0,
      contentCount = void 0,
      cloneContentCount = void 0,
      chapterIndex = pipeData.chapterIndex,
      pageType = pipeData.pageType,
      containerRelated = pipeData.containerRelated,
      seasonRelated = pipeData.seasonRelated,
      isMaster = pageType === 'master',

  //文本框
  //2016.1.7
  contentHtmlBoxIds = [],

  //所有content的id记录
  //返回出去给ibooks预编译使用
  idFix = [],

  //文本效果
  //2017.1.3
  //收集对应的content数据
  textFx = [],

  //缓存contentDataset
  contentDataset = {},

  //缓存content结构
  cachedContentStr = [],

  //页眉页脚对象合集
  headerFooterMode = {},

  //自定义样式
  getStyle = pipeData.getStyle;

  /*开始过滤参数*/
  if (containerRelated && containerRelated.length) {
    containerObj = createContainer$2(containerRelated, chapterIndex, getStyle);
  }

  /**
   * 转化canvas模式 contentMode 0/1
   * 页面或者母板浮动对象
   * 页面是最顶级的
   */
  function parseContentParameter(parameter, contentId, conData) {
    _.each(parameter, function (para) {
      /*如果有css3的滤镜效果*/
      if (para.filter && para.filter.length) {
        conData.filterNames = parseJSON(para.filter);
      }
      /*是否启动代码追踪*/
      if (para.trackCode) {
        conData.trackCode = true;
      }
      /*在模式2与3模式下元素可能会溢出,保证不溢出处理*/
      if (para.fixedPosition) {
        conData.fixedPosition = Number(para.fixedPosition);
      }
      //如果有二维码标记
      //2017.3.1
      if (para.qrCode) {
        conData.qrCode = true;
      }
      //有页眉页脚对象
      //2017.1.18
      if (para.HeaderOrFooter) {
        if (headerFooterMode[contentId]) {
          $warn({
            type: 'pagebase',
            content: '页眉页脚对象重复设置,contentId:' + contentId
          });
        }
        headerFooterMode[contentId] = Number(para.HeaderOrFooter);
      }
      //保持图片正比缩放
      //给mini使用
      //2016.12.15
      if (para.fixRadio) {
        conData.fixRadio = true;
      }
      //针对母版content的topmost数据处理，找出浮动的对象Id
      //排除数据topmost为0的处理
      var zIndex = para['topmost'];
      if (zIndex && zIndex != 0) {
        if (isMaster) {
          //收集浮动的母版对象id
          $$floatDivertor.master.ids.push(contentId);
          $$floatDivertor.master.zIndex[contentId] = zIndex;
        } else {
          //浮动页面
          $$floatDivertor.page.ids.push(contentId);
          $$floatDivertor.page.zIndex[contentId] = zIndex;
        }
      }
    });
  }

  /*开始过滤参数*/
  function prefilter(conData, contentId) {
    //如果是模板书签，强制为浮动对象
    var eventId = void 0;
    if (isMaster && (eventId = seasonRelated[contentId])) {
      if (eventId['BookMarks']) {
        $$floatDivertor.master.ids.push(contentId);
      }
    }

    //如果有parameter参数
    //1 浮动对象
    //2 canvas对象
    if (conData) {
      /*匹配canvas对象数据*/
      conData.category && parseCanvas(contentId, conData.category, conData, pipeData);

      /*如果有parameter,保持数据格式，方便解析*/
      var parameter = void 0;
      if (parameter = conData.parameter && parseJSON(conData.parameter)) {
        parseContentParameter(parameter.length ? parameter : [parameter], contentId, conData);
      }
    }
  }

  /**
   * 解析出每一个content对应的动作
   * 传递prefilter过滤器
   * 1 浮动动作
   * 2 canvas动作
   * @type {[type]}
   */
  contentCollection = parseContentData(pipeData.createContentIds, prefilter);
  contentCount = cloneContentCount = contentCollection.length;

  //如果是启动了特殊高精灵动画
  //强制打开canvas模式设置
  //这里可以排除掉其余的canvas动画
  if (pipeData.canvasRelated.onlyCompSprite) {
    pipeData.canvasRelated.enable = true;
  }

  /*创建content节点*/
  function createRelated(contentId, wrapObj) {
    externalFile(wrapObj, function (wrapObj) {
      var uuid = void 0,
          startStr = void 0,
          contentStr = void 0;
      var conData = wrapObj.contentData;

      /*分析图片地址*/
      analysisPath(wrapObj, conData);

      //////////////////////
      /// 扩展给PPT调用
      /// 处理一次性APNG的不播放问题
      //////////////////////
      conData.resourcePath = wrapObj.resourcePath;

      //canvas节点
      if (conData.canvasMode) {
        contentStr = createCanvas(conData, wrapObj);
      } else {
        //dom节点
        contentStr = createDom(conData, wrapObj);
      }
      //如果创建的是容器对象
      if (containerObj && (uuid = containerObj[contentId])) {
        startStr = containerObj[uuid];
        startStr.start.push(contentStr);
      } else {
        //普通对象
        cachedContentStr.unshift(contentStr);
      }
      //检测完毕
      checkComplete();
    });
  }

  /*开始创建*/
  function startCreate(wrapObj, content, contentId) {
    contentDataset[contentId] = content; //缓存数据
    createRelated(contentId, wrapObj);
  }

  /*清理剔除的content*/
  function checkComplete() {
    if (cloneContentCount === 1) {
      var userData = {
        contentDataset: contentDataset,
        idFix: idFix,
        textFx: textFx,
        contentHtmlBoxIds: contentHtmlBoxIds,
        headerFooterMode: headerFooterMode,
        containerPrefix: ''

        //针对容器处理
      };if (containerObj) {
        var start, end, containerPrefix, containerStr;
        containerStr = [];

        //合并容器
        containerObj.createUUID.forEach(function (uuid) {
          start = containerObj[uuid].start.join('');
          end = containerObj[uuid].end;
          containerStr.push(start.concat(end));
        });
        containerStr = containerStr.join('');
        containerPrefix = containerObj.containerName;
        containerObj = null;
        userData.contentStr = cachedContentStr.join('').concat(containerStr);
        userData.containerPrefix = containerPrefix;
      } else {
        userData.contentStr = cachedContentStr.join('');
      }
      callback(userData);
    }
    cloneContentCount--;
  }

  //开始生成所有的节点
  //1:dom
  //2:canvas
  while (contentCount--) {
    //根据数据创content结构
    if (content = contentCollection[contentCount]) {
      contentId = content['_id'];
      //创建包装器,处理数据引用关系
      wrapObj = createScopeWarpObj(contentId, content, pageType, chapterIndex);

      idFix.push(wrapObj.containerName);

      //如果有文本效果标记
      //content.texteffect = " "//数据库写错，多了一个空格
      if (content.texteffect && content.texteffect.trim()) {
        content.texteffectId = wrapObj.containerName;
        textFx.push(content);
      }
      //保存文本框content的Id
      if (wrapObj.isJs) {
        contentHtmlBoxIds.push(contentId);
      }

      /*转换缩放比*/
      var setRatio = function setRatio() {
        var proportion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getStyle.pageProportion;

        sizeResults = reviseSize({
          results: wrapObj.contentData,
          getStyle: getStyle,
          proportion: proportion,
          zoomMode: allotRatio(content.fixRadio, headerFooterMode[contentId])
        });
      };
      setRatio();

      /*设置页面缩放比*/
      var setPageProportion = function setPageProportion(baseRatio) {
        var pageProportion = {};
        _.each(getStyle.pageProportion, function (prop, key) {
          pageProportion[key] = prop * baseRatio;
        });
        return pageProportion;
      };

      /*溢出模式才计算，保证元素不溢出，继续修正缩放比*/
      if (content.fixedPosition && getStyle.pageVisualMode === 3) {
        var originalTop = sizeResults.scaleTop;
        var originalHeight = sizeResults.scaleHeight;
        var visualLeftInteger = getStyle.visualLeftInteger;
        var layerWidth = sizeResults.scaleWidth + sizeResults.scaleLeft;
        var overflowMode = '';

        //左边溢出
        if (visualLeftInteger > sizeResults.scaleLeft) {
          overflowMode = 'left';
        }

        //右边溢出
        var rightVisual = getStyle.visualWidth - visualLeftInteger;
        if (layerWidth > rightVisual) {
          if (overflowMode === 'left') {
            overflowMode = 'all'; //全溢出
          } else {
            overflowMode = 'right';
          }
        }

        if (overflowMode === 'left') {
          var baseRatio = (sizeResults.scaleWidth - visualLeftInteger) / sizeResults.scaleWidth;
          setRatio(setPageProportion(baseRatio));
          var ratioWidth = (layerWidth - sizeResults.scaleWidth - visualLeftInteger) / 2;
          sizeResults.scaleLeft = visualLeftInteger + ratioWidth;
          sizeResults.scaleTop = originalTop + (originalHeight - sizeResults.scaleHeight) / 2;
        } else if (overflowMode === 'right') {
          var _baseRatio = rightVisual / layerWidth;
          setRatio(setPageProportion(_baseRatio));
          sizeResults.scaleTop = originalTop + (originalHeight - sizeResults.scaleHeight) / 2;
        } else if (overflowMode === 'all') {
          //左右都溢出
          //强制全屏
          var _baseRatio2 = config.screenSize.width / sizeResults.scaleWidth;
          setRatio(setPageProportion(_baseRatio2));
          sizeResults.scaleLeft = visualLeftInteger;
          sizeResults.scaleTop = originalTop + (originalHeight - sizeResults.scaleHeight) / 2;
        }
      }

      //如果是隐藏的页面页脚，重写这个标记
      if (sizeResults.isHide && headerFooterMode[contentId]) {
        headerFooterMode[contentId] = 'hide';
      }

      //正常模式下创建
      startCreate(wrapObj, content, contentId);
    } else {
      //或者数据出错
      checkComplete();
    }
  }
}

/****************************************************
 *           构建TaskContents对象
 *      依赖数据解析算法类 Algorithm
 *      结构合并创建类    Structure
 *      行为动画绑定类     Content
 * ***************************************************/
/**
 * 构建快速查询节点对象
 * 转成哈希方式
 * @return {[type]} [description]
 */
function toObject(cachedContentStr) {
  var tempFragmentHash = {};
  _.each($(cachedContentStr), function (ele, index) {
    tempFragmentHash[ele.id] = ele;
  });
  return tempFragmentHash;
}

/**
 * 转成数组格式
 * 分组
 *     主体部分内容
 *     页眉页脚内容
 */
function toArray$1(contentsFragment, headerFooterMode) {
  var bodyContent = [];
  var headerFooterContent = [];
  _.each(contentsFragment, function ($node, key) {
    var id = key.split('_').pop();
    var state = void 0;
    if (headerFooterMode && (state = headerFooterMode[id])) {
      if (state !== 'hide') {
        //隐藏抛弃的元素，不需要显示了
        headerFooterContent.push($node);
      }
    } else {
      bodyContent.push($node);
    }
  });
  return {
    bodyContent: bodyContent,
    headerFooterContent: headerFooterContent
  };
}

/**
 * content任务类
 */

var TaskActivitys = function (_TaskSuper) {
  inherits(TaskActivitys, _TaskSuper);

  /*管道参数，贯通*/
  function TaskActivitys(pipeData, success, detector) {
    classCallCheck(this, TaskActivitys);

    var _this = possibleConstructorReturn(this, (TaskActivitys.__proto__ || Object.getPrototypeOf(TaskActivitys)).call(this, detector));

    _.extend(_this, pipeData);
    _this.success = success;

    /*chapter => activity*/
    var activitys = activityParser(pipeData);
    if (activitys) {
      pipeData = contentParser(activitys, pipeData);
      pipeData.createContentIds.length ? _this._dataAfterCheck(pipeData) : _this._loadComplete();
    } else {
      _this._loadComplete();
    }
    return _this;
  }

  /**
   * 检测下个任务创建
   */


  createClass(TaskActivitys, [{
    key: '_checkNextTask',
    value: function _checkNextTask(taskName, nextTask) {
      //如果是当前页面构建,允许打断一次
      var interrupt = void 0;
      if (this.base.hasAutoRun && taskName === 'strAfter') {
        interrupt = true;
      }
      this._$$checkNextTask('内部contents', function () {
        nextTask();
      }, interrupt);
    }

    /**
     * 中断一:构建数据之后
     * 构建结构
     */

  }, {
    key: '_dataAfterCheck',
    value: function _dataAfterCheck(pipeData) {
      var _this2 = this;

      this._checkNextTask('dataAfter', function () {

        /*解析Parameter*/
        parseParameter(pipeData);

        /*构建页面content类型结构*/
        contentStructure(pipeData, _this2.$$floatDivertor, function (userData) {
          pipeData.contentHtmlBoxIds = userData.contentHtmlBoxIds;
          pipeData.contentsFragment = {};
          //iboosk节点预编译
          //在执行的时候节点已经存在
          //不需要在创建
          if (Xut.IBooks.runMode()) {
            _.each(userData.idFix, function (id) {
              pipeData.contentsFragment[id] = pipeData.$containsNode.find("#" + id)[0];
            });
          } else {
            //构件快速查询节点对象
            pipeData.contentsFragment = toObject(userData.contentStr);
            delete userData.contentStr;
          }
          //容器的前缀
          pipeData.containerPrefix = userData.containerPrefix;
          /* eslint-disable */
          //2015.5.6暴露到全局
          //提供给音频字幕上下文
          if (!Xut.Contents.contentsFragment[pipeData.chapterId]) {
            Xut.Contents.contentsFragment[pipeData.chapterId];
          }
          Xut.Contents.contentsFragment[pipeData.chapterId] = pipeData.contentsFragment;
          /* elist-enable */
          _this2._dataStrCheck(pipeData, userData);
        });
      });
    }

    /**
     * 中断二:构建结构之后
     * 绑定事件
     */

  }, {
    key: '_dataStrCheck',
    value: function _dataStrCheck(pipeData, userData) {
      var _this3 = this;

      this._checkNextTask('strAfter', function () {
        /*缩放图片*/
        if (Object.keys(pipeData.zoomBehavior).length) {
          _this3.zoomObjs = zoomPicture(pipeData);
          _this3.zoomBehavior = pipeData.zoomBehavior;
        }
        //文本特效
        if (userData.textFx.length) {
          _this3.textFxObjs = textFx(pipeData, userData.textFx);
        }
        //保留场景的留信息
        //用做软件制作单页预加载
        sceneController.seasonRelated = pipeData.seasonRelated;
        //初始化content对象
        compileActivity(function (delayHooks) {
          _this3._eventAfterCheck(pipeData, delayHooks, userData.headerFooterMode);
        }, pipeData, userData.contentDataset, _this3.$$floatDivertor);
      });
    }

    /**
     * 中断三:绑定事件事件之后
     * @param  {[type]} iScrollHooks [description]
     * @return {[type]}              [description]
     */

  }, {
    key: '_eventAfterCheck',
    value: function _eventAfterCheck(pipeData, delayHooks, headerFooterMode) {
      var _this4 = this;

      this._checkNextTask('eventAfter', function () {

        /*
        计算回调的成功的次数
        1 正常节点创建
        2 浮动节点创建
        3 页眉页脚创建
         */
        pipeData.taskCount = 1;

        /**
         * 完成钩子函数
         * 1 content的卷滚条
         * 2 canvas事件绑定
         */
        var hookfns = function hookfns() {
          var iscrollHooks = delayHooks.iscrollHooks;
          var hook = void 0;
          if (iscrollHooks.length) {
            while (hook = iscrollHooks.shift()) {
              hook();
            }
          }
        };

        /**
         * 1 页面浮动
         * 2 母版浮动
         * 3 正常对象
         * 4 页眉页脚
         */
        var complete = function () {
          return function () {
            if (pipeData.taskCount === 1) {
              delayHooks && hookfns();
              _this4._applyAfterCheck();
              return;
            }
            --pipeData.taskCount;
          };
        }();

        /*创建浮动层*/
        _this4._$$createFloatLayer(complete, pipeData, _this4.base.floatGroup);

        /*iboosk节点预编译,在执行的时候节点已经存在,不需要在创建*/
        if (Xut.IBooks.runMode()) {
          complete();
        } else {
          var fragment = toArray$1(pipeData.contentsFragment, headerFooterMode);
          var bodyContent = fragment.bodyContent;
          var headerFooterContent = fragment.headerFooterContent;
          var watchCount = 0;

          /*页面页脚需要叠加计算*/
          headerFooterContent.length && ++watchCount;
          bodyContent.length && ++watchCount;

          /*没有渲染数据*/
          if (!watchCount) {
            complete();
            return;
          }

          var watchNextTick = function () {
            return function () {
              if (watchCount === 1) {
                complete();
                return;
              }
              --watchCount;
            };
          }();

          /*页眉页脚*/
          if (headerFooterContent.length) {
            nextTick({
              'container': pipeData.$headFootNode,
              'content': fragment.headerFooterContent
            }, watchNextTick);
          }

          /*主体内容*/
          if (bodyContent.length) {
            nextTick({
              'container': pipeData.$containsNode,
              'content': fragment.bodyContent
            }, watchNextTick);
          }
        }
      });
    }

    /**
     * 中断四：渲染content
     * @return {[type]} [description]
     */

  }, {
    key: '_applyAfterCheck',
    value: function _applyAfterCheck() {
      var _this5 = this;

      this._checkNextTask('applyAfter', function () {
        _this5._loadComplete(true);
      });
    }

    /**
     * 构建完毕
     * @return {[type]} [description]
     */

  }, {
    key: '_loadComplete',
    value: function _loadComplete() {
      this.success && this.success();
    }

    //============================
    //      super方法
    //============================

    /**
     * 清理引用
     * @return {[type]} [description]
     */

  }, {
    key: '_destroy',
    value: function _destroy() {

      //文字动画
      if (this.textFxObjs) {
        _.each(this.textFxObjs, function (obj) {
          obj.destroy();
        });
        this.textFxObjs = null;
      }

      //删除字幕用的碎片文档
      if (Xut.Contents.contentsFragment[this.chapterId]) {
        delete Xut.Contents.contentsFragment[this.chapterId];
      }

      //清理放大图片功能
      if (this.zoomBehavior && Object.keys(this.zoomBehavior).length) {
        //清理缩放绑定事件
        _.each(this.zoomBehavior, function (zoomBehavior) {
          if (zoomBehavior.off) {
            zoomBehavior.off();
          }
        });
        this.zoomBehavior = null;

        //清理缩放对象
        _.each(this.zoomObjs, function (zoom) {
          zoom.destroy();
        });
        this.zoomObjs = null;
      }

      this.canvasRelated = null;
      this.pageBaseHooks = null;
      this.$containsNode = null;
      this.rootNode = null;
      this.contentsFragment = null;
    }
  }]);
  return TaskActivitys;
}(TaskSuper);

/**
 * 获取访问对象参数
 * 如果pageBase 不存在，则取当前页面的
 * @return {[type]} [description]
 */
function access$2(pageBase, callback) {

  //如果只提供回调函数
  if (arguments.length === 1 && _.isFunction(pageBase)) {
    callback = pageBase;
    pageBase = Xut.Presentation.GetPageBase && Xut.Presentation.GetPageBase();
  } else {
    pageBase = pageBase || Xut.Presentation.GetPageBase && Xut.Presentation.GetPageBase();
  }

  if (pageBase) {
    var activitys = pageBase.baseGetActivity();
    var components = pageBase.baseGetComponent();
    var pageType = pageBase.pageType || 'page';
    var flag = callback(pageBase, activitys, components.length && components, pageType);
    return flag;
  }
}

/**
 * by 2016.6.30
 * judgment is backstage run
 * Take the opposite judgment
 * @return {[type]} [description]
 */
var allowNext = function allowNext() {
  if (window.MMXCONFIG) {
    return function () {
      return !(window.MMXCONFIG.back || Xut.Application.IsBackStage());
    };
  } else {
    return function () {
      return !false;
    };
  }
};

var allowNext$1 = allowNext();

/*
提供给auto运行动作的延时触发处理
需要注意快速翻页要立马清理，因为定时器在延后触发
 */
var queue = {};
var timer$1 = null;

/*
重设状态
 */
function resetBatcherState() {
  queue = {};
  if (timer$1) {
    clearTimeout(timer$1);
    timer$1 = null;
  }
}

/*
  运行队列
 */
function runBatcherQueue() {
  for (var key in queue) {
    var watchers = queue[key];
    if (watchers.length) {
      var wather = void 0;
      while (wather = watchers.shift()) {
        wather();
        wather = null;
      }
    }
  }
}

/*
加入监控
 */
function pushWatcher(pageIndex, watcher) {
  //如果存在了
  if (queue[pageIndex]) {
    queue[pageIndex].push(watcher);
  } else {
    //如果找不到
    //并且存在了上一个处理，清空
    if (Object.keys(queue).length) {
      resetBatcherState();
    }
    queue[pageIndex] = [watcher];
  }

  if (!timer$1) {
    //只第一次调用开始执行
    timer$1 = setTimeout(function () {
      runBatcherQueue();
      resetBatcherState();
    }, 500);
  }
}

/*
清理
 */
function clearWatcher() {
  resetBatcherState();
}

/**
 * 自动触发控制
 * @return {[type]} [description]
 */

var noop = function noop() {};

/**
 * 运行自动的Activity对象
 * 延时500毫秒执行
 * @return {[type]} [description]
 */
function autoActivitys(activityObjs, taskAnimCallback) {
  var markComplete = function () {
    var completeStatistics = activityObjs.length; //动画完成统计
    return function () {
      if (completeStatistics === 1) {
        taskAnimCallback && taskAnimCallback();
        markComplete = null;
      }
      completeStatistics--;
    };
  }();

  _.each(activityObjs, function (obj, index) {
    if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
      //同一个对象类型
      //直接调用对象接口
      obj.autoPlay(markComplete);
    } else {
      markComplete();
    }
  });
}

/**
 * 运行自动的静态类型
 * @return {[type]} [description]
 */
function autoComponents(pageBase, pageIndex, autoData, pageType) {

  if (pageIndex === undefined) {
    pageIndex = Xut.Presentation.GetPageIndex();
  }

  var chapterId = pageBase.baseGetPageId(pageIndex);
  var directive = void 0;

  _.each(autoData, function (data, index) {
    directive = directives[data.actType];
    //零件类型的接口调用不一致
    //这里需要转接口处理
    if (directive && directive.autoPlay) {
      directive.autoPlay({
        'id': data.id,
        'pageType': pageType,
        'rootNode': pageBase.getContainsNode(),
        'chapterId': chapterId,
        'category': data.category,
        'autoPlay': data.autoPlay,
        'pageIndex': pageIndex
      });
    }
  });
}

/*翻页停止，
翻页速度大于定会器的延时，
那么这个任务就会被重复叠加触发，
所以每次翻页必须停止*/
function $stopAutoWatch() {
  clearWatcher();
}

/**
 * 兼容高级动画闪动的问题处理
 * 新版本只有apng动画了
 */
function delayWatcher(pageIndex, fn) {
  if (window.preloadData) {
    pushWatcher(pageIndex, fn);
  } else {
    fn();
  }
}

/**
 * 自动动作
 */
function $autoRun(pageBase, pageIndex, taskAnimCallback) {

  /**
   * 编译IBOOKSCONFIG的时候过滤自动运行的调用
   * @return {[type]}              [description]
   */
  if (Xut.IBooks.compileMode()) {
    return;
  }

  //When the home button by invoking
  //Does not perform automatic animation
  //fix 2016.6.29
  // originalApp
  // window.miaomiaoxue.back = 1;
  // activateApp
  // window.miaomiaoxue.back = 0;
  if (!allowNext$1()) {
    taskAnimCallback();
    return;
  }

  /**
   * 设置母版不重复，但是需要排除一个问题
    //标记已经运行过autoComponent的命令了
    //因为采用delayWatcher
    //那么共享模板，如果翻页低于delayWatcher的延时
    //那么自动运行的动作在第二页会丢失
    //所以这里需要标注下
    //只要满足一个，就可以了
   */
  function setMaster(pageBase) {
    if (pageBase && pageBase.pageType === 'master') {
      pageBase.onceMaster = true;
    }
  }

  //pageType
  //用于区别触发类型
  //页面还是母版
  access$2(pageBase, function (pageBase, activityObjs, componentObjs, pageType) {

    //如果是母版对象，一次生命周期种只激活一次
    if (pageBase.onceMaster) {
      return;
    }

    taskAnimCallback = taskAnimCallback || noop;

    /*自动组件*/
    var autoData = pageBase.baseAutoRun();
    if (autoData) {
      delayWatcher(pageIndex, function () {
        setMaster(pageBase);
        autoComponents(pageBase, pageIndex, autoData, pageType);
      });
    }

    /*自动Activity*/
    if (activityObjs) {
      delayWatcher(pageIndex, function () {
        setMaster(pageBase);
        autoActivitys(activityObjs, taskAnimCallback);
      });
    } else {
      taskAnimCallback(); //无动画
    }
  });
}

/**
 * 全局事件
 * 手动触发控制
 */
function $trigger(_ref, columnData) {
  var target = _ref.target,
      attribute = _ref.attribute,
      rootNode = _ref.rootNode,
      pageIndex = _ref.pageIndex;

  var id = void 0,
      type = void 0;
  var key = target.id;
  if (columnData) {
    type = columnData.type;
    id = columnData.id;
  } else if (key) {
    var tag = key.split('_');
    type = tag[0];
    id = tag[1];
  }

  if (type && id) {
    var directive = directives[type];
    if (directive && directive.trigger) {

      /*获取页面类型,page或master*/
      var pageType = rootNode && rootNode.id ? /page/.test(rootNode.id) ? 'page' : 'master' : 'page';

      var data = { id: id, key: key, type: type, rootNode: rootNode, target: target, pageIndex: pageIndex, pageType: pageType, "activityId": id, columnData: columnData

        /*如果有代码跟踪*/
      };config.sendTrackCode('hot', {
        id: id,
        type: type,
        pageId: Xut.Presentation.GetPageId(pageType, pageIndex),
        eventName: 'tap'
      });

      /*如果是重复点击,比如widget零件*/
      var instance = Xut.Application.GetExistObject(pageType, data);
      if (instance) {
        if (instance.toggle) {
          //如果有对应的处理方法
          return instance.toggle();
        }
      }

      //委派新的任务
      directive.trigger(data);
    }
  }
}

/**
 * 暂停控制
 * @return {[type]} [description]
 */
/**
 * 翻页停止content动作
 * 翻页时,暂停滑动页面的所有热点动作
 *
 * 如果传递了allHandle 停止所有的视频
 * allHandle 给接口Xut.Application.Original() 使用
 *
 * 页面与模板翻页都会调用暂停接口
 */
function $suspend(pageBase, pageId, allHandle) {

  //零件对象翻页就直接销毁了
  //无需暂时
  //这里只处理音频 + content类型
  access$2(pageBase, function (pageBase, activityObjs) {

    /*停止预加载*/
    // stopPreload()

    /*这个必须要，翻页停止AUTO的自动延时延时器，否则任务会乱套,e.g. 跨页面音频*/
    $stopAutoWatch();

    //多媒体处理
    if (pageId !== undefined) {
      //离开页面销毁视频
      removeVideo(pageId);
      //翻页停止母板音频
      if (pageBase.pageType === 'master') {
        hangUpAudio();
      }
    }

    //content类型
    activityObjs && _.each(activityObjs, function (obj) {
      obj.stop && obj.stop();
    });

    //如果是外部调用接口
    //Xut.Application.Original
    //销毁视频
    //销毁所有的音频
    if (allHandle) {
      clearVideo();
      clearAudio$1();
    }
  });
}

/**
 * 复位到初始化的状态
 * @return {[type]} [description]
 */

/**
 * 优化检测
 * @param  {Function} fn [description]
 * @return {[type]}      [description]
 */
var hasOptimize = function hasOptimize(fn) {
  if (!config.launch.visualMode !== 4) {
    fn && fn();
  }
};

/**
 * 翻一页处理： 翻页完毕触发
 * 大量操作DOM结构，所以先隐藏根节点
 * 1 删除所有widget节点
 * 2 复位所有content节点
 * @param  {[type]} pageBase [description]
 * @return {[type]}         [description]
 */
function $original(pageBase) {

  access$2(pageBase, function (pageBase, activityObjs, componentObjs) {

    //母版对象不还原
    if (pageBase.pageType === 'master') {
      //因为苗苗学的问题，需要单独处理hasForumClose的还原
      //2017.11.30
      activityObjs && _.each(activityObjs, function (obj) {
        if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
          if (obj.dataRelated && obj.dataRelated.hasForumClose) {
            obj.reset && obj.reset();
          }
        }
      });
      return;
    }

    var $containsNode;

    if ($containsNode = pageBase.getContainsNode()) {

      //隐藏根节点
      //display:none下刷新
      hasOptimize(function () {
        $containsNode.hide();
      });

      //content类型复位
      activityObjs && _.each(activityObjs, function (obj) {
        if (!Xut.CreateFilter.has(obj.pageId, obj.id)) {
          obj.reset && obj.reset();
        }
      });

      //销毁所有widget类型的节点
      if (componentObjs) {
        _.each(componentObjs, function (obj) {
          obj && obj.destroy();
        });
        //销毁widget对象管理
        pageBase.baseRemoveComponent();
      }

      hasOptimize(function () {
        setTimeout(function () {
          $containsNode.show();
          $containsNode = null;
        }, 0);
      });
    }
  });
}

/**
 * 停止动作
 * 给全局stop接口使用
 * 与suspend的区别就是，这个全除了suspend的处理，还包括零件的暂停
 * @return {[type]} [description]
 */
/**
 * 停止所有热点动作,并返回状态
 * 1 content
 * 2 widget
 * 动画,视频,音频...........................
 * 增加场景模式判断
 *
 *  skipAudio 是否跳过音频，不处理
 *    true 跳过
 *    false 不跳过
 */

/**
 * 复位状态/状态控制
 * 如果返回false证明有热点
 * 第一次只能关闭热点不能退出页面
 * @param  {[type]} pageObj [description]
 * @return {[type]}         [description]
 */
function $stop(skipAudio) {

  if (!skipAudio) {
    //清理音频
    clearAudio$1();
  }

  //清理视频
  clearVideo();

  //场景页面切换的调用，需要停止
  $stopAutoWatch();

  //停止热点
  return access$2(function (pageBase, activityObjs, componentObjs) {

    //如果返回值是false,则是算热点处理行为
    var falg = false;

    //content类型
    activityObjs && _.each(activityObjs, function (obj) {
      if (obj.stop && obj.stop()) {
        falg = true;
      }
    });

    //零件类型
    componentObjs && _.each(componentObjs, function (obj) {
      if (obj.stop && obj.stop()) {
        falg = true;
      }
    });

    return falg;
  });
}

/**
 *
 *  动作对象
 *      1 跳转页面
 *      2 打开系统程序
 *      3 加载子文档
 *
 */

/**
 * 跳转页面
 * @param  {[type]} para1 [description]
 * @return {[type]}       [description]
 */
var toPage = function toPage(para1) {
  para1 = JSON.parse(para1);
  if (para1.seasonId) {
    Xut.View.GotoSlide(para1.seasonId, para1.chapterId);
  } else {
    //向下兼容
    Xut.View.GotoSlide(para1);
  }
};

function Action$2(data) {
  var id = parseInt(data.id);
  var results = Xut.data.query('Action', id, 'activityId');
  var para1 = results.para1; //跳转参数
  var actionType = parseInt(results.actionType);
  if (actionType == 0) {
    toPage(para1);
  }
}

/**
 * 动作热点
 * 1. 跳转页面
 * 2. 打开系统应用程序
 */
var Action$1 = {
  createDom: function createDom(_ref, chpaterData, chapterId, pageIndex, zIndex, pageType) {
    var _id = _ref._id,
        md5 = _ref.md5,
        actType = _ref.actType,
        scaleWidth = _ref.scaleWidth,
        scaleHeight = _ref.scaleHeight,
        scaleTop = _ref.scaleTop,
        scaleLeft = _ref.scaleLeft;

    return String.styleFormat('<div id="' + (actType + "_" + _id) + '"\n            data-belong="' + pageType + '"\n            data-delegate="action"\n            style="cursor:pointer;\n                   width:' + scaleWidth + 'px;\n                   height:' + scaleHeight + 'px;\n                   left:' + scaleLeft + 'px;\n                   top:' + scaleTop + 'px;\n                   background-size:100% 100%;\n                   position:absolute;\n                   z-index:' + zIndex + ';\n            ' + (md5 ? "background-image: url(" + getFileFullPath(md5, 'hot-action') + ");" : '') + '">\n      </div>');
  }

  /*
   * touchEnd 全局派发的点击事件
   * 如果stopGlobalEvent == ture 事件由全局派发
   */

  ,
  trigger: function trigger(data) {
    Action$2(data);
  }
};

//临时音频动作数据
var tempData = {};

//音频按钮尺寸
var mediaIconSize = 74;

/**
 * 仅创建一次
 * data传递参数问题
 * @param  {[type]} id [description]
 * @return {[type]}    [description]
 */
var onlyCreateOnce = function onlyCreateOnce(id) {
  var data = tempData[id];
  if (data) {
    delete tempData[id];
    return data;
  }
};

var Media = {
  createDom: function createDom(_ref, chpaterData, chapterId, pageIndex, zIndex, pageType) {
    var _id = _ref._id,
        md5 = _ref.md5,
        actType = _ref.actType,
        category = _ref.category,
        itemArray = _ref.itemArray,
        scaleWidth = _ref.scaleWidth,
        scaleHeight = _ref.scaleHeight,
        scaleTop = _ref.scaleTop,
        scaleLeft = _ref.scaleLeft;


    //如果没有宽高则不创建绑定节点
    if (!scaleWidth || !scaleHeight) return '';

    var display = void 0;
    var startImage = void 0;
    var startScript = void 0;
    var stopImage = void 0;
    var stopScript = void 0;
    var mediaIcon = '';

    //解析音乐动作
    if (itemArray) {

      itemArray = parseJSON(itemArray);

      /**
       * 老模式
       *      "itemArray": "[\r\n  {\r\n    \"startImg\": \"027c3803a38237ad567484bbe42385df.png\"\r\n  },\r\n  {\r\n    \"stopImg\": \"676183f05ef671b9ba3609ec762f9e5e.png\"\r\n  }"
       *
       *  */
      if (itemArray.length) {
        var start = itemArray[0];
        var stop = itemArray[1];
        /*音频Action参数*/
        if (start) {
          startImage = start.startImg ? start.startImg : '';
          startScript = start.script ? start.script : '';
        }
        if (stop) {
          stopImage = start.stopImg ? start.stopImg : '';
          stopScript = stop.script ? start.script : '';
        }
      } else {
        /*
        新模式
         itemArray:{
           startImage:'027c3803a38237ad567484bbe42385df.png',
           stopImage:'676183f05ef671b9ba3609ec762f9e5e.png',
           startScript:'',
           stopScript:'',
           zIndex:12,
           display:'hidden'
         }
        */
        zIndex = itemArray.zIndex;
        display = itemArray.display;
        startImage = itemArray.startImage;
        startScript = itemArray.startScript;
        stopImage = itemArray.stopImage;
        stopScript = itemArray.stopScript;
      }

      /*音频Action动作数据*/
      tempData[_id] = {};
      if (startImage) {
        tempData[_id]['startImage'] = startImage;
        startImage = 'background-image:url(' + getFileFullPath(startImage, 'hot-media') + ');';
      }
      if (startScript) {
        tempData[_id]['startScript'] = startScript;
      }
      if (stopImage) {
        tempData[_id]['stopImage'] = stopImage;
        stopImage = 'background-image:url(' + getFileFullPath(stopImage, 'hot-media') + ');';
      }
      if (stopScript) {
        tempData[_id]['stopScript'] = stopScript;
      }
    }

    //只针对网页插件增加单独的点击界面
    //如果有视频图标
    if (category == 'webpage' && scaleWidth > 200 && scaleHeight > 100 && scaleWidth <= config.visualSize.width && scaleHeight <= config.visualSize.height) {
      mediaIcon = '<div id="icon_' + _id + '"\n              type="icon"\n              style="width:' + mediaIconSize + 'px;\n                     height:' + mediaIconSize + 'px;\n                     top:' + (scaleHeight - mediaIconSize) / 2 + 'px;\n                     left:' + (scaleWidth - mediaIconSize) / 2 + 'px;\n                     position:absolute;background-image:url(images/icons/web_hotspot.png)">\n         </div>';
    }

    //首字母大写
    var mediaType = titleCase(category);

    /*默认状态*/
    var imageBackground = startImage || '';

    /*
    音频在创建dom的时候需要查下
    这个hot对象是否已经被创建过
    如果创建过，那么图标状态需要处理
    */
    if (hasHotAudioPlay(chapterId, _id)) {
      imageBackground = stopImage;
    }

    /*
    查找视频音频是否被浮动到页面,这个很特殊的处理
    需要把节点合并到content种一起处理浮动对象
     */
    var hasFloat = false;
    var mediaData = getMediaData(mediaType, _id);
    if (mediaData && mediaData.isfloat) {
      hasFloat = true;
    }

    /*是否隐藏,如果隐藏通过脚本调用*/
    var visibility = display === 'hidden' ? "visibility:hidden;" : '';

    //创建音频对象
    //Webpage_1
    //Audio_1
    //Video_1
    var html = String.styleFormat('<div id="' + (mediaType + "_" + _id) + '"\n            data-belong="' + pageType + '"\n            data-delegate="' + category + '"\n            style="width:' + scaleWidth + 'px;\n                   height:' + scaleHeight + 'px;\n                   left:' + scaleLeft + 'px;\n                   top:' + scaleTop + 'px;\n                   z-index:' + zIndex + ';\n                   ' + visibility + '\n                   ' + imageBackground + '\n                   background-size:100% 100%;\n                   position:absolute;">\n            ' + mediaIcon + '\n       </div>');

    return {
      html: html,
      hasFloat: hasFloat
    };
  }

  /**
   * 自动运行
   * @param  {[type]} data [description]
   * @return {[type]}      [description]
   */

  ,
  autoPlay: function autoPlay(_ref2) {
    var id = _ref2.id,
        pageType = _ref2.pageType,
        category = _ref2.category,
        rootNode = _ref2.rootNode,
        pageIndex = _ref2.pageIndex,
        chapterId = _ref2.chapterId;

    if (!category) return;
    if (category == 'audio') {
      autoAudio(chapterId, id, onlyCreateOnce(id));
    } else {
      /*通过id搜索*/
      rootNode = rootNode.closest('#' + Xut.View.GetPageNodeIdName(pageType, pageIndex, chapterId));
      if (!rootNode.length) {
        /*自动ppt视频，是采用的li父节点，所以这里需要处理下*/
        rootNode = rootNode.closest('li');
      }
      autoVideo({
        pageType: pageType,
        rootNode: rootNode,
        chapterId: chapterId,
        pageIndex: pageIndex,
        'activityId': id
      });
    }
  }

  /**
   * touchEnd 全局派发的点击事件
   * 如果stopGlobalEvent == ture 事件由全局派发
   * isColumn 流式排版触发的媒体
   */

  ,
  trigger: function trigger(_ref3) {
    var id = _ref3.id,
        target = _ref3.target,
        rootNode = _ref3.rootNode,
        pageIndex = _ref3.pageIndex,
        activityId = _ref3.activityId,
        _ref3$columnData = _ref3.columnData,
        columnData = _ref3$columnData === undefined ? {} : _ref3$columnData;


    /*************
      流式布局处理
    **************/
    if (columnData.isColumn) {
      if (columnData.type === 'Audio') {
        triggerAudio({
          activityId: activityId,
          columnData: columnData,
          chapterId: columnData.chapterId,
          data: onlyCreateOnce(id)
        });
      } else {
        triggerVideo({
          chapterId: columnData.chapterId,
          columnData: columnData,
          activityId: activityId,
          rootNode: rootNode,
          pageIndex: pageIndex
        });
      }
      return;
    }

    /*************
      PPT页面处理
    **************/
    var category = target.getAttribute('data-delegate');
    if (category) {
      /*音频点击可以是浮动母版了，所以这里必须要明确查找chapter属于的类型页面*/
      var pageType = target.getAttribute('data-belong');
      var chapterId = Xut.Presentation.GetPageId(pageType, pageIndex);
      if (category == 'audio') {
        triggerAudio({
          chapterId: chapterId,
          activityId: activityId,
          data: onlyCreateOnce(id)
        });
      } else {
        triggerVideo({
          chapterId: chapterId,
          activityId: activityId,
          rootNode: rootNode,
          pageIndex: pageIndex,
          pageType: pageType
        });
      }
    }
  }

  /*销毁数据*/

  ,
  destory: function destory() {}
};

/**
 * 路径地址
 * @param  {[type]} name [description]
 * @return {[type]}      [description]
 */
function path$2(fileName, widgetId) {
  return config.getWidgetPath() + widgetId + '/' + fileName;
}

/**
 * 去重加载处理
 */
var toRepeat = {};

var add = function add(path, callback) {
  //去重复处理
  //可能同时执行了多个同样的js文件加载
  if (!toRepeat[path]) {
    toRepeat[path] = [];
  }
  toRepeat[path].push(callback);
  if (toRepeat[path].length > 1) {
    return;
  }
  loadFile(path, function () {
    _.each(toRepeat[path], function (fn) {
      fn && fn();
    });
    toRepeat[path] = null;
    delete toRepeat[path];
  });
};

function removeFileLoad() {
  toRepeat = {};
}

/**
 * 加载js,css文件
 * @return {[type]} [description]
 */
function fileLoad(callback, base) {
  var jsPath,
      cssPath,
      completeCount,
      widgetId = base.widgetId,

  //定义css,js的命名
  jsName = base.widgetName + '.min.js',
      cssName = base.widgetType == 'page' || base.widgetType == 'js' ? 'style.min.css' : 0;

  //需要等待完成
  var completeCount = function () {
    var count = 0;
    jsName && count++;
    cssName && count++;
    return function () {
      if (count === 1) {
        return callback && callback.call(base);
      }
      count--;
    };
  }();

  //加载css
  if (cssName) {
    cssPath = path$2(cssName, widgetId);
    add(cssPath, completeCount);
  }

  //加载js
  if (jsName) {
    jsPath = path$2(jsName, widgetId);
    add(jsPath, completeCount);
  }
}

/**
 * 创建数据
 * @return {[type]} [description]
 */
function createData(outputPara, scrollPaintingMode, calculate) {
  var item,
      field,
      source = [],
      images = Xut.data['Image'],
      token = null,
      items = outputPara.source;

  for (item in items) {
    if (items.hasOwnProperty(item)) {
      field = {};
      token = images.item((parseInt(items[item]) || 1) - 1);
      field['img'] = token.md5;
      field['thumb'] = '';
      field['title'] = token.imageTitle;
      source.push(field);
    }
  }

  outputPara.source = source;
  outputPara.scrollPaintingMode = scrollPaintingMode;
  outputPara.calculate = calculate;

  /**
   * 2016.8.3
   * 给妙妙学的js零件增加前缀
   * @type {[type]}
   */
  outputPara.rootPath = Xut.config.getWidgetPath();

  return outputPara;
}

/**
 * 眷顾区域扩展
 * @type {Boolean}
 */

var ScrollArea = function () {
  function ScrollArea(data, options) {
    classCallCheck(this, ScrollArea);

    this.data = data;
    this.options = options;
    this.scrolls = [];
    this._init();
  }

  createClass(ScrollArea, [{
    key: '_init',
    value: function _init() {
      var content = this.options;
      var prefix = this.data.contentPrefix;
      //创建多个眷滚区域
      for (var i = 0; i < content.length; i++) {
        var iscroll = this._create(content[i], prefix);
        if (iscroll) {
          this.scrolls.push(iscroll);
        }
      }
    }
  }, {
    key: '_createWrapper',
    value: function _createWrapper() {
      return String.styleFormat('<div data-type="area-wrapper" style="position:absolute;width:100%; height:100%;overflow:hidden;">\n          <ul data-type="area-scroller"\n               data-behavior="disable"\n               style="position:absolute; width:100%; height:100%;overflow:hidden;">\n          </ul>\n       </div>');
    }
  }, {
    key: '_create',
    value: function _create(content, prefix) {

      var contentId = content.id;
      var contentName = prefix + contentId;

      var theTitle = parseJSON(content.theTitle);

      //data-widgetscrollareaList
      //data-widgetscrollareascrolltype
      var obj = theTitle["data-widgetscrollareaList"].split(",");
      if (obj.length == 0) {
        return;
      }

      var contentPanle = $("#" + contentName);
      if (contentPanle.length == 0) {
        console.log(contentId + "not find obj");
        return;
      }

      var scrolltype = theTitle["data-widgetscrollareascrolltype"] ? theTitle["data-widgetscrollareascrolltype"] : "xy";

      //滚动的方向
      //x / y /xy
      scrolltype = scrolltype.toLowerCase();
      var scrollX = scrolltype.indexOf("x") > -1;
      var scrollY = scrolltype.indexOf("y") > -1;

      var $wrapper = void 0;

      //如果来回翻页
      //因为子节点的排列关系已经被改变
      //所以这里直接处理事件
      var hasIscroll = contentPanle.attr("data-iscroll");
      if (hasIscroll) {
        //需要滚动条
        if (hasIscroll === 'visible') {
          $wrapper = contentPanle.children('div[data-type="area-wrapper"]');
          return this._bindIscroll($wrapper[0], scrollX, scrollY, contentId);
        }
        //hidden
        return;
      }

      //去掉默认行为
      Xut.Contents.ResetDefaultControl("page", contentName, "");

      var contentSize = {
        x: parseInt(contentPanle.css("left")),
        y: parseInt(contentPanle.css("top")),
        w: parseInt(contentPanle.css("width")),
        h: parseInt(contentPanle.css("height"))
      };

      var size = this._getSize(obj, prefix);
      var min = size.min;
      var max = size.max;

      //创建容器
      $wrapper = $(this._createWrapper());

      //滚动容器
      var $scroller = $wrapper.children();
      contentPanle.append($wrapper);

      //设置滚动容器宽高
      this._setScrollerStyle(max, min, contentSize, scrollX, scrollY, $scroller);

      //重置各个content的left top值 并得到
      //x轴方向卷滚：snap容器的宽度 个数以及每个snap容器包含的content个数
      //y轴方向卷滚：snap容器的高度 个数以及每个snap容器包含的content个数
      var colsObj = this._resetContents(obj, prefix, contentSize, scrollX, scrollY, min);

      //创建snap容器
      var snapContainer = this._createSnapContainer(colsObj, $scroller, contentId, scrollX, scrollY);

      //将content添加到snap容器中
      if (scrollX) {
        for (var j = 0; j < obj.length; j++) {
          var childId = prefix + obj[j];
          var childObj = $("#" + childId);
          childObj.appendTo(snapContainer[Math.floor(j / colsObj.contentsPerSnapX)]);
        }
      }

      if (scrollY) {
        for (var j = 0; j < obj.length; j++) {
          var childId = prefix + obj[j];
          var childObj = $("#" + childId);
          childObj.appendTo(snapContainer[Math.floor(j / colsObj.contentsPerSnapY)]);
        }
      }

      //如果不满足溢出条件
      var $areaScroller = snapContainer.parent();
      if (scrollX) {
        var snapContainerWidth = parseInt($areaScroller.css('width'));
        if (snapContainerWidth < contentSize.w) {
          scrollX = false;
        }
      }
      if (scrollY) {
        var snapContainerHeight = parseInt($areaScroller.css('height'));
        if (snapContainerHeight < contentSize.h) {
          scrollY = false;
        }
      }

      if (scrollY || scrollX) {
        contentPanle.attr("data-iscroll", "visible");
        //只存在一屏 需要卷滚时 不要要snap
        if (snapContainer.length == 1) {
          return this._bindIscroll($wrapper[0], scrollX, scrollY);
        }
        return this._bindIscroll($wrapper[0], scrollX, scrollY, contentId);
      } else {
        contentPanle.attr("data-iscroll", "hidden");
      }
    }
  }, {
    key: '_bindIscroll',
    value: function _bindIscroll(wrapper, hasScrollX, hasScrollY, contentId) {
      if (contentId) {
        return IScroll(wrapper, {
          scrollX: hasScrollX ? true : false,
          scrollY: hasScrollY ? true : false,
          snap: ".contentsContainer" + contentId,
          scrollbars: 'custom',
          probeType: 2
        });
      } else {
        return IScroll(wrapper, {
          scrollX: hasScrollX ? true : false,
          scrollY: hasScrollY ? true : false,
          scrollbars: 'custom',
          probeType: 2
        });
      }
    }
  }, {
    key: '_getSize',
    value: function _getSize(objIds, prefix) {
      //最大区间
      var max = {
        l: null,
        t: null

        //最小区间
      };var min = {
        l: null,
        t: null
      };

      var obj = void 0;
      for (var i = 0; i < objIds.length; i++) {
        obj = $("#" + prefix + objIds[i]);
        if (obj.length == 0) {
          console.log(objIds[i] + " not find");
          continue;
        }
        var width = parseInt(obj.css("width"));
        var left = parseInt(obj.css("left"));
        var height = parseInt(obj.css("height"));
        var top = parseInt(obj.css("top"));

        //获取最小区间
        var xMin = left;
        var yMin = top;
        if (min.l == null || min.l > xMin) {
          min.l = xMin;
        }
        if (min.t == null || min.t > yMin) {
          min.t = yMin;
        }

        //获取最大元素的值
        var xMax = width + left;
        var yMax = height + top;
        if (max.l == null || max.l < xMax) {
          max.l = xMax;
        }
        if (max.t == null || max.t < yMax) {
          max.t = yMax;
        }
      }

      return {
        min: min,
        max: max
      };
    }

    /**
     * 设置scroller标签的宽高
     * @param {[type]} max         [description]
     * @param {[type]} min         [description]
     * @param {[type]} contentSize [description]
     * @param {[type]} scrollX     [description]
     * @param {[type]} scrollY     [description]
     * @param {[type]} $scroller   [description]
     */

  }, {
    key: '_setScrollerStyle',
    value: function _setScrollerStyle(max, min, contentSize, scrollX, scrollY, $scroller) {
      var width = 0;
      var height = 0;
      var start = { x: 0, y: 0 };
      var end = { x: 0, y: 0 };

      if (min.l < contentSize.x) {
        start.x = min.l;
      } else {
        start.x = contentSize.x;
      }

      if (min.t < contentSize.y) {
        start.y = min.t;
      } else {
        start.y = contentSize.y;
      }

      if (max.l > contentSize.x + contentSize.w) {
        end.x = max.l;
      } else {
        end.x = contentSize.x + contentSize.w;
      }

      if (max.t > contentSize.y + contentSize.h) {
        end.y = max.t;
      } else {
        end.y = contentSize.y + contentSize.h;
      }

      if (!scrollX && end.x - start.x > contentSize.w) {
        width = contentSize.w;
      } else {
        width = end.x - start.x;
      }

      if (!scrollY && end.y - start.y > contentSize.h) {
        height = contentSize.h;
      } else {
        height = end.y - start.y;
      }

      $scroller.css({
        width: width + "px",
        height: height + "px"
      });
    }

    /**
     * 重设各个子content的left top值 以包裹他们的父容器为基准
     * 并且得到snapContainer的个数 宽度 以及每个snapContainer中可以放的content个数
     */

  }, {
    key: '_resetContents',
    value: function _resetContents(obj, prefix, contentSize, scrollX, scrollY, min) {
      var contentsPerSnapX = void 0,
          contentsPerSnapY = void 0,
          snapXCount = void 0,
          snapYCount = void 0,
          snapContainerWidth = void 0,
          snapContainerHeight = void 0;

      var contentsXTemp = 0;
      var contentsYTemp = 0;
      var leftArray = new Array();
      var topArray = new Array();

      var contentsLength = obj.length;

      for (var j = 0; j < contentsLength; j++) {
        var childId = prefix + obj[j];
        var childObj = $("#" + childId);

        Xut.Contents.ResetDefaultControl("page", childId, "");
        if (childObj.attr("data-iscroll") == "true") {
          continue;
        }

        var childLeft = parseInt(childObj.css("left"));
        var childTop = parseInt(childObj.css("top"));
        var childWidth = parseInt(childObj.css("width"));

        if (min.l < contentSize.x && scrollX) {
          childLeft = childLeft - min.l;
        } else {
          childLeft = childLeft - contentSize.x;
        }

        if (min.t < contentSize.y && scrollY) {
          childTop = childTop - min.t;
        } else {
          childTop = childTop - contentSize.y;
        }

        childObj.css("left", childLeft);
        childObj.css("top", childTop);

        leftArray.push(childLeft);
        topArray.push(childTop);

        childObj.css("visibility", "inherit");
        childObj.attr("data-iscroll", "true");
      }

      //将left值进行冒泡排序处理 以便后面比较left值与content宽之间的大小 确定一个snap容器中可以放几个content以及snap容器的宽度
      //将top值进行冒泡排序处理 以便后面比较top值与content高之间的大小 确定一个snap容器中可以放几个content以及snap容器的高度
      leftArray = this._bubbleSort(leftArray);
      topArray = this._bubbleSort(topArray);

      //x轴卷滚
      if (scrollX) {
        for (var i = 0; i < leftArray.length; i++) {
          var temp = leftArray[i];
          if (temp < contentSize.w) {
            contentsXTemp++;
          } else {
            if (!contentsPerSnapX) {
              contentsPerSnapX = contentsXTemp;
              snapContainerWidth = temp;
            }
          }
        }

        //无需创建卷滚
        if (!contentsPerSnapX) {
          contentsPerSnapX = obj.length;
          snapXCount = 1;
          snapContainerWidth = contentSize.w;
        } else {
          snapXCount = Math.ceil(obj.length / contentsPerSnapX);
        }
      }

      //y轴卷滚
      if (scrollY) {
        for (var i = 0; i < topArray.length; i++) {
          var temp = topArray[i];
          //contentSize.h 有1px的差距，在不同设备下
          //导致布局出错，所以这里减去1
          if (temp < contentSize.h - 1) {
            contentsYTemp++;
          } else {
            if (!contentsPerSnapY) {
              contentsPerSnapY = contentsYTemp;
              snapContainerHeight = temp;
            }
          }
        }

        //得到卷滚区域一行可以放多少列
        var colsPerRow = 1;
        for (var k = 0; k < contentsLength; k++) {
          var childId = prefix + obj[k];
          var childObj = $("#" + childId);
          var childTop = parseInt(childObj.css("top"));
          if (k > 0) {
            var prevChildId = prefix + obj[k - 1];
            var prevChildObj = $("#" + prevChildId);
            var prevChildTop = parseInt(prevChildObj.css("top"));
            if (childTop < prevChildTop + 10) {
              colsPerRow++;
            } else {
              break;
            }
          }
        }

        //无需创建卷滚
        if (!contentsPerSnapY) {
          contentsPerSnapY = Math.floor(obj.length / colsPerRow) + 1; ////在不需要卷滚的条件下 只会存在一个snap snap中的行数由content的总数/每行的个数 +1
          snapYCount = 1;
          snapContainerHeight = contentSize.h;
        } else {
          snapYCount = Math.ceil(obj.length / contentsPerSnapY);
        }
      }

      return {
        contentsPerSnapX: contentsPerSnapX,
        snapXCount: snapXCount,
        snapContainerWidth: snapContainerWidth,
        contentsPerSnapY: contentsPerSnapY,
        snapYCount: snapYCount,
        snapContainerHeight: snapContainerHeight
      };
    }

    /**
     * 冒泡排序
     * @param  {[type]} array [description]
     * @return {[type]}       [description]
     */

  }, {
    key: '_bubbleSort',
    value: function _bubbleSort(array) {
      for (var i = 0; i < array.length - 1; i++) {
        for (var j = 0; j < array.length - 1 - i; j++) {
          if (array[j] > array[j + 1]) {
            var temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
          }
        }
      }
      return array;
    }

    /**
     * 创建snapContainer并添加到scroller中
     * @param  {[type]} colsObj   [description]
     * @param  {[type]} $scroller [description]
     * @param  {[type]} contentId [description]
     * @return {[type]}           [description]
     */

  }, {
    key: '_createSnapContainer',
    value: function _createSnapContainer(colsObj, $scroller, contentId, scrollX, scrollY) {
      var snapContainer = '';

      if (scrollX) {
        var scrollerWidth = parseInt($scroller.css("width"));
        var snapXCount = colsObj.snapXCount;
        var snapContainerWidth = colsObj.snapContainerWidth;
        var lastSnapContainerWidth = scrollerWidth - (snapXCount - 1) * snapContainerWidth;
        var containerWidth = void 0;
        for (var i = 0; i < colsObj.snapXCount; i++) {
          //最后一个snap容器的宽度需要单独设置 否则可能所有的snap容器宽度和会大于scroller的宽度
          if (i == colsObj.snapXCount - 1) {
            containerWidth = lastSnapContainerWidth;
          } else {
            containerWidth = snapContainerWidth;
          }
          snapContainer += '<li class="contentsContainer' + contentId + '"\n                              style=\'width:' + containerWidth + 'px;height:100%;float:left;\'>\n                          </li>';
        }
      }
      //Y轴滚动
      else if (scrollY) {
          var scrollerHeight = parseInt($scroller.css("height"));
          var snapYCount = colsObj.snapYCount;
          var snapContainerHeight = colsObj.snapContainerHeight;
          var lastSnapContainerHeight = scrollerHeight - (snapYCount - 1) * snapContainerHeight;
          for (var i = 0; i < colsObj.snapYCount; i++) {
            snapContainer += '<li class="contentsContainer' + contentId + '"\n                              style=\'height:' + snapContainerHeight + 'px;width:100%;float:left;\'>\n                          </li>';
          }
        }

      snapContainer = $(snapContainer);
      snapContainer.appendTo($scroller);
      return snapContainer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.scrolls.length) {
        for (var i = 0; i < this.scrolls.length; i++) {
          var obj = this.scrolls[i];
          if (obj) {
            obj.scrollTo(0, 0);
            obj.destroy();
          }
          this.scrolls[i] = null;
        }
        this.scrolls = null;
      }
      this.data.container = null;
      this.options = null;
    }
  }]);
  return ScrollArea;
}();

/********************************************************************
 *
 *                  创建所有的JS页面零件类
 *                  1 js
 *                  2 page
 *                  3 svg
 *                  4 canvas
 *                  5 webgL
 *
 * *******************************************************************/

/**
 * 解析数据,获取content对象
 * @return {[type]} [description]
 */
function parseContentObjs(pageType, inputPara, pageProportion) {
  var contentIds = [];
  inputPara.content && _.each(inputPara.content, function (contentId) {
    contentIds.push(contentId);
  });
  return Xut.Contents.GetPageWidgetData(pageType, contentIds, pageProportion);
}

/**
 * 页面零件
 * @param {[type]} data [description]
 */

var PageWidget = function () {
  function PageWidget(data) {
    classCallCheck(this, PageWidget);

    _.extend(this, data);
    this.pageObj = null;
    this._init();
  }

  /**
   * 初始化,加载文件
   * @return {[type]} [description]
   */


  createClass(PageWidget, [{
    key: '_init',
    value: function _init() {
      //滚动区域
      if (this.widgetId == 60 && this.widgetName == "scrollarea") {
        var arg = this._getOptions();
        var resetStyle = this._resetOpacityVisibility(arg[0], arg[1]);
        this.pageObj = new ScrollArea(arg[0], arg[1]);
        //还原原有样式
        _.each(resetStyle, function (resetFunction, value) {
          resetFunction();
        });
        resetStyle = null;
      }
      //Load the localized code first
      //Combined advanced Sprite
      else if (this.widgetId == 72 && this.widgetName == "spirit") {
          var arg = this._getOptions();
          this.pageObj = AdvSprite(arg[0], arg[1]);
        }
        //直接扩展加载
        else {
            //If there is no
            if (typeof window[this.widgetName + "Widget"] != "function") {
              this.hasload = true;
              fileLoad(this._executive, this);
            } else {
              this._executive();
            }
          }
    }

    /**
     * 获取参数
     * 得到content对象与数据
     * @return {[type]} [description]
     */

  }, {
    key: '_getOptions',
    value: function _getOptions() {
      return [createData(this.inputPara, this.scrollPaintingMode, this.calculate), parseContentObjs(this.pageType, this.inputPara, this.pageProportion)];
    }

    /**
     * 元素隐藏状态下，绑定iScroll获取高度是有问题
     * 所以这里需要补丁方式修正一下
       让其不可见，但是可以获取高度 存在卷滚区域 第一个子元素最开始也要修改样式
       修改第一个子元素样式后 在初始化卷滚条后不是将第一个子元素的visibility还原为
       其最开始的状态，而是跟scroll.area.js中346行一样的值
     * @return {[type]} [description]
     */

  }, {
    key: '_resetOpacityVisibility',
    value: function _resetOpacityVisibility(firstArg, secondArg) {
      var resetStyle = new Array();

      var _loop = function _loop() {
        var content = secondArg[i];
        var $parentNode = $("#" + content.idName);
        var visible = $parentNode.css('visibility');
        //元素隐藏状态下，绑定iScroll获取高度是有问题
        //所以这里需要补丁方式修正一下
        //让其不可见，但是可以获取高度 存在卷滚区域 只有第一个卷滚区域的第一个子元素最开始也要修改样式
        if (visible == 'hidden') {
          if (i == 0) {
            //第一个卷滚区域的第一个子元素样式修改 如果不改的话 强制显示后他会显示出来 出现闪图现象
            var parent = secondArg[0];
            var prefix = firstArg.contentPrefix;
            var contentName = void 0,
                $firstChild = void 0;
            var theTitle = parseJSON(parent.theTitle);
            var obj = theTitle["data-widgetscrollareaList"].split(",");
            if (obj[0]) {
              contentName = prefix + obj[0];
              $firstChild = $("#" + contentName);
              $firstChild.css('visibility', "hidden");
            }

            var firstChildTemp = function firstChildTemp() {
              $firstChild.css('visibility', "inherit");
            };
            resetStyle.push(firstChildTemp);
          }

          var opacity = $parentNode.css('opacity');
          var setStyle = function setStyle(key, value) {
            arguments.length > 1 ? $parentNode.css(key, value) : $parentNode.css(key);
          };
          //如果设置了不透明,则简单设为可见的
          //否则先设为不透明,再设为可见
          if (opacity == 0) {
            setStyle('visibility', 'visible');
            var temp = function temp() {
              setStyle('visibility', visible);
            };
            resetStyle.push(temp);
          } else {
            setStyle({
              'opacity': 0,
              'visibility': 'visible'
            });
            var _temp = function _temp() {
              setStyle({
                'visibility': visible,
                'opacity': opacity

              });
            };
            resetStyle.push(_temp);
          }
        }
      };

      for (var i = 0; i < secondArg.length; i++) {
        _loop();
      }

      return resetStyle;
    }

    /**
     * 执行函数
     * @return {[type]} [description]
     */

  }, {
    key: '_executive',
    value: function _executive() {
      if (typeof window[this.widgetName + "Widget"] == "function") {
        var arg = this._getOptions();
        this.pageObj = new window[this.widgetName + "Widget"](arg[0], arg[1]);
      } else {
        console.error("Function [" + this.widgetName + "Widget] does not exist.");
      }
    }

    /**
     * 动画运行
     * @return {[type]} [description]
     */

  }, {
    key: 'play',
    value: function play() {
      return this.pageObj.play();
    }

    /**
     * 外部切换调用接口
     * @return {[type]} [description]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      this.pageObj && this.pageObj.toggle && this.pageObj.toggle();
    }

    /**
     * 动作停止接口
     * @return {[type]} [description]
     */

  }, {
    key: 'stop',
    value: function stop() {
      this.pageObj && this.pageObj.stop && this.pageObj.stop();
    }

    /**
     * 销毁页面零件
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.hasload && removeFileLoad();
      this.pageObj && this.pageObj.destroy && this.pageObj.destroy();
    }
  }]);
  return PageWidget;
}();

/*
混入图片数据
 */
function mixData(inputPara) {
  var _ref = [undefined],
      item = _ref[0],
      field = _ref[1],
      token = _ref[2];

  var source = [];
  var images = Xut.data['Image'];
  var items = inputPara.source;
  for (item in items) {
    if (items.hasOwnProperty(item)) {
      field = {};
      token = images.item((parseInt(items[item]) || 1) - 1);
      field['img'] = '../gallery/' + token.md5;
      field['thumb'] = '';
      field['title'] = token.imageTitle;
      source.push(field);
    }
  }
  inputPara.source = source;
  return inputPara;
}

/**
 * 创建iframe零件包装器
 */

var iframeWidget = function () {
  function iframeWidget(data) {
    var _this = this;

    classCallCheck(this, iframeWidget);

    _.extend(this, data);
    this._$wapper = this._createWapper();
    Xut.nextTick({ 'container': this.rootNode, 'content': this._$wapper }, function () {
      _this.rootNode = null;
      _this._bindMessage();
    });
    return this;
  }

  createClass(iframeWidget, [{
    key: '_createWapper',
    value: function _createWapper() {
      if (this.zIndex !== 0) {
        this.zIndex = this.zIndex || Xut.zIndexlevel();
      }
      this._$iframe = this._createIframe();
      return $(String.styleFormat('<div id="widget_iframe_' + this.id + '"\n            style="z-index:' + this.zIndex + ';\n                   width:' + this.width + 'px;\n                   height:' + this.height + 'px;\n                   top:' + this.top + 'px;\n                   left:' + this.left + 'px;\n                   position:absolute;">\n       </div>')).append(this._$iframe);
    }
  }, {
    key: '_createIframe',
    value: function _createIframe() {
      var _this2 = this;

      var ifr = document.createElement('iframe');
      var path = config.data.rootPath + '/widget/' + this.widgetId + '/index.html?xxtParaIn=' + this.key;
      ifr.id = 'iframe_' + this.id;
      ifr.src = path;
      ifr.style.width = '100%';
      ifr.style.height = '100%';
      ifr.sandbox = "allow-scripts allow-same-origin";
      ifr.frameborder = 0;
      if (ifr.attachEvent) {
        ifr.attachEvent('onload', function () {
          _this2._iframeComplete();
        });
      } else {
        ifr.onload = function () {
          _this2._iframeComplete();
        };
      }
      return ifr;
    }
  }, {
    key: '_iframeComplete',
    value: function _iframeComplete() {
      var dataSource = mixData(this.inputPara);
      var width = this._$iframe.offsetWidth;
      var height = this._$iframe.offsetHeight;
      if (dataSource.screenSize.width * 0.98 <= width && dataSource.screenSize.height * 0.98 <= height) {
        Xut.View.Toolbar({ show: 'button', hide: 'controlBar' });
      } else if (dataSource.screenSize.width * 0.7 <= width && dataSource.screenSize.height * 0.7 <= height) {
        Xut.View.Toolbar({ show: 'button' });
      }
      PMS.send({
        target: this._$iframe.contentWindow,
        origin: '*',
        type: 'loadData',
        data: dataSource,
        success: function success() {},
        error: function error() {}
      });
      this.state = true;
    }

    /*与iframe通讯接口*/

  }, {
    key: '_bindMessage',
    value: function _bindMessage() {
      var _this3 = this;

      var markId = this.id;
      var $wapper = this._$wapper;
      var $iframe = $(this._$iframe);

      //隐藏widget
      PMS.bind("onHideWapper" + markId, function () {
        $wapper.hide();
        _this3.state = false;
      }, '*');

      /*全屏操作*/
      PMS.bind("onFullscreen" + markId, function (e) {
        if (!$iframe.length) return;

        /*关闭视频*/
        clearVideo();
        $wapper.css({ width: '100%', height: '100%', zIndex: Xut.zIndexlevel(), top: 0, left: 0 });

        /*Widget全屏尺寸自动调整*/
        if (e.full == false) {
          var body = document.body,
              width = parseInt(body.clientWidth),
              height = parseInt(body.clientHeight),
              rote = _this3.width / _this3.height,
              getRote = function getRote(width, height, rote) {
            var w = width,
                h = width / rote;
            if (h > height) {
              h = height;
              w = h * rote;
            }
            return {
              w: parseInt(w),
              h: parseInt(h)
            };
          },
              size = getRote(width, height, rote),
              left = (width - size.w) / 2,
              top = (height - size.h) / 2;
          $iframe.css({ width: size.w, height: size.h, position: 'absolute', top: top, left: left });
        }

        /*隐藏工作条*/
        Xut.View.Toolbar("hide");
      }, '*');

      /*全屏还原*/
      PMS.bind("onReset" + markId, function () {
        if (!$iframe.length) return;
        $wapper.css({
          zIndex: _this3.zIndex,
          width: _this3.width + 'px',
          height: _this3.height + 'px',
          top: _this3.top + 'px',
          left: _this3.left + 'px'
        });
        $iframe.css({ width: '100%', height: '100%', position: '', top: '0', left: '0' });
        Xut.View.Toolbar("show");
      }, '*');

      /*隐藏工作条*/
      PMS.bind("onHideToolbar" + markId, function () {
        Xut.View.HideToolBar();
      }, '*');

      /*跳转页面*/
      PMS.bind('scrollToPage' + markId, function (data) {
        Xut.View.GotoSlide(data['ppts'], data['pageIndex']);
      }, '*');
    }

    /*发送消息通知*/

  }, {
    key: '_send',
    value: function _send(type) {
      PMS.send({
        type: type,
        origin: '*',
        target: this._$iframe.contentWindow,
        url: this._$iframe.src,
        success: function success() {}
      });
    }

    /*处理包装容器的状态*/

  }, {
    key: '_perform',
    value: function _perform(type, state) {
      var _this4 = this;

      if (this.state) {
        this._$wapper.hide();
      } else {
        this._$wapper.show();
      }
      this._send(type);
      setTimeout(function () {
        _this4.state = state;
      }, 0);
    }

    /*开始*/

  }, {
    key: '_start',
    value: function _start() {
      this._perform('onShow', true);
    }

    /*暂停*/

  }, {
    key: '_stop',
    value: function _stop() {
      this._perform('onHide', false);
    }

    /*停止*/

  }, {
    key: 'stop',
    value: function stop() {
      this._stop();
    }

    /*外部调用接口*/

  }, {
    key: 'toggle',
    value: function toggle() {
      if (this.state) {
        this._stop();
      } else {
        this._start();
      }
    }

    /*销毁接口*/

  }, {
    key: 'destroy',
    value: function destroy() {
      var _this5 = this;

      this._send('onDestory');
      PMS.unbind();
      setTimeout(function () {
        _this5._$iframe = null;
        _this5._$wapper.remove();
        _this5._$wapper = null;
      }, 0);
    }
  }]);
  return iframeWidget;
}();

/********************************************************************
 *
 *                   零件适配器
 *
 *              1 数据过滤
 *              构件5种类型
 *
 * *******************************************************************/
/**
 * 注册所有组件对象
 * 2 widget 包括 视频 音频 Action 子文档 弹出口 类型
 * 这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
 * @param  {[type]} regData [description]
 * @return {[type]}         [description]
 */
var injectionComponent = function injectionComponent(regData) {
  var sceneObj = sceneController.containerObj('current');
  sceneObj.$$mediator.$injectionComponent = regData;
};

var load = function load(type, data, constructor) {
  injectionComponent({
    'pageType': data.pageType, //标记类型区分
    'pageIndex': data.pageIndex,
    'widget': new constructor(data)
  });
};

/**
 * 构建5中零件类型
 *  1、iframe零件
 *  2、页面零件
 *  3、SVG零件
 *  4、canvas零件
 *  5、webGL零件
 * @type {Object}
 */
var adapterType = {

  /**
   * iframe零件类型
   * @param  {[type]} data [description]
   * @return {[type]}      [description]
   */
  'iframe': function iframe(data) {
    load('widget', data, iframeWidget);
  },
  'widget': function widget(data) {
    load('widget', data, iframeWidget);
  },


  /**
   * js零件类型处理
   * @param  {[type]} data [description]
   * @return {[type]}      [description]
   */
  'js': function js(data) {
    load('js', data, PageWidget);
  },
  'page': function page(data) {
    load('page', data, PageWidget);
  },
  'svg': function svg(data) {
    load('svg', data, PageWidget);
  },
  'canvas': function canvas(data) {
    load('canvas', data, PageWidget);
  },
  'webgL': function webgL(data) {
    load('webgL', data, PageWidget);
  }
};

/*过滤出数据*/
var getWidgetData = function getWidgetData(data) {
  //直接通过id查询数据
  if (data.widgetId) {
    _.extend(data, Xut.data.query('Widget', data.widgetId));
  } else {
    //直接通过activityId查询数据
    _.extend(data, Xut.data.query('Widget', data.activityId, 'activityId'));
  }
  return data;
};

/*计算元素的缩放比*/
var calculateSize = function calculateSize(data, pageStyle) {
  var sizeResults = reviseSize({
    results: data,
    getStyle: pageStyle,
    proportion: pageStyle.pageProportion
  });
  data.width = data.scaleWidth;
  data.height = data.scaleHeight;
  data.top = data.scaleTop;
  data.left = data.scaleLeft;
  return data;
};

/*ifarme内部，请求返回数据*/
var parsePara = function parsePara(data) {
  var inputPara = void 0;
  if (inputPara = data.inputPara) {
    return parseJSON(inputPara);
  }
  return {};
};

function Adapter(para) {

  //获取数据
  var data = getWidgetData(_.extend({}, para));

  data.id = data.activityId;
  data.inputPara = parsePara(data);

  /*增加属性参数*/
  if (data.widgetType === 'page') {
    data.inputPara.container = data.rootNode;
  }

  /*重新定义页面的布局参数*/
  var pageStyle = Xut.Presentation.GetPageStyle(para.pageIndex);
  var pageVisualSize = {
    width: pageStyle.visualWidth,
    height: pageStyle.visualHeight,
    left: pageStyle.visualLeft,
    top: pageStyle.visualTop
  };
  data.pageProportion = pageStyle.pageProportion;

  /*缩放比值*/
  data = calculateSize(data, pageStyle);

  data.inputPara.uuid = config.data.appId + '-' + data.activityId; //唯一ID标示
  data.inputPara.id = data.activityId;
  data.inputPara.screenSize = pageVisualSize;

  //content的命名前缀
  data.inputPara.contentPrefix = Xut.Presentation.GetContentPrefix(data.pageIndex, data.pageType);

  //画轴模式
  data.scrollPaintingMode = config.launch.visualMode === 4;
  data.calculate = pageVisualSize;

  //执行类构建
  adapterType[(data.widgetType || 'widget').toLowerCase()](data);
}

var Widget = {

  /**
   * 创建热点元素结构（用于布局可触发点
   * 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
   * 根据数据创建自己的热点元素结构（用于拼接结构字符串）
   * @return {[type]}              [description]
   */
  createDom: function createDom(_ref, chpaterData, chapterId, pageIndex, zIndex, pageType) {
    var _id = _ref._id,
        md5 = _ref.md5,
        autoPlay = _ref.autoPlay,
        actType = _ref.actType,
        scaleWidth = _ref.scaleWidth,
        scaleHeight = _ref.scaleHeight,
        scaleTop = _ref.scaleTop,
        scaleLeft = _ref.scaleLeft;

    //如果是自动播放,则不创建结构
    if (autoPlay) {
      return '';
    }
    return String.styleFormat('<div id="' + (actType + "_" + _id) + '"\n            data-belong="' + pageType + '"\n            data-delegate="' + actType + '"\n            style="cursor:pointer;\n                   background-size:100% 100%;\n                   position:absolute;\n                   width:' + scaleWidth + 'px;\n                   height:' + scaleHeight + 'px;\n                   left:' + scaleLeft + 'px;\n                   top:' + scaleTop + 'px;\n                   z-index:' + zIndex + ';\n            ' + (md5 ? "background-image: url(" + getFileFullPath(md5, 'hot-widget') + ");" : '') + '">\n      </div>');
  }

  /**
   * 自动零件
   * @param  {[type]} data [description]
   * @return {[type]}      [description]
   */

  ,
  autoPlay: function autoPlay(_ref2) {
    var id = _ref2.id,
        rootNode = _ref2.rootNode,
        pageType = _ref2.pageType,
        pageIndex = _ref2.pageIndex;

    Adapter({
      rootNode: rootNode,
      pageType: pageType,
      pageIndex: pageIndex,
      activityId: id,
      isAutoPlay: true
    });
  }

  /**
   * 事件委托
   * 通过点击触发
   * @param  {[type]} data [description]
   * @return {[type]}      [description]
   */

  ,
  trigger: function trigger(data) {
    return Adapter(data);
  }
};

/**
 * 提示框
 */
var ShowNote$1 = function () {
  function ShowNote(data) {
    classCallCheck(this, ShowNote);

    data.id = parseInt(data.id);
    data.actType = data.type;
    _.extend(this, data);
    this.setup();
  }

  createClass(ShowNote, [{
    key: 'setup',
    value: function setup() {
      var that = this,
          note = this.data.note,
          prop = Xut.config.proportion,
          width = Math.round((prop.width + prop.height) / 2 * config.data.iconHeight),
          space = Math.round(width / 2);

      var retStr = '<div class="xut-shownote-box" style="z-index:' + Xut.zIndexlevel() + '">' + '<div class="close" style="width:' + width + 'px;height:' + width + 'px;top:-' + space + 'px;right:-' + space + 'px"></div>' + '<div class="content">' + note + '</div>' + '</div>';

      this._dom = $(retStr);
      this._dom.find('.close').on("touchend mouseup", function () {
        that.toggle();
      });
      $(this.rootNode).append(this._dom);

      this.show();

      this.iscroll = IScroll(this._dom.find('.content')[0], {
        scrollbars: 'custom',
        fadeScrollbars: true
      });
      return true;
    }

    //外部调用接口

  }, {
    key: 'toggle',
    value: function toggle() {
      //自动热点 取消关闭
      if (this.isAutoPlay) return;
      //当前对象状态
      this.state ? this.hide() : this.show();
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this.state) {
        this.toggle();
        return true;
      }
      return false;
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.state = false;
      $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/hideNote.png)');
      this._dom.hide();
    }
  }, {
    key: 'show',
    value: function show() {
      this.state = true;
      $("#ShowNote_" + this.id).css('background-image', 'url(images/icons/showNote.png)');
      this._dom.show();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._dom) {
        this._dom.find('.close').off();
        this._dom && this._dom.hide().remove();
      }

      //iscroll销毁
      if (this.iscroll) {
        this.iscroll.destroy();
        this.iscroll = null;
      }
    }
  }]);
  return ShowNote;
}();

var ShowNote$$1 = {

  /**
   * 创建热点元素结构（用于布局可触发点）
   * 根据数据创建自己的热点元素结构（用于拼接结构字符串）
   * 要retrun返回这个结构，主要是多人操作时,保证只有最终的dom渲染只有一次
   * actType + "_" + _id
   * @return {[type]}              [description]
   */
  createDom: function createDom(_ref, chpaterData, chapterId, pageIndex, zIndex, pageType) {
    var _id = _ref._id,
        md5 = _ref.md5,
        actType = _ref.actType,
        category = _ref.category,
        itemArray = _ref.itemArray,
        scaleWidth = _ref.scaleWidth,
        scaleHeight = _ref.scaleHeight,
        scaleTop = _ref.scaleTop,
        scaleLeft = _ref.scaleLeft;

    var newWidth = (scaleWidth + scaleHeight) / 2 * config.data.iconHeight;
    return String.styleFormat('<div id="ShowNote_' + _id + '"\n            class="xut-showNote"\n            data-belong ="' + pageType + '"\n            data-delegate="shownote"\n            style="width:' + newWidth + 'px;height:' + newWidth + 'px">\n       </div>');
  }

  /**
   * touchEnd 全局派发的点击事件
   * 如果stopGlobalEvent == ture 事件由全局派发
   */

  ,
  trigger: function trigger(options) {
    options.data = Xut.Presentation.GetPageData(options.pageIndex);
    new ShowNote$1(options);
  }

  /**
   * 自动运行生成Action或者widget触发点对象
   * @param  {[type]} opts [description]
   * @return {[type]}      [description]
   */

  ,
  autoPlay: function autoPlay() {}

  /**
   * 销毁页面hotspot事件与Action或widget事件
   * @param  {[type]} activeObejct [需要处理的活动对象]
   * @param  {[type]} pageIndex    [页码标示]
   * @param  {[type]} rootEle      [根元素]
   * @return {[type]}              [description]
   */

  ,
  destroy: function destroy(opts) {
    this && this.destroy();
  }
};

var directives = {
  'Video': Media,
  'Audio': Media,
  'Webpage': Media,
  Action: Action$1,
  Widget: Widget,
  ShowNote: ShowNote$$1
};

/**
 *  创建widgets对象任务片
 *  state状态
 *      0 未创建
 *      1 正常创建
 *      2 创建完毕
 *      3 创建失败
 */
var TaskComponents = function (_TaskSuper) {
  inherits(TaskComponents, _TaskSuper);

  function TaskComponents(pipeData, success, detector) {
    classCallCheck(this, TaskComponents);

    //预编译模式跳过创建
    var _this = possibleConstructorReturn(this, (TaskComponents.__proto__ || Object.getPrototypeOf(TaskComponents)).call(this, detector));

    if (Xut.IBooks.runMode()) {
      success();
      return possibleConstructorReturn(_this);
    }

    if (pipeData.activitys && pipeData.activitys.length) {
      _this.success = success;
      _this.$containsNode = pipeData.$containsNode;
      _this.pageBaseHooks = pipeData.pageBaseHooks;
      _this.pipeData = pipeData;
      _this._checkNextTask(_this._create(pipeData));
    } else {
      success();
    }
    return _this;
  }

  /**
   * 创建dom节点，但是浮动类型例外
   */


  createClass(TaskComponents, [{
    key: '_create',
    value: function _create() {
      var _this2 = this;

      var _pipeData = this.pipeData,
          pageType = _pipeData.pageType,
          activitys = _pipeData.activitys,
          chpaterData = _pipeData.chpaterData,
          chapterId = _pipeData.chapterId,
          chapterIndex = _pipeData.chapterIndex;


      var resultHTML = [];

      /*
        创建DOM元素结构,返回是拼接字符串
        判断返回值
        1 纯html
        2 对象（浮动音频处理）
      */
      var createDom = function createDom(actType, activityData) {
        activityData = reviseSize({
          results: activityData,
          proportion: _this2.pipeData.getStyle.pageProportion
        });
        var result = directives[actType]['createDom'](activityData, chpaterData, chapterId, chapterIndex, Xut.zIndexlevel(), pageType);
        if (_.isString(result)) {
          resultHTML.push(result);
        } else {
          /*如果有浮动类型，保存*/
          if (result.hasFloat) {
            _this2.$$floatDivertor[pageType].html.push(result.html);
          } else {
            resultHTML.push(result.html);
          }
        }
      };

      //需要创建的数据结构
      activitys.forEach(function (activityData, index) {
        //创建类型
        var actType = activityData.actType || activityData.animation;
        //特殊类型 showNote
        if (!actType && activityData.note) {
          activityData['actType'] = actType = "ShowNote";
        }
        switch (actType) {
          case 'ShowNote':
          case 'Action':
          case 'Widget':
          case 'Audio':
          case 'Video':
            createDom(actType, activityData);
            break;
        }
      });

      return resultHTML.join("");
    }

    /**
     * 检测下个任务是否中断运行
     */

  }, {
    key: '_checkNextTask',
    value: function _checkNextTask(htmlString) {
      var _this3 = this;

      this._$$checkNextTask('内部Component', function () {
        _this3._float(function () {
          _this3._render(htmlString);
        });
      });
    }

    /**
     * 浮动处理
     * @param  {Function} callback [description]
     * @return {[type]}            [description]
     */

  }, {
    key: '_float',
    value: function _float(callback) {
      var _this4 = this;

      /*制作浮点回调*/
      this.pipeData.taskCount = 0;

      var complete = function () {
        return function () {
          if (_this4.pipeData.taskCount === 1) {
            callback();
            return;
          }
          --_this4.pipeData.taskCount;
        };
      }();

      this._$$createFloatLayer(complete, this.pipeData);

      /*如果不存在浮动*/
      if (this.pipeData.taskCount === 0) {
        complete = null;
        callback();
      }
    }

    /**
     * 渲染页面*
     * @param  {[type]} htmlString [description]
     * @return {[type]}            [description]
     */

  }, {
    key: '_render',
    value: function _render(htmlString) {
      var _this5 = this;

      /*正常component*/
      if (htmlString) {
        Xut.nextTick({
          container: this.$containsNode,
          content: $(htmlString)
        }, function () {
          _this5._destroy();
          _this5.success();
        });
      } else {
        this._destroy();
        this.success();
      }
    }

    //============================
    //      super方法
    //============================

  }, {
    key: '_destroy',
    value: function _destroy() {
      this.$containsNode = null;
    }
  }]);
  return TaskComponents;
}(TaskSuper);

/**
 * 页面切换效果
 * 平移
 * @return {[type]} [description]
 */
var transitionDuration$1 = Xut.style.transitionDuration;

/**
 * 切换坐标
 * 保证只是pageType === page才捕获动作
 */
var setTranslate = function setTranslate(node, distance, speed, callback) {
  if (node) {
    if (config.launch.scrollMode === 'v') {
      Xut.style.setTranslate({ node: node, speed: speed, y: distance });
    } else {
      Xut.style.setTranslate({ node: node, speed: speed, x: distance });
    }
    callback && callback();
  }
};

/**
 * 设置
 * @param  {[type]} node [description]
 * @return {[type]}      [description]
 */
var set$1 = function set(node, value) {
  if (node) {
    if (config.launch.scrollMode === 'v') {
      Xut.style.setTranslate({ node: node, y: value });
    } else {
      Xut.style.setTranslate({ node: node, x: value });
    }
  }
};

/**
 * 复位
 * @return {[type]} [description]
 */
var reset = function reset(node) {
  if (node) {
    Xut.style.setTranslate({ node: node, x: 0, y: 0 });
    node.style[transitionDuration$1] = '';
  }
};

/**
 * 移动
 * @return {[type]} [description]
 */
var flipMove$1 = function flipMove() {
  setTranslate.apply(undefined, arguments);
};

/**
 * 移动反弹
 * @return {[type]} [description]
 */
var flipRebound$1 = function flipRebound() {
  setTranslate.apply(undefined, arguments);
};

/**
 * 移动结束
 * @return {[type]} [description]
 */
var flipOver$1 = function flipOver() {
  setTranslate.apply(undefined, arguments);
};

/**
 * translation滑动接口
 * @type {Object}
 */
var translation = {
  set: set$1,
  reset: reset,
  flipMove: flipMove$1,
  flipRebound: flipRebound$1,
  flipOver: flipOver$1

  /**
   * 创建translate初始值
   * @param  {[type]} offset [description]
   * @return {[type]}        [description]
   */
};var createTranslate = function createTranslate(value) {
  if (config.launch.scrollMode === 'v') {
    return Xut.style.setTranslateStyle(0, value);
  }
  return Xut.style.setTranslateStyle(value, 0);
};

/**
 * 修正坐标
 * 跳转使用
 * @return {[type]} [description]
 */
function fix($node, action) {
  var translate = void 0;
  if (config.launch.scrollMode === 'v') {
    var visualHight = config.visualSize.height;
    translate = action === 'prevEffect' ? createTranslate(-visualHight) : createTranslate(visualHight);
  } else {
    var visualWidth = config.visualSize.width;
    translate = action === 'prevEffect' ? createTranslate(-visualWidth) : createTranslate(visualWidth);
  }
  $node.css(Xut.style.transform, translate);
}

/************************
 * 左边页面钩子
 *     distance 正数，1-2-3-4 -> N 变化
 *     pageStyle：3个页面的style配置
 *************************/
var leftPageHook = {
  flipMove: {
    prev: function prev(getStyle, distance) {
      var middlePageStyle = getStyle('middle');
      var leftPageStyle = getStyle('left');

      //中间：溢出
      if (middlePageStyle && middlePageStyle.visualLeftInteger) {
        //左边：溢出
        if (leftPageStyle && leftPageStyle.visualLeftInteger) {
          return -leftPageStyle.visualWidth + distance;
        }
        //左边：正常
        else {
            return distance - leftPageStyle.visualWidth - middlePageStyle.visualLeftInteger;
          }
      }
      //中间：正常
      else {
          //左边：溢出
          if (leftPageStyle && leftPageStyle.visualLeftInteger) {
            return distance - leftPageStyle.visualWidth + leftPageStyle.visualLeftInteger;
          }
          //左边：正常
          else {
              return distance - leftPageStyle.visualWidth;
            }
        }
    },
    next: function next() {}
  },
  flipRebound: {
    prev: function prev(getStyle) {
      var middlePageStyle = getStyle('middle');
      var leftPageStyle = getStyle('left');

      //中间：溢出
      if (middlePageStyle && middlePageStyle.visualLeftInteger) {
        //左边：溢出
        if (leftPageStyle && leftPageStyle.visualLeftInteger) {
          return -leftPageStyle.visualWidth;
        }
        //左边：正常
        else {
            return -(leftPageStyle.visualWidth + middlePageStyle.visualLeftInteger);
          }
      }
      //中间：正常
      else {
          //左边：溢出
          if (leftPageStyle && leftPageStyle.visualLeftInteger) {
            return -(leftPageStyle.visualWidth - leftPageStyle.visualLeftInteger);
          }
          //左边：正常
          else {
              return -leftPageStyle.visualWidth;
            }
        }
    },
    next: function next() {}
  },
  flipOver: {
    prev: function prev(getStyle, distance) {
      return 0;
    },
    next: function next() {}
  }
};

/************************
 * 中间页面钩子
 *************************/
var hMiddlePageHook = {
  flipMove: {
    prev: function prev() {},
    next: function next() {}
  },
  flipOver: {
    /**
     * 左翻页结束
     */
    prev: function prev(getStyle, distance) {
      var middlePageStyle = getStyle('middle');
      var leftPageStyle = getStyle('left');

      //中间：溢出
      if (middlePageStyle && middlePageStyle.visualLeftInteger) {
        //左边：溢出
        if (leftPageStyle && leftPageStyle.visualLeftInteger) {
          return middlePageStyle.visualWidth;
        }
        //左边：正常
        else {
            return middlePageStyle.visualWidth - middlePageStyle.visualLeftInteger;
          }
      }
      //中间：正常
      else {
          //左边：溢出
          if (leftPageStyle && leftPageStyle.visualLeftInteger) {
            return middlePageStyle.visualWidth + leftPageStyle.visualLeftInteger;
          }
          //左边：正常
          else {
              return middlePageStyle.visualWidth;
            }
        }
    },

    /**
     * 右翻页结束
     */
    next: function next(getStyle) {

      var middlePageStyle = getStyle('middle');
      var rightPageStyle = getStyle('right');

      //中间：溢出
      if (middlePageStyle && middlePageStyle.visualLeftInteger) {
        //右边：溢出
        if (rightPageStyle && rightPageStyle.visualLeftInteger) {
          return -middlePageStyle.visualWidth;
        }
        //右边：正常
        else {
            return -(middlePageStyle.visualWidth - middlePageStyle.visualLeftInteger);
          }
      }
      //中间：正常
      else {
          //右边：溢出
          if (rightPageStyle && rightPageStyle.visualLeftInteger) {
            return -(middlePageStyle.visualWidth + rightPageStyle.visualLeftInteger);
          }
          //右边：正常
          else {
              return -rightPageStyle.visualWidth;
            }
        }
    }
  }
};

/************************
 * right页面钩子
 * distance -1 -2 -3 -N 递减
 *************************/
var rightPageHook = {
  flipMove: {
    prev: function prev() {},

    /**
     * 右滑动
     * distance -1 -> -N 递减
     */
    next: function next(getStyle, distance) {

      var middlePageStyle = getStyle('middle');
      var rightPageStyle = getStyle('right');

      //中间：溢出
      if (middlePageStyle && middlePageStyle.visualLeftInteger) {
        //右边：溢出
        if (rightPageStyle && rightPageStyle.visualLeftInteger) {
          return distance + rightPageStyle.visualWidth;
        }
        //右边：正常
        else {
            return distance + middlePageStyle.visualWidth - middlePageStyle.visualLeftInteger;
          }
      }
      //中间：正常
      else {
          //右边：溢出
          if (rightPageStyle && rightPageStyle.visualLeftInteger) {
            return distance + middlePageStyle.visualWidth + rightPageStyle.visualLeftInteger;
          }
          //右边：正常
          else {
              return distance + rightPageStyle.visualWidth;
            }
        }
    }
  },
  flipRebound: {
    prev: function prev() {},
    next: function next(getStyle) {

      var rightPageStyle = getStyle('right');

      /*如果页面模式是5，特殊处理,返回半页宽度*/
      if (rightPageStyle && rightPageStyle.pageVisualMode === 5) {
        return rightPageStyle.visualWidth / 2;
      }

      var middlePageStyle = getStyle('middle');

      //中间：溢出
      if (middlePageStyle && middlePageStyle.visualLeftInteger) {
        //右边：溢出
        if (rightPageStyle && rightPageStyle.visualLeftInteger) {
          return rightPageStyle.visualWidth;
        }
        //右边：正常
        else {
            return middlePageStyle.visualWidth - middlePageStyle.visualLeftInteger;
          }
      }
      //中间：正常
      else {
          //右边：溢出
          if (rightPageStyle && rightPageStyle.visualLeftInteger) {
            return middlePageStyle.visualWidth + rightPageStyle.visualLeftInteger;
          }
          //右边：正常
          else {
              return middlePageStyle.visualWidth;
            }
        }
    }
  },
  flipOver: {
    prev: function prev() {},
    next: function next() {
      return 0;
    }
  }
};

/************************
 * 顶部页面钩子
 *************************/
var topPageHook = {
  flipMove: {
    /*顶部页面往中间移动*/
    prev: function prev(getStyle, distance) {
      var topPageStyle = getStyle('top');
      return distance - topPageStyle.visualHeight;
    }
  },
  flipRebound: {
    /*顶部往中间反弹*/
    prev: function prev(getStyle) {
      var topPageStyle = getStyle('top');
      return -topPageStyle.visualHeight;
    }
  },
  flipOver: {
    /*顶部往中间翻页*/
    prev: function prev() {
      return 0;
    }
  }
};

/************************
 * 中间页面钩子
 *************************/
var vMiddlePageHook = {
  flipOver: {
    /**
     * 中间页面向底部滑动
     */
    prev: function prev(getStyle) {
      var middle = getStyle('middle');
      return middle.visualHeight;
    },

    /**
     * 中间页面向顶部滑动
     */
    next: function next(getStyle) {
      var middle = getStyle('middle');
      return -middle.visualHeight;
    }
  }
};

/************************
 * 底部页面钩子
 *************************/
var bottomPageHook = {
  flipMove: {
    /*从底部往中间移动*/
    next: function next(getStyle, distance) {
      var bottomPageStyle = getStyle('bottom');
      return distance + bottomPageStyle.visualHeight;
    }
  },
  flipRebound: {
    /*底部往中间反弹*/
    next: function next(getStyle) {
      var topPageStyle = getStyle('bottom');
      return topPageStyle.visualHeight;
    }
  },
  flipOver: {
    /*底部页面，翻页结束后，目标变为当前可是页面*/
    next: function next() {
      return 0;
    }
  }
};

/**
 * 获取页面对象的样式配置对象
 * @param  {[type]} pageIndex [description]
 * @return {[type]}           [description]
 */
var _getPageStyle = function _getPageStyle(pageIndex) {
  if (pageIndex === undefined) {
    return {};
  }
  var pageBase = Xut.Presentation.GetPageBase(pageIndex);
  return pageBase && pageBase.getStyle || {};
};

var makeAccess = function makeAccess(action, direction, distance, getStyle) {
  return function (hooks) {
    return hooks && hooks[action] && hooks[action][direction] && hooks[action][direction](getStyle, distance);
  };
};

/**
 * 单页模式
 * 计算每个页面的移动距离
 * direction  = prev/next
 * orientation  = v/h
 */
var getSingle = function getSingle(_ref) {
  var action = _ref.action,
      distance = _ref.distance,
      direction = _ref.direction,
      frontIndex = _ref.frontIndex,
      middleIndex = _ref.middleIndex,
      backIndex = _ref.backIndex,
      orientation = _ref.orientation;


  /*如果没有传递布方向，就取页面
  flow中没有定义，这个在全局接口中处理*/
  if (!orientation) {
    orientation = config.launch.scrollMode;
  }

  var front = 0;
  var middle = 0;
  var back = 0;

  //当前视图页面
  //用来处理页面回调
  var visualPage = undefined;

  /*根据后去的定位，获取页面的样式*/
  var getStyle = function getStyle(position) {
    var style = void 0,
        pageIndex = void 0;
    switch (position) {
      case 'left':
      case 'top':
        pageIndex = frontIndex;
        break;
      case 'right':
      case 'bottom':
        pageIndex = backIndex;
        break;
      case 'middle':
        pageIndex = middleIndex;
        break;
    }
    return _getPageStyle(pageIndex);
  };

  /*获取页面样式*/
  var access = makeAccess(action, direction, distance, getStyle);

  /*滑动与反弹*/
  if (hasIndexOf(action, ['flipMove', 'flipRebound'])) {
    if (orientation === 'h') {
      front = access(leftPageHook);
      back = access(rightPageHook);
    } else {
      front = access(topPageHook);
      back = access(bottomPageHook);
    }
    middle = distance;
  }

  /*翻页*/
  if (action === 'flipOver') {
    if (orientation === 'h') {
      front = access(leftPageHook);
      middle = access(hMiddlePageHook);
      back = access(rightPageHook);
    } else {
      front = access(topPageHook);
      middle = access(vMiddlePageHook);
      back = access(bottomPageHook);
    }
    visualPage = direction === 'prev' ? front : back;
  }
  return [front, middle, back, visualPage];
};

/*
双页模式
仅计算包裹容器移动的距离
 */
var getDouble = function getDouble(_ref2) {
  var action = _ref2.action,
      distance = _ref2.distance,
      direction = _ref2.direction,
      frontIndex = _ref2.frontIndex,
      middleIndex = _ref2.middleIndex,
      backIndex = _ref2.backIndex;

  var left = 0;
  var middle = 0;
  var right = 0;
  var view = middleIndex;
  var screenWidth = config.screenSize.width;
  if (direction === 'next') {
    /*滑动,反弹，需要叠加当期之前之前所有页面的距离综合，
    因为索引从0开始，所以middleIndex就是之前的总和页面数*/
    if (action === 'flipMove' || action === 'flipRebound') {
      middle = -(screenWidth * middleIndex) + distance;
    }

    /*翻页，需要设置下一页的页面宽度长度*/
    if (action === 'flipOver') {
      middle = -(screenWidth * backIndex);
    }
  }
  return [left, middle, right, view];
};

/**
 * 动态计算翻页距离
 * @return {[type]} [description]
 */
function getVisualDistance(options) {
  return config.launch.doublePageMode ? getDouble(options) : getSingle(options);
}

/**
 * 获取跳转页面依赖的数据
 * visualIndex 可视区页面索引
 * targetIndex 目标页面索引
 * totalIndex  总页数
 */
function getJumpDepend(visualIndex, targetIndex, totalIndex) {
  var i = 0,
      existpage,
      createpage,
      pageIndex,
      exclude = [],
      create = [],
      destroy,
      newPointers;

  //存在的页面
  if (visualIndex === 0) {
    existpage = [visualIndex, visualIndex + 1];
  } else if (visualIndex === totalIndex - 1) {
    existpage = [visualIndex - 1, visualIndex];
  } else {
    existpage = [visualIndex - 1, visualIndex, visualIndex + 1];
  }

  //需要创建的新页面
  if (targetIndex === 0) {
    createpage = [targetIndex, targetIndex + 1];
  } else if (targetIndex === totalIndex - 1) {
    createpage = [targetIndex - 1, targetIndex];
  } else {
    createpage = [targetIndex - 1, targetIndex, targetIndex + 1];
  }

  for (; i < createpage.length; i++) {
    pageIndex = createpage[i];
    //跳过存在的页面
    if (-1 === existpage.indexOf(pageIndex)) {
      //创建目标的页面
      create.push(pageIndex);
    } else {
      //排除已存在的页面
      exclude.push(pageIndex);
    }
  }

  _.each(exclude, function (excludeIndex) {
    existpage.splice(existpage.indexOf(excludeIndex), 1);
  });

  destroy = existpage;

  newPointers = [].concat(create).concat(exclude).sort(function (a, b) {
    return a - b;
  });

  return {
    'create': create, //创建的页面
    'exclude': exclude, //排除已存在的页面
    'destroy': destroy, //销毁的页面
    'newPointers': newPointers, //新的页码合集
    'targetIndex': targetIndex,
    'visualIndex': visualIndex
  };
}

/**
 * 初始化首次范围
 * 动态分页一共有3页
 * 横版
 *   左中右 front middle back
 * 竖版
 *   上中下 front middle back
 * @return {[type]} [description]
 */
function initPointer(init, totalIndex) {
  var pointer = {};
  if (init === 0) {
    //首页
    pointer['middleIndex'] = init;
    pointer['backIndex'] = init + 1;
  } else if (init === totalIndex - 1) {
    //尾页
    pointer['middleIndex'] = init;
    pointer['frontIndex'] = init - 1;
  } else {
    //中间页
    pointer['frontIndex'] = init - 1;
    pointer['middleIndex'] = init;
    pointer['backIndex'] = init + 1;
  }
  return pointer;
}

/*
  转换页码索引
  direction 方向
  pointer 当前页码标示
  [17 18 19]  pagePointer
  [18 19 20]  转换后
  17 销毁
  20 创建
 */
function getActionPointer(direction, frontIndex, backIndex) {
  var createIndex = void 0; //创建的页
  var destroyIndex = void 0; //销毁的页
  switch (direction) {
    case 'prev':
      //前处理
      createIndex = frontIndex - 1;
      destroyIndex = backIndex;
      break;
    case 'next':
      //后处理
      createIndex = backIndex + 1;
      destroyIndex = frontIndex;
      break;
  }
  return { createIndex: createIndex, destroyIndex: destroyIndex };
}

function api(Swiper) {

  /**
   * 在column中滑动的时候，会丢失Direction
   * 具体就是flow在首页，而且chpater只有一个flow的情况下
   */
  Swiper.prototype.setDirection = function (value) {
    if (value !== undefined) {
      this.direction = value > 0 ? 'prev' : 'next';
    }
  };

  /**
   * 获取动作
   * 是翻页还是反弹
   * @return {[type]} [description]
   */
  Swiper.prototype.getActionType = function (touchX, touchY, duration, orientation) {
    orientation = orientation || this.orientation;
    if (orientation === 'h') {
      /**单独PPT页面内部滑动 */
      if (this.options.insideScroll) {
        //////////////////
        /// 判断是内部滑动
        //////////////////
        /*left/up* 并且不是前边界*/
        if (this.direction === 'prev' && this.distX < 0) {
          return 'flipMove';
        }
        /*right/down ,如果移动的距离小于页面宽度*/
        if (this.direction === 'next' && Math.abs(this.distX) < this.visualWidth) {
          return 'flipMove';
        }
        ///////////////////////////////
        /// 判断是单页面，强制打开了滑动
        /// 翻页强制改为反弹
        ///////////////////////////////
        if (!this.options.hasMultiPage) {
          return 'flipRebound';
        }
      }
      /*PPT页面之间的处理*/
      touchX = Math.abs(touchX);
      return duration < 200 && touchX > 30 || touchX > this.actualWidth / 6 ? 'flipOver' : 'flipRebound';
    } else if (orientation === 'v') {
      touchY = Math.abs(touchY);
      return duration < 200 && touchY > 30 || touchY > this.actualHeight / 6 ? 'flipOver' : 'flipRebound';
    }
  };

  /**
   * column的情况
   * 动态设置新的页面总数
   */
  Swiper.prototype.setLinearTotal = function (total, location) {

    //如果当前是column
    if (location === 'middle') {

      var borderIndex = void 0;
      //必须是有2页以上并且当前页面就是最后一页
      //如果分栏默认只分出1页的情况，后需要不全就跳过这个处理
      if (this.totalIndex > 1 && this.visualIndex == this.totalIndex - 1) {
        borderIndex = this.visualIndex;
      }

      this.totalIndex = total;

      //如果是最后一页，叠加新的页面
      //需要重写一些数据
      if (borderIndex !== undefined) {
        this.setPointer(borderIndex - 1, total);
        this._updatePointer();
      }
    }

    //如果左边是column页面
    //改变总页面数
    //改变可视区页面为最后页
    if (location === 'left') {
      this.totalIndex = total;
      this.visualIndex = total - 1;
      this.setPointer(this.visualIndex, total);
      this._updatePointer();
      //设置Transform的偏移量，为最后一页
      this._setTransform();
    }

    //如果是右边的column
    if (location === 'right') {
      this.totalIndex = total;
    }

    this._setContainerValue();
  };

  /**
   * 获取初始化距离值
   * @return {[type]} [description]
   */
  Swiper.prototype.getInitDistance = function () {
    return this._initDistance;
  };

  /**
   * 模拟完成状态调用
   * @return {[type]} [description]
   */
  Swiper.prototype.simulationComplete = function () {
    var _this = this;

    setTimeout(function () {
      _this._setRestore();
      _this.enable();
    });
  };

  /*启动滑动*/
  Swiper.prototype.enable = function () {
    this.enabled = true;
  };

  //禁止滑动
  Swiper.prototype.disable = function () {
    this.enabled = false;
  };

  /**
   * 是否锁定
   * @return {Boolean} [description]
   */
  Swiper.prototype.hasEnabled = function () {
    return this.enabled;
  };

  /**
   * 是否为边界
   * @param  {[type]}  distance [description]
   * @return {Boolean}          [description]
   */
  Swiper.prototype.isBorder = function () {
    this._borderBounce.apply(this, arguments);
  };

  /**
   * 获取移动状态
   * @return {Boolean} [description]
   */
  Swiper.prototype.getMoved = function () {
    return this._moved;
  };

  /**
   * 外部直接调用
   * 前翻页接口
   * callback 翻页完成
   * {
      speed,
      callback
    }
   */
  Swiper.prototype.prev = function () {
    var _this2 = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        speed = _ref.speed,
        callback = _ref.callback;

    if (!this._borderBounce(1)) {

      var toNext = function toNext() {
        _this2._slideTo({ speed: speed, callback: callback, direction: 'prev', action: 'outer' });
      };

      /*启动了预加载模式*/
      if (config.launch.preload) {
        var status = requestInterrupt({
          type: 'linear',
          direction: 'prev',
          processed: function processed() {
            toNext();
            Xut.View.HideBusy();
          }
        }, this);
        /*如果还在预加载，禁止跳转*/
        if (status) {
          Xut.View.ShowBusy();
          return;
        }
      }

      /*正常跳页面*/
      toNext();
    } else {
      //边界反弹
      this._setRebound({ direction: 'next' });
      callback && callback();
    }
  };

  /**
   * 外部直接调用
   * 后翻页接口
   * Xut.View.GotoNextSlide
   * callback 翻页完成
   */
  Swiper.prototype.next = function () {
    var _this3 = this;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        speed = _ref2.speed,
        callback = _ref2.callback;

    if (!this._borderBounce(-1)) {

      var toNext = function toNext() {
        _this3._slideTo({ speed: speed, callback: callback, direction: 'next', action: 'outer' });
      };

      /*启动了预加载模式*/
      if (config.launch.preload) {
        var status = requestInterrupt({
          type: 'linear',
          direction: 'next',
          processed: function processed() {
            toNext();
            Xut.View.HideBusy();
          }
        }, this);
        /*如果还在预加载，禁止跳转*/
        if (status) {
          Xut.View.ShowBusy();
          return;
        }
      }

      /*正常模式*/
      toNext();
    } else {
      //边界反弹
      this._setRebound({
        direction: 'prev',
        isAppBoundary: true
      });
      callback && callback();
    }
  };

  /**
   * 获取当前页码
   * @return {[type]} [description]
   */
  Swiper.prototype.getVisualIndex = function () {
    return this.visualIndex;
  };

  /**
   * 主动设置页码编号
   * 因为分栏的关系，内部修改外部
   * 页面需要拼接
   */
  Swiper.prototype.setPointer = function (target, totalIndex) {
    this.pagePointer = initPointer(target, totalIndex || this.totalIndex);
  };

  /**
   * 获取页面Pointer
   * @return {[type]} [description]
   */
  Swiper.prototype.getPointer = function () {
    return this.pagePointer;
  };

  /**
   * 跳指定页面
   * targetIndex：目标页面
   * 在一个场景内部跳转
   * 提供一个跳转完毕后的回调
   */
  Swiper.prototype.scrollToPage = function (targetIndex, callback) {

    //如果还在翻页中
    if (!this.enabled) return;

    var visualIndex = this.visualIndex; //当前页面

    /*跳转页面复位上一个页面的初始化坐标值*/
    this._setKeepDist(0, 0);

    //相邻页
    switch (targetIndex) {
      //前一页
      case visualIndex - 1:
        if (this.options.hasMultiPage) {
          return this.prev({ callback: callback });
        }
        break;
      //首页
      case visualIndex:
        if (visualIndex == 0) {
          this.$$emit('onDropApp');
        }
        return;
      //后一页
      case visualIndex + 1:
        if (this.options.hasMultiPage) {
          return this.next({ callback: callback });
        }
        break;
    }

    //算出是跳页相关数据
    var data = getJumpDepend(visualIndex, targetIndex, this.totalIndex);

    data.callback = callback;

    //更新新的页码索引
    this._updatePointer(data);

    data.pagePointer = this.pagePointer;

    this.$$emit('onJumpPage', data);
  };

  /**
   * 设置页面移动
   */
  Swiper.prototype._setPageMove = function (position, speed) {
    var distance = this.actualWidth * (position / 100) / 2;

    /*必须有效*/
    if (distance == 0) {
      return;
    }

    this.distX = this.distY = -distance;
    this._setKeepDist(this.distX, this.distY);

    var self = this;
    this._distributeMove({
      distance: this.distX,
      speed: speed,
      action: 'flipMove',
      /**
       * 是否无效函数
       * 如果无效，end方法抛弃掉
       * 必须是同步方法：
       * 动画不能在回调中更改状态，因为翻页动作可能在动画没有结束之前，所以会导致翻页卡住
       */
      setSwipeInvalidCallback: function setSwipeInvalidCallback() {
        self._isInvalid = true;
      }
    });
  };

  /**
   * 清理延时运行
   * @return {[type]} [description]
   */
  Swiper.prototype.clearDelayTimer = function () {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
  };

  /**
   * 移动指定的距离
   * position 默认最右边
   * speed 默认3秒
   * delay 默认没有延时
   */

  Swiper.prototype.scrollToPosition = function () {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

    var _this4 = this;

    var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    /*清理上一个延时*/
    this.clearDelayTimer();

    /*如果有延时运行*/
    /*这里没用动画的时间延时，因为运动中延时有问题*/
    if (delay) {
      this.delayTimer = setTimeout(function () {
        _this4.clearDelayTimer();
        _this4._setPageMove(position, speed);
      }, delay);
      return;
    }
    this._setPageMove(position, speed);
  };

  /**
   * 销毁所有
   * @return {[type]} [description]
   */
  Swiper.prototype.destroy = function () {
    this._off();
    this.$$unWatch();
    this.clearDelayTimer();
    if (this._childNodes) {
      this._childNodes.page = null;
      this._childNodes.master = null;
    }
    if (this.options.mouseWheel) {
      this.container.removeEventListener('wheel', this._onWheel, false);
      this.container.removeEventListener('mousewheel', this._onWheel, false);
      this.container.removeEventListener('DOMMouseScroll', this._onWheel, false);
    }
    this.container = null;
  };

  /**
   * 调用动画完成
   * @param {[type]} element [description]
   */
  Swiper.prototype.setTransitionComplete = function () {
    this._distributeComplete.apply(this, arguments);
  };

  /**
   * 目标元素
   * 找到li元素
   * @param  {Function} callback [description]
   * @return {[type]}            [description]
   */
  Swiper.prototype.findBubbleRootNode = function (point, pageType) {
    var liNode = void 0,
        pageChpaterIndex = void 0;
    var visualIndex = this.visualIndex;
    var sectionRang = this.options.sectionRang;

    //找到对应的li
    var childNodes = this._childNodes[pageType].childNodes;
    var nodeTotal = childNodes.length;

    while (nodeTotal--) {
      liNode = childNodes[nodeTotal];
      pageChpaterIndex = liNode.getAttribute('data-cix');
      if (sectionRang) {
        visualIndex += sectionRang.start;
      }
      if (pageChpaterIndex == visualIndex) {
        return liNode;
      }
      visualIndex = this.visualIndex;
    }
  };
}

var LINEARTAG = 'data-linearVisual';

function init(Swiper) {

  Swiper.prototype._init = function () {
    this._initMode();
    this._initEvents();
    this._initPrevent();
    if (this.options.mouseWheel) {
      this._initWheel();
    }
  };

  /*基本模式设置*/
  Swiper.prototype._initMode = function () {
    /*分段模式*/
    if (this.options.snap) {
      //用于查找跟元素
      //ul => page
      //ul => master
      var ul = this.container.querySelectorAll('ul');
      if (!ul.length) {
        $warn({
          type: 'swiper',
          content: "ul element don't found"
        });
      } else {
        this._childNodes = {
          page: ul[0],
          master: ul[1]
        };
      }
    }

    /*父容器滑动模式*/
    if (this.options.scope === 'parent') {
      if (this.options.scrollX) {
        this.container.setAttribute(LINEARTAG, true);
        this._setTransform();
        this._setContainerValue();
      } else if (this.options.scrollY) {
        this.options.scrollerMode = true;

        /*竖版处理,滚动容器*/
        this.scroller = this.container.children[0];
        this.scrollerStyle = this.scroller.style;
        /*最大溢出高度*/
        this.wrapperHeight = this.container.clientHeight;
        this.maxScrollY = this.wrapperHeight - this.scroller.offsetHeight;
        this._setTransform(this.scroller);
        this._setContainerValue(this.scroller);
      }
    }
  };

  /*默认行为*/
  Swiper.prototype._initPrevent = function () {
    this._stopDefault = this.options.preventDefault ? function (e) {
      e.preventDefault && e.preventDefault();
    } : function () {};
  };

  /**
   * 设置初始的
   */
  Swiper.prototype._setTransform = function (element) {
    this._initDistance = -this.visualIndex * this._getRollVisual();
    if (element) {
      Xut.style.setTranslate({
        y: this._initDistance,
        node: element
      });
    } else {
      Xut.style.setTranslate({
        x: this._initDistance,
        node: this.container
      });
    }
  };

  /**
   * 设置容易溢出的尺寸
   */
  Swiper.prototype._setContainerValue = function (element) {
    if (element) {
      element.style.height = this.actualHeight * this.totalIndex + 'px';
    } else {
      this.container.style.width = this.actualWidth * this.totalIndex + 'px';
    }
  };

  /**
   * 绑定事件
   */
  Swiper.prototype._initEvents = function () {
    var callback = {
      start: this,
      end: this,
      cancel: this,
      leave: this
    };

    if (this.options.banMove) {
      //移动被锁定，不绑定滑动事件
    } else if (this.options.hasMultiPage) {
      //不需要绑定transitionend，会设置手动会触发
      callback.move = this;
      callback.transitionend = this;
    }

    /*如果内部滚动模式打开了，必须强制绑定move*/
    if (!callback.move && this.options.insideScroll) {
      callback.move = this;
    }

    $on(this.container, callback);
  };

  /*滚轮*/
  Swiper.prototype._initWheel = function () {
    this.container.addEventListener('wheel', this._onWheel.bind(this), false);
    this.container.addEventListener('mousewheel', this._onWheel.bind(this), false);
    this.container.addEventListener('DOMMouseScroll', this._onWheel.bind(this), false);
  };
}

/*翻页速率*/
var FLIPSPEED = 600;

function slide(Swiper) {

  Swiper.prototype._transitionTime = function (time) {
    time = time || 0;
    var durationProp = Xut.style.transitionDuration;
    if (!durationProp) {
      return;
    }
    this.scrollerStyle[durationProp] = time + 'ms';
  };

  Swiper.prototype._transitionTimingFunction = function (easing) {
    this.scrollerStyle[Xut.style.transitionTimingFunction] = easing;
  };

  /**
   * 滑动内部页面
   */
  Swiper.prototype._translate = function (x, y) {
    /*父容器滑动模式*/
    if (this.options.scope === 'parent') {
      if (this.options.scrollY) {
        Xut.style.setTranslate({ y: y, node: this.scroller });
      }
    }
    /*更新坐标*/
    this.x = x;
    this.y = y;
  };

  /**
   * 获取滚动的尺寸
   */
  Swiper.prototype._getRollVisual = function () {
    var orientation = this.orientation;
    if (orientation) {
      return this.orientation === 'h' ? this.actualWidth : this.actualHeight;
    }
    //在flow初始化时候，在边界往PPT滑动，是没有值的，所以需要通过全局参数判断
    return this.options.scrollX ? this.actualWidth : this.actualHeight;
  };

  /**
   * 获取滚动的距离值
   * 获取用户在页面滑动的距离
   * flow页面
   * 修复2个问题
   *  1 交界处，没有生成全局翻页的dist的值
   *  2 flow内部，滑动鼠标溢出了浏览器，会卡死
   */
  Swiper.prototype._getRollDist = function () {
    var dist = this.orientation === 'h' ? this.distX : this.distY;
    var visualSize = this._getRollVisual();

    /*这是一个bug,临时修复
    如果一开始布局的页面在flow的首位交界的位置，那么往前后翻页
    在全局中还没有产生dist的值，所以这里强制用一个基本值处理*/
    if (dist === undefined) {
      return visualSize / 1.2;
    }

    dist = Math.abs(dist);

    /**
     * 同样在flow中间页，快速用鼠标滑动到app页面外面部分
     * 会产生dist 大于可视区宽度是情况
     * 浏览器调试模式下会出现
     * 会导致动画回到不触发卡死
     * 因为flow的情况下，没有做定时器修复，所以这里强制给一个时间
     */
    if (dist > visualSize) {
      dist = visualSize / 2;
    }

    return Math.abs(dist);
  };

  /**
   * 快速翻页时间计算
   */
  Swiper.prototype._setRate = function () {
    this._speedRate = 50 / this._getRollVisual();
    this._isFastSlider = true;
  };

  /**
   * 复位速率
   */
  Swiper.prototype._resetRate = function () {
    this._speedRate = this._originalRate;
    this._isFastSlider = false;
  };

  /**
   * 判断是否快速翻页
   * 如果是快速翻页
   * 重设置_setRate
   */
  Swiper.prototype._setQuick = function () {
    var startDate = Swiper.getDate();
    if (this._preTapTime) {
      if (startDate - this._preTapTime < FLIPSPEED) {
        this._setRate();
      }
    }
    this._preTapTime = Swiper.getDate();
  };

  /**
   * 边界控制
   */
  Swiper.prototype._isBorder = function (direction) {
    var overflow = void 0;
    var pointer = this.pagePointer;
    var fillength = Object.keys(pointer).length;
    switch (direction) {
      case 'prev':
        //前翻页
        overflow = pointer.middleIndex === 0 && fillength === 2 ? true : false;
        break;
      case 'next':
        //后翻页
        overflow = pointer.middleIndex === this.totalIndex - 1 && fillength === 2 ? true : false;
        break;
    }
    return overflow;
  };

  /**
   * 获取翻页结束的speed的速率
   */
  Swiper.prototype._getFlipOverSpeed = function () {
    var speed = (this._getRollVisual() - this._getRollDist()) * this._speedRate;
    if (speed === undefined) {
      speed = this._defaultFlipTime;
    }
    return speed;
  };

  /**
   * 如果是通过接口翻页的
   * 就需要计算出2次翻页的点击速率
   * 可能是快速翻页
   * @return {[type]} [description]
   */
  Swiper.prototype._getOuterSpeed = function (action) {
    var speed = undefined;

    /*外部调用，比如左右点击案例，需要判断点击的速度*/
    if (action === 'outer') {
      /*如果是第二次开始同一个点击动作*/
      if (action === this._recordRreTick.action) {
        /*最大的点击间隔时间不超过默认的_defaultFlipTime时间，最小的取间隔时间*/
        var time = Swiper.getDate() - this._recordRreTick.time;
        if (time <= this._defaultFlipTime) {
          speed = time;
        } else {
          speed = this._defaultFlipTime;
        }
      }
      /*点击时间啊*/
      this._recordRreTick.time = Swiper.getDate();

      /*外部调用，第一次没有速度，就用默认的*/
      if (speed === undefined) {
        speed = this._defaultFlipTime;
      }
    }

    /*保存每次点击动作*/
    this._recordRreTick.action = action;

    return speed;
  };

  /**
   * 滑动到上下页面
   * 需要区分是否快速翻页
   * 这里有内部翻页跟外部接口调用的处理
   * 内部翻页存在了speed算法
   * 外部翻页需要通过点击的时间差计算
   * direction
   *   "perv" / "next"
   * action
   *   1. inner 用户直接翻页滑动触发，提供hasTouch
   *   2. outer 通过接口调用翻页
   */
  Swiper.prototype._slideTo = function (_ref) {
    var _this = this;

    var speed = _ref.speed,
        action = _ref.action,
        direction = _ref.direction,
        callback = _ref.callback;


    //如果在忙碌状态,如果翻页还没完毕
    if (!this.enabled) {
      return;
    }

    /*外部调用，direction需要更新
    内部调用赋予direction*/
    if (direction) {
      this.direction = direction;
    } else {
      direction = this.direction;
    }

    /**
     * _slideTo => Swipe.prototype.next => Xut.View.GotoNextSlide
     *如果行为一致,并且是外部接口调用，
     *需要手动计算出滑动的speed
     *  inner 用户内部滑动
     *  outer 外部接口调用
     */
    var outerSpeed = speed || this._getOuterSpeed(action);

    /*是外部调用触发接口
    提供给翻页滑动使用*/
    var outerCallFlip = outerSpeed === undefined ? false : true;

    //前后边界
    if (this.options.snap && this._isBorder(direction)) return;

    this.disable();
    this._setQuick();

    /**
     * 监听内部翻页，通过接口调用
     * 需要翻页结束后触发外部通知，绑定一次
     */
    if (callback) {
      this.$$once('_slideFlipOver', callback);
    }

    var distance = 0;

    /*如果启动了内部模式滑动，然后往前翻页，就应该是一半的尺寸，而不是0*/
    if (this.options.insideScroll && this.direction === 'prev') {
      distance = -(this.actualWidth / 2);
    }

    this._distributeMove({
      distance: distance,
      'speed': outerSpeed || this._getFlipOverSpeed(),
      'action': 'flipOver',
      direction: direction,
      outerCallFlip: outerCallFlip
    });

    /*更新数据，触发停止动作*/
    setTimeout(function () {
      _this._updateActionPointer();
      /*手指移开屏幕*/
      _this.$$emit('onEnd', _this.pagePointer);
      _this._updateVisualIndex(_this.pagePointer.middleIndex);
    }, 0);
  };

  /**
   * 增加索引的动作
   * 修正页码指示
   */
  Swiper.prototype._updateActionPointer = function () {

    var pointer = this.pagePointer;

    //获取动作索引
    var actionPointer = getActionPointer(this.direction, pointer.frontIndex, pointer.backIndex);

    var createIndex = actionPointer.createIndex;
    var stopIndex = pointer.middleIndex;

    switch (this.direction) {
      case 'prev':
        if (-1 < createIndex) {
          //首页情况
          this._updatePointer(createIndex, pointer.frontIndex, pointer.middleIndex);
        }
        if (-1 === createIndex) {
          this.pagePointer.backIndex = pointer.middleIndex;
          this.pagePointer.middleIndex = pointer.frontIndex;
          delete this.pagePointer.frontIndex;
        }
        break;
      case 'next':
        if (this.totalIndex > createIndex) {
          this._updatePointer(pointer.middleIndex, pointer.backIndex, createIndex);
        }
        if (this.totalIndex === createIndex) {
          //如果是尾页
          this.pagePointer.frontIndex = pointer.middleIndex;
          this.pagePointer.middleIndex = pointer.backIndex;
          delete this.pagePointer.backIndex;
        }
        break;
    }

    //更新页面索引标识
    this.pagePointer.createIndex = createIndex;
    this.pagePointer.destroyIndex = actionPointer.destroyIndex;
    this.pagePointer.stopIndex = stopIndex;
  };
}

function distribute$1(Swiper) {

  /**
   * 处理松手后滑动
   * pageIndex 页面
   * distance  移动距离
   * speed     时间
   * viewTag   可使区标记
   * follow    是否为跟随滑动
   * @return {[type]} [description]
   */
  Swiper.prototype._distributeMove = function (data) {
    data.direction = this.direction;
    data.orientation = this.orientation;

    /*页码索引标识*/
    var pointer = this.pagePointer;
    data.frontIndex = pointer.frontIndex;
    data.backIndex = pointer.backIndex;
    data.middleIndex = this.visualIndex;

    this.$$emit('onMove', data);
  };

  /*
  翻页结束后，派发动作完成事件
  1 还原动作参数
  2 触发翻页的内部事件监听
  3 延长获取更pagePointer的更新值，并且解锁
   */
  Swiper.prototype._distributeComplete = function () {
    var _this = this;

    this._setRestore.apply(this, arguments);
    /*触发翻页结束，通过slideTo绑定*/
    this.$$emit('_slideFlipOver');
    var callback = function callback() {
      return _this.enable();
    };
    setTimeout(function () {
      _this.$$emit('onComplete', {
        unlock: callback,
        direction: _this.direction,
        pagePointer: _this.pagePointer,
        isFastSlider: _this._isFastSlider
      });
    }, 50);
  };
}

/***********************
        惯性算法
************************/

var transitionDuration$2 = Xut.style.transitionDuration;

var ABS = Math.abs;

/**
 * 是否多点触发
 * @return {Boolean} [description]
 */
var hasMultipleTouches = function hasMultipleTouches(e) {
  return e.touches && e.touches.length > 1;
};

/**
 * 自定义事件类型
 * onSwipeDown 触屏点击
 * onSwipeMove 触屏移动
 * onSwipeUp   触屏松手
 * onSwipeUpSlider触屏松手 滑动处理
 * onFlipSliding 松手动画（反弹）
 * onFlipRebound 执行反弹
 * _onComplete 动画完成
 * onDropApp 退出应用
 */

var Swiper = function (_Observer) {
  inherits(Swiper, _Observer);
  createClass(Swiper, null, [{
    key: 'mixProperty',
    value: function mixProperty(target, src) {
      for (var key in src) {
        target[key] = src[key];
      }
    }
  }, {
    key: 'getDate',
    value: function getDate() {
      return +new Date();
    }

    /**
     * 静态方法，获取基本配置
     * @return {[type]} [description]
     */

  }, {
    key: 'getConfig',
    value: function getConfig() {
      /*提供swiperConfig快速配置文件,关键配置*/
      var scrollX = true;
      var scrollY = false;
      if (config.launch.scrollMode === 'v') {
        scrollX = false;
        scrollY = true;
      }
      return {
        scrollY: scrollY,
        scrollX: scrollX,
        banMove: config.launch.gestureSwipe === false ? true : false
      };
    }

    /**
     * 2种大模式
     * 1 分段，分变化
     * 2 分段，不分变化
     * @type {String}
     */

  }]);

  function Swiper(_ref) {
    var _ref$scope = _ref.scope,
        scope = _ref$scope === undefined ? 'child' : _ref$scope,
        _ref$snap = _ref.snap,
        snap = _ref$snap === undefined ? true : _ref$snap,
        _ref$snapSpeed = _ref.snapSpeed,
        snapSpeed = _ref$snapSpeed === undefined ? 800 : _ref$snapSpeed,
        _ref$banMove = _ref.banMove,
        banMove = _ref$banMove === undefined ? false : _ref$banMove,
        _ref$momentum = _ref.momentum,
        momentum$$1 = _ref$momentum === undefined ? true : _ref$momentum,
        _ref$scrollX = _ref.scrollX,
        scrollX = _ref$scrollX === undefined ? true : _ref$scrollX,
        _ref$scrollY = _ref.scrollY,
        scrollY = _ref$scrollY === undefined ? false : _ref$scrollY,
        _ref$mouseWheel = _ref.mouseWheel,
        mouseWheel = _ref$mouseWheel === undefined ? false : _ref$mouseWheel,
        _ref$hasHook = _ref.hasHook,
        hasHook = _ref$hasHook === undefined ? false : _ref$hasHook,
        _ref$borderBounce = _ref.borderBounce,
        borderBounce = _ref$borderBounce === undefined ? true : _ref$borderBounce,
        _ref$stopPropagation = _ref.stopPropagation,
        stopPropagation = _ref$stopPropagation === undefined ? false : _ref$stopPropagation,
        _ref$preventDefault = _ref.preventDefault,
        preventDefault = _ref$preventDefault === undefined ? true : _ref$preventDefault,
        _ref$insideScroll = _ref.insideScroll,
        insideScroll = _ref$insideScroll === undefined ? false : _ref$insideScroll,
        container = _ref.container,
        visualIndex = _ref.visualIndex,
        totalIndex = _ref.totalIndex,
        actualWidth = _ref.actualWidth,
        actualHeight = _ref.actualHeight,
        hasMultiPage = _ref.hasMultiPage,
        sectionRang = _ref.sectionRang,
        visualWidth = _ref.visualWidth;
    classCallCheck(this, Swiper);

    /*加强判断，如果*/
    var _this = possibleConstructorReturn(this, (Swiper.__proto__ || Object.getPrototypeOf(Swiper)).call(this));

    if (insideScroll) {
      if (!visualWidth || visualWidth && actualWidth < visualWidth) {
        insideScroll = false;
        $warn({
          type: 'swiper',
          content: '启动了insideScroll，但是条件还不成立'
        });
      }
    }

    Swiper.mixProperty(_this, {
      container: container,
      visualIndex: visualIndex,
      totalIndex: totalIndex,
      actualWidth: actualWidth,
      actualHeight: actualHeight,
      visualWidth: visualWidth
    });

    _this.options = {
      scope: scope,
      snap: snap,
      banMove: banMove,
      scrollX: scrollX,
      scrollY: scrollY,
      momentum: momentum$$1,
      mouseWheel: mouseWheel,
      insideScroll: insideScroll,
      hasHook: hasHook,
      borderBounce: borderBounce,
      stopPropagation: stopPropagation,
      preventDefault: preventDefault,
      hasMultiPage: hasMultiPage,
      sectionRang: sectionRang

      /**
       * 滑动的方向
       * 横版：prev next (left/right)
       * 竖版：prev next (up/down)
       */
    };_this.direction = '';

    /*默认允许滑动*/
    _this.enabled = true;

    /*翻页时间*/
    _this._defaultFlipTime = banMove ? 0 : snapSpeed;

    /*翻页速率*/
    _this._speedRate = _this._originalRate = _this._defaultFlipTime / (scrollX ? actualWidth : actualHeight);

    /*计算初始化页码*/
    _this.pagePointer = initPointer(visualIndex, totalIndex);

    /*标记上一个翻页动作*/
    _this._recordRreTick = { ation: null, time: null };

    _this._init();

    /*保存上次滑动值*/
    _this.keepDistX = 0;
    _this.keepDistY = 0;

    /*内部滑动页面，优化边界的敏感度*/
    _this.insideScrollRange = {
      min: visualWidth * 0.01,
      max: visualWidth - visualWidth * 0.01
    };

    return _this;
  }

  /**
   * 事件处理
   */


  createClass(Swiper, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      this.options.stopPropagation && e.stopPropagation();
      $handle({
        start: function start(e) {
          //如果没有配置外部钩子
          if (!this.options.hasHook) {
            this._stopDefault(e);
          }
          this._onStart(e);
        },
        move: function move(e) {
          this._stopDefault(e);
          this._onMove(e);
        },
        end: function end(e) {
          if (!this.options.hasHook) {
            this._stopDefault(e); //超链接有影响
          }
          this._onEnd(e);
        },
        transitionend: function transitionend(e) {
          this._stopDefault(e);
          this._onComplete(e);
        }
      }, this, e);
    }

    /**
     * 触发页面
     */

  }, {
    key: '_onStart',
    value: function _onStart(e) {

      //如果停止滑动
      //或者多点触发
      if (!this.enabled || hasMultipleTouches(e)) {
        return;
      }

      //判断双击速度
      //必须要大于350
      var currtTime = Swiper.getDate();
      if (this._clickTime) {
        if (currtTime - this._clickTime < 350) {
          return;
        }
      }
      this._clickTime = currtTime;

      var interrupt = void 0;
      var point = $event(e);

      /*如果没有事件对象*/
      if (!point) {
        this._stopped = true;
        return;
      }

      /**
       * 获取观察对象
       * 钩子函数
       * point 事件对象
       * @return {[type]} [description]
       */
      this.$$emit('onFilter', function () {
        interrupt = true;
      }, point, e);

      /*打断动作*/
      if (interrupt) return;

      /*针对拖拽翻页阻止是否滑动事件受限*/
      this._stopped = false; //如果页面停止了动作，触发
      this._banBounce = false; //是否有禁止了反弹
      this._hasTap = true; //点击了屏幕
      this._isInvalid = false; //无效的触发
      this._moved = false; /*是否移动中*/
      this._behavior = 'swipe'; //用户行为

      /*锁定滑动相反方向*/
      this._directionBan = false;

      /*滑动方向*/
      this.orientation = '';

      this.distX = 0;
      this.distY = 0;

      /*手指触碰屏幕移动的距离，这个用于反弹判断*/
      this.touchX = 0;
      this.touchY = 0;

      this.pointX = point.pageX;
      this.pointY = point.pageY;

      /*每次滑动第一次触碰页面的实际移动坐标*/
      this.firstMovePosition = 0;

      this.startTime = Swiper.getDate();
    }

    /**
     * 移动
     */

  }, {
    key: '_onMove',
    value: function _onMove(e) {

      //如果停止翻页
      //或者没有点击
      //或是Y轴滑动
      //或者是阻止滑动
      if (!this.enabled || !this._hasTap || this._stopped) return;

      this._moved = true;

      var point = $event(e);

      /*每次滑动的距离*/
      var deltaX = point.pageX - this.pointX;
      var deltaY = point.pageY - this.pointY;
      var absDistX = ABS(deltaX);
      var absDistY = ABS(deltaY);

      /**
       * 判断锁定横竖版滑动
       * 只锁定一次
       * 因为在滑动过程中，
       * 用户的手指会偏移方向，
       * 比如开始是h滑动，在中途换成v了，但是还是锁定h
       */
      var $delta = void 0,
          $absDelta = void 0;
      if (absDistX > absDistY) {
        if (!this.orientation) {
          this.orientation = 'h';
        }
        $delta = deltaX;
        $absDelta = absDistX;
      } else if (absDistY >= absDistX) {
        if (!this.orientation) {
          this.orientation = 'v';
        }
        $delta = deltaY;
        $absDelta = absDistY;
      }

      /**
       * 1.相反方向禁止滑动
       * 2.提供给sendTrackCode使用
       *     猜测用户的意图，滑动轨迹小于80,想翻页
       *     猜测用户相反的方向意向
       *     比如横屏的时候，用户想竖屏上下滑动翻页
       *     竖屏的时候，用户想横屏左右翻页
       *     如果继续保持了Y轴移动，记录下最大偏移量算不算上下翻页动作
       */
      if (this.options.scrollX && this.orientation === 'v') {
        //左右翻页，猜测上下翻页
        if ($absDelta > 80) {
          this._behavior = 'reverse';
        }
        this._directionBan = 'v';
      } else if (this.options.scrollY && this.orientation === 'h') {
        //上下翻页，猜测左右翻页
        if ($absDelta > 80) {
          this._behavior = 'reverse';
        }
        this._directionBan = 'h';
      }

      /*滑动距离*/
      var $dist = void 0;
      if (this.orientation === 'h') {
        this.touchX = this._getDist(deltaX, absDistX);
        $dist = this.distX = this.touchX + this.keepDistX;
        this.setDirection(deltaX);
      } else if (this.orientation === 'v') {
        this.touchY = this._getDist(deltaY, absDistY);
        $dist = this.distY = this.touchY + this.keepDistY;
        this.setDirection(deltaY);
      }

      /*锁定*/
      if (this._directionBan) return;

      /*
       * 减少抖动
       * 算一次有效的滑动
       * 移动距离必须20px才开始移动
       */
      var delayDist = 10;
      var distance = $dist;
      if ($absDelta <= delayDist) return;

      /**
       * 因为抖动优化的关系，需要重新计算distX distY的值
       */
      if (this.direction === 'prev') {
        //正值递增
        distance = this.distX = this.distY = $dist - delayDist;
      } else if (this.direction === 'next') {
        //负值递增
        distance = this.distX = this.distY = $dist + delayDist;
      }

      var self = this;
      this._distributeMove({
        distance: distance,
        speed: 0,
        action: 'flipMove',
        /**
         * 因为模式5的情况下，判断是否是边界，需要获取正确的页面值才可以
         * 获取的值，需要转化，所以必须流程在在后面的代码中控制
         * 移动页面在反弹计算之后，所以必须在延后 movePageBases中判断是否为反弹
         */
        setPageBanBounceCallback: function setPageBanBounceCallback(position) {

          //如果没有启动边界反弹
          //要主动探测下是否到了边界
          if (!self.options.borderBounce) {
            //如果是到边界了，就禁止反弹
            if (self._banBounce = self._borderBounce(position)) {
              return true;
            }
          }

          //模式5下，边界翻页的敏感度处理
          //滑动页面到边界的时候，需要判断当前的操作行为
          //确定是否是翻页行为
          if (self.options.insideScroll) {

            var absPosition = Math.abs(position);

            /*只判断每次移动的，第一次触碰*/
            if (!self.firstMovePosition) {
              self.firstMovePosition = absPosition;
            }

            if (self.direction === 'next') {
              if (absPosition >= self.visualWidth) {
                if (self.firstMovePosition > self.insideScrollRange.max) {

                  /*如果是单页面，并且右边移动溢出了，这需要处理*/
                  if (!self.options.hasMultiPage) {
                    self._setKeepDist(-self.visualWidth, 0);
                    self._banBounce = true;
                    return true;
                  }

                  /*如果是在尾部边界的位置翻页，是被允许的*/
                  return false;
                } else {
                  /*其余位置都是被禁止翻页的*/
                  self._setKeepDist(-self.visualWidth, 0);
                  self._banBounce = true;
                  return true;
                }
              }
            } else if (self.direction === 'prev') {
              // 边界
              if (position >= 0) {
                if (self.firstMovePosition < self.insideScrollRange.min) {
                  return false;
                } else {
                  self._setKeepDist(0, 0);
                  self._banBounce = true;
                  return true;
                }
              }
            }
          }
        },

        /**
         * 是否无效函数
         * 如果无效，end方法抛弃掉
         * 必须是同步方法：
         * 动画不能在回调中更改状态，因为翻页动作可能在动画没有结束之前，所以会导致翻页卡住
         */
        setSwipeInvalidCallback: function setSwipeInvalidCallback() {
          self._isInvalid = true;
        }
      });
    }

    /**
     * 翻页松手
     */

  }, {
    key: '_onEnd',
    value: function _onEnd(e) {

      /*停止滑动，或者多点触发，或者是边界，或者是停止翻页*/
      if (!this.enabled || this._banBounce || this._stopped || hasMultipleTouches(e)) {
        return;
      }

      this._hasTap = this._moved = false;

      var duration = void 0;

      /*可能没有点击页面，没有触发start事件*/
      if (this.startTime) {
        duration = Swiper.getDate() - this.startTime;
      }

      /*滑动距离、滑动方向*/
      var distX = ABS(this.distX);
      var distY = ABS(this.distY);
      var orientation = this.orientation;

      /*如果没有滚动页面，判断为点击
        2017.8.30
        在三星9150设备上，没用移动，会产生X或Y的移动值，很小的值
        兼容处理X Y 都要<5
      */
      if (!distX && !distY || distX && distX < 5 && !distY || distY && distY < 5 && !distX) {
        var isReturn = false;
        this.$$emit('onTap', this.visualIndex, function () {
          return isReturn = true;
        }, e, duration);
        if (isReturn) return;
      }

      /*如果是Y轴移动，发送请求,并且不是mouseleave事件，在PC上mouseleave离开非可视区重复触发*/
      if (this._behavior === 'reverse' && e.type !== 'mouseleave') {
        config.sendTrackCode('swipe', {
          'direction': orientation,
          'pageId': this.visualIndex + 1
        });
      }

      /**
       * 锁定滑动
       * 1 横版模式下，如果有Y滑动，但是如果没有X的的变量，就判断无效
       * 1 竖版模式下，如果有X滑动，但是如果没有Y的的变量，就判断无效
       */
      if (this._directionBan === 'v' && !this.distX) {
        return;
      } else if (this._directionBan === 'h' && !this.distY) {
        return;
      }

      /**
       * mini功能，合并翻页时事件
       * move的情况会引起
       * 如果是无效的动作，则不相应
       * 还原默认设置
       */
      if (this._isInvalid) {
        var hasSwipe = void 0;
        if (orientation === 'h') {
          hasSwipe = duration < 200 && distX > this.actualWidth / 10;
        } else if (orientation === 'v') {
          hasSwipe = duration < 200 && distY > this.actualHeight / 10;
        }
        if (hasSwipe) {
          this._distributeMove({ action: 'swipe' });
        }
        this._setRestore();
        return;
      }

      /**
       * 动作推测
       * 1 翻页或者反弹，或者移动
       * 2 这里要区分PPT之间，与PPT内部滑动
       */
      var actionType = this.getActionType(this.touchX, this.touchY, duration);

      /**
       * 单独控制翻页的预加载检测
       * 如果还在预加载中，强制翻页为反弹
       * 然后记录动作，等加载结束后处理
       */
      if (actionType === 'flipOver' && config.launch.preload) {
        var status = requestInterrupt({
          type: 'linear',
          direction: this.direction,
          /*预加载加载结束*/
          processed: function processed() {
            this._nextAction('flipOver');
            Xut.View.HideBusy();
          }
        }, this);

        /*如果还在预加载，执行反弹与等待*/
        if (status) {
          Xut.View.ShowBusy();
          actionType = 'flipRebound';
        }
      }

      /*正常松手后动作处理*/
      this._nextAction(actionType);
    }

    /**
     * 执行松手后的动作
     */

  }, {
    key: '_nextAction',
    value: function _nextAction(actionType) {

      /*如果是首位页面，直接反弹*/
      if (this._isFirstOrEnd()) {
        /*如果是是内部滚动模式，而且还是最后一页*/
        if (this.options.insideScroll) {
          if (this.direction === 'next') {
            if (actionType === 'flipMove') {
              /*如果是向后移动，更新distX*/
              this._setKeepDist(this.distX, this.distY);
            } else if (actionType === 'flipOver' || actionType === 'flipRebound') {
              /*如果是向后移动反弹*/
              var distance = -(this.actualWidth / 2);
              this._setRebound({ distance: distance });
              this._setKeepDist(distance);
            }
          } else if (this.direction === 'prev') {
            /*向前翻页，反弹或者翻页，都强制设置反弹*/
            var _distance = 0;
            this._setRebound({ distance: _distance });
            this._setKeepDist(_distance);
          }
          return;
        }
        this._setKeepDist();
        this._setRebound();
      } else if (actionType === 'flipOver') {
        /*如果是翻页动作*/
        this._setKeepDist();
        this._slideTo({ action: 'inner' });
      } else if (actionType === 'flipRebound') {
        /*如果启动了insideScroll*/
        if (this.options.insideScroll) {
          /*并且是后往回方向反弹，那么反弹的距离只有一半*/
          if (this.direction === 'next') {
            var _distance2 = -(this.actualWidth / 2);
            this._setRebound({ distance: _distance2 });
            this._setKeepDist(_distance2);
          } else if (this.direction === 'prev') {
            /*前反弹，设置为开始值*/
            var _distance3 = 0;
            this._setRebound({ distance: _distance3 });
            this._setKeepDist(_distance3);
          }
        } else {
          /*正常单页PPT的反弹*/
          this._setRebound();
        }
      } else if (actionType === 'flipMove') {
        /*如果还是内部移动*/
        this._setKeepDist(this.distX, this.distY);
      }
    }

    /**
     * 设置Keep
     * @return {[type]} [description]
     */

  }, {
    key: '_setKeepDist',
    value: function _setKeepDist() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this.keepDistX = x;
      this.keepDistY = y;
    }

    /*
    判断是不是首位页面，直接反弹
    如果是首尾
    如果是liner模式排除
    */

  }, {
    key: '_isFirstOrEnd',
    value: function _isFirstOrEnd(actionType) {
      if (this.options.snap) {
        if (this.orientation === 'h') {
          return !this.visualIndex && this.distX > 0 || this.visualIndex == this.totalIndex - 1 && this.distX < 0;
        }
        if (this.orientation === 'v') {
          return !this.visualIndex && this.distY > 0 || this.visualIndex == this.totalIndex - 1 && this.distY < 0;
        }
      } else {
        return false;
      }
    }

    /**
     * 鼠标滚动
     * win 平台鼠标每次滑动一次产生一次变化
     * mac 平台带有惯性
     * @return {[type]} [description]
     */

  }, {
    key: '_onWheel',
    value: function _onWheel(e) {

      e.preventDefault();
      e.stopPropagation();

      var wheelDeltaX = void 0,
          wheelDeltaY = void 0;

      if ('deltaX' in e) {
        wheelDeltaX = -e.deltaX;
        wheelDeltaY = -e.deltaY;
      } else if ('wheelDeltaX' in e) {
        wheelDeltaX = e.wheelDeltaX;
        wheelDeltaY = e.wheelDeltaY;
      } else if ('wheelDelta' in e) {
        wheelDeltaX = wheelDeltaY = e.wheelDelta;
      } else if ('detail' in e) {
        wheelDeltaX = wheelDeltaY = -e.detail;
      } else {
        return;
      }

      /*强制修复滑动的方向是上下
      因为在页面中左右滑动一下，这个值被修改
      后续就会报错*/
      this.orientation = 'v';

      this.$$emit('onWheel', e, wheelDeltaY);

      return;
    }

    /**
     * 翻页结束
     */

  }, {
    key: '_onComplete',
    value: function _onComplete(e) {

      var node = e.target;
      /*page与master*/
      var pageType = node.getAttribute('data-type');
      /*可能存在多组动画回调，只找到标记data-visual的页面，可视窗口*/
      var isVisual = node.getAttribute('data-visual');
      /*线性的布局方式，cloumn使用*/
      var isLinearVisual = node.getAttribute(LINEARTAG);

      this._removeDuration(node);

      //cloumn流式布局处理
      if (isLinearVisual && !isVisual) {
        this._distributeComplete(node, isVisual);
        return;
      }

      //反弹效果,未翻页
      //页面与母版都不触发回调
      if (!isVisual) {
        //只针对母板处理
        if (!pageType) {
          this.$$emit('onMasterMove', this.visualIndex, node);
        }
        return;
      }

      this._distributeComplete(node, isVisual);
    }

    /**
     * 获取移动距离
     */

  }, {
    key: '_getDist',
    value: function _getDist(value, absDist) {
      return value / (!this.visualIndex && value > 0 || // 在首页
      this.visualIndex == this.totalIndex - 1 && // 尾页
      value < 0 // 中间
      ? absDist / this.actualWidth + 1 : 1);
    }

    /**
     * 前尾边界反弹判断
     */

  }, {
    key: '_borderBounce',
    value: function _borderBounce(position) {
      //首页,并且是左滑动
      if (this.visualIndex === 0 && position > 0) {
        /*到首页边界，end事件不触发，还原内部的值*/
        this._setKeepDist(0, 0);
        return true;
      } else if (this.visualIndex === this.totalIndex - 1) {

        //如果是模式5，左右页面
        //让在最后一页需要判断可以向前移动
        //不能通过position<0因为position左边移动也是<0
        if (this.options.insideScroll) {
          //往后翻页，需要判断
          if (this.direction === 'next' && Math.abs(position) > this.visualWidth) {
            //最后一页，还往右边翻需要禁止
            return true;
          }
          //往前翻
          if (this.direction === 'prev' && position > 0) {
            return true;
          }
        } else {
          //单页模式的尾页
          if (position < 0) {
            return true;
          }
        }
      }
    }

    /**
     * 设置反弹
     * isBoundary ##317
     * 边界后反弹，最后一页刚好有是视觉差，反弹不归位
     * 这里要强制处理
     * 外部接口可以设置参数
     */

  }, {
    key: '_setRebound',
    value: function _setRebound() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$distance = _ref2.distance,
          distance = _ref2$distance === undefined ? 0 : _ref2$distance,
          direction = _ref2.direction,
          isAppBoundary = _ref2.isAppBoundary;

      this._distributeMove({
        direction: direction || this.direction, //方向
        distance: distance, //反弹的位置
        isAppBoundary: isAppBoundary, //是边界后，反弹回来的
        'speed': 300,
        'action': 'flipRebound'
      });
    }

    /*去掉动画时间*/

  }, {
    key: '_removeDuration',
    value: function _removeDuration(node) {
      if (node) {
        node.style[transitionDuration$2] = '';
      }
    }

    /**
     * 还原设置
     * 1 针对拖拽翻页阻止
     * 2 恢复速率
     * 3 去掉页面指示
     */

  }, {
    key: '_setRestore',
    value: function _setRestore(node, isVisual) {
      this._stopped = true;
      this._hasTap = false;
      this._resetRate();
      if (isVisual && node) {
        node.removeAttribute('data-visual');
      }
    }

    /**
     * 修正页面索引
     * 设置新的页面可视区索引
     */

  }, {
    key: '_updateVisualIndex',
    value: function _updateVisualIndex(index) {
      this.visualIndex = index;
    }

    /**
     * 更新页码标示
     * 1. 1个数组参数
     * 2. 2个参数
     * 3. 3个参数
     */

  }, {
    key: '_updatePointer',
    value: function _updatePointer(frontIndex, middleIndex, backIndex) {
      if (arguments.length === 3) {
        this.pagePointer = { frontIndex: frontIndex, middleIndex: middleIndex, backIndex: backIndex };
        return;
      }
      //跳转页面传入一个对象数据
      if (arguments.length === 1) {
        var data = frontIndex;
        var newPointers = data.newPointers;
        //设置新的页面当前页码索引
        this._updateVisualIndex(data.targetIndex);
        if (newPointers.length === 3) {
          this._updatePointer(newPointers[0], newPointers[1], newPointers[2]);
        }
        if (newPointers.length === 2) {
          //2017.10.20修复问题
          //根据目标的地址判断是否首页页面，来更新对应的页码
          //如果是跳到首页
          if (newPointers[0] === data.targetIndex) {
            this.pagePointer.backIndex = newPointers[1];
            this.pagePointer.middleIndex = newPointers[0];
            delete this.pagePointer.frontIndex;
          } else {
            //跳尾页
            this.pagePointer.frontIndex = newPointers[0];
            this.pagePointer.middleIndex = newPointers[1];
            delete this.pagePointer.backIndex;
          }
        }
        return;
      }
    }

    /**
     * 销毁事件
     * @return {[type]} [description]
     */

  }, {
    key: '_off',
    value: function _off() {
      $off(this.container);
    }
  }]);
  return Swiper;
}(Observer);

api(Swiper);
init(Swiper);
slide(Swiper);
distribute$1(Swiper);

////////////////////////
/// 全局钩子
////////////////////////

/**
 * 阻止元素的默认行为
 * 在火狐下面image带有href的行为
 * 会自动触发另存为
 * @return {[type]} [description]
 *
 * 2016.3.18
 * 妙妙学 滚动插件默认行为被阻止
 *
 * 2016.7.26
 * 读库强制PC模式了
 */
function swiperHook(e, node) {

  //禁止鼠标右键
  if (e.button && e.button == 2) {
    return;
  }

  var dataType = node.getAttribute('data-type');

  //代码跟踪
  //如果是点击的超链接页面
  //这个是fast-pipe功能
  var hasTyperlink = false;
  if (dataType === 'hyperlink') {
    hasTyperlink = true;
    config.sendTrackCode('hot', {
      id: node.getAttribute('data-id'),
      pageId: node.getAttribute('data-page-id'),
      type: 'hyperlink',
      eventName: 'tap'
    });
  }

  var nodeName = node.nodeName.toLowerCase();

  //如果是移动端的情况下 && 支持二维码 && 是图片 && 是二维码标记
  if (config.launch.supportQR && Xut.plat.hasTouch && nodeName === "img" && dataType === 'qrcode') {
    return 'qrcode';
  } else {
    if (Xut.plat.isBrowser && !Xut.IBooks.Enabled && !window.MMXCONFIG && !window.DUKUCONFIG && nodeName !== 'a' && //并且不是a标签(在cloumn中有a标签，需要跳转)
    nodeName !== 'video' && //pc视频控制条不灵敏问题
    !hasTyperlink) {
      //超链接不阻止
      e.preventDefault && e.preventDefault();
    }
  }
}

//调度器
//委托事件处理钩子
var delegateHooks = {

  /**
   * 超连接,跳转
   * svg内嵌跳转标记处理
   */
  'data-xxtlink': function dataXxtlink(target, attribute, rootNode, pageIndex) {
    try {
      var para = attribute.split('-');
      if (para.length > 1) {
        //如果有多个就是多场景的组合
        Xut.View.GotoSlide(para[0], para[1]);
      } else {
        Xut.View.GotoSlide(para[0]);
      }
    } catch (err) {
      console.log('跳转错误');
    }
  },


  /**
   * Action', 'Widget', 'Video', 'ShowNote', 'SubDoc'委托
   * arg
   *   target, attribute, rootNode, pageIndex
   */
  'data-delegate': function dataDelegate(target, attribute, rootNode, pageIndex) {
    $trigger({
      target: target,
      attribute: attribute,
      rootNode: rootNode,
      pageIndex: pageIndex
    });
  },


  /**
   * 有效,可滑动
   */
  'data-flow': function dataFlow() {},


  /**
   * 如果是canvas节点
   */
  'data-canvas': function dataCanvas(cur) {
    // alert(1)
  }
};

//事件钩子
/**
 * 简化委托处理，默认一层元素只能绑定一个委托事件
 */
function closestProcessor(event, pageType) {

  var i,
      k,
      attribute,
      attributes,
      value,
      cur = event.target;

  if (cur.nodeType) {
    //如果触发点直接是li
    if (cur === this) {
      return {
        'rootNode': this,
        'elem': cur,
        'handlers': delegateHooks['data-container']
      };
    }
    //否则是内部的节点
    try {
      for (; cur !== this; cur = cur.parentNode || this) {
        //如果是canvas节点
        if (cur.nodeName && cur.nodeName.toLowerCase() === 'canvas') {
          //是否为滑动行为
          if (Xut.Contents.Canvas.getSupportState()) {
            return true;
          } else {
            return false;
          }
        }
        //如果是dom节点
        attributes = cur['attributes'];
        for (k in delegateHooks) {
          if (attribute = attributes[k]) {
            value = attribute['value' || 'nodeValue'];
            return {
              'rootNode': this,
              'elem': cur,
              'attribute': value,
              'pageType': pageType,
              'handlers': delegateHooks[k]
            };
          }
        }
      }
    } catch (err) {
      // Xut.plat.isBrowser && console.log('默认事件跟踪', err)
    }
  }
}

/*
委托处理媒体
视频、音频
 */
function closestMedia(target, chapterId, pageIndex) {
  if (target) {

    var hasPoster = target.getAttribute('data-type');

    /*
      如果是column视频的poster层
      1 保存视频的嵌套容器
      2 修正target的目标为父容器Video
      视频播放节点与图片Poster是平行的
      poster 层级index -1
      video  层级index 0
    */
    var container = void 0;
    if (hasPoster === 'poster' && !key) {
      container = target;
      target = target.parentNode;
    }

    var key = target.getAttribute('id');
    var matchType = key && key.match(/(Audio|Video)_(\w+)/);
    if (matchType) {
      var fileName = target.getAttribute('data-name'); //文件名
      if (fileName) {
        var type = matchType[1];
        var id = matchType[2];

        if (fileName) {
          $trigger({
            target: target,
            pageIndex: pageIndex
          }, {
            id: id,
            type: type,
            startImage: target.getAttribute('data-startImage'),
            stopImage: target.getAttribute('data-stopImage'),
            container: container || target,
            track: 8888, //播放就删除
            chapterId: 'column',
            isColumn: true,
            fileName: fileName
          });
        }
      } else {
        console.log('column中的媒体文件不存在');
      }
    }
  }
}

/**
 * 2017.9.7
 * 流式排版
 */

var ColumnClass = function () {
  function ColumnClass(_ref) {
    var _this = this;

    var rootNode = _ref.rootNode,
        pptMaster = _ref.pptMaster,
        pageIndex = _ref.pageIndex,
        seasonId = _ref.seasonId,
        chapterId = _ref.chapterId,
        callback = _ref.callback;
    classCallCheck(this, ColumnClass);

    /*存放缩放对象*/
    this._scaleObjs = {};
    this.pptMaster = pptMaster;
    this.chapterId = chapterId;
    this.seasonId = seasonId;
    this.initIndex = pageIndex;
    this.$container = $($('#chapter-flow-' + chapterId).html());

    /*布局显示*/
    Xut.nextTick({
      container: rootNode,
      content: this.$container
    }, function () {
      if (config.launch.scrollMode === 'h') {
        _this._initX();
      } else if (config.launch.scrollMode === 'v') {
        _this._initY();
      }
      callback();
    });
  }

  /**
   * 缩放图片
   */


  createClass(ColumnClass, [{
    key: '_zoomPicture',
    value: function _zoomPicture(node) {
      var src = node.src;
      if (!src) {
        return;
      }

      var conver = converUrlName(src);
      var original = conver.original;

      /*存在*/
      var zoomObj = this._scaleObjs[original];
      if (zoomObj) {
        return zoomObj.play();
      }

      /*创建*/
      this._scaleObjs[original] = new ScalePicture({
        element: $(node),
        originalSrc: getFileFullPath(conver.suffix, 'column-zoom'),
        hdSrc: getFileFullPath(conver.hdName, 'getHDFilePath')
      });
    }

    /**
     * pagesCount = 5
     *   等分=> 0.25/0.5/0.75/1/0
     */

  }, {
    key: '_getNodes',
    value: function _getNodes() {
      if (this.pptMaster) {
        var nodes = [];
        var ratio = 1 / (this.columnCount - 1); //比值
        for (var i = 1; i < this.columnCount; i++) {
          nodes.push(i * ratio);
        }
        return nodes.push(0);
      }
    }

    /**
     * 获取母版对象
     */

  }, {
    key: '_getMasterObj',
    value: function _getMasterObj() {
      if (this._masterObj) {
        return this._masterObj;
      }
      if (this.pptMaster) {
        this._masterObj = Xut.Presentation.GetPageBase('master', this.initIndex);
      }
    }

    /**
     * 移动视觉差
     * 处理当前页面内的视觉差对象效果
     */

  }, {
    key: '_moveParallax',
    value: function _moveParallax(action, speed, nodes, visualIndex, direction, viewBeHideDistance) {
      var masterObj = this._getMasterObj();
      if (masterObj) {
        masterObj.moveParallax({
          speed: speed,
          action: action,
          direction: direction,
          pageIndex: visualIndex + 1,
          moveDistance: viewBeHideDistance,
          nodes: direction === 'next' ? nodes[visualIndex] : ''
        });
      }
    }

    /**
     * 横版处理
     * 更新页码
     */

  }, {
    key: '_updataPageNumber',
    value: function _updataPageNumber(direction, location) {
      var initIndex = this.initIndex;
      if (location) {
        direction = location === 'right' ? 'prev' : 'next';
        if (location === 'middle' && initIndex > 0) {
          //如果中间是分栏页
          --initIndex;
        }
      }
      Xut.View.UpdatePage({
        parentIndex: initIndex,
        sonIndex: this.swipe.getVisualIndex() + 1,
        hasSon: true,
        direction: direction
      });
    }

    /**
     * 横版模式下，页面是通过分栏处理的
     * @return {[type]} [description]
     */

  }, {
    key: '_initX',
    value: function _initX() {

      /**************************************
       *     横版模式下的分栏处理
       * ************************************/

      var container = this.$container[0];
      var coloumnObj = this;
      var columnWidth = resetVisualLayout(1).width;

      //分栏数
      this.columnCount = getColumnCount$1(this.seasonId, this.chapterId);

      //边界
      coloumnObj.minBorder = 0;
      coloumnObj.maxBorder = this.columnCount - 1;

      var nodes = this._getNodes();

      var setOptions = {
        container: container,
        scope: 'parent', //父容器滑动
        snap: false, //不分段
        hasHook: true,
        hasMultiPage: true,
        stopPropagation: true,
        visualIndex: Xut.Presentation.GetPageIndex() > coloumnObj.initIndex ? coloumnObj.maxBorder : coloumnObj.minBorder,
        totalIndex: this.columnCount,
        actualWidth: columnWidth
      };

      _.extend(setOptions, Swiper.getConfig());

      /**
       * 分栏整体控制
       * @type {[type]}
       */
      var swipe = this.swipe = new Swiper(setOptions);

      var moveDistance = 0;

      coloumnObj.lastDistance = swipe.getInitDistance();

      var hasQrcode = void 0;
      swipe.$$watch('onFilter', function (hookCallback, point, evtObj) {
        /*二维码*/
        hasQrcode = false;
        if (swiperHook(evtObj, point.target) === 'qrcode') {
          hasQrcode = true;
        }
      });

      swipe.$$watch('onTap', function (pageIndex, hookCallback, point, duration) {
        var node = point.target;
        /*图片缩放*/
        if (!hasQrcode) {
          if (node && node.nodeName.toLowerCase() === "img") {
            coloumnObj._zoomPicture(node);
          }
          if (!Xut.Contents.Canvas.getIsTap()) {
            Xut.View.Toolbar();
          }
        }
        /*点击媒体，视频音频*/
        closestMedia(node, coloumnObj.chapterId, swipe.visualIndex);
      });

      swipe.$$watch('onMove', function (options) {
        var action = options.action,
            speed = options.speed,
            distance = options.distance,
            direction = options.direction;

        /**
         * 首页边界
         */

        if (swipe.visualIndex === coloumnObj.minBorder && swipe.direction === 'prev') {
          if (action === 'flipOver') {
            clearColumnAudio();
            clearVideo();
            Xut.View.GotoPrevSlide({ speed: speed });
            swipe.simulationComplete();
          } else {
            //前边界前移反弹
            Xut.View.SetSwiperMove({
              speed: speed,
              action: action,
              distance: distance,
              direction: swipe.direction
            });
          }
        }
        /**
         * 尾页边界
         */
        else if (swipe.visualIndex === coloumnObj.maxBorder && swipe.direction === 'next') {
            if (action === 'flipOver') {
              clearColumnAudio();
              clearVideo();
              Xut.View.GotoNextSlide({ speed: speed });
              swipe.simulationComplete();
            } else {
              //后边界前移反弹
              Xut.View.SetSwiperMove({
                speed: speed,
                action: action,
                distance: distance,
                direction: swipe.direction
              });
            }
          }
          /**
           * 中间页面
           */
          else {

              var visualIndex = Xut.Presentation.GetPageIndex();

              var viewBeHideDistance = getVisualDistance({
                action: action,
                distance: distance,
                direction: direction,
                frontIndex: visualIndex,
                middleIndex: visualIndex,
                backIndex: visualIndex
              })[1];

              moveDistance = viewBeHideDistance;

              switch (direction) {
                case 'prev':
                  moveDistance = moveDistance + coloumnObj.lastDistance;
                  break;
                case 'next':
                  moveDistance = moveDistance + coloumnObj.lastDistance;
                  break;
              }

              //反弹
              if (action === 'flipRebound') {
                if (direction === 'next') {
                  //右翻页，左反弹
                  moveDistance = -columnWidth * swipe.visualIndex;
                } else {
                  //左翻页，右反弹
                  moveDistance = -(columnWidth * swipe.visualIndex);
                }
              }

              //更新页码
              if (action === 'flipOver') {
                clearColumnAudio();
                clearVideo();
                coloumnObj._updataPageNumber(direction);
              }

              translation[action](container, moveDistance, speed);

              //移动视觉差对象
              coloumnObj._moveParallax(action, speed, nodes, swipe.visualIndex, direction, viewBeHideDistance);
            }
      });

      swipe.$$watch('onComplete', function (_ref2) {
        var unlock = _ref2.unlock;

        coloumnObj.lastDistance = moveDistance;
        unlock();
      });
    }

    /**
     * 获取卷滚的索引
     * @return {[type]} [description]
     */

  }, {
    key: '_initY',


    /**
     * 竖版模式下，整体数据滑动
     * 1 需要判断2个方式，3个方向，3个值
     * 初始化、通过touch的方式滑动，通过鼠标滑动
     * 根据3种行为区分了3种方式，分别要标明，进来进来的方向
     * 通过这个方向值处理内部的滑动
     */
    value: function _initY() {
      var _this2 = this;

      var container = this.$container[0];
      this.columnCount = getColumnCount$1(this.seasonId, this.chapterId);

      var iscroll = this.iscroll = delegateScrollY(container, {
        // mouseWheel: true,
        // scrollbars: true
      });

      /*全局的卷滚条对象*/
      this.scrollBar = Xut.Application.GetScrollBarObject();

      /*全局不止一个迷你bar对象，所以需要不同的更新机制*/
      // if (this.scrollBar && Xut.Application.GetMiniBars() > 1) {
      //   this.multiToolbar = true
      //   this.rangeY = ColumnClass.getScrollYRange(iscroll.maxScrollY, this.columnCount)
      // }

      this.wheelEntryDirection = ''; //鼠标滚动进来的方向
      this.touchEntryDirection = ''; //触摸进来的方向
      this.initEntryDirection = ''; //初始化进来的方向

      /**
       * 进来flow的方式
       * init / touch / wheel
       * @type {String}
       */
      this.entryWay = '';

      /*如果flow初始化是可视区，那么需要开始就设定wheelEntryDirection的值*/
      var setDirection = false;
      if (this.initIndex === Xut.Presentation.GetPageIndex()) {
        setDirection = true;
        this.entryWay = 'init';
      }

      /*初始化Y轴的定位位置*/
      if (Xut.Presentation.GetPageIndex() > this.initIndex) {
        /*从下往上滑动,滚动页面设为最大值*/
        iscroll.scrollTo(0, iscroll.maxScrollY);
        this.visualIndex = this.columnCount - 1;
        this.touchEntryDirection = 'up';
        if (setDirection) {
          this.initEntryDirection = 'up';
        }
      } else {
        /*从上往下滑动*/
        this.visualIndex = 0;
        this.touchEntryDirection = 'down';
        if (setDirection) {
          this.initEntryDirection = 'down';
        }
      }

      var hasQrcode = void 0;
      iscroll.on('beforeScrollStart', function (e) {
        hasQrcode = false;
        if (swiperHook(e, e.target) === 'qrcode') {
          hasQrcode = true;
        }
      });

      /*点击动作
        1. 图片缩放
        2. 点击媒体，视频音频
      */
      iscroll.on('scrollCancel', function (e) {
        var node = e.target;
        if (!hasQrcode) {
          if (node && node.nodeName.toLowerCase() === "img") {
            _this2._zoomPicture(node);
          }
          if (!Xut.Contents.Canvas.getIsTap()) {
            Xut.View.Toolbar();
          }
        }
        closestMedia(node, _this2.chapterId, 0);
      });

      /**
       * 滚动时候变化
       * 强制显示滚动工具栏
       */
      iscroll.on('scroll', function (e) {
        _this2.scrollBar.showBar();
      });

      /**
       * 如果是突然中断
       * 停止滚动
       */
      iscroll.on('intermit', function (y) {
        _this2._updatePosition(y);
      });

      /**
       * 扩展的API
       * 如果是滚动的内容部分
       */
      iscroll.on('scrollContent', function (e) {
        if (!_this2.entryWay) {
          _this2.entryWay = 'touch';
        }
        _this2._updatePosition(_this2.iscroll.y);
      });

      /**
       * 松手后的惯性滑动
       */
      iscroll.on('momentum', function (newY, time) {
        _this2._updatePosition(newY, time);
      });

      /**
       * 扩展API 滚动翻页
       */
      iscroll.on('scrollExit', function (direction) {
        _this2._leave(direction);
      });

      /*滑动的平均概率值*/
      this.sizeRatioY = this.scrollBar.ratio * (this.columnCount - 1) / this.iscroll.maxScrollY;

      /*在翻页的时候，禁止滚动页面*/
      this.wheellook = false;
    }

    /*离开页面：
    touchEntryDirection标记的是进来的方向,
    触摸动作需要取反，因为这个是代表出去的方向*/

  }, {
    key: '_leave',
    value: function _leave(direction) {
      if (direction === 'down') {
        this.touchEntryDirection = 'up';
      } else if (direction === 'up') {
        this.touchEntryDirection = 'down';
      }
      this.wheelEntryDirection = '';
      this.entryWay = '';

      clearColumnAudio();
      clearVideo();
    }

    ////////////////////
    /// 竖版操作
    ///////////////////

    /**
     * 更新滚动坐标
     */

  }, {
    key: '_updatePosition',
    value: function _updatePosition(y, time, directionY) {

      var direction = '';

      if (this.entryWay === 'init') {
        direction = this.initEntryDirection;
      } else if (this.entryWay === 'touch') {
        direction = this.touchEntryDirection;
      } else if (this.entryWay === 'wheel') {
        direction = this.wheelEntryDirection;
      }

      /*如果是下往上进来的*/
      if (direction === 'up') {
        y = Math.round((this.iscroll.maxScrollY - y) * this.sizeRatioY);
        this.scrollBar.updatePosition(y, time, 'up');
        return;
      }

      /*如果是从上往下进来的*/
      if (direction === 'down') {
        y = Math.round(this.sizeRatioY * y) || 0;
        this.scrollBar.updatePosition(y, time, 'down');
      }
    }

    ////////////////////
    /// 鼠标滚动操作
    ///////////////////

  }, {
    key: 'onWheel',
    value: function onWheel(e, wheelDeltaY, direction) {
      var _this3 = this;

      if (wheelDeltaY === undefined) {
        return;
      }

      if (!this.entryWay) {
        this.entryWay = 'wheel';
      }

      /*进来的方向，每次flow页面运行只标记一次*/
      if (!this.wheelEntryDirection) {
        this.wheelEntryDirection = direction;
      }

      /*离开页面，鼠标快速滑动，禁止内部滑动*/
      if (!this.wheellook) {

        /*向上移动，离开flow页面*/
        if (this.iscroll.y === 0 && direction === 'up') {
          this.wheellook = true;
          Xut.View.GotoPrevSlide(function () {
            /*向下翻页，滚动条设置0*/
            _this3.iscroll.scrollTo(0, 0);
            _this3.wheellook = false;
            _this3._leave('up');
          });
          return;
        }

        /*向下移动，离开flow页面*/
        if (this.iscroll.y === this.iscroll.maxScrollY && direction === 'down') {
          this.wheellook = true;
          Xut.View.GotoNextSlide(function () {
            /*向下翻页，滚动条设置最大值*/
            _this3.iscroll.scrollTo(0, _this3.iscroll.maxScrollY);
            _this3.wheellook = false;
            _this3._leave('down');
          });
          return;
        }

        this.iscroll._wheel(e);
      }
    }

    /**
     * 获取进入方向
     * @return {[type]} [description]
     */

  }, {
    key: 'getEntry',
    value: function getEntry() {
      return this.entryWay;
    }

    ////////////////////
    /// 横版分栏刷新接口
    ///////////////////

    /**
     * 横版分栏更新
     * @param  {[type]} newColumnCount [description]
     * @return {[type]}                [description]
     */

  }, {
    key: '_resetX',
    value: function _resetX(newColumnCount) {
      this.columnCount = newColumnCount;
      this.maxBorder = newColumnCount - 1;

      var visualPageId = Xut.Presentation.GetPageId();
      var columnPageId = this.chapterId;
      var location = void 0;

      //区分控制column属于哪个页面对象
      if (visualPageId > columnPageId) {
        location = 'left';
      } else if (visualPageId < columnPageId) {
        location = 'right';
      } else if (visualPageId === columnPageId) {
        location = 'middle';
      }

      //设置column
      this.swipe.setLinearTotal(newColumnCount, location);
      this.lastDistance = this.swipe.getInitDistance();

      //页码
      this._updataPageNumber('', location);
    }

    /**
     * 竖版分栏更新
     * @param  {[type]} newColumnCount [description]
     * @return {[type]}                [description]
     */

  }, {
    key: '_resetY',
    value: function _resetY(newColumnCount) {
      console.log('竖版数据丢失，需要添加功能，补全');
      // console.log(this.columnCount,newColumnCount)
      // this.iscroll.refresh()
      // this._updatePosition(this.iscroll.y)
    }

    /**
     * 重新计算分栏依赖
     * @return {[type]} [description]
     */

  }, {
    key: 'resetColumnDep',
    value: function resetColumnDep() {
      var newColumnCount = getColumnCount$1(this.seasonId, this.chapterId);
      /*假如分栏数有变化*/
      if (newColumnCount > this.columnCount) {
        if (config.launch.scrollMode === 'h') {
          this._resetX(newColumnCount);
        } else if (config.launch.scrollMode === 'v') {
          this._resetY(newColumnCount);
        }
      }
    }

    /*销毁*/

  }, {
    key: 'destroy',
    value: function destroy() {
      var _this4 = this;

      //销毁缩放图片
      if (Object.keys(this._scaleObjs).length) {
        _.each(this._scaleObjs, function (obj, key) {
          obj.destroy();
          _this4._scaleObjs[key] = null;
        });
      }

      this.iscroll && this.iscroll.destroy();
      this.swipe && this.swipe.destroy();
    }
  }], [{
    key: 'getScrollYIndex',
    value: function getScrollYIndex(distY, rangeY) {
      var key = void 0,
          value = void 0,
          pageIndex = void 0;
      var startY = Math.abs(distY);
      for (var _key in rangeY) {
        var _value = rangeY[_key];
        if (startY >= _value.min && startY <= _value.max) {
          pageIndex = _key;
          break;
        }
      }
      return Number(pageIndex);
    }

    /**
     * 获取滚动Y轴的坐标分组
     * 计算出通过坐标模拟分段是区间
     * @return {[type]} [description]
     */

  }, {
    key: 'getScrollYRange',
    value: function getScrollYRange(maxScrollY, columnCount) {
      var baseY = Math.abs(maxScrollY / columnCount);
      var count = columnCount;

      /*获取对比的数据区间值，快速比较*/
      var rangeY = {};
      while (count--) {
        rangeY[count] = {
          min: Math.abs(count * baseY),
          max: Math.abs((count + 1) * baseY)
        };
      }
      return rangeY;
    }
  }]);
  return ColumnClass;
}();

/**
 * 2017.9.7
 * 流式排版
 */
var TaskColumns = function (base, callback) {
  var chapterData = base.chapterData;
  //只有页面类型支持flow && chpater页存在flow数据
  if (base.pageType === "page" && isColumnPage(chapterData.seasonId, base.chapterId)) {
    base.columnGroup.add(new ColumnClass({
      pptMaster: base.chapterData.pptMaster, //母版ID
      pageIndex: base.pageIndex,
      rootNode: base.getContainsNode(),
      seasonId: base.chapterData.seasonId,
      chapterId: base.chapterId,
      callback: callback
    }));
  } else {
    callback();
  }
};

/**
 * 分配Container构建任务
 * 1 同步数据
 * 2 构建容器
 * 3 给出构建回调,这里不能中断,翻页必须存在节点
 * 4 等待之后自动创建或者后台空闲创建之后的任务
 * @return {[type]} [description]
 */
var assignedTasks = {

  /**
   * 主容器
   */
  'assign-container': function assignContainer(success, base) {
    //同步数据
    syncCache(base, function () {
      var pageData = base.baseData();
      parseChapterParameter(pageData, base);
      TaskContainer(base, pageData, success);
    });
  },


  /**
   *  分配背景构建任务
   *    1 构建数据与结构,执行中断检测
   *    2 绘制结构,执行回调
   *
   *  提供2组回调
   *    1 构建数据结构 suspendCallback
   *    2 执行innerhtml构建完毕 successCallback
   */
  'assign-background': function assignBackground(success, base) {
    if (base.rerunInstanceTask('assign-background')) {
      return;
    }
    var data = base.baseData(base.chapterIndex);
    var $containsNode = base.getContainsNode();
    base.threadTaskRelated.assignTaskGroup['assign-background'] = new TaskBackground(data, $containsNode, success, function () {
      base.detectorTask.apply(base, arguments);
    });
  },


  /**
   * 流式排版
   */
  'assign-column': function assignColumn(success, base) {
    TaskColumns(base, success);
  },


  /**
   * 分配Components构建任务
   * @return {[type]} [description]
   */
  'assign-component': function assignComponent(success, base) {
    if (base.rerunInstanceTask('assign-component')) {
      return;
    }
    var chapterData = base.chapterData;
    var baseData = base.baseData();
    base.threadTaskRelated.assignTaskGroup['assign-component'] = new TaskComponents({
      'rootNode': base.rootNode,
      '$containsNode': base.getContainsNode(),
      'nodes': chapterData['nodes'],
      'pageOffset': chapterData['pageOffset'],
      'activitys': base.baseActivits(),
      'chpaterData': baseData,
      'chapterId': baseData['_id'],
      'chapterIndex': base.chapterIndex,
      'pageType': base.pageType,
      'pageBaseHooks': base.divertorHooks,
      'getStyle': base.getStyle
    }, success, function () {
      base.detectorTask.apply(base, arguments);
    });
  },


  /**
   * 分配Activity构建任务
   * @return {[type]} [description]
   */
  'assgin-activity': function assginActivity(success, base) {

    //通过content数据库为空处理
    if (Xut.data.preventContent) {
      return success();
    }

    if (base.rerunInstanceTask('assgin-activity')) {
      return;
    }

    var chapterData = base.chapterData;
    var baseData = base.baseData();

    base.threadTaskRelated.assignTaskGroup['assgin-activity'] = new TaskActivitys({
      base: base,
      'canvasRelated': base.canvasRelated,
      'rootNode': base.rootNode,
      '$containsNode': base.getContainsNode(),
      '$headFootNode': base.getHeadFootNode(),
      'pageType': base.pageType,
      'nodes': chapterData['nodes'],
      'pageOffset': chapterData['pageOffset'],
      'activitys': base.baseActivits(),
      'chpaterData': baseData,
      'chapterId': baseData._id,
      'pageIndex': base.pageIndex,
      'chapterIndex': base.chapterIndex,
      'pageBaseHooks': base.divertorHooks,
      'getStyle': base.getStyle
    }, success, function () {
      base.detectorTask.apply(base, arguments);
    });
  }
};

var noop$1 = function noop() {};

function initThreadState(instance) {

  return {
    /**
     * 主线任务等待
     */
    taskHangFn: null,

    /**
     * 创建相关的信息
     * @type {Object}
     */
    tasksTimer: 0,

    /**
     * 当前任务是否中断
     * return
     *     true  中断
     *     false 没有中断
     */
    isTaskSuspend: false,

    /**
     * 是否预创建背景中
     */
    isPreCreateBackground: false,

    /*
    缓存的任务名
    动态注册
     */
    assignTaskGroup: null,

    /**
     * 下一个将要运行的任务标示
     */
    nextTaskName: '',

    /**
     * 预创建
     * 构建页面主容器完毕后,此时可以翻页
     * @return {[type]} [description]
     */
    preforkComplete: noop$1,

    /**
     * 整个页面都构建完毕通知
     * @return {[type]} [description]
     */
    createTasksComplete: noop$1
  };
}

/**
 * 页面缩放
 */
function initPageScale(rootNode, pageIndex) {
  return new ScalePan({
    rootNode: rootNode,
    hasButton: true,
    tapClose: true,
    updateHook: function updateHook(transform, speed) {
      if (transform) {
        /*如果有母版，缩放母版*/
        var relatedMasterObj = Xut.Presentation.GetPageBase('master', pageIndex);
        if (relatedMasterObj) {
          var pageMasterNode = relatedMasterObj.getContainsNode()[0];
          Xut.style.setTranslate({
            speed: speed,
            translate: transform.translate,
            scale: transform.scale,
            node: pageMasterNode
          });
        }
      }
    }
  });
}

/**
 * 缓存构建中断回调
 * 构建分2步骤
 * 1 构建数据与结构（执行中断处理）
 * 2 构建绘制页面
 * @type {Object}
 */
function registerCacheTask(tasks) {
  /*设置缓存的任务名*/
  var cache = {};
  Object.keys(tasks).forEach(function (taskName) {
    cache[taskName] = false;
  });
  return cache;
}

function initThreadtasks(instance) {

  /**
   * 创建相关的信息
   * threadTaskRelated
   */
  var threadTaskRelated = instance.threadTaskRelated = initThreadState(instance);

  /*注册缓存任务名*/
  threadTaskRelated.assignTaskGroup = registerCacheTask(assignedTasks);
  //初始化第一次的任务名
  threadTaskRelated.nextTaskName = 'container';

  /**
   * 设置下一个任务名
   * 用于标记完成度
   */
  function setNextTaskName(taskName) {
    threadTaskRelated.nextTaskName = taskName;
  }

  /* 创建新任务*/
  function createAssignTask(taskName, fn) {
    return assignedTasks[taskName](fn, instance);
  }

  /**
   * 任务钩子
   */
  instance.threadtasks = {

    /**
     * li容器
     */
    container: function container() {

      createAssignTask('assign-container', function ($pageNode, $pseudoElement) {

        //////////////
        //li,li-div //
        //////////////
        instance.$pageNode = $pageNode;
        instance.$pseudoElement = $pseudoElement;

        /**
         * 获取根节点
         * 获取包含容器
         */
        var $containsElement = $pageNode.find('.page-scale > div:first-child');
        instance.getContainsNode = function () {
          return $pseudoElement ? $pseudoElement : $containsElement;
        };

        //页眉页脚
        instance.getHeadFootNode = function () {
          return $pageNode.find('.page-scale > div:last-child');
        };

        //缩放根节点
        instance.getScaleNode = function () {
          return $pseudoElement ? $pseudoElement : $pageNode.find('.page-scale');
        };

        setNextTaskName('background');

        //构建主容器li完毕,可以提前执行翻页动作
        //必须是启动了快速翻页
        threadTaskRelated.preforkComplete();

        //模板上继续创建，不处理创建问题
        if (instance.isMaster) {
          instance.detectorTask({
            'taskName': '外部Background',
            'nextTask': function nextTask() {
              instance.dispatchTasks();
            }
          });
        }
      });
    },


    /**
     * 背景
     */
    background: function background() {

      createAssignTask('assign-background', function () {
        threadTaskRelated.isPreCreateBackground = false;
        setNextTaskName('column');
        //针对当前页面的检测
        //没有背景挂起，或者是母版继续往下创建
        if (!threadTaskRelated.taskHangFn || instance.isMaster) {
          instance.detectorTask({
            'taskName': '外部widgets',
            nextTask: function nextTask() {
              instance.dispatchTasks();
            }
          });
        }
        //如果有挂起任务，则继续执行
        if (threadTaskRelated.taskHangFn) {
          threadTaskRelated.taskHangFn();
        }
      });
    },


    /**
     * 2016.9.7
     * 特殊的一个内容
     * 是否为流式排版
     */
    column: function column() {

      //如果是页面类型
      var isPageType = instance.pageType === 'page';

      /*
      创建页面缩放缩放
      1.page页面可以配置缩放
      2.flow页面不允许缩放
       */
      var createScale = function createScale() {
        var salePageType = config.launch.salePageType;
        if (isPageType && (salePageType === 'page' || salePageType === 'all')) {
          instance._pageScaleObj = initPageScale(instance.getScaleNode(), instance.pageIndex);
        }
      };

      /*
      chapter=>note == 'flow'
      设计上chapter只有一个flow效果，所以直接跳过别的创建
      只处理页面类型，母版跳过
       */
      if (isPageType && instance.hasColumnData) {
        createAssignTask('assign-column', function () {
          setNextTaskName('complete');
          threadTaskRelated.createTasksComplete();
        });
      } else {
        createScale();
        setNextTaskName('component');
        instance.dispatchTasks();
      }
    },


    /**
     * 组件
     * 构件零件类型任务
     */
    component: function component() {
      createAssignTask('assign-component', function () {
        setNextTaskName('activity');
        instance.detectorTask({
          'taskName': '外部contents',
          nextTask: function nextTask() {
            instance.dispatchTasks();
          }
        });
      });
    },


    /**
     * activity类型
     */
    activity: function activity() {
      createAssignTask('assgin-activity', function () {
        setNextTaskName('complete');
        threadTaskRelated.createTasksComplete();
      });
    }
  };
}

// 观察
/**
 * canvas相关处理
 * 启动canvas,pixi库
 * 事件，动画等
 * 需要收集所有content的执行
 * 因为canvas只能绘制一次
 * cnavas模式下 category === "Sprite" 转化cid
 */

var Factory = function (_Observer) {
    inherits(Factory, _Observer);

    function Factory() {
        classCallCheck(this, Factory);

        /**
         * 是否启动模式
         * @type {Boolean}
         */
        var _this = possibleConstructorReturn(this, (Factory.__proto__ || Object.getPrototypeOf(Factory)).call(this));

        _this.enable = false;

        /**
         * CompSprite非常特殊
         * 可以在dom的情况下使用
         * 所以如果是dom模式要强制开始enable‘
         * 这样会导致 精灵等动画强制转canvas
         * 这是错误的，所以增加一个判断
         *
         */
        _this.onlyCompSprite = false;

        /**
         * 加载失败content列表
         * @type {Array}
         */
        _this.failCid = [];

        //所有contentId合集
        _this.contentIdset = [];

        //开启了contentMode的节点
        //对应的content转化成canvas模式
        //普通精灵动画
        //ppt动画=>转化
        _this.pptId = [];

        //普通灵精
        _this.spiritId = [];

        //widget零件保存的content id
        //高级精灵动画
        _this.widgetId = [];

        //复杂精灵动画
        _this.compSpriteId = [];

        //默认canvas容器的层级
        //取精灵动画最高层级
        //2016.2.25
        _this.containerIndex = 1;

        /**
         * cid=>wid
         * 对应的pixi对象容器
         * @type {Object}
         */
        _this.collections = {};
        return _this;
    }

    return Factory;
}(Observer);

/****************************
 *
 *  监控columns内容是否需要补全
 *
 *****************************/

function watchColumn(instance, config) {
  //注册_columns对象改变
  if (config.launch.columnCheck) {
    var columnObj = instance.columnGroup.get();
    if (columnObj && columnObj.length) {
      if (!instance.unWatchDep) {
        instance.unWatchDep = [];
      }
      columnObj.forEach(function (obj) {
        var dep = Xut.Application.Watch('change:column', function () {
          obj.resetColumnDep();
        });

        //保存监控引用
        instance.unWatchDep.push(function () {
          return Xut.Application.unWatch('change:column', dep);
        });
      });
    }
  }
}

/**
 * 移除监控
 * @param  {[type]} instance [description]
 * @return {[type]}          [description]
 */
function unWatchColumn(instance) {
  //如果有更新记录依赖
  if (instance.unWatchDep) {
    instance.unWatchDep.forEach(function (unDep) {
      unDep();
    });
    instance.unWatchDep = null;
  }
}

var initstate = function (baseProto) {

  /**
   * 初始化多线程任务
   */
  baseProto.init = function (options) {

    var instance = this;

    _.extend(instance, options);

    /**
     * 数据缓存容器
     * @type {Object}
     */
    this.dataActionGroup = {};
    this.seasonId = this.chapterData.seasonId;
    this.chapterId = this.chapterData._id;

    /**
     * 是否开启多线程,默认开启
     * 如果是非线性，则关闭多线程创建
     * 启动 true
     * 关闭 false
     * @type {[type]}
     */
    this.hasMultithread = this.hasMultiPage ? true : false;

    //母版处理
    if (instance.pageType === 'master') {
      this.isMaster = true;
    }

    //canvas模式
    this.canvasRelated = new Factory();

    /*有流式排版数据*/
    if (instance.chapterData.note === 'flow') {
      this.hasColumnData = true;
    }

    ///////////////////////////////////////
    ///
    /// 内部钩子相关
    /// 监听状态的钩子
    /// 注册所有content对象管理
    /// 收集所有content对象
    /// 构建li主结构后,即可翻页
    /// 构建所有对象完毕后处理
    ///
    ////////////////////////////////////////

    /**
     * 缓存所有的content对象引用
     * 1对1的关系
     */
    this.contentGroup = {};

    /**
     * 抽象activtiys合集,用于关联各自的content
     * 划分各自的子作用域
     * 1对多的关系
     */
    this.activityGroup = new Collection();

    /**
     * widget热点处理类
     * 只存在当前页面
     * 1 iframe零件
     * 2 页面零件
     */
    this.componentGroup = new Collection();

    /**
     * 2016.9.7
     * column热点对象
     */
    this.columnGroup = new Collection();

    /**
     * 为mini杂志新功能
     * 动画的调用序列
     * 收集滑动委托对象，针对事件合集触发处理
     * 2016.11.8
     */
    if (config.launch.swipeDelegate) {
      this.swipeSequence = {
        swipeleft: [],
        swiperight: [],
        swipeleftTotal: 0,
        swiperightTotal: 0,
        swipeleftIndex: 0,
        swiperightIndex: 0
      };
    }

    /**
     * 页面中是最高的
     * 浮动对象分组
     * 1 母版
     * 2 页面
     */
    var floatGroup = this.floatGroup = {

      /**
       * 页面浮动对象容器
       */
      pageContainer: null,

      /**
       * 浮动页面对象
       */
      pageGroup: {},

      /**
       * 浮动母版容器
       */
      masterContainer: null,

      /**
       * 浮动母版的content对象
       * 用于边界切换,自动加上移动
       *     1：Object {}      //空对象,零件
       *     2: PPTeffect  {}  //行为对象
       */
      masterGroup: {}

      /**
       * 对象的处理情况的内部钩子方法
       * 收集内部的一些状态与对象
       */
    };this.divertorHooks = {

      /**
       * 多线程任务完成后
       * createTasksComplete方法中
       * 开始column观察器
       */
      threadtaskComplete: function threadtaskComplete() {
        watchColumn(instance, config);
      },


      /**
       * 保存Activity类实例
       */
      cacheActivity: function cacheActivity(activityInstance) {
        instance.activityGroup.add(activityInstance);
      },


      /**
       * 搜集所有的content(每一个content对象)
       * 因为content多页面共享的,所以content的合集需要保存在pageMgr中（特殊处理）
       */
      contents: function contents(chapterIndex, id, contentScope) {
        var scope = instance.baseGetContentObject[id];
        //特殊处理,如果注册了事件ID,上面还有动画,需要覆盖
        if (scope && scope.isBindEventHooks) {
          instance.contentGroup[id] = contentScope;
        }
        if (!scope) {
          instance.contentGroup[id] = contentScope;
        }
      },


      /**
       * 2014.11.7
       * 新概念，浮动页面对象
       * 用于是最顶层的，比母版浮动对象还要高
       * 所以这个浮动对象需要跟随页面动
       */
      floatPages: function floatPages(divertor) {

        /*component与activity共享了一个Container，所以只能处理一次*/
        if (divertor && floatGroup.pageContainer) {
          Xut.$warn({
            type: 'pagebase',
            content: 'floatPages重复pageContainer'
          });
        } else {
          floatGroup.pageContainer = divertor.container;
        }

        if (divertor.ids.length) {
          var contentObj = void 0;
          _.each(divertor.ids, function (id) {
            if (contentObj = instance.baseGetContentObject(id)) {
              //初始视察坐标
              if (contentObj.parallax) {
                contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
              }
              floatGroup.pageGroup[id] = contentObj;
            } else {
              Xut.$warn({
                type: 'pagebase',
                content: '页面浮动对象找不到'
              });
            }
          });
        }
      },


      /**
       * 浮动母版对象
       * 1 浮动的对象是有动画数据或者视觉差数据
       * 2 浮动的对象是用于零件类型,这边只提供创建
       *  所以需要制造一个空的容器，用于母版交界动
       */
      floatMasters: function floatMasters(divertor) {

        /*component与activity共享了一个Container，所以只能处理一次*/
        if (divertor && floatGroup.masterContainer) {
          Xut.$warn({
            type: 'pagebase',
            content: 'floatMasters重复masterContainer'
          });
        } else {
          floatGroup.masterContainer = divertor.container;
        }

        if (divertor.ids.length) {
          var contentObj = void 0;
          var contentNode = void 0;
          //浮动对象
          _.each(divertor.ids, function (id) {
            //转化成实际操作的浮动对象,保存
            if (contentObj = instance.baseGetContentObject(id)) {
              //初始视察坐标
              if (contentObj.parallax) {
                contentObj.parallaxOffset = contentObj.parallax.parallaxOffset;
              }
              floatGroup.masterGroup[id] = contentObj;
            } else {
              Xut.plat.isBrowser && console.log('浮动母版对象数据不存在原始对象,制作伪对象母版移动', id);

              var activity = instance.threadTaskRelated['assgin-activity'];
              var contentsFragment = activity.contentsFragment;

              //获取DOM节点
              if (contentsFragment) {
                var prefix = 'Content_' + instance.chapterIndex + "_";
                _.each(contentsFragment, function (dom) {
                  var makePrefix = prefix + id;
                  if (dom.id == makePrefix) {
                    contentNode = dom;
                  }
                });
              }
              //制作一个伪数据
              //作为零件类型的空content处理
              floatGroup.masterGroup[id] = {
                id: id,
                chapterIndex: instance.chapterIndex,
                $contentNode: $(contentNode),
                'empty': true //空类型
              };
            }
          });
        }
      },


      /**
       * 多事件钩子
       * 执行多事件绑定
       */
      eventBinding: function eventBinding(eventRelated) {
        create(instance, eventRelated);
      },


      /**
       * 2016.11.8
       * 收集滑动委托对象，针对事件合集触发处理
       */
      swipeDelegateContents: function swipeDelegateContents(eventName, fn) {
        ++instance.swipeSequence[eventName + 'Total'];
        instance.swipeSequence[eventName].push(fn);
      }
    };

    /**
     * 初始化任务
     * 等待状态初始化，比如_isFlows
     */
    initThreadtasks(instance);
  };
};

/**
 * 多线程检测代码
 */
function threadCheck(baseProto) {

  /**
   * 自动运行：检测是否需要开始创建任务
   * 1 如果任务全部完成了毕
   * 2 如果有中断任务,就需要继续创建未完成的任务
   * 3 如果任务未中断,还在继续创建
   * currtask 是否为当前任务，加速创建
   */
  baseProto._checkNextTaskCreate = function (callback) {
    var _this = this;

    //如果任务全部完成
    if (this.threadTaskRelated.nextTaskName === 'complete') {
      return callback();
    }

    //开始构未完成的任务
    this._cancelTaskSuspend();

    //任务创建完毕回调
    this.threadTaskRelated.createTasksComplete = function () {
      _this.divertorHooks && _this.divertorHooks.threadtaskComplete();
      callback();
    };

    //派发任务
    this.detectorTask({
      nextTask: function nextTask() {
        this.dispatchTasks();
      }
    });
  };

  /**
   * 任务调度，自动创建下个任务
   * container/background/column/component/activity
   */
  baseProto.dispatchTasks = function () {
    var threadtasks = this.threadtasks[this.threadTaskRelated.nextTaskName];
    if (threadtasks) {
      Xut.$warn({
        type: 'create',
        content: '\u5F00\u59CB\u8C03\u5EA6\u4EFB\u52A1' + this.threadTaskRelated.nextTaskName
      });
      threadtasks.apply(undefined, arguments);
    }
  };

  /**
   * 开始执行下一个线程任务,检测是否中断
      suspendTask,
      nextTask,
      interrupt,
      taskName
   * @return {[type]} [description]
   */
  baseProto.detectorTask = function (options) {
    this._asyTasks({
      suspendCallback: function suspendCallback() {
        options.suspendTask && options.suspendTask.call(this);
      },
      nextTaskCallback: function nextTaskCallback() {
        options.nextTask && options.nextTask.call(this);
      }
    }, options.interrupt);
  };

  /**
   * 任务队列挂起
   * nextTaskCallback 成功回调
   * suspendCallback  中断回调
   * @return {[type]} [description]
   */
  baseProto._asyTasks = function (callbacks, interrupt) {
    //如果关闭多线程,不检测任务调度
    if (!this.hasMultithread) {
      return callbacks.nextTaskCallback.call(this);
    }
    //多线程检测
    this._multithreadCheck(callbacks, interrupt);
  };

  /**
   * 多线程检测
   * @return {[type]} [description]
   */
  baseProto._multithreadCheck = function (callbacks, interrupt) {
    var _this2 = this;

    var check = function check() {
      if (_this2._checkTaskSuspend()) {
        _this2.tasksTimeOutId && clearTimeout(_this2.tasksTimeOutId);
        callbacks.suspendCallback.call(_this2);
      } else {
        callbacks.nextTaskCallback.call(_this2);
      }
    };
    var next = function next() {
      _this2.tasksTimeOutId = setTimeout(function () {
        check();
      }, _this2.canvasRelated.tasksTimer);
    };

    //自动运行页面构建
    if (this.hasAutoRun) {
      //自动运行content中断检测 打断一次
      if (interrupt) {
        next();
      } else {
        check();
      }
    } else {
      //后台构建
      next();
    }
  };

  /**
   * 取消任务中断
   */
  baseProto._cancelTaskSuspend = function () {
    this.canvasRelated.isTaskSuspend = false;
  };

  /**
   * 检测任务是否需要中断
   */
  baseProto._checkTaskSuspend = function () {
    return this.canvasRelated.isTaskSuspend;
  };
}

/**
 *  对外接口
 *  1 开始调用任务
 *  2 调用自动运行任务
 *  3 设置中断
 *  4 取消中断设置
 */

var threadExternal = function (baseProto) {

  /**
   * 开始调用任务
   * dispatch=>index=>create=>startThreadTask
   * 如果是快速翻页，创建container就提前返回callback
   */
  baseProto.startThreadTask = function (isFlipAction, callback) {
    var _this = this;

    /**
     * 构建container任务完成后的一次调用
     *   1 如果是快速翻頁，並且是翻頁動作
     *   2 否則則繼續創建剩下的任務
     */
    this.threadTaskRelated.preforkComplete = function () {
      return function () {
        /*当创建完容器后，就允许快速翻页了
        如果此时是快速打开，并且是翻页的动作*/
        if (config.launch.quickFlip && isFlipAction) {
          callback();
        } else {
          /*如果不是快速翻页，那么就继续往下分解任务*/
          _this._checkNextTaskCreate(callback);
        }
      };
    }();

    //开始构建任务
    this.dispatchTasks();
  };

  /**
   * 主动调用
   * 检测任务是否完成,自动运行的时候需要检测
   * page => autoRun中需要保证任务完成后才能执行自动运行任务
   * src\lib\scenario\manage\page.js
   */
  baseProto.checkThreadTaskComplete = function (completeCallback) {
    var _this2 = this;

    this.hasAutoRun = true;
    this._checkNextTaskCreate(function () {
      _this2.hasAutoRun = false;
      completeCallback();
    });
  };

  /**
   * 主动调用
   * 翻页的时候要设置任务中断
   * left middle right 默认三个页面
   * src\lib\scenario\manage\page.js
   */
  baseProto.setTaskSuspend = function () {
    this.hasAutoRun = false;
    this.canvasRelated.isTaskSuspend = true;
    this.threadTaskRelated.isPreCreateBackground = false;
    this.threadTaskRelated.taskHangFn = null;
  };

  /**
   * 主动调用
   * 后台预创建任务
   * 自动运行任务完成后，需要开始预创建其他页面任务没有创建完毕的的处理
   * 断点续传
   * \src\lib\scenario\manage\page.js:
   */
  baseProto.createPreforkTask = function (callback, isPreCreate) {
    var self = this;
    //2个预创建间隔太短
    //背景预创建还在进行中，先挂起来等待
    if (this.threadTaskRelated.isPreCreateBackground) {
      this.threadTaskRelated.taskHangFn = function (callback) {
        return function () {
          self._checkNextTaskCreate(callback);
        };
      }(callback);
      return;
    }

    /**
     * 翻页完毕后
     * 预创建背景
     */
    if (isPreCreate) {
      this.threadTaskRelated.isPreCreateBackground = true;
    }

    this._checkNextTaskCreate(callback);
  };

  /**
   * 主动调用
   * 2016.10.13 给妙妙学增加watch('complete')
   * 如果有最后一个动作触发，创建最后一次页面动作
   *
   * 只有最后一页的时候才会存在runLastPageAction方法
   * this.runLastPageAction在parseMode中定义
   * \lib\scenario\pagebase\multithread\assign-task\index.js:
   */
  baseProto.createPageAction = function () {
    if (this.runLastPageAction) {
      //返回停止方法
      this.stopLastPageAction = this.runLastPageAction();
    }
  };

  /**
   * 销毁动作触发
   * 处理最后一页动作
   * \src\lib\scenario\manage\page.j
   */
  baseProto.destroyPageAction = function () {
    if (this.stopLastPageAction) {
      this.stopLastPageAction();
      this.stopLastPageAction = null;
    }
  };
};

/**
 * 构建模块任务对象
 * taskCallback 每个模块任务完毕后的回调
 * 用于继续往下个任务构建
 */
var dataExternal = function (baseProto) {

  /**
   * 设置页面容器层级
   * 页面跳转使用接口
   * @return {[type]} [description]
   */
  baseProto.setPageContainerHierarchy = function (style) {
    this.$pageNode.css(style);
  };

  /**
   * 获取文字动画对象
   * 2017.1.6
   * @return {[type]} [description]
   */
  baseProto.getLetterObjs = function (contentId) {
    var activity = this.threadTaskRelated.assignTaskGroup['assgin-activity'];
    if (activity && activity.textFxObjs) {
      return activity.textFxObjs[contentId];
    }
  };

  /**
   * 转化序列名
   * @return {[type]} [description]
   */
  baseProto._converSequenceName = function (direction) {
    return direction === 'next' ? 'swipeleft' : 'swiperight';
  };

  /**
   * 是否有动画序列
   */
  baseProto.hasSwipeSequence = function (direction) {
    var eventName = this._converSequenceName(direction);
    var swipeSequence = this.swipeSequence;

    //如果执行完毕了
    if (swipeSequence[eventName + 'Index'] === swipeSequence[eventName + 'Total']) {
      return false;
    }
    return swipeSequence[eventName].length;
  };

  /**
   * 执行动画序列
   * @return {[type]} [description]
   */
  baseProto.callSwipeSequence = function (direction) {
    if (!this.swipeSequence) {
      return;
    }
    var eventName = this._converSequenceName(direction);
    var sequence = this.swipeSequence[eventName];
    var callAnimSequence = sequence[this.swipeSequence[eventName + 'Index']];
    if (callAnimSequence) {
      ++this.swipeSequence[eventName + 'Index'];
      callAnimSequence(); //动画不能在回调中更改状态，因为翻页动作可能在动画没有结束之前，所以会导致翻页卡住
    }
  };

  /**
   * 复位动画序列
   * @param  {[type]} direction [description]
   * @return {[type]}           [description]
   */
  baseProto.resetSwipeSequence = function () {
    if (!this.swipeSequence) {
      return;
    }
    this.swipeSequence.swipeleftIndex = 0;
    this.swipeSequence.swiperightIndex = 0;
  };

  /**
   * 对象实例内部构建
   * 重新实例运行任务
   */
  baseProto.rerunInstanceTask = function (taskName) {
    var tasksObj;
    if (tasksObj = this.threadTaskRelated.assignTaskGroup[taskName]) {
      tasksObj.rerunTask && tasksObj.rerunTask();
      return true;
    }
  };

  /**
   * 获取页面数据
   * @return {[type]} [description]
   */
  baseProto.baseData = function () {
    return this.dataActionGroup[this.pageType];
  };

  /**
   * 获取热点数据信息
   * @return {[type]} [description]
   */
  baseProto.baseActivits = function () {
    return this.dataActionGroup['activitys'];
  };

  /**
   * 获取自动运行数据
   * @return {[type]} [description]
   */
  baseProto.baseAutoRun = function () {
    var data = this.dataActionGroup['auto'];
    return data && data;
  };

  /**
   * 获取chapterid
   * @return {[type]}     [description]
   */
  baseProto.baseGetPageId = function (index) {
    return this.baseData(index)['_id'];
  };

  /**
   * 找到对象的content对象
   * @param  {[type]}   contentId [description]
   * @param  {Function} callback  [description]
   * @return {[type]}             [description]
   */
  baseProto.baseGetContentObject = function (contentId) {
    var contentsObj = this.contentGroup[contentId];
    if (contentsObj) {
      return contentsObj;
    }

    //查找浮动母版
    return this.floatGroup.masterGroup[contentId];
  };

  /**
   * Xut.Content.show/hide 针对互斥效果增加接口
   * 扩充，显示，隐藏，动画控制接口
   * @param  {[type]} name [description]
   * @return {[type]}      [description]
   */
  baseProto.baseContentMutex = function (contentId, type) {
    var contentObj = void 0;
    if (contentObj = this.baseGetContentObject(contentId)) {
      var $contentElement = contentObj.$contentNode.view ? contentObj.$contentNode.view : contentObj.$contentNode;

      var handle = {
        'Show': function Show() {
          if (contentObj.type === 'dom') {
            $contentElement.css({
              'display': 'blcok',
              'visibility': 'visible'
            }).prop("mutex", false);
          } else {
            $contentElement.visible = true;
          }
        },
        'Hide': function Hide() {
          if (contentObj.type === 'dom') {
            $contentElement.css({
              'display': 'none',
              'visibility': 'hidden'
            }).prop("mutex", true);
          } else {
            $contentElement.visible = false;
          }
        },
        'StopAnim': function StopAnim() {
          contentObj.stopAnims && contentObj.stopAnims();
        }
      };
      handle[type]();
    }
  };

  //获取Activity对象
  baseProto.baseGetActivity = function (callback) {
    var activitys = this.activityGroup.get();
    if (activitys && activitys.length) {
      if (callback) {
        _.each(activitys, function (obj) {
          return callback(obj);
        });
      } else {
        return activitys;
      }
    }
  };

  baseProto.baseSpecifiedContent = function (data) {
    return this.activityGroup.specified(data);
  };

  /**
   * 隐藏li节点
   * @return {[type]} [description]
   */
  baseProto.hide = function () {
    this.$pageNode.hide();
  };

  /**
   * 显示li节点
   * @return {[type]} [description]
   */
  baseProto.show = function () {
    this.$pageNode.show();
  };

  //components零件类型处理
  //baseGetComponent
  //baseRemoveComponent
  //baseAddComponent
  //baseSpecifiedComponent
  _.each(["Get", "Remove", "Add", "Specified"], function (type) {
    baseProto['base' + type + 'Component'] = function (data) {
      switch (type) {
        case 'Add':
          return this.componentGroup.add(data);
        case 'Get':
          return this.componentGroup.get();
        case 'Specified':
          return this.componentGroup.specified(data);
        case 'Remove':
          return this.componentGroup.remove();
      }
    };
  });

  /**
   *  运行辅助对象事件
   *  执行运行对象的动画
   *  但是如果提供contentID，那么就是只运行这组序列动画中的
   *  指定contentID的这个动画
   */
  baseProto.baseAssistRun = function (activityId, outCallBack, actionName, contentId) {
    var activity;
    if (activity = this.activityGroup) {
      _.each(activity.get(), function (contentObj, index) {
        if (activityId == contentObj.activityId) {
          if (actionName == 'Run') {
            contentObj.runAnimation(outCallBack, true, contentId);
          }
          if (actionName == 'Stop') {
            contentObj.stopAnimation(outCallBack);
          }
          if (actionName == 'Hide') {
            contentObj.hideAnimation(outCallBack);
          }
        }
      }, this);
    }
  };
};

////////////////////////////////////////////
///
/// 修复采用img的图片错误问题
///   修复错误的图片加载
///   图片错误了，会先隐藏，然后再去请求一次
///   如果还是错误，就抛弃，正确就显示出来
///   queue:{
///     chpaerId:[1.png,2.png,3.png]
///     ................
///   }
///   特别注意，这里是动态加入的
///   所以，有可能是边解析边加入新的
///
///////////////////////////////////////////

var queue$1 = {};
var waiting = false;

/**
 * 检测一个chpater中的图片加载是否完成
 * @param  {[type]} chapterIndex [description]
 * @return {[type]}              [description]
 */
function checkFigure$1(chapterIndex, callback) {
  var length = queue$1[chapterIndex].length;

  if (!length) {
    callback();
    return;
  }

  var count = length;
  var complete = function complete() {
    if (count === 1) {
      callback();
      return;
    }
    --count;
  };

  var data = void 0;
  while (data = queue$1[chapterIndex].shift()) {
    data(complete);
  }
}

/*
  运行队列
  1.因为queue的对象结构通过chapterId做页面的标记，保存所有每个页面图片的索引
  2.在这个chapter去检测图片的时候，如果成功了就处理图片显示，然后要删除这个检测的fn
  3.因为是动态加入的，所以每个chapter检测完毕后，还要根据列表是否有值，在去处理
  4.最后通过runBatcherQueue在递归一次检测，最终每个chapter是否都处理完毕了
 */
function runBatcherQueue$1() {
  var keys = Object.keys(queue$1);
  if (keys.length) {
    var chapterIndex = keys.shift();
    if (chapterIndex.length) {
      checkFigure$1(chapterIndex, function () {
        /*如果列表没有数据了*/
        if (!queue$1[chapterIndex].length) {
          delete queue$1[chapterIndex];
        }
        /*如果列表还有后续新加入的继续修复当前这个列表*/
        runBatcherQueue$1();
      });
    } else {
      delete queue$1[chapterIndex];
    }
  } else {
    waiting = false;
  }
}

/**
 * 修复错误的图片加载
 * @return {[type]} [description]
 */
function repairImage(node, chapterIndex, src) {

  if (!node) {
    return;
  }
  /*先隐藏错误节点*/
  node.style.display = "none";

  /*根据页面chpater加入列表*/
  if (!queue$1[chapterIndex]) {
    queue$1[chapterIndex] = [];
  }

  /*做一次错误节点的预加载处理*/
  queue$1[chapterIndex].push(function (callback) {
    loadFigure(src, function (data) {
      /*如果请求成功，修改图片状态*/
      if (data.state === 'success') {
        if (node && node.style) {
          node.style.display = "block";
        }
      }
      node = null;
      callback();
    });
  });

  if (!waiting) {
    waiting = true;
    runBatcherQueue$1();
  }
}

/**
 * 清理错误检测的图片
 * @return {[type]} [description]
 */
function clearRepairImage(chapterIndex) {
  if (queue$1 && queue$1[chapterIndex]) {
    queue$1[chapterIndex].length = 0;
    delete queue$1[chapterIndex];
  }
}

var destroy$1 = function (baseProto) {

  /**
   * 销毁页面对象
   * @return {[type]} [description]
   */
  baseProto.baseDestroy = function () {

    /**
     * 2017.6.26
     * 销毁图片apng
     * 一次性的apng图片，必须要清理src
     * 否则重复不生效，因为缓存的关系
     */
    cleanImage(this.$pageNode);

    //最后一页动作处理
    //for miaomiaoxue
    this.destroyPageAction();

    //2016/9/30
    //页面缩放对象
    if (this._pageScaleObj) {
      this._pageScaleObj.destroy();
      this._pageScaleObj = null;
    }

    //流式布局对象
    //2016.9.10
    var columns = this.columnGroup.get();
    if (columns && columns.length) {
      columns.forEach(function (flowObj) {
        flowObj.destroy();
      });
    }

    /**
     * 清理可能错误的img修复文件列表
     */
    clearRepairImage(this.chapterIndex);

    //清理多线程任务块
    var taskGroup = this.threadTaskRelated.assignTaskGroup;
    if (taskGroup) {
      for (var key in taskGroup) {
        var task = taskGroup[key];
        if (task) {
          task.destroy && task.destroy();
        }
      }
    }

    //浮动对象
    var floatMaterContents = this.floatGroup.masterGroup;

    //是否有浮动对象
    var hasFloatMater = !_.isEmpty(floatMaterContents);

    //清理activity类型对象
    var activitys = this.activityGroup.get();
    if (activitys && activitys.length) {
      activitys.forEach(function (activityObj) {
        activityObj.destroy(function (destroyObj) {
          //如果不是浮动对象,清理元素引用
          if (!hasFloatMater || destroyObj && !floatMaterContents[destroyObj.id]) {
            destroyObj.$contentNode = null;
          }
        });
      });
    }

    //清除母版浮动容器
    if (hasFloatMater && this.floatGroup.masterContainer) {
      this.floatGroup.masterContainer.remove();
    }

    //清除浮动页面对象
    if (this.floatGroup.pageGroup && this.floatGroup.pageContainer) {
      this.floatGroup.pageContainer.remove();
    }

    //清理零件类型对象
    var components = this.baseGetComponent();
    if (components && components.length) {
      components.forEach(function (obj) {
        obj.destroy && obj.destroy();
      });
    }

    //多事件销毁
    destroy(this);

    //伪li节点
    if (this.$pseudoElement) {
      this.$pseudoElement = null;
    }

    unWatchColumn(this);

    //移除li容器节点节点
    this.$pageNode.remove();
    this.rootNode = null;
    this.$pageNode = null;
  };
};

/**
 * 滑动容器
 * @param  {[type]} baseProto [description]
 * @return {[type]}           [description]
 */
var movePage = function (baseProto) {

  /**
   * 页面移动
   * @return {[type]} [description]
   */
  baseProto.movePage = function (action, distance, speed, viewOffset, outerCallFlip) {

    var pageNode = this.$pageNode[0];

    //浮动页面
    if (this.pageType === 'page') {
      var floatPageContainer = this.floatGroup.pageContainer;
      if (floatPageContainer) {
        translation[action](floatPageContainer[0], distance, speed);
      }
    }

    //浮动母版
    if (this.pageType === 'master') {
      //母版交接判断
      //用户事件的触发
      this.onceMaster = false;
      var floatMasterContainer = this.floatGroup.masterContainer;
      if (floatMasterContainer) {
        translation[action](floatMasterContainer[0], distance, speed);
      }
    }

    /*
    针对翻页结束的处理
     */
    var isVisual = false; // 是可视页面
    var fixQuickFlip = false; //修复翻页
    var timer = null;
    var toTranslateCB = null;

    /*
    只有翻页的时候才处理
    1 增加页面标记
    2 处理页面回调
     */
    if (action === 'flipOver') {
      /*
         如果outerCall存在，就是外部调用翻页的的情况下处理
         修复一个bug,超快速翻页的时候(speed<300)，动画结束事件会丢失页面
         所以针对这种情况，强制改speed改成0，这样动画事件完全屏蔽
         通过回调中手动调用SetSwiperFilpComplete事件处理
         这里扩大下speed的范围
       */
      if (outerCallFlip) {
        if (speed < 100) {
          speed = 0;
          fixQuickFlip = true;
        }
      }

      /*
        过滤多个动画回调
        保证指向始终是当前页面
        翻页 && 是母版页 && 是当前页面
       */
      if (this.pageType === 'page' && distance === viewOffset) {
        /*标记可视区页面*/
        isVisual = true;

        /*增加可视页面标记*/
        pageNode.setAttribute('data-visual', true);

        /*
         就上做了fixQuickFlip修复都有可能不触发动画回调的情况，
         是这里做一个手动调用的强制处理,延长原本时间的500毫秒调用
         只处理Visual页面
         这里必须监控data-visual是否被移除了，才能正确处理
         */
        timer = setTimeout(function () {
          clearTimeout(timer);
          timer = null;
          if (pageNode.getAttribute('data-visual')) {
            Xut.$warn({
              type: 'pagebase',
              content: '翻页translate回调丢失了，通过定时器手动调用修复'
            });
            toTranslateCB = null;
            Xut.View.SetSwiperFilpComplete(pageNode, true);
          }
        }, speed + 500);
      }
    }

    /*Translate调用，通过引用方式，在定时器中可以取消*/
    toTranslateCB = function toTranslateCB() {
      /*
      2种情况下会主动触发翻页结束回调
      1.gestureSwipe，关闭了翻页效果,直接跳页面，并且是可视区页面
      2.超快翻页的时候丢失了动画回调，并且是可视区页面
       */
      if (isVisual && (fixQuickFlip || !config.launch.gestureSwipe)) {
        Xut.View.SetSwiperFilpComplete(pageNode, true);
        return true;
      }
    };

    translation[action](pageNode, distance, speed, toTranslateCB);
  };
};

/**
 * 移动视觉差对象
 */
var translateParallax = function translateParallax(_ref) {
  var $contentNode = _ref.$contentNode,
      scope = _ref.scope,
      direction = _ref.direction,
      pageIndex = _ref.pageIndex,
      action = _ref.action,
      speed = _ref.speed,
      nodes = _ref.nodes,
      distance = _ref.distance,
      isColumn = _ref.isColumn;


  var lastProperty = scope.lastProperty;
  var targetProperty = scope.targetProperty;

  //往前翻页
  if (direction === 'prev') {
    //分割的比例
    var nodeRatio = scope.nodeRatio;

    //如果往前溢出则取0
    nodes = nodes == nodeRatio ? 0 : nodeRatio;
  }

  //每次单步变化属性值
  var stepProperty = getStepProperty({
    nodes: nodes,
    isColumn: isColumn,
    distance: distance,
    lastProperty: lastProperty,
    pageIndex: pageIndex,
    targetProperty: targetProperty
  });

  switch (action) {
    case 'flipMove':
      //移动中
      stepProperty = flipMove(stepProperty, lastProperty);
      break;
    case 'flipRebound':
      //反弹
      stepProperty = flipRebound(stepProperty, lastProperty);
      break;
    case 'flipOver':
      if (direction === 'prev') {
        stepProperty = flipOver(stepProperty, lastProperty);
      }

      //缩放单独处理
      //因为缩放是从1开始的
      //所以每次计算出单步的值后，需要叠加原始的值1
      if (direction === 'next') {
        if (stepProperty.scaleX !== undefined) {
          stepProperty.scaleX = stepProperty.scaleX + 1;
        }
        if (stepProperty.scaleY !== undefined) {
          stepProperty.scaleY = stepProperty.scaleY + 1;
        }
        if (stepProperty.scaleZ !== undefined) {
          stepProperty.scaleZ = stepProperty.scaleZ + 1;
        }
      }

      //翻页结束,记录上一页的坐标
      cacheProperty(stepProperty, lastProperty);
      break;
  }

  // if($contentNode[0].id === 'Content_1_4'){
  //     console.log(stepProperty)
  // }


  //直接操作元素
  setStyle({
    $contentNode: $contentNode,
    action: 'master',
    interaction: action,
    pageIndex: pageIndex,
    targetProperty: targetProperty,
    property: stepProperty,
    speed: speed,
    opacityStart: lastProperty.opacityStart
  });
};

/**
 * 滑动
 * @param  {[type]} baseProto [description]
 * @return {[type]}           [description]
 */
var moveParallax = function (baseProto) {

  /**
   * 移动视察对象
   */
  baseProto.moveParallax = function (_ref2) {
    var action = _ref2.action,
        direction = _ref2.direction,
        moveDistance = _ref2.moveDistance,
        pageIndex = _ref2.pageIndex,
        speed = _ref2.speed,
        nodes = _ref2.nodes,
        parallaxProcessedContetns = _ref2.parallaxProcessedContetns;


    var base = this;
    var activitys = this.baseGetActivity();

    if (!activitys) {
      return;
    }

    //是珊栏页面，那么翻页的参数需要转化
    var isColumn = base.getStyle.pageVisualMode === 1;

    //移动距离
    var distance = moveDistance.length ? moveDistance[1] : moveDistance;

    //遍历所有活动对象
    _.each(activitys, function (content) {
      content.eachAssistContents(function (scope) {
        //如果是视察对象移动
        if (scope.parallax) {

          var $contentNode = scope.parallax.$contentNode;

          /**
           * 如果有这个动画效果
           * 先停止否则通过视觉差移动会出问题
           * 影响，摩天轮转动APK
           * 重新激动视觉差对象
           * 因为视察滑动对象有动画
           * 2个CSS3动画冲突的
           * 所以在视察滑动的情况下先停止动画
           * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
           * 通过动画回调在重新加载动画
           */
          if (parallaxProcessedContetns) {
            var contentObj = base.baseGetContentObject(scope.id);
            if (contentObj && action === "flipMove" && contentObj.pptObj && //ppt动画
            !contentObj.parallaxProcessed) {
              //标记
              var actName = contentObj.actName;
              contentObj.stop && contentObj.stop();
              //视觉差处理一次,停止过动画
              contentObj.parallaxProcessed = true;
              //增加标记
              $contentNode.attr('data-parallaxProcessed', actName);
              //记录
              parallaxProcessedContetns[actName] = contentObj;
            }
          }

          //移动视觉差对象
          translateParallax({
            pageIndex: pageIndex,
            $contentNode: $contentNode,
            scope: scope.parallax,
            direction: direction,
            action: action,
            speed: speed,
            nodes: nodes,
            distance: distance,
            isColumn: isColumn
          });
        }
      });
    });
  };
};

/*********************************************************************
 *                 构建页面对象
 *             实现目标：
 *                快速翻页
 *                最快中断任务
 *                提高优先级
 *
 *             1 构建四个大任务，每个大人物附属一堆小任务
 *             2 每次触发一个新的任务，都会去检测是否允许创建的条件
 *
 *  2014.11.18
 *  新增canvan模式
 *    contentMode 分为  0 或者 1
 *    0 是dom模式
 *    1 是canvas模式
 *    以后如果其余的在增加
 *    针对页面chapter中的parameter写入 contentMode   值为 1
 *    如果是canvas模式的时候，同时也是能够存在dom模式是
 *
 *                                                         *
 **********************************************************************/

var Pagebase = function Pagebase(options) {
  classCallCheck(this, Pagebase);

  this.init(options);
};

var baseProto = Pagebase.prototype;

initstate(baseProto);
threadCheck(baseProto);
threadExternal(baseProto);
dataExternal(baseProto);
movePage(baseProto);
moveParallax(baseProto);
destroy$1(baseProto);

/**
 * 判断是否能整除2
 * @param  {[type]} num [description]
 * @return {[type]}     [description]
 */


/**
 * 页面之间关系
 * createIndex 创建的页面
 * visualIndex 可视区页面
 * 有横竖布局
 *   所以根据全局的scrollMode参数而定
 */
function getPosition(createIndex, visualIndex) {
  var isVertical = config.launch.scrollMode === 'v';
  var direction = void 0;
  if (createIndex < visualIndex) {
    direction = isVertical ? 'top' : 'left';
  } else if (createIndex > visualIndex) {
    direction = isVertical ? 'bottom' : 'right';
  } else if (visualIndex == createIndex) {
    direction = 'middle';
  }
  return direction;
}

var mixRang = function mixRang(pageIndex, start) {
  return pageIndex.map(function (oldPageIndex) {
    return oldPageIndex - start;
  });
};

/**
 * 如果是场景加载，转化页码数
 * 转化按0开始
 * pageIndex 页码
 * visualPageIndex 可见页面chpaterId
 */
function converVisualPid(options, chapterIndex, visualPageIndex) {

  //转化可视区域值viewPageIndex
  if (options.hasMultiScene) {
    var sectionRang = options.sectionRang;
    //如果传入的是数组数据
    if (!visualPageIndex && _.isArray(chapterIndex)) {
      return mixRang(chapterIndex, sectionRang.start);
    }
    chapterIndex -= sectionRang.start;
    visualPageIndex += sectionRang.start;
  } else {
    //pageIndex是数组，并且realPage为空
    if (_.isArray(chapterIndex)) {
      return chapterIndex;
    }
  }
  return {
    pageIndex: chapterIndex,
    visualChapterIndex: visualPageIndex
  };
}

/**
 * 计算初始化页码
 */
function initPointer$1(targetIndex, pageTotal, hasMultiPage) {

  var leftscope = 0,
      initPointer = {},
      createPointer = [];

  function setValue(pointer) {
    if (pointer.frontIndex !== undefined) {
      initPointer.frontIndex = pointer.frontIndex;
      createPointer.push(pointer.frontIndex);
    }
    if (pointer.middleIndex !== undefined) {
      initPointer.middleIndex = pointer.middleIndex;
      createPointer.push(pointer.middleIndex);
    }
    if (pointer.backIndex !== undefined) {
      initPointer.backIndex = pointer.backIndex;
      createPointer.push(pointer.backIndex);
    }
  }

  //如果只有一页 or  非线性,只创建一个页面
  if (pageTotal === 1 || !hasMultiPage) {
    setValue({
      'middleIndex': targetIndex
    });
  } else {
    //多页情况
    if (targetIndex === leftscope) {
      //首页
      setValue({
        'middleIndex': targetIndex,
        'backIndex': targetIndex + 1
      });
    } else if (targetIndex === pageTotal - 1) {
      //尾页
      setValue({
        'middleIndex': targetIndex,
        'frontIndex': targetIndex - 1
      });
    } else {
      //中间页
      setValue({
        'middleIndex': targetIndex,
        'frontIndex': targetIndex - 1,
        'backIndex': targetIndex + 1
      });
    }
  }

  return {
    createPointer: createPointer,
    initPointer: initPointer
  };
}

/*
页面页面，转化双页面
///启动了双页模式
///创建的页面需要修改了索引处理
///创建索引0
/// 变化成 0-1
///以此类推
needTotal 为true 就是返回带total的合集
1 返回带needTotal的合集
2 返回单页转化的双页数组
 */
function converDoublePage(createPointer, needTotal) {

  /////////////////////////////////////
  ///
  ///启动了双页模式
  ///创建的页面需要修改了索引处理
  ///创建索引0
  /// 变化成 0-1
  ///以此类推
  /////////////////////////////////////
  var createDoublePage = {};

  /*记录总数*/
  var total = 0;

  if (createPointer == undefined) {
    return createDoublePage;
  }

  if (config.launch.doublePageMode) {
    var base = void 0,
        left = void 0,
        right = void 0;
    if (!createPointer.length) {
      createPointer = [createPointer];
    }
    createPointer.forEach(function (index) {
      if (index === 0) {
        createDoublePage[index] = [0, 1];
        total += 2;
      } else {
        base = index * 2;
        left = base;
        right = base + 1;
        total += 2;
        (createDoublePage[index] = []).push(left, right);
      }
    });
  }

  if (needTotal) {
    createDoublePage.total = total;
    return createDoublePage;
  }

  /*createPointer => [0]
    createDoublePage => [0,1]*/
  return createDoublePage[createPointer[0]];
}

/*
获取页面处理的合集，保持接口处理一致，判断逻辑封装
1.双页
2.单页
return []
 */
function getRealPage(pageIndex, type) {

  if (pageIndex === undefined) {
    return [];
  }

  if (config.launch.doublePageMode) {
    /*转化后的页面合集*/
    var pageIds = converDoublePage(pageIndex);
    /*双页*/
    if (pageIds.length) {
      return pageIds;
    }
  }

  return [pageIndex];
}

/**
  1 加快页面解析，可视区页面最开始创建
  2 双页面页码解析
  3 场景加载模式,计算正确的chapter顺序
  进入 [0,1,2]
  出来
      1 单页面 [1,0,2]
      2 多页面 [2, 3, 0, 1, 4, 5]
 * createSinglePage 需要创建的页面
 * visualPageIndex 可视区页面
 * createDoublePage 多页面索引
 */
function converChapterIndex(options, createSinglePage, createDoublePage, visualPageIndex) {

  var cloneCreateSinglePage = _.extend([], createSinglePage);

  /*
    保证可视区优先创建
    如果最先创建的的页面不是可视区页面
    就需要切换对应的
   */
  if (cloneCreateSinglePage[0] !== visualPageIndex) {
    var indexOf = cloneCreateSinglePage.indexOf(visualPageIndex);
    var less = cloneCreateSinglePage.splice(indexOf, 1);
    cloneCreateSinglePage = less.concat(cloneCreateSinglePage);
  }

  //如果有双页面，那么转化是页面就是这个了
  //而不是传递的createPage单页面
  //[1,0,2] => [2,3,1,2,4,5]
  if (createDoublePage.total) {
    var newCreatePage = [];
    cloneCreateSinglePage.forEach(function (pageIndex) {
      var doublePage = createDoublePage[pageIndex];
      if (doublePage.length) {
        newCreatePage.push(doublePage[0]);
        if (doublePage[1]) {
          newCreatePage.push(doublePage[1]);
        }
      }
    });
    cloneCreateSinglePage = newCreatePage;
  }

  //场景加载模式,计算正确的chapter顺序
  //多场景的模式chpater分段后
  //叠加起始段落
  if (options.hasMultiScene) {
    //需要提前解析数据库的排列方式
    //chpater的开始位置
    var start = options.sectionRang.start;
    cloneCreateSinglePage.forEach(function (page, index) {
      cloneCreateSinglePage.splice(index, 1, page + start);
    });
  }

  // [0,1,2] => [73,74,75]
  return cloneCreateSinglePage;
}

/**
 * 页码转化成相对应的chpater表数据
 * @param  {[type]} createPage [description]
 * @return {[type]}            [description]
 */
function converChapterData(createPage) {
  return query('chapter', createPage);
}

/**
 * 检测是否构建母板模块处理
 * @return {[type]} [description]
 */
function hasMaster() {
  var table = errorTable();
  //如果没有Master数据,直接过滤
  if (-1 !== table.indexOf('Master') || !Xut.data['Master'] || !Xut.data['Master'].length) {
    return false;
  }
  return true;
}

/**
 * 页面模块
 * @param  {[type]}
 * @return {[type]}
 */
/**
 * 检测脚本注入
 * @return {[type]} [description]
 */
var runScript$1 = function runScript(pageObject, type) {
  var code = pageObject.chapterData[type];
  if (code) {
    execScript(code, type);
  }
};

var PageMgr = function (_ManageSuper) {
  inherits(PageMgr, _ManageSuper);

  function PageMgr(rootNode) {
    classCallCheck(this, PageMgr);

    var _this = possibleConstructorReturn(this, (PageMgr.__proto__ || Object.getPrototypeOf(PageMgr)).call(this));

    _this.rootNode = rootNode;
    _this.pageType = 'page';

    /*
    双页模式，给父节点绑定一个翻页监听事件
    如果翻页完成，手动触发翻页事件
    */
    if (config.launch.doublePageMode) {
      $on(rootNode, {
        transitionend: function transitionend() {
          Xut.View.SetSwiperFilpComplete();
        }
      });
    }
    return _this;
  }

  /*设置页面的初始化的translate值*/


  createClass(PageMgr, [{
    key: 'setInitTranslate',
    value: function setInitTranslate(pageIndex) {
      if (config.launch.doublePageMode) {
        var distance = config.screenSize.width * pageIndex;
        Xut.style.setTranslate({
          x: -distance,
          node: this.rootNode
        });
      }
    }

    /**
     * 创建页新的页面
     * @param  {[type]} dataOpts  [description]
     * @param  {[type]} pageIndex [description]
     * @return {[type]}           [description]
     */

  }, {
    key: 'create',
    value: function create(dataOpts, pageIndex) {
      //生成指定页面对象
      var pageObjs = new Pagebase(_.extend(dataOpts, {
        'pageType': this.pageType, //创建页面的类型
        'rootNode': this.rootNode //根元素
      }));
      //增加页面管理
      this._$$addBaseGroup(pageIndex, pageObjs);
      return pageObjs;
    }

    /*
    滑动页面容器
     */

  }, {
    key: '_moveContainer',
    value: function _moveContainer(distance, speed) {
      Xut.style.setTranslate({
        speed: speed,
        x: distance,
        node: this.rootNode
      });
    }

    /**
     * 移动页面
     * @return {[type]}
     */

  }, {
    key: 'move',
    value: function move(data) {
      var speed = data.speed,
          action = data.action,
          outerCallFlip = data.outerCallFlip,
          moveDistance = data.moveDistance,
          frontIndex = data.frontIndex,
          middleIndex = data.middleIndex,
          backIndex = data.backIndex;

      /*双页模式，移动父容器*/

      if (config.launch.doublePageMode) {
        this._moveContainer(moveDistance[1], speed);
      } else {
        /*单页模式，移动每个独立的页面*/
        _.each([this.$$getPageBase(frontIndex), this.$$getPageBase(middleIndex), this.$$getPageBase(backIndex)], function (pageObj, index) {
          var dist = moveDistance[index];
          if (pageObj && dist !== undefined) {
            pageObj.movePage(action, dist, speed, moveDistance[3], outerCallFlip);
          }
        });
      }
    }

    /**
     * 触屏翻页开始
     * 1 中断所有任务
     * 2 停止热点对象运行
     *     停止动画,视频音频等等
     */

  }, {
    key: 'suspend',
    value: function suspend(frontIndex, middleIndex, backIndex, stopIndex) {

      var suspendPageObj = this.$$getPageBase(stopIndex);
      var prveChapterId = suspendPageObj.baseGetPageId(stopIndex);

      /*如果有代码跟踪*/
      if (suspendPageObj.startupTime) {
        config.sendTrackCode('flip', {
          pageId: suspendPageObj.chapterId,
          pageAttr: suspendPageObj.pageAttr,
          time: +new Date() - suspendPageObj.startupTime
        });
      }

      //翻页结束脚本
      runScript$1(suspendPageObj, 'postCode');
      //中断节点创建任务
      this._suspendInnerCreateTasks(frontIndex, middleIndex, backIndex);
      //停止活动对象活动
      suspendPageObj.destroyPageAction();
      suspendPageObj.resetSwipeSequence();
      $suspend(suspendPageObj, prveChapterId);
    }

    /**
     * 复位初始状态
     * 转化：双页
     * @return {[type]} [description]
     */

  }, {
    key: 'resetOriginal',
    value: function resetOriginal(pageIndex) {
      var _this2 = this;

      var originalIds = getRealPage(pageIndex, 'resetOriginal');
      originalIds.forEach(function (originaIndex) {
        var originalPageObj = _this2.$$getPageBase(originaIndex);
        if (originalPageObj) {
          var floatPageContainer = originalPageObj.floatGroup.pageContainer;
          if (floatPageContainer) {
            //float-Pages设置的content溢出后处理
            //在非视区增加overflow:hidden
            //可视区域overflow:''
            floatPageContainer.css({ 'zIndex': 2000, 'overflow': 'hidden' });
          }
          $original(originalPageObj);
        }
      });
    }

    /**
     * 触屏翻页完成
     * 转化：双页
     * 1 停止热点动作
     * 2 触发新的页面动作
     */

  }, {
    key: 'autoRun',
    value: function autoRun(data) {
      var _this3 = this;

      var createPointer = data.createPointer,
          frontIndex = data.frontIndex,
          middleIndex = data.middleIndex,
          backIndex = data.backIndex,
          suspendIndex = data.suspendIndex,
          isFastSlider = data.isFastSlider,
          direction = data.direction;


      var self = this;

      /**
       * 预执行背景创建
       * 支持多线程快速翻页
       * 1 初始化,或者快速翻页补全前后页面
       * 2 正常翻页创建前后
       */
      var preCreateTask = function preCreateTask(taskName) {
        var resumePointer = void 0;
        if (isFastSlider || !direction) {
          //init
          resumePointer = [frontIndex, backIndex];
        } else {
          //flip
          resumePointer = createPointer || backIndex || frontIndex;
        }
        _this3._checkPreforkTasks(resumePointer, taskName);
      };

      /*激活自动运行对象*/
      var activateAutoRun = function activateAutoRun(pageObj, data) {

        //结束通知
        var _complete = function _complete() {
          data.processComplete();
          preCreateTask();
        };

        //运行动作
        var _startRun = function _startRun() {
          $autoRun(pageObj, middleIndex, _complete);
        };

        //如果页面容器存在,才处理自动运行
        var currpageNode = pageObj.getContainsNode();
        if (!currpageNode) {
          return _complete();
        }

        //运行如果被中断,则等待
        if (data.suspendCallback) {
          data.suspendCallback(_startRun);
        } else {
          _startRun();
        }
      };

      /*检测页面是否已经完全创建完毕，并且返回页面对象*/
      this._checkTaskCompleted(middleIndex, function (activatePageObj) {

        //进入每次页面触发
        config.sendTrackCode('enter', {
          pageId: activatePageObj.chapterId,
          pageAttr: activatePageObj.pageAttr
        });

        //跟踪，每个页面的停留时间，开始
        if (config.hasTrackCode('flip')) {
          activatePageObj.startupTime = +new Date();
        }

        /*watch('complete')方法调用*/
        activatePageObj.createPageAction();

        /*提升当前页面浮动对象的层级,因为浮动对象可以是并联的*/
        var floatPageContainer = activatePageObj.floatGroup.pageContainer;
        if (floatPageContainer) {
          floatPageContainer.css({ 'zIndex': 2001, 'overflow': '' });
        }

        /*IE上不支持蒙版效果的处理*/
        if (Xut.style.noMaskBoxImage) {
          addEdges();
        }

        /*构建完成通知*/
        data.buildComplete(activatePageObj.seasonId);

        /*执行自动动作之前的脚本*/
        runScript$1(activatePageObj, 'preCode');

        /*热点状态复位,多页也只运行一次*/
        self.resetOriginal(suspendIndex);

        /*预构建背景*/
        preCreateTask('background');

        //等待动画结束后构建
        activateAutoRun(activatePageObj, data);
      });
    }

    /**
     * 销毁单个页面的对象
     * 这里不包含管理对象
     * 移除页面对象
     */

  }, {
    key: 'clearPage',
    value: function clearPage(clearPageIndex) {
      var pageObj = this.$$getPageBase(clearPageIndex);
      if (pageObj) {
        pageObj.baseDestroy();
        this._$$removeBaseGroup(clearPageIndex);
      }
    }

    /**
     * 一般退出页面处理
     * 销毁整个页面管理对象
     * 包含所有页面与管理对象
     * @return {[type]} [description]
     */

  }, {
    key: 'destroyManage',
    value: function destroyManage() {
      //清理视频
      var pageId = Xut.Presentation.GetPageId(Xut.Presentation.GetPageIndex());

      removeVideo(pageId);

      //清理对象
      this._$$destroyBaseGroup();

      //销毁事件
      if (config.launch.doublePageMode) {
        $off(this.rootNode);
      }

      //清理节点
      this.rootNode = null;
    }

    /**
     * 设置中断正在创建的页面对象任务
     */

  }, {
    key: '_suspendInnerCreateTasks',
    value: function _suspendInnerCreateTasks(frontIndex, middleIndex, backIndex) {
      var self = this;

      /*设置中断任务
      1.如果没有参数返回
      2.保证数组格式遍历*/
      var suspendTask = function suspendTask(pageIndex) {
        if (pageIndex !== undefined) {
          if (!pageIndex.length) {
            pageIndex = [pageIndex];
          }
          var pageObj = void 0;
          pageIndex.forEach(function (pointer) {
            if (pageObj = self.$$getPageBase(pointer)) {
              pageObj.setTaskSuspend();
            }
          });
        }
      };

      suspendTask(frontIndex);
      suspendTask(middleIndex);
      suspendTask(backIndex);
    }

    /*检测活动窗口任务*/

  }, {
    key: '_checkTaskCompleted',
    value: function _checkTaskCompleted(currIndex, callback) {
      var currPageObj = this.$$getPageBase(currIndex);
      if (currPageObj) {
        currPageObj.checkThreadTaskComplete(function () {
          // console.log('11111111111当前页面创建完毕',currIndex+1)
          callback(currPageObj);
        });
      }
    }

    /**
     * 检测后台预创建任务
     * @return {[type]} [description]
     */

  }, {
    key: '_checkPreforkTasks',
    value: function _checkPreforkTasks(resumePointer, preCreateTask) {
      var resumeObj, resumeCount;
      if (!resumePointer.length) {
        resumePointer = [resumePointer];
      }
      resumeCount = resumePointer.length;
      while (resumeCount--) {
        if (resumeObj = this.$$getPageBase(resumePointer[resumeCount])) {
          resumeObj.createPreforkTask(function () {
            // console.log('后台处理完毕')
          }, preCreateTask);
        }
      }
    }
  }]);
  return PageMgr;
}(ManageSuper);

/*
 * 母版管理模块
 * @param  {[type]}
 * @return {[type]}
 */
/**
 * 扁平化对象到数组
 * @param  {[type]} filter [description]
 * @return {[type]}        [description]
 */
var toArray$2 = function toArray$$1(filter) {
  var arr = [];
  if (!filter.length) {
    for (var key in filter) {
      arr.push(filter[key]);
    }
    filter = arr;
  }
  return filter;
};

var rword = "-";

/**
 * parallaObjsCollection: Object
 *      0: Page
 *      1: Page
 *
 *  recordMasterId: Object
 *      0: 9001
 *      1: 9001
 *
 *  recordMasterRange: Object
 *      9001: Array[2]
 *
 *  rootNode: ul # parallax.xut - parallax xut - flip
 *
 *  currMasterId: 9001 //实际的可使区
 */

var MasterMgr = function (_ManageSuper) {
  inherits(MasterMgr, _ManageSuper);

  function MasterMgr(rootNode) {
    classCallCheck(this, MasterMgr);

    var _this = possibleConstructorReturn(this, (MasterMgr.__proto__ || Object.getPrototypeOf(MasterMgr)).call(this));

    _this.visualWidth = config.visualSize.width;
    _this.visualHeight = config.visualSize.height;

    _this.pageType = 'master';

    _this.rootNode = rootNode;
    _this.recordMasterRange = {}; //记录master区域范围
    _this.recordMasterId = {}; //记录页面与母板对应的编号
    _this.currMasterId = null; //可视区母板编号

    /**
     * 记录视察处理的对象
     * @type {Object}
     */
    _this.parallaxProcessedContetns = {};
    return _this;
  }

  /**
   * 注册状态管理
   */


  createClass(MasterMgr, [{
    key: 'register',
    value: function register(pageIndex, type, hotspotObj) {
      var parallaxObj = this.$$getPageBase(this.converMasterId(pageIndex));
      if (parallaxObj) {
        parallaxObj.registerCotents.apply(parallaxObj, arguments);
      }
    }

    /**
     * 创建
     */

  }, {
    key: 'create',
    value: function create(dataOpts, pageIndex, createCallBack, repeatCallBack) {
      var reuseMasterKey = void 0;
      var pptMaster = dataOpts.chapterData.pptMaster;
      var pageOffset = dataOpts.chapterData.pageOffset;

      //母板复用的标示
      var reuseMasterId = pageOffset && pageOffset.split(rword);

      //组合下标
      if (reuseMasterId && reuseMasterId.length === 3) {
        reuseMasterKey = pptMaster + rword + reuseMasterId[2];
      } else {
        reuseMasterKey = pptMaster;
      }

      //检测母版已经创建
      if (this._hasMaster(reuseMasterKey, pageOffset, pageIndex)) {
        //重复的母版对象
        //用于检测页面模式是否一致
        var currMasterObj = this.$$getPageBase(reuseMasterKey);
        currMasterObj && repeatCallBack(currMasterObj);
        return;
      }

      //通知外部,需要创建的母版
      createCallBack();

      var masterObj = new Pagebase(_.extend(dataOpts, {
        pptMaster: pptMaster, //ppt母板ID
        'pageType': this.pageType, //创建页面的类型
        'rootNode': this.rootNode //根元素
      }));

      //增加页面管理
      this._$$addBaseGroup(reuseMasterKey, masterObj);

      return masterObj;
    }

    /**
     * 页面滑动处理
     * 1 母版之间的切换
     * 2 浮动对象的切换
     */

  }, {
    key: 'move',
    value: function move(options, isAppBoundary) {
      var _this2 = this;

      var nodes = options.nodes,
          speed = options.speed,
          action = options.action,
          moveDistance = options.moveDistance,
          direction = options.direction,
          frontIndex = options.frontIndex,
          middleIndex = options.middleIndex,
          backIndex = options.backIndex;

      //是边界处理
      //边界外处理母版
      //边界内处理视觉差

      var isBoundary = false;

      //找到需要滑动的母版
      var masterObjs = this._findMaster(frontIndex, middleIndex, backIndex, direction, action, isAppBoundary);

      _.each(masterObjs, function (pageObj, index) {
        if (pageObj) {
          isBoundary = true;
          pageObj.movePage(action, moveDistance[index], speed, moveDistance[3]);
        }
      });

      //越界不需要处理内部视察对象
      this.isBoundary = isBoundary;
      if (isBoundary) {
        return;
      }

      /**
       * 移动内部的视察对象
       * 处理当前页面内的视觉差对象效果
       */
      var moveParallaxObject = function moveParallaxObject(nodes) {
        var getMasterId = _this2.converMasterId(middleIndex);
        var currParallaxObj = _this2.$$getPageBase(getMasterId);
        if (currParallaxObj) {
          //处理当前页面内的视觉差对象效果
          currParallaxObj.moveParallax({
            action: action,
            direction: direction,
            speed: speed,
            nodes: nodes,
            moveDistance: moveDistance,
            parallaxProcessedContetns: _this2.parallaxProcessedContetns
          });
        }
      };

      //移动视察对象
      switch (direction) {
        case 'prev':
          moveParallaxObject();
          break;
        case 'next':
          nodes && moveParallaxObject(nodes);
          break;
      }
    }

    /**
     * 停止行为
     * @return {[type]} [description]
     */

  }, {
    key: 'suspend',
    value: function suspend(action, stopPointer) {
      //翻页，如果越界，需要处理
      //跳页，需要处理
      //
      //暂时没有处理
      //如果跳的新页面，还是同一个模板的情况
      if (this.isBoundary || action === 'toPage') {
        var masterObj = void 0;
        if (masterObj = this.$$getPageBase(stopPointer)) {
          var pageId = masterObj.baseGetPageId(stopPointer);
          //停止活动对象活动
          $suspend(masterObj, pageId);
        }
      }
    }

    /**
     * 复位初始状态
     * @return {[type]} [description]
     */

  }, {
    key: 'resetOriginal',
    value: function resetOriginal(pageIndex) {
      var originalPageObj;
      if (originalPageObj = this.$$getPageBase(pageIndex)) {
        $original(originalPageObj);
      }
    }

    /**
     *  母版自动运行
     */

  }, {
    key: 'autoRun',
    value: function autoRun(action, data) {
      var middleIndex = data.middleIndex,
          suspendIndex = data.suspendIndex;

      var masterObj = this.$$getPageBase(middleIndex);
      if (masterObj) {
        //如果没有运行自动任务
        //如果动作是初始化，或者触发了母版自动运行
        //如果是越界处理
        if (!masterObj.onceMaster || action || this.isBoundary) {
          //热点状态复位
          this.resetOriginal(suspendIndex);
          $autoRun(masterObj, middleIndex);
        }
      }
    }

    /**
     * 重新激动视觉差对象
     * 因为视察滑动对象有动画
     * 2个CSS3动画冲突的
     * 所以在视察滑动的情况下先停止动画
     * 然后给每一个视察对象打上对应的hack=>data-parallaxProcessed
     * 通过动画回调在重新加载动画
     * @return {[type]} [description]
     */

  }, {
    key: 'reactivation',
    value: function reactivation(target) {
      if (this.parallaxProcessedContetns) {
        var actName = target.id;
        var contentObj = this.parallaxProcessedContetns[actName];
        if (contentObj) {
          contentObj.runAnimations();
          //视觉差处理一次,停止过动画
          contentObj.parallaxProcessed = false;
          //移除标记
          target.removeAttribute('data-parallaxProcessed');
          //记录
          delete this.parallaxProcessedContetns[actName];
        }
      }
    }

    /**
     * 制作处理器
     * 针对跳转页面
     */

  }, {
    key: 'makeJumpPocesss',
    value: function makeJumpPocesss(targetIndex) {
      var filter;
      var master = this;
      return {
        pre: function pre() {
          //目标母板对象
          var targetkey = master.converMasterId(targetIndex);
          //得到过滤的边界keys
          //在filter中的页面为过滤
          filter = master._scanBounds(targetIndex, targetkey);
          //清理多余母板
          //filter 需要保留的范围
          master._checkClear(filter, true);
          //更新可视母板编号
          master.currMasterId = targetkey;
        },
        //修正位置
        clean: function clean(visualIndex, targetIndex) {
          master._fixPosition(filter);
          master._checkParallaxPox(visualIndex, targetIndex);
        }
      };
    }

    /**
     * 销毁整页面管理对象
     * 退出应用处理
     * @return {[type]} [description]
     */

  }, {
    key: 'destroyManage',
    value: function destroyManage() {
      this.rootNode = null;
      //销毁对象
      this._$$destroyBaseGroup();
    }

    /**
     * 找到当前页面的可以需要滑动是视觉页面对象
     * isAppBoundary 是应用边界反弹，##317,最后一页带有视觉差反弹出错,视觉差不归位
     */

  }, {
    key: '_findMaster',
    value: function _findMaster(frontIndex, middleIndex, backIndex, direction, action, isAppBoundary) {
      var prevFlag = void 0,
          nextFlag = void 0,
          prevMasterId = void 0,
          nextMasterId = void 0,
          prevMasterObj = void 0,
          currMasterObj = void 0,
          nextMasterObj = void 0,
          currMasterId = this.converMasterId(middleIndex);

      switch (direction) {
        case 'prev':
          prevMasterId = this.converMasterId(frontIndex);
          prevFlag = currMasterId !== prevMasterId;

          //如果2个页面不一样的视觉差
          //或者是应用最后一页反弹的情况，2个页面同一个视觉差，也就是最后一页，往前面反弹
          if (prevFlag || isAppBoundary) {
            currMasterObj = this.$$getPageBase(currMasterId);
          }

          if (prevMasterId && prevFlag) {
            action === 'flipOver' && this._checkClear([currMasterId, prevMasterId]); //边界清理
            prevMasterObj = this.$$getPageBase(prevMasterId);
          }

          break;
        case 'next':
          nextMasterId = this.converMasterId(backIndex);
          nextFlag = currMasterId !== nextMasterId;
          if (nextFlag) {
            currMasterObj = this.$$getPageBase(currMasterId);
          }
          if (nextMasterId && nextFlag) {
            action === 'flipOver' && this._checkClear([currMasterId, nextMasterId]); //边界清理
            nextMasterObj = this.$$getPageBase(nextMasterId);
          }
          break;
      }
      return [prevMasterObj, currMasterObj, nextMasterObj];
    }

    //扫描边界
    //扫描key的左右边界
    //当前页面的左右边

  }, {
    key: '_scanBounds',
    value: function _scanBounds(currPage, currkey) {
      var currKey = this.converMasterId(currPage),
          filter = {},
          i = currPage,
          prevKey,
          nextKey;

      //往前
      while (i--) {
        prevKey = this.converMasterId(i);
        if (prevKey && prevKey !== currkey) {
          filter['prev'] = prevKey;
          break;
        }
      }

      //往后
      nextKey = this.converMasterId(currPage + 1);

      //如果有下一条记录
      if (nextKey && nextKey !== currkey) {
        //如果不是当期页面满足范围要求
        filter['next'] = nextKey;
      }

      //当前页面
      if (currKey) {
        filter['curr'] = currKey;
      }
      return filter;
    }

    /**
     * 修正位置
     * @param  {[type]} filter [description]
     * @return {[type]}        [description]
     */

  }, {
    key: '_fixPosition',
    value: function _fixPosition(filter) {

      var self = this;

      var setPosition = function setPosition(parallaxObj, position) {

        /**
         * 设置移动
         */
        var _fixToMove = function _fixToMove(distance, speed) {
          var $pageNode = parallaxObj.$pageNode;
          if ($pageNode) {
            Xut.style.setTranslate({
              speed: speed,
              x: distance,
              node: $pageNode
            });
          }
        };

        if (position === 'prev') {
          _fixToMove(-self.visualWidth);
        } else if (position === 'next') {
          _fixToMove(self.visualWidth);
        } else if (position === 'curr') {
          _fixToMove(0);
        }
      };

      for (var key in filter) {
        switch (key) {
          case 'prev':
            setPosition(this.$$getPageBase(filter[key]), 'prev');
            break;
          case 'curr':
            setPosition(this.$$getPageBase(filter[key]), 'curr');
            break;
          case 'next':
            setPosition(this.$$getPageBase(filter[key]), 'next');
            break;
        }
      }
    }
  }, {
    key: '_checkParallaxPox',
    value: function _checkParallaxPox(currPageIndex, targetIndex) {
      var key,
          pageObj,
          pageCollection = this._$$getBaseGroup();
      for (key in pageCollection) {
        pageObj = pageCollection[key];
        //跳跃过的视觉容器处理
        this._fixParallaxPox(pageObj, currPageIndex, targetIndex);
      }
    }

    /**
     * 当前同一视觉页面作用的范围
     * @param  {[type]} reuseMasterKey [description]
     * @param  {[type]} pageIndex      [description]
     * @return {[type]}                [description]
     */

  }, {
    key: '_toRepeat',
    value: function _toRepeat(reuseMasterKey, pageIndex) {
      var temp;
      if (temp = this.recordMasterRange[reuseMasterKey]) {
        return temp;
      }
      return false;
    }

    //更新母板作用域范围
    //recordMasterRange:{
    //   9001-1:[0,1], master 对应记录的页码
    //   9002-1:[2,3]
    //   9001-2:[4,5]
    //}

  }, {
    key: '_updataMasterscope',
    value: function _updataMasterscope(reuseMasterKey, pageIndex) {
      var scope;
      if (scope = this.recordMasterRange[reuseMasterKey]) {
        if (-1 === scope.indexOf(pageIndex)) {
          scope.push(pageIndex);
        }
      } else {
        this.recordMasterRange[reuseMasterKey] = [pageIndex];
      }
    }

    /**
     * 记录页面与模板标示的映射
     */

  }, {
    key: '_updatadParallaxMaster',
    value: function _updatadParallaxMaster(reuseMasterKey, pageIndex) {
      //记录页面与模板标示的映射
      this.recordMasterId[pageIndex] = reuseMasterKey;

      //更新可视区母板的编号
      this.currMasterId = this.converMasterId(Xut.Presentation.GetPageIndex());
    }

    /**
     * 检测是否需要创建母版
     */

  }, {
    key: '_hasMaster',
    value: function _hasMaster(reuseMasterKey, pageOffset, pageIndex) {
      var tag = this._toRepeat(reuseMasterKey, pageIndex); //false就是没找到母版对象
      this._updataMasterscope(reuseMasterKey, pageIndex);
      this._updatadParallaxMaster(reuseMasterKey, pageIndex);
      return tag;
    }

    /**
     * 修正跳转后视觉对象坐标
     * @param  {[type]} parallaxObj   [description]
     * @param  {[type]} currPageIndex [description]
     * @param  {[type]} targetIndex   [description]
     * @return {[type]}               [description]
     */

  }, {
    key: '_fixParallaxPox',
    value: function _fixParallaxPox(parallaxObj, currPageIndex, targetIndex) {
      var self = this;
      var activitys = void 0;
      var prevNodes = void 0;
      var nodes = void 0;

      var repairNodes = function repairNodes(parallax) {
        var rangePage = parallax.calculateRangePage();
        var lastProperty = parallax.lastProperty;

        if (targetIndex > currPageIndex) {
          //next
          if (targetIndex > rangePage['end']) {
            nodes = 1;
          }
        } else {
          //prev
          if (targetIndex < rangePage['start']) {
            nodes = 0;
          }
        }

        var property = getStepProperty({
          targetProperty: parallax.targetProperty,
          distance: -self.visualWidth,
          nodes: nodes
        });

        //直接操作元素
        setStyle({
          $contentNode: parallax.$contentNode,
          action: 'master',
          property: property,
          speed: 300,
          opacityStart: lastProperty.opacityStart
        });

        cacheProperty(property, lastProperty);
      };

      if (activitys = parallaxObj.baseGetActivity()) {
        //获取到页面nodes
        nodes = Xut.Presentation.GetPageNode(targetIndex - 1);
        activitys.forEach(function (contentObj) {
          contentObj.eachAssistContents(function (scope) {
            if (scope.parallax) {
              repairNodes(scope.parallax);
            }
          });
        });
      }
    }

    //检测是否需要清理
    // 1 普通翻页清理  【数组过滤条件】
    // 2 跳转页面清理  【对象过滤条件】

  }, {
    key: '_checkClear',
    value: function _checkClear(filter, toPage) {
      var key,
          indexOf,
          removeMasterId = _.keys(this._$$getBaseGroup());

      // 如果有2个以上的母板对象,就需要清理
      if (removeMasterId.length > 2 || toPage) {
        //或者是跳转页面
        //解析对象
        filter = toArray$2(filter);
        //过滤
        _.each(filter, function (masterId) {
          if (masterId !== undefined) {
            indexOf = removeMasterId.indexOf(masterId.toString());
            if (-1 !== indexOf) {
              //过滤需要删除的对象
              removeMasterId.splice(indexOf, 1);
            }
          }
        });
        this._clearMemory(removeMasterId);
      }
    }

    /**
     * 清理内存
     * 需要清理的key合集
     * @param  {[type]} removeMasterId [description]
     * @return {[type]}                [description]
     */

  }, {
    key: '_clearMemory',
    value: function _clearMemory(removeMasterId) {
      var pageObj,
          self = this;
      _.each(removeMasterId, function (removekey) {
        //销毁页面对象事件
        if (pageObj = self.$$getPageBase(removekey)) {
          //移除事件
          pageObj.baseDestroy();
          //移除列表
          self._$$removeBaseGroup(removekey);
          self._removeRecordMasterRange(removekey);
        }
        //清理作用域缓存
        delete self.recordMasterRange[removekey];
      });
    }

    /**
     * page转化成母版ID
     * @param  {[type]} pageIndex [description]
     * @return {[type]}           [description]
     */

  }, {
    key: 'converMasterId',
    value: function converMasterId(pageIndex) {
      return this.recordMasterId ? this.recordMasterId[pageIndex] : undefined;
    }
  }, {
    key: '_removeRecordMasterRange',
    value: function _removeRecordMasterRange(removekey) {
      var me = this;
      var recordMasterRange = me.recordMasterRange[removekey];
      //清理页码指示标记
      recordMasterRange.forEach(function (scope) {
        delete me.recordMasterId[scope];
      });
    }
  }]);
  return MasterMgr;
}(ManageSuper);

/**
 * 跳转之前提高层级问题
 * 提高当前页面的层级，方便别的页面切换不产生视觉影响
 */
function raiseHierarchy(complier, visualIndex) {
  complier.pageMgr.assistPocess(visualIndex, function (pageObj) {
    pageObj.setPageContainerHierarchy({ 'z-index': 9997 });
  });
  complier.getMasterContext(function () {
    complier.masterMgr.assistPocess(visualIndex, function (pageObj) {
      pageObj.setPageContainerHierarchy({ 'z-index': 1 });
    });
  });
}

/**
 * 创建新的页面
 */
function createNewPage(complier, data, createCallback) {

  //缓存当前页面索引用于销毁
  var pageIndex = void 0;
  var i = 0;
  var collectContainers = [];
  var create = data.create;
  var targetIndex = data.targetIndex;

  //需要创建的页面闭包器
  for (; i < create.length; i++) {
    pageIndex = create[i];
    collectContainers.push(function (targetIndex, pageIndex) {
      return function (callback) {
        //创建新结构
        this.createPageBase([pageIndex], targetIndex, 'toPage', callback, {
          'opacity': 0 //同页面切换,规定切换的样式
        });
      };
    }(targetIndex, pageIndex));
  }

  /**
   * 二维数组保存，创建返回的对象
   * 1 page对象
   * 2 母版对象
   * @type {Array}
   */
  data.pageBaseCollect = [];

  var count = void 0,
      collectLength = void 0;
  var j = 0;

  count = collectLength = collectContainers.length;

  if (collectContainers && collectLength) {
    for (; j < collectLength; j++) {
      //收集创建的根节点,异步等待容器的创建
      collectContainers[j].call(complier, function (callbackPageBase) {
        if (count === 1) {
          collectContainers = null;
          setTimeout(function () {
            createCallback(data);
          }, 100);
        }
        //接受创建后返回的页面对象
        data.pageBaseCollect.push(callbackPageBase);
        count--;
      });
    }
  }
}

/**
 * 节点创建完毕后，切换页面动，执行动作
 */
function creationLogic(complier, data) {

  var visualIndex = data.visualIndex;
  var pageMgr = complier.pageMgr;
  var targetIndex = data.targetIndex;

  //停止当前页面动作
  complier.suspendPageBases({ 'stopIndex': visualIndex, 'action': 'toPage' });

  //========处理跳转中逻辑=========

  /**
   * 清除掉不需要的页面
   * 排除掉当前提高层次页面
   */
  _.each(data.destroy, function (destroyIndex) {
    if (destroyIndex !== visualIndex) {
      pageMgr.clearPage(destroyIndex);
    }
  });

  /*修正翻页2页的页面坐标值*/
  _.each(data.ruleOut, function (pageIndex) {
    if (pageIndex > targetIndex) {
      pageMgr.assistAppoint(pageIndex, function (pageObj) {
        fix(pageObj.$pageNode, 'nextEffect');
      });
    }
    if (pageIndex < targetIndex) {
      pageMgr.assistAppoint(pageIndex, function (pageObj) {
        fix(pageObj.$pageNode, 'prevEffect');
      });
    }
  });

  var jumpPocesss = void 0;

  //母版
  complier.getMasterContext(function () {
    jumpPocesss = this.makeJumpPocesss(targetIndex);
    jumpPocesss.pre();
  });

  //===========跳槽后逻辑========================
  pageMgr.clearPage(visualIndex);

  jumpPocesss && jumpPocesss.clean(visualIndex, targetIndex);

  /**
   * 同页面切换,规定切换的样式复位
   */
  _.each(data.pageBaseCollect, function (pageBase) {
    _.each(pageBase, function (pageObj) {
      pageObj && pageObj.setPageContainerHierarchy({
        'opacity': 1
      });
    });
  });

  data.pageBaseCollect = null;
  jumpPocesss = null;
}

/**
 * 跳转页面逻辑处理
 * @param  {[type]} complier [description]
 * @param  {[type]} data     [description]
 * @param  {[type]} success  [description]
 * @return {[type]}          [description]
 */
function goToPage(complier, data, success) {
  //跳前逻辑
  raiseHierarchy(complier, data.visualIndex);
  /*创建新页面*/
  createNewPage(complier, data, function (data) {
    /*执行切换动作*/
    creationLogic(complier, data);
    success.call(complier, data);
  });
}

/**
 * 加入数组处理
 */
var Stack = function () {
  function Stack() {
    classCallCheck(this, Stack);

    this._cache = [];
  }

  /**
   * 加入首部
   * @return {[type]} [description]
   */


  createClass(Stack, [{
    key: "shift",
    value: function shift(fn) {
      this._cache.unshift(fn);
    }

    /**
     * 获取总数
     * @return {[type]} [description]
     */

  }, {
    key: "getTotal",
    value: function getTotal() {
      return this._cache.length;
    }

    /**
     * 加入尾部
     * @param  {Function} fn [description]
     * @return {[type]}      [description]
     */

  }, {
    key: "push",
    value: function push(fn) {
      this._cache.push(fn);
    }

    /**
     * 从头部取出全部执行
     * @return {[type]} [description]
     */

  }, {
    key: "shiftAll",
    value: function shiftAll() {
      if (this._cache.length) {
        var fn = void 0;
        while (fn = this._cache.shift()) {
          fn.apply(null, arguments);
        }
      }
      return this;
    }

    /**
     * 尾部取出执行
     * @return {[type]} [description]
     */

  }, {
    key: "popAll",
    value: function popAll() {
      if (this._cache.length) {
        var fn = void 0;
        while (fn = this._cache.pop()) {
          fn.apply(null, arguments);
        }
      }
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._cache = null;
    }
  }]);
  return Stack;
}();

/**
 * 创建li的translate起始坐标信息
 * flowType 如果是flow类型
 * @return {[type]}
 */
function getVisualSize$1(styleDataset) {
  var pageVisualMode = styleDataset.pageVisualMode,
      direction = styleDataset.direction,
      doubleMainIndex = styleDataset.doubleMainIndex,
      doublePosition = styleDataset.doublePosition,
      visualChapterIndex = styleDataset.visualChapterIndex;

  //默认的config.launch.visualMode

  var visualSize = config.visualSize;
  var hasRecalculate = false;

  /*
  如果页面模式不跟页面保持一致或者是模式3的情况的
  就需要重新计算
  */
  if (pageVisualMode && pageVisualMode !== config.launch.visualMode || pageVisualMode === 3) {
    visualSize = resetVisualLayout(pageVisualMode);
    hasRecalculate = true;
  }

  /*
  双页模式，重新定义页面尺寸与布局,从0页面开始叠加每个页面的距离
   */
  if (doublePosition && doubleMainIndex !== undefined) {
    var doubleIds = converDoublePage(doubleMainIndex);
    if (doublePosition === 'left') {
      visualSize.left = doubleIds[0] * visualSize.width;
    } else {
      visualSize.left = doubleIds[1] * visualSize.width;
    }
  }

  return {
    visualWidth: visualSize.width,
    visualHeight: visualSize.height,
    visualTop: visualSize.top,
    visualLeft: visualSize.left,
    visualLeftInteger: Math.abs(visualSize.left),
    hasRecalculate: hasRecalculate //标记需要重新计算
  };
}

/**
 * 修复动态的缩放比
 * 1 如果尺寸被重新计算过，那么需要重新获取缩放比
 * 2 否则用默认的
 * @return {[type]} [description]
 */
function getPageProportion(data) {
  if (data.hasRecalculate) {
    return resetVisualProportion({
      width: data.visualWidth,
      height: data.visualHeight,
      top: data.visualTop,
      left: data.visualLeft
    });
  } else {
    return config.proportion;
  }
}

/************************
 * 左边页面Translate钩子
 ************************/

function leftTranslate(styleDataset) {

  var middlePageStyle = styleDataset.getPageStyle('middle', 'left');
  var leftPageStyle = styleDataset.getPageStyle('left');

  //中间：溢出
  if (middlePageStyle && middlePageStyle.visualLeftInteger) {
    //左边：溢出
    if (leftPageStyle && leftPageStyle.visualLeftInteger) {
      return -middlePageStyle.visualWidth;
    }
    //左边：正常
    else {
        return -(middlePageStyle.visualWidth - middlePageStyle.visualLeftInteger);
      }
  }
  //中间：正常
  else {
      //左边：溢出
      if (leftPageStyle && leftPageStyle.visualLeftInteger) {
        return -(leftPageStyle.visualWidth - leftPageStyle.visualLeftInteger);
      }
      //左边：正常
      else {
          return -leftPageStyle.visualWidth;
        }
    }
}

/************************
 * 右边页面Translate钩子
 ************************/

function rightTranslate(styleDataset) {

  var middlePageStyle = styleDataset.getPageStyle('middle', 'right');
  var rightPageStyle = styleDataset.getPageStyle('right');

  if (rightPageStyle.pageVisualMode === 5) {
    return rightPageStyle.visualWidth / 2;
  }

  //中间：溢出
  if (middlePageStyle && middlePageStyle.visualLeftInteger) {
    //右边：溢出
    if (rightPageStyle && rightPageStyle.visualLeftInteger) {
      return rightPageStyle.visualWidth - rightPageStyle.visualLeftInteger;
    }
    //右边：正常
    else {
        return rightPageStyle.visualWidth + middlePageStyle.visualLeftInteger;
      }
  }
  //中间：正常
  else {
      //右边：溢出
      if (rightPageStyle && rightPageStyle.visualLeftInteger) {
        return rightPageStyle.visualWidth - rightPageStyle.visualLeftInteger;
      }
      //右边：正常
      else {
          return rightPageStyle.visualWidth + rightPageStyle.visualLeftInteger;
        }
    }
}

/************************
 * 上面页面Translate钩子
 ************************/
function topTranslate(styleDataset) {
  var bottomPageStyle = styleDataset.getPageStyle('top');
  return -bottomPageStyle.visualHeight;
}

/************************
 * 下面页面Translate钩子
 ************************/

function bottomTranslate(styleDataset) {
  var bottomPageStyle = styleDataset.getPageStyle('bottom');
  return bottomPageStyle.visualHeight;
}

var match = { left: leftTranslate, right: rightTranslate, top: topTranslate, bottom: bottomTranslate };

function getOffset$1(name, styleDataset) {
  return match[name](styleDataset);
}

/**
 * 创建translate初始值
 * @param  {[type]} offset [description]
 * @return {[type]}        [description]
 */
var setTranslate$1 = function setTranslate() {
  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  return Xut.style.setTranslateStyle(x, y);
};

/**
 * 默认样式
 */
function initTranslate(_ref) {
  var position = _ref.position,
      styleDataset = _ref.styleDataset;


  var translate = void 0;
  var offset = void 0;

  switch (position) {
    case 'left':
    case 'right':
      /*设置X轴*/
      offset = getOffset$1(position, styleDataset);
      translate = setTranslate$1(offset);
      break;
    case 'top':
    case 'bottom':
      /*设置Y轴*/
      offset = getOffset$1(position, styleDataset);
      translate = setTranslate$1(0, offset);
      break;
    case 'middle':
      translate = setTranslate$1();
      offset = 0;
      break;
  }

  return {
    //translate样式
    translate: translate,
    //偏移量
    offset: offset
  };
}

/**
 * 获取页面对象的样式配置对象
 * @param  {[type]} pageIndex [description]
 * @return {[type]}           [description]
 */
var getPageStyle = function getPageStyle(pageIndex) {
  var pageBase = Xut.Presentation.GetPageBase(pageIndex);
  return pageBase && pageBase.getStyle;
};

/**
 * 自定义样式页面容器的样式
 * 创建页面的样式，与布局
 * 1 创建页面的初始化的Transform值
 * 是否初始化创建
 * @return {[type]} [description]
 */
function setCustomStyle(styleDataset) {

  /*
  1.容器可视区尺寸
  2.容器内部元素的缩放比
  3.提供快速索引
   */
  _.each(styleDataset, function (data, index) {
    /*获取容器尺寸*/
    _.extend(data, getVisualSize$1(data));
    data.pageProportion = getPageProportion(data);
    /*数组形式，因为有双页面的情况*/
    if (!styleDataset['_' + data.position]) {
      styleDataset['_' + data.position] = [];
    }
    styleDataset['_' + data.position].push(data.chapterIndex);
  });

  if (!config.launch.doublePageMode) {

    /**
     * 获取指定页面样式
     * pageName
     * assistName 辅助页面名
     * 初始化的时候，可以正常创建多个页面的style，在不同页面可以获取不同的style
     * 但是在翻页的时候，由于只动态创建了一个页，所以在获取其他页面的时候，必须通过辅助参数
     * 跨页面对象获取数据
     */
    styleDataset.getPageStyle = function (pageName, assistName) {
      var pageStyle = this[this['_' + pageName]];
      //翻页动态创建的时候，只能索取到一页，因为只动态创建了一页
      //所以这里需要动态获取关联的中间页面对象
      if (!pageStyle && pageName === 'middle') {
        var standbyStyle = this.getPageStyle(assistName);
        if (assistName === 'left') {
          return getPageStyle(standbyStyle.chapterIndex + 1);
        }
        if (assistName === 'right') {
          return getPageStyle(standbyStyle.chapterIndex - 1);
        }
      }
      return this[this['_' + pageName]];
    };

    _.each(styleDataset, function (data, index) {
      //容器的初始translate值
      if (data.position) {
        _.extend(data, initTranslate({
          styleDataset: styleDataset,
          position: data.position
        }));
      }
    });
  }

  return styleDataset;
}

/**
 * 获取母版页面的visualMode设置
 * 覆盖全局的设置
 * 预先抽出母版上的页面模式定义
 * 定义visualMode：1/2/3/4 覆盖全局页面模式
 * 母版关联的页面必须跟这个参数统一
 * @return {[type]} [description]
 */
function getVisualMode(chapterData) {

  //反向模式设置
  //如果是全局模式1，并且是竖向横显示
  if (config.launch.visualMode === 1 && config.verticalToHorizontalVisual) {
    return 1;
  }

  //flow页面返回1
  if (chapterData.note === 'flow') {
    return 1;
  }

  //如果有独立的页面模式
  var parameter = chapterData.parameter;
  if (parameter) {
    var matchMode = parameter.match(/visualMode[":\s]*(\d)/);
    if (matchMode) {
      return Number(matchMode[1]);
    }
  }

  //返回全局页面模式
  return config.launch.visualMode || 1;
}

/*********************************************************************
 *            调度器 生成页面模块
 *            处理：事件动作分派
 *            调度：
 *                1. PageMgr     模块
 *                2. MasterMgr 模块                                                          *
 **********************************************************************/

/*
获取双页参数
1:从属的主索引
2:摆放位置
 */
function getDoubleOption(chapterIndex, doublePage) {
  if (doublePage.total) {
    for (var key in doublePage) {
      if (key !== 'total') {
        var doubleData = doublePage[key];
        var index = doubleData.indexOf(chapterIndex);
        if (~index) {
          return {
            doubleMainIndex: Number(key),
            doublePosition: index == 0 ? 'left' : 'right'
          };
        }
      }
    }
  }
  return {
    doubleMainIndex: undefined,
    doublePosition: undefined
  };
}

var Scheduler = function () {
  function Scheduler($$mediator) {
    classCallCheck(this, Scheduler);


    this.$$mediator = $$mediator;

    //创建前景页面管理模块
    this.pageMgr = new PageMgr($$mediator.options.scenePageNode);

    //检测是否需要创母版模块
    if (hasMaster()) {
      this.masterMgr = new MasterMgr($$mediator.options.sceneMasterNode);
    }
  }

  /**
   * 初始化页面创建
   * 因为多个页面的问题，所以不是创建调用
   * 提供外部接口启动创建
   */


  createClass(Scheduler, [{
    key: 'initCreate',
    value: function initCreate() {
      var options = this.$$mediator.options;
      var pointer = initPointer$1(options.initIndex, options.pageTotal, options.hasMultiPage);
      this.pagePointer = pointer.initPointer;
      this.createPageBase(pointer.createPointer, options.initIndex, 'init', '', '');
    }

    /**
     *  创建普通页面
     *  创建母版页面
     *  createSinglePage  需要创建的单页面索引
     *  visualPageIndex   当前可视区页面索引
     *  action            创建的动作：toPage/init/flipOver
     *  toPageCallback    跳转页面支持回调通知
     *  userStyle         规定创建的style属性
     *
     * 2017.3.27增加createDoublePage
     *   创建双页的页面记录
     *   createPageIndex中对应的createDoublePage如果有子索引值
     *
     * 流程：
     * 1：传递页面索引createSinglePage  [0]/[0,1]/[0,1,2]
     * 2: 转化索引为chpaterInder的排序，把索引提出当期显示页面最先解析， 如果是非线性，需要转化对应的chpaterIndex ,[1,0,2]
     * 3：通过编译chpaterInder的合集，获取到每一个chapter页面的数据
     * 4：由于非线性存在， 每一个新的场景，可包含有多个chpater，pageIndex都是从0开始的. chapterIndex，不一定是从0开始的
     * 5: 解析出pageIndex，visualChapterIndex的数值
     * 6：自定义每一个页面的样式styleDataset
     * 7：调用page/master管理器，创建pagebase
     **/

  }, {
    key: 'createPageBase',
    value: function createPageBase(createSinglePage, visualPageIndex, action, toPageCallback, userStyle) {

      var firstValue = createSinglePage[0];

      //2016.1.20
      //确保createPage不是undefined
      if (firstValue === undefined) {
        return;
      }

      var self = this;
      var options = this.$$mediator.options;
      var hasMultiPage = options.hasMultiPage; //是否线性
      var isToPageAction = action === 'toPage'; //如果是跳转
      var isFlipAction = action === 'flipOver'; //如果是翻页

      /*启动了双页模式，单页转化双页*/
      var createDoublePage = converDoublePage(createSinglePage, true);

      /* 需要创建的总页面，双页面或者单页面*/
      var createTotal = createDoublePage.total || createSinglePage.length;

      /*
      转化页面合集，自然索引index => chapter Index
      传递的页面的索引永远只是从0,1,2....这样的自然排序
      1.最后需要把最先展示的页面提取到第一位解析，加快页面展示
      2.如果是非线性的多场景应用，那么这样的自然排序，需要转化成对应的chapter的索引(为了直接获取chapter的数据)
      */
      var createChpaterIndexGroup = converChapterIndex(options, createSinglePage, createDoublePage, visualPageIndex);

      /*
       收集创建的页面对象
       1.用于处理2个页面在切换的时候闪屏问题
       2.主要是传递createStyle自定义样式的处理
        */
      var collectPageBase = [];

      /*
      是否触发母版的自动时间
      因为页面每次翻页都会驱动auto事件
      但是母版可能是共享的
       */
      var createMaster = false;

      //收集完成回调
      var collectCallback = function () {
        //收集创建页码的数量
        var createContent = 0;
        return function (callback) {
          ++createContent;
          if (createContent === createTotal) {
            callback();
          }
        };
      }();

      //构建执行代码
      var callbackAction = {
        /*初始化完毕*/
        init: function init() {
          collectCallback(function () {
            self.initPage('init');
          });
        },

        /*翻页完毕，运行自动*/
        flipOver: function flipOver() {
          collectCallback(function () {
            self._runPageBase({
              'createPointer': createChpaterIndexGroup,
              'createMaster': createMaster
            });
          });
        },

        /*跳转处理*/
        toPage: function toPage() {
          collectCallback(function () {
            toPageCallback(collectPageBase);
          });
        }
      };

      /**
       * 预编译
       * 因为要需要对多个页面进行预处理
       * 需要同步多个页面数据判断
       * 这样需要预编译出数据，做了中间处理后再执行后续动作
       * @type {Array}
       */
      var compile = new Stack();

      /*收集有用的数据*/
      var styleDataset = hash();

      /*双页，初始化页面的Translate容器坐标*/
      if (action === 'init') {
        this.pageMgr.setInitTranslate(visualPageIndex);
      }

      /*
        1.pageIndex：页面自然索引号
        2.visualPageIndex：页面自然索引号，可见编号
         3.chapterIndex： 页面chpater的索引号
        4.visualChapterIndex:  可见页面的的chpater索引号
       */
      _.each(createChpaterIndexGroup, function (chapterIndex) {

        compile.push(function () {

          /*
          双页模式
          1:子页面从属主页面，一左一右从属
            比如子页面   chapterIndex：  [2,3,0,1,4,5]
            从属的主页面 belongMainIndex:[1,1,0,0,2,2]
           2:计算页面是左右摆放位置
            position: left/right
           */
          var _getDoubleOption = getDoubleOption(chapterIndex, createDoublePage),
              doubleMainIndex = _getDoubleOption.doubleMainIndex,
              doublePosition = _getDoubleOption.doublePosition;

          var chapterData = converChapterData(chapterIndex);

          if (chapterData === undefined) {
            $warn({
              type: 'pagebase',
              content: '\u521B\u5EFA\u9875\u9762\u51FA\u9519,chapterIndex:' + chapterIndex
            });
            return;
          }

          /*
          1.转化可视区页码对应的chapter的索引号
          2.获取出实际的pageIndex自然索引号
          因为多场景的情况下
          chapterIndex != pageIndex
          每一个新的场景，可包含有多个chpater，pageIndex都是从0开始的
          chapterIndex，不一定是从0开始的
          */

          var _converVisualPid = converVisualPid(options, chapterIndex, visualPageIndex),
              visualChapterIndex = _converVisualPid.visualChapterIndex,
              pageIndex = _converVisualPid.pageIndex;

          if (createTotal === 1) {
            options.chapterId = chapterData._id;
          }

          /*
          跳转的时候，创建新页面可以自动样式信息
          优化设置，只是改变当前页面即可
          */
          if (isToPageAction && visualChapterIndex !== chapterIndex) {
            userStyle = undefined;
          }

          /*自定义页面的style属性*/
          styleDataset[chapterIndex] = {
            userStyle: userStyle,
            chapterIndex: chapterIndex,
            visualChapterIndex: visualChapterIndex,
            doublePosition: doublePosition, //双页面位置
            doubleMainIndex: doubleMainIndex, //从属主页面，双页模式
            /*页面的布局位置*/
            position: getPosition(doubleMainIndex !== undefined ? doubleMainIndex : chapterIndex, visualChapterIndex),
            pageVisualMode: getVisualMode(chapterData)

            ///////////////////////////
            /// 延迟创建,先处理style规则
            ///////////////////////////
          };return function (pageStyle) {

            /**
             * 创建新的页面管理，masterFilter 母板过滤器回调函数
             */
            function _createPB(masterFilter) {

              Xut.$warn({
                type: 'create',
                content: '-----\u5F00\u59CB\u521B\u5EFA\u9875\u9762,\u9875\u7801:' + pageIndex + '-----'
              });

              //初始化构建页面对象
              //1:page，2:master
              var currentStyle = pageStyle[chapterIndex];
              var pageBase = this.create({
                pageIndex: pageIndex,
                chapterData: chapterData,
                chapterIndex: chapterIndex,
                hasMultiPage: hasMultiPage,
                'getStyle': currentStyle
              }, pageIndex, masterFilter, function (shareMaster) {
                if (shareMaster.getStyle.pageVisualMode !== currentStyle.pageVisualMode) {
                  $warn({
                    type: 'pagebase',
                    content: '\u6BCD\u7248\u4E0E\u9875\u9762VisualMode\u4E0D\u4E00\u81F4,\n                            \u9519\u8BEF\u9875\u7801:' + (pageIndex + 1) + ',\n                            \u6BCD\u7248visualMode:' + shareMaster.getStyle.pageVisualMode + ',\n                            \u9875\u9762visualMode:' + currentStyle.pageVisualMode
                  });
                }
              });

              //判断pageBase是因为母版不需要重复创建
              //母版是共享多个paga
              if (pageBase) {
                //开始线程任务，如果是翻页模式,支持快速创建
                pageBase.startThreadTask(isFlipAction, function () {
                  $warn({
                    type: 'create',
                    content: '-----\u9875\u9762\u521B\u5EFA\u5B8C\u6BD5,\u9875\u7801:' + pageIndex + '-----'
                  });
                  callbackAction[action]();
                });

                //收集自定义样式的页面对象
                if (userStyle) {
                  collectPageBase.push(pageBase);
                }
              }
            }

            //创建母版层
            if (chapterData.pptMaster && self.masterMgr) {
              _createPB.call(self.masterMgr, function () {
                //母版是否创建等待通知
                //母版是共享的所以不一定每次翻页都会创建
                //如果需要创建,则叠加总数
                ++createTotal;
                createMaster = true;
                $warn({
                  type: 'create',
                  content: '\u68C0\u6D4B' + pageIndex + '\u9875\u6709\u6BCD\u7248\uFF0C\u521B\u5EFA\u603B\u6570\u88AB\u6539\u53D8' + createTotal
                });
              });
            }

            //创建页面层
            _createPB.call(self.pageMgr);
          };
        }());
      });

      $warn({
        type: 'create',
        content: '\u521B\u5EFA\u9875\u9762\u603B\u6570:' + createTotal
      });

      /**
       * 创建页面的样式与翻页的布局
       * 存在存在flows页面处理
       * 这里创建处理的Transfrom
       */
      compile.shiftAll(setCustomStyle(styleDataset)).destroy();
    }

    /**
     * 滑动处理
     *  1 滑动
     *  2 反弹
     *  3 翻页
     */

  }, {
    key: 'movePageBases',
    value: function movePageBases(options) {
      var action = options.action,
          speed = options.speed,
          outerCallFlip = options.outerCallFlip,
          distance = options.distance,
          frontIndex = options.frontIndex,
          middleIndex = options.middleIndex,
          backIndex = options.backIndex,
          direction = options.direction,
          orientation = options.orientation,
          isAppBoundary = options.isAppBoundary;

      //用户强制直接切换模式
      //禁止页面跟随滑动

      if (!config.launch.gestureSwipe && action == 'flipMove') {
        return;
      }

      var visualObj = this.pageMgr.$$getPageBase(middleIndex);

      //2016.11.8
      //mini杂志功能
      //一次是拦截
      //一次是触发动作
      if (config.launch.swipeDelegate && visualObj) {

        //如果是swipe就全局处理
        if (action === 'swipe') {
          //执行动画序列
          visualObj.callSwipeSequence(direction);
          return;
        }

        //2016.11.8
        //mini杂志功能
        //如果有动画序列
        //拦截翻页动作
        //执行序列动作
        //拦截
        if (visualObj.hasSwipeSequence(direction)) {
          //设置为无效翻页
          options.setSwipeInvalidCallback && options.setSwipeInvalidCallback();
          return;
        }
      }

      //视觉差页面滑动
      var nodes = void 0;
      if (visualObj) {
        var chapterData = visualObj.chapterData;
        nodes = chapterData && chapterData.nodes ? chapterData.nodes : undefined;
      }

      //移动的距离,合集
      var moveDistance = getVisualDistance({
        action: action,
        distance: distance,
        direction: direction,
        frontIndex: frontIndex,
        middleIndex: middleIndex,
        backIndex: backIndex,
        orientation: orientation
      });

      /**
       * 外部设置swiper内部的反弹
       * 主要是模式5的情况下处理
       * swiper延伸判断，通过这里获取到页面真是的坐标
       * 反馈给swiper,如果是反弹就不再处理了
       */
      if (options.setPageBanBounceCallback && options.setPageBanBounceCallback(moveDistance[1])) {
        return;
      }

      var data = {
        nodes: nodes,
        speed: speed,
        action: action,
        outerCallFlip: outerCallFlip,
        moveDistance: moveDistance,
        direction: direction,
        frontIndex: frontIndex,
        middleIndex: middleIndex,
        backIndex: backIndex

        /*移动页面*/
      };this.pageMgr.move(data);
      this.getMasterContext(function () {
        this.move(data, isAppBoundary);
      });

      //更新页码
      if (action === 'flipOver') {
        Xut.nextTick(function () {
          Xut.View.UpdatePage({
            action: action,
            parentIndex: direction === 'next' ? backIndex : frontIndex,
            direction: direction
          });
        });
      }
    }

    /**
     * 翻页松手后
     * 暂停页面的各种活动动作
     */

  }, {
    key: 'suspendPageBases',
    value: function suspendPageBases(options) {
      var _this = this;

      var frontIndex = options.frontIndex,
          middleIndex = options.middleIndex,
          backIndex = options.backIndex,
          stopIndex = options.stopIndex;

      //翻页停止录音

      Xut.Assist.RecordStop(function () {
        Xut.$warn('record', '\u7FFB\u9875\u6709\u5F55\u97F3\u52A8\u4F5C\uFF0C\u5F3A\u5236\u505C\u6B62');
      });
      //停止录音播放
      Xut.Assist.RecordPlayStop();

      $warn({
        type: 'logic',
        content: '----\u7FFB\u9875\u6682\u505C\u9875\u9762:' + stopIndex + '----'
      });

      /*暂停*/
      var suspendAction = function suspendAction(front, middle, back, stop) {

        //秒秒学的单独处理
        //在iframe外部加了自己的显示区域
        //翻页需要关闭
        Xut.Assist.GlobalForumClose();
        Xut.Assist.GlobalDirClose();

        _this.pageMgr.suspend(front, middle, back, stop);
        _this.getMasterContext(function () {
          this.suspend(options.action, stop);
        });
      };

      var stopPageIndexs = converDoublePage(stopIndex);

      /*多页面,停止每个页面的动作
      1.停止的可能是多页面
      2.转化对应的页面数据，用于停止页面任务创建*/
      if (stopPageIndexs && stopPageIndexs.length) {
        var leftIds = converDoublePage(frontIndex);
        var currIds = converDoublePage(middleIndex);
        var rightIds = converDoublePage(backIndex);
        /**
         * 因为stopPageIndexs是数组形式，
         * 所以会调用多次相同的任务关闭操作
         * 所以这里为了优化，强制只处理一次
         */
        var onlyonce = false;
        stopPageIndexs.forEach(function (index) {
          if (onlyonce) {
            /*只关闭，任务不需要重复再处理了*/
            suspendAction('', '', '', index);
          } else {
            suspendAction(leftIds, currIds, rightIds, index);
            onlyonce = true;
          }
        });
      } else {
        /*单页面*/
        suspendAction(frontIndex, middleIndex, backIndex, stopIndex);
      }

      //复位工具栏
      Xut.View.ResetToolbar();
    }

    /**
     * 翻页动画完毕后
     * 1.需要解锁页面滑动
     * 2.需要创建更新页面
     * 3.需要清理页面
     */

  }, {
    key: 'completePageBases',
    value: function completePageBases(options) {
      var direction = options.direction,
          pagePointer = options.pagePointer,
          unlock = options.unlock,
          isFastSlider = options.isFastSlider;
      /*方向*/

      this.direction = direction;
      /*是否快速翻页*/
      this.isFastSlider = isFastSlider || false;
      /*翻页解锁*/
      this.unlock = unlock;
      /*清理上一个页面*/
      this._clearPage(pagePointer.destroyIndex);
      /*更新索引*/
      this._updatePointer(pagePointer);
      //预创建下一页
      this._preforkPage(direction, pagePointer);
    }

    /**
     * 自动运行处理
     *  流程四:执行自动触发动作
     *   1.初始化创建页面完毕
     *   2.翻页完毕
     *   3.跳转后
     */

  }, {
    key: '_runPageBase',
    value: function _runPageBase(para) {

      var $$mediator = this.$$mediator;
      var options = this.$$mediator.options;
      var pagePointer = this.pagePointer;
      var frontIndex = pagePointer.frontIndex;
      var middleIndex = pagePointer.middleIndex;
      var backIndex = pagePointer.backIndex;
      var action = para ? para.action : '';
      var createPointer = para ? para.createPointer : '';
      var direction = this.direction;

      /*跳转与翻页的情况下，转化页码标记*/
      if (createPointer) {
        createPointer = converVisualPid(options, createPointer);
      }

      var data = {
        frontIndex: frontIndex,
        middleIndex: middleIndex,
        backIndex: backIndex,
        direction: direction,
        createPointer: createPointer,
        'isFastSlider': this.isFastSlider,

        /**
         * 暂停的页面索引autorun
         */
        'suspendIndex': action === 'init' ? '' : direction === 'next' ? frontIndex : backIndex,

        /**
         * 中断通知
         */
        'suspendCallback': options.suspendAutoCallback,

        /**
         * 构建完成通知,用于处理历史缓存记录
         * 如果是调试模式 && 不是收费提示页面 && 多场景应用
         */
        buildComplete: function buildComplete(seasonId) {

          if (config.launch.historyMode && !options.isInApp) {

            //如果是主页面，删除历史记录
            if (options.isMain) {
              $removeStorage('history');
            }

            //如果是副场景，添加历史记录
            if (options.hasMultiScene) {
              var history = sceneController.sequence(seasonId, middleIndex);
              if (history) {
                $setStorage("history", history);
              }
            }
          }
        },


        /**
         * 流程结束通知
         * 包括动画都已经结束了
         */
        processComplete: function processComplete() {
          Xut.Application.Notify('autoRunComplete');
        }
      };

      $warn({
        type: 'logic',
        content: '++++\u81EA\u52A8\u64AD\u653E\u9875\u9762:' + middleIndex + '++++'
      });

      //页面自动运行
      this.pageMgr.autoRun(data);

      //模板自动运行
      this.getMasterContext(function () {
        this.autoRun(action, data);
      });

      /*初始化与跳转针对翻页案例的设置逻辑*/
      var setToolbar = function setToolbar() {
        //不显示首尾对应的按钮
        if (middleIndex == 0) {
          Xut.View.HidePrevBar();
        } else if (middleIndex == options.pageTotal - 1) {
          Xut.View.HideNextBar();
          Xut.View.ShowNextBar();
        } else {
          Xut.View.ShowNextBar();
          Xut.View.ShowPrevBar();
        }
      };

      switch (action) {
        case 'init':
          //更新页码标示
          Xut.View.UpdatePage({
            action: action,
            parentIndex: middleIndex,
            direction: direction
          });
          setToolbar.call(this);
          break;
        case 'toPage':
          //更新页码标示
          Xut.View.UpdatePage({
            action: action,
            parentIndex: middleIndex,
            direction: direction
          });
          setToolbar.call(this);
          break;
      }

      /**
       * 线性结构
       * 保存目录索引
       */
      if (config.launch && config.launch.historyMode && !options.hasMultiScene) {
        $setStorage("pageIndex", middleIndex);
      }

      /**
       * 解锁翻页
       * 允许继续执行下一个翻页作用
       */
      if (this.unlock) {
        this.unlock();
        this.unlock = null;
      }

      //关闭快速翻页
      this.isFastSlider = false;
    }

    /**
     * 清理页面结构,双页与单页
     */

  }, {
    key: '_clearPage',
    value: function _clearPage(destroyIndex) {
      var _this2 = this;

      getRealPage(destroyIndex, 'clearPage').forEach(function (index) {
        _this2.pageMgr.clearPage(index);
      });
    }

    /**
     * 更新页码索引标示
     */

  }, {
    key: '_updatePointer',
    value: function _updatePointer(pointer) {
      this.pagePointer = pointer;
    }

    /**
     * 预创建新页面
     */

  }, {
    key: '_preforkPage',
    value: function _preforkPage(direction, pagePointer) {
      var _this3 = this;

      var pageTotal = this.$$mediator.options.pageTotal;
      var createIndex = pagePointer.createIndex;
      var middleIndex = pagePointer.middleIndex;

      /*清理页码*/
      var clearPointer = function clearPointer() {
        pagePointer.createIndex = null;
        pagePointer.destroyIndex = null;
      };

      /*创建新的页面对象*/
      var createNextPageBase = function createNextPageBase() {
        return _this3.createPageBase([createIndex], middleIndex, 'flipOver');
      };

      //如果是前翻页
      if (direction === 'prev') {
        //首尾无须创建页面
        if (middleIndex === 0) {
          this._runPageBase();
          if (pageTotal == 2) {
            //如果总数只有2页，那么首页的按钮是关闭的，需要显示
            Xut.View.ShowNextBar();
          }
          Xut.View.HidePrevBar();
          return;
        }
        if (middleIndex > -1) {
          //创建的页面
          createNextPageBase();
          clearPointer();
          Xut.View.ShowNextBar();
          return;
        }
      }

      //如果是后翻页
      if (direction === 'next') {
        //首尾无须创建页面
        if (middleIndex === pageTotal - 1) {
          this._runPageBase();
          if (pageTotal == 2) {
            //如果总数只有2页，那么首页的按钮是关闭的，需要显示
            Xut.View.ShowPrevBar();
          }
          //多页处理
          Xut.View.HideNextBar();
          return;
        }
        if (createIndex < pageTotal) {
          //创建的页面
          createNextPageBase();
          clearPointer();
          Xut.View.ShowPrevBar();
          return;
        }
      }

      clearPointer();

      return;
    }

    /**
     * 页面跳转
     */

  }, {
    key: 'gotoPageBases',
    value: function gotoPageBases(data) {

      Xut.View.ShowBusy();

      //如果是非线性,创建页面修改
      if (!this.$$mediator.options.hasMultiPage) {
        data.create = [data.targetIndex]; //创建
        data.destroy = [data.visualIndex]; //销毁
        data.ruleOut = [data.targetIndex]; //排除已存在
        /*更新索引值*/
        data.pagePointer = {
          middleIndex: data.targetIndex
        };
      }

      //执行页面切换
      goToPage(this, data, function (data) {
        this._updatePointer(data.pagePointer);
        this._runPageBase({
          'action': 'toPage',
          'createPointer': data.create
        });
        Xut.View.HideBusy();
        //执行切换完毕通知
        data.callback && data.callback();
      });
    }

    /**
     * 调用母版管理器
     */

  }, {
    key: 'getMasterContext',
    value: function getMasterContext(callback) {
      if (this.masterMgr) {
        callback.call(this.masterMgr);
      }
    }

    /**
     * 销毁接口
     * 销毁页面的所有的管理
     * 一般是退出处理
     */

  }, {
    key: 'destroyManage',
    value: function destroyManage() {
      this.pageMgr.destroyManage();
      this.getMasterContext(function () {
        this.destroyManage();
      });
    }

    /*
     *加载页面事件与动作
     *每次初始化一个新的场景都会触发
     */

  }, {
    key: 'initPage',
    value: function initPage(action) {
      var _this4 = this;

      var hasRun = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.$$mediator.$$emit('createPageComplete', function () {
        hasRun && _this4._runPageBase({ action: action });
      });
    }
  }]);
  return Scheduler;
}();

/********************************************
 * 场景API
 * 数据接口。和电子杂志的数据相关的接口，都在这里。
 ********************************************/

/**
 * 命名前缀
 * @type {String}
 */
var CONTENTPREFIX = 'Content_';

function extendPresentation(access, $$globalSwiper) {

  /**
   * 获取当前页码
   */
  Xut.Presentation.GetPageIndex = function () {
    return $$globalSwiper.getVisualIndex();
  };

  /**
   *  四大数据接口
   *  快速获取一个页面的nodes值
   *  获取当前页面的页码编号 - chapterId
   *  快速获取指定页面的chapter数据
   *  pagebase页面管理对象
   * @return {[type]}            [description]
   */
  _.each(["GetPageId", "GetPageNode", "GetPageData", "GetPageBase"], function (apiName) {
    Xut.Presentation[apiName] = function (pageType, pageIndex) {
      return access(function (manager, pageType, pageIndex) {
        if (pageIndex === undefined) {
          pageIndex = $$globalSwiper.getVisualIndex(); //当前页面
        }
        /*$$-manage-super接口*/
        return manager["$$" + apiName](pageIndex, pageType);
      }, pageType, pageIndex);
    };
  });

  /**
   * 获取页面的总数据
   * 1 chapter数据
   * 2 section数据
   * @return {[type]}
   */
  _.each(["Section", "Page"], function (apiName) {
    Xut.Presentation['GetApp' + apiName + 'Data'] = function (callback) {
      var i = 0,
          temp = [],
          cps = Xut.data.query('app' + apiName),
          cpsLength = cps.length;
      for (i; i < cpsLength; i++) {
        temp.push(cps.item(i));
      }
      return temp;
    };
  });

  /*
  获取浮动元素的根节点
  1 page
  2 master
   */
  Xut.Presentation.GetFloatContainer = function (pageType) {
    var pageObj = Xut.Presentation.GetPageBase(pageType);
    var containerName = pageType === 'page' ? 'pageContainer' : 'masterContainer';
    if (pageObj.floatGroup[containerName].length) {
      return pageObj.floatGroup[containerName];
    } else {
      Xut.$warn({
        type: 'api',
        content: "\u6D6E\u52A8\u6839\u8282\u70B9\u6CA1\u6709\u627E\u5230, pageType:" + pageType,
        color: 'red'
      });
    }
  };

  /**
   * 获取首页的pageId
   * @param {[type]} seasonId [description]
   */
  Xut.Presentation.GetFirstPageId = function (seasonId) {
    var sectionRang = Xut.data.query('sectionRelated', seasonId);
    var pageData = Xut.data.query('appPage');
    return pageData.item(sectionRang.start);
  };

  /**
   * 得到页面根节点
   * li节点
   */
  Xut.Presentation.GetPageRootNode = function (pageType) {
    var obj = Xut.Presentation.GetPageBase(pageType || 'page');
    return obj.$pageNode;
  };

  /**
   * 获取页面样式配置文件
   * @return {[type]} [description]
   */
  Xut.Presentation.GetPageStyle = function (pageIndex) {
    var pageBase = Xut.Presentation.GetPageBase(pageIndex);
    if (pageBase && pageBase.getStyle) {
      return pageBase.getStyle;
    } else {
      Xut.$warn({
        type: 'api',
        content: "\u9875\u9762Style\u914D\u7F6E\u6587\u4EF6\u83B7\u53D6\u5931\u8D25, pageIndex:" + pageIndex,
        color: 'red'
      });
    }
  };

  /**
   * 获取页码标记
   * 因为非线性的关系，页面都是按chpater组合的
   * page_0
   * page_10
   * 但是每一个章节页面的索引是从0开始的
   * 区分pageIndex
   */
  Xut.Presentation.GetPagePrefix = function (pageType, pageIndex) {
    var pageObj = Xut.Presentation.GetPageBase(pageType, pageIndex);
    return pageObj.chapterIndex;
  };

  /**
   * 得到content的命名规则
   */
  Xut.Presentation.GetContentPrefix = function (pageIndex) {
    return CONTENTPREFIX + Xut.Presentation.GetPagePrefix(pageIndex) + "_";
  };

  /**
   * 获取命名规则
   */
  Xut.Presentation.GetContentName = function (id) {
    if (id) {
      return CONTENTPREFIX + Xut.Presentation.GetPagePrefix() + "_" + id;
    } else {
      return CONTENTPREFIX + Xut.Presentation.GetPagePrefix();
    }
  };
}

/********************************************
 * 场景API
 * 视图接口。视图是窗口的展示方式，和页面相关的接口，都在这里。
 ********************************************/
function extendView($$mediator, access, $$globalSwiper) {

  var options = $$mediator.options;

  /**
   * 获取页面根节点的ID命名规则
   * chapterId是页面ID编号
   * base.pageType + "-" + (base.pageIndex + 1) + "-" + base.chapterId
   */
  Xut.View.GetPageNodeIdName = function (pageType, pageIndex, chapterId) {
    return pageType + '-' + (pageIndex + 1) + '-' + chapterId;
  };

  //========================
  //  页面工具栏按钮
  //========================

  /**
   * 更新页码
   * @param {[type]} point [description]
   *   parentIndex  父索引
   *   subIndex     子索引
   */
  Xut.View.UpdatePage = function () {
    for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
      arg[_key] = arguments[_key];
    }

    $$mediator.$$emit.apply($$mediator, ['updatePage'].concat(arg));
  };

  /**
   * 显示上一页按钮
   * @param {...[type]} arg [description]
   */
  Xut.View.ShowPrevBar = function () {
    for (var _len2 = arguments.length, arg = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      arg[_key2] = arguments[_key2];
    }

    $$mediator.$$emit.apply($$mediator, ['showPrev'].concat(arg));
  };

  /**
   * 隐藏上一页按钮
   * @param {...[type]} arg [description]
   */
  Xut.View.HidePrevBar = function () {
    for (var _len3 = arguments.length, arg = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      arg[_key3] = arguments[_key3];
    }

    $$mediator.$$emit.apply($$mediator, ['hidePrev'].concat(arg));
  };

  /**
   * 显示下一页按钮
   * @param {...[type]} arg [description]
   */
  Xut.View.ShowNextBar = function () {
    for (var _len4 = arguments.length, arg = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      arg[_key4] = arguments[_key4];
    }

    $$mediator.$$emit.apply($$mediator, ['showNext'].concat(arg));
  };

  /**
   * 隐藏下一页按钮
   * @param {...[type]} arg [description]
   */
  Xut.View.HideNextBar = function () {
    for (var _len5 = arguments.length, arg = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      arg[_key5] = arguments[_key5];
    }

    $$mediator.$$emit.apply($$mediator, ['hideNext'].concat(arg));
  };

  /**
   * state, pointer
   */
  Xut.View.ToggleToolbar = function () {
    for (var _len6 = arguments.length, arg = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      arg[_key6] = arguments[_key6];
    }

    $$mediator.$$emit.apply($$mediator, ['toggleToolbar'].concat(arg));
  };

  /**
   * 显示工具栏
   * 没有参数显示 工具栏与控制翻页按钮
   * 有参数单独显示指定的
   */
  Xut.View.ShowToolBar = function (point) {
    Xut.View.ToggleToolbar('show', point);
  };

  /**
   * 隐藏工具栏
   * 没有参数隐藏 工具栏与控制翻页按钮
   * 有参数单独隐藏指定
   */
  Xut.View.HideToolBar = function (point) {
    Xut.View.ToggleToolbar('hide', point);
  };

  /**
   * 复位工具栏
   */
  Xut.View.ResetToolbar = function () {
    $$mediator.$$emit('resetToolbar');
  };

  /**
   * 指定特定的显示与隐藏
   *  Xut.View.Toolbar({
   *       show :'bottom',
   *       hide :'controlBar'
   *   })
   *
   *  //工具栏与翻页按钮全部显示/隐藏
   *  Xut.View.Toolbar('show')
   *  Xut.View.Toolbar('hide')
   *
   */
  Xut.View.Toolbar = function (cfg) {
    Xut.View.ToggleToolbar(cfg);
  };

  /*
  跳转页面
   options
     obj / fn
   direction
     prev
     next
   */
  function gotoPage(data, direction) {
    var seasonId = void 0,
        chapterId = void 0,
        callback = void 0,
        speed = void 0;

    /**
     * data 可以传，可以不传递
     * 1 传递回调函数
     * 2 传递对象
     */
    if (data) {
      if (_.isFunction(data)) {
        //回调
        callback = data;
      } else {
        seasonId = data.seasonId;
        chapterId = data.chapterId;
        callback = data.callback;
        speed = data.speed;
      }
    }

    if (seasonId && chapterId) {
      Xut.View.LoadScenario({
        'seasonId': seasonId,
        'chapterId': chapterId
      }, callback);
      return;
    }

    //ibooks模式下的跳转
    //全部转化成超链接
    if (Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
      var pageIndex = direction === 'prev' ? Xut.IBooks.pageIndex - 1 : Xut.IBooks.pageIndex + 1;
      location.href = pageIndex + ".xhtml";
      callback && callback();
      return;
    }

    options.hasMultiPage && $$globalSwiper[direction]({ callback: callback, speed: speed });
  }

  /**
   * 跳转到上一个页面
   */
  Xut.View.GotoPrevSlide = function (data) {
    gotoPage(data, 'prev');
  };

  /**
   * 跳转到下一个页面
   */
  Xut.View.GotoNextSlide = function (data) {
    gotoPage(data, 'next');
  };

  /**
   * 是否启动
   * @return {[type]} [description]
   */
  Xut.View.HasEnabledSwiper = function () {
    return $$globalSwiper.hasEnabled();
  };

  /**
   * 禁止滑动
   */
  Xut.View.SetSwiperDisable = function () {
    $$globalSwiper.disable();
  };

  /**
   * 允许滑动
   */
  Xut.View.SetSwiperEnable = function () {
    $$globalSwiper.enable();
  };

  /**
   * 设置翻页完成
   */
  Xut.View.SetSwiperFilpComplete = function () {
    $$globalSwiper.setTransitionComplete.apply($$globalSwiper, arguments);
  };

  /**
   * 获取全局swiper的动作选择
   * 1.翻页
   * 2.反弹
   * distX, distY, duration
   */
  Xut.View.GetSwiperActionType = function () {
    return $$globalSwiper.getActionType.apply($$globalSwiper, arguments);
  };

  /**
   * 是否为翻页的边界
   * @return {Boolean} [description]
   */
  Xut.View.GetSwpierBorderBounce = function (distance) {
    return $$globalSwiper.isBorder(distance);
  };

  /**
   * 修正参数
   */
  function fixParameter(index) {
    index = Number(index) - 1;
    if (index < 0) {
      index = 0;
    }
    return index;
  }

  /**
   * 跳转页面
   * 场景内部切换
   * 跳转到指定编号的页面
   * Action 类型跳转
   * xxtlink 超连接跳转,svg内嵌跳转标记处理
   * 文本框跳转
   * ........
   */
  Xut.View.GotoSlide = function (seasonId, chapterId, pageIndex, callback) {

    //ibooks模式下的跳转
    //全部转化成超链接
    if (Xut.IBooks.Enabled && Xut.IBooks.runMode() && chapterId) {
      location.href = chapterId + ".xhtml";
      return;
    }

    //兼容数据错误
    if (!seasonId && !chapterId) return;

    ///////////////////////////////////////
    // 如果是一个参数是传递页码数,则为内部跳转
    ///////////////////////////////////////
    if (arguments.length === 1) {
      //复位翻页按钮
      Xut.View.ShowNextBar();
      //seasonId == pageIndex
      return $$globalSwiper.scrollToPage(fixParameter(seasonId), callback);
    }

    ////////////////////////////
    /// 场景模式内部跳转
    /// 1 保证同一个seasonId
    /// 2 如果传递了pageIndex
    /// 3 如果只传递了chpaterId
    ////////////////////////////
    if (options.seasonId == seasonId) {
      if (pageIndex && !chapterId) {
        //如果传递了页码数
        return $$globalSwiper.scrollToPage(fixParameter(pageIndex), callback);
      } else {
        //chpaterId 转化成实际页码
        var sectionRang = Xut.data.query('sectionRelated', seasonId);
        var pageIndex = chapterId - sectionRang.start;
        Xut.View.ShowNextBar();
        return $$globalSwiper.scrollToPage(fixParameter(pageIndex), callback);
      }
    }

    ////////////////////
    // 场景与场景的跳转
    ////////////////////
    return Xut.View.LoadScenario({
      'seasonId': seasonId,
      'chapterId': chapterId
    }, callback);
  };

  /**
   * 动态出入PPT页面
   * 数据中链接的对应映射处理
   * @type {[type]}
   */
  var linkMap = Xut.View.linkMap = {};

  /**
   * 将指定页面插入到目标的页面后面
   * originalChapterId 当前chapterId页面
   * targetChapterId   目标chapterId页面
   * 1.传递2个参数，将指定original页面，插入出入到目标target页面之后
   * 2.如果只有一个参数，只需要传递目标target页面, 默认original为当前页面
   * 3.如果不传递任何参数，讲当前页面插入到下一页
   */
  Xut.View.InsertAfter = function (originalChapterId, targetChapterId) {

    //这个模式必须是禁止手势滑动的
    if (config.launch.gestureSwipe) {
      Xut.$warn({
        type: 'api',
        content: 'gestureSwipe启动了，Xut.View.InsertAfter不生效',
        color: 'red'
      });
      return;
    }

    var pageObj = Xut.Presentation.GetPageBase('page');
    if (!pageObj) {
      return;
    }

    var chapterId = pageObj.chapterId;

    //是下一页
    var isNext = false;

    //一个参数情况，只传递目标
    if (originalChapterId && !targetChapterId) {
      //如果目标是当前页之后
      if (originalChapterId === chapterId) {
        isNext = true;
      }
    }

    //当前页面直接插入到下一页
    //做一个最简单的还原处理
    if (!originalChapterId && !targetChapterId) {
      isNext = true;
    }

    //下一页插入处理
    if (isNext) {
      if (chapterId && !linkMap[chapterId] && linkMap[chapterId] !== 0) {
        linkMap[chapterId] = function () {
          pageObj.hide();
          $$mediator.$reset();
          setTimeout(function () {
            pageObj.show();
            $autoRun();
            //只处理一次
            linkMap[chapterId] = 0;
          }, 0);
        };
      }
    }
  };

  /**
   * 页面滑动
   * action 动作
   * direction 方向
   * distance 移动距离
   * speed 速度
   *
      action: "flipRebound"
      backIndex : 4
      direction : "prev"
      distance : 0
      frontIndex : 2
      middleIndex: 3
      orientation : "h"
      speed : 300
   *
   */
  Xut.View.SetSwiperMove = function (_ref) {
    var action = _ref.action,
        direction = _ref.direction,
        distance = _ref.distance,
        speed = _ref.speed,
        orientation = _ref.orientation;


    //如果禁止翻页模式 || 如果是滑动,不是边界
    if (!options.hasMultiPage || $$globalSwiper.getMoved() || action === 'flipMove' && $$globalSwiper.isBorder(distance)) {
      return;
    }

    var pagePointer = $$globalSwiper.getPointer();

    /**
     * 在column中滑动的时候，会丢失Direction
     * 具体就是flow在首页，而且chpater只有一个flow的情况下
     */
    $$globalSwiper.setDirection(distance);

    /*如果没有传递布方向，就取页面，这个在全局接口中处理*/
    orientation = orientation || config.launch.scrollMode;

    $$mediator.$$scheduler.movePageBases({
      action: action,
      direction: direction,
      distance: distance,
      speed: speed,
      orientation: orientation,
      'frontIndex': pagePointer.frontIndex,
      'middleIndex': pagePointer.middleIndex,
      'backIndex': pagePointer.backIndex
    });
  };
}

//========================
// 录音接口相关
//========================
/**
 * 是否存在音频插件
 * @return {Boolean} [description]
 */
function hasRecordPlugin(callback, id) {
  //iframe模式下插件的查找
  if (GLOBALIFRAME) {
    if (GLOBALCONTEXT.Recorder) {
      callback(Xut.config.data.originalAppId + '-' + id);
    }
    return;
  }
  //单独apk情况下
  if (window.cordova && Xut.Plugin.Recorder) {
    callback(Xut.config.data.originalAppId + '-' + id);
  }
}

function extendRecord(access, $$globalSwiper) {

  //正在录音中
  var recording = false;
  //下一个动作的回调
  var currentNextCallback = null;
  //当前运行的重复执行方法
  var cuurentRepeatCallback = null;
  //播放的id合集
  var playIds = [];

  /**
   * 给录音的回调动作
   * 增加一个当前页面接管的全局接口
   * 意思就是用户再不录音的情况下，失败的动作中
   * 会弹出一个可以继续往下走的动作，而不会造成死循环
   * 跳到下一个默认录音动作
   * 这样代码默认会绑定最后一个录音的成功动作
   */
  Xut.Assist.RecordNextAction = function (callback) {
    //执行自己的隐藏
    callback && callback();
    if (currentNextCallback) {
      setTimeout(function () {
        //执行当前成功的回调
        currentNextCallback();
      }, 1000);
    } else {
      Xut.$warn('record', '\u6CA1\u6709currentSucceedCallback,\u65E0\u6CD5\u7EE7\u7EED\u4E0B\u4E2A\u52A8\u753B');
    }
  };

  /**
   * 重复录音
   * 自动定位到当前失败的录音上
   * callback 是成功回调的关闭
   */
  Xut.Assist.RecordRepeat = function (callback) {
    //执行自己的隐藏
    callback && callback();
    if (cuurentRepeatCallback) {
      setTimeout(function () {
        //执行当前成功的回调
        cuurentRepeatCallback();
      }, 500);
    } else {
      Xut.$warn('record', '\u6CA1\u6709cuurentRepeatCallback,\u65E0\u6CD5\u91CD\u590D\u5F53\u524D\u52A8\u753B');
    }
  };

  /**
   * 脚本函数
   * 1:id
   * 2:提供成功与失败回调
   * 3：injectFn可以注入处理函数
   * Xut.Assist.RecordStart(id, {
   *   succeed: function() {
   *     Xut.Assist.Run(1)
   *   },
   *   fail: function() {
   *     Xut.Assist.Run(2)
   *   }
   * })
   */
  Xut.Assist.RecordStart = function (injectFn, id) {
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


    if (!injectFn) {
      Xut.$warn('record', '\u6CA1\u6709\u4F20\u9012\u5F55\u97F3\u7684\u5FC5\u8981\u6570\u636E' + injectFn);
      return;
    }

    //如果不通过ppt处理，那么只会传递2个参数
    //如果只传递了2个参数id/callback
    if (typeof injectFn !== 'function') {
      var a = id;
      id = injectFn;
      callback = a;
    }

    hasRecordPlugin(function (newId) {
      Xut.Assist.RecordStop(function () {
        Xut.$warn('record', '\u5F53\u524D\u6709\u97F3\u9891\u5728\u5F55\u5236\uFF0C\u5148\u5F3A\u5236\u505C\u6B62');
      });
      Xut.$warn('record', '\u5F00\u59CB\u5F55\u97F3,id:' + newId);
      //如果有执行成功回调
      if (callback.succeed) {
        currentNextCallback = callback.succeed;
      }
      //如果有注入重新运行的回调
      if (injectFn) {
        cuurentRepeatCallback = injectFn;
      }
      recording = true;
      Xut.Plugin.Recorder.startRecord(newId,
      //成功
      function () {
        recording = false;
        Xut.$warn('record', '\u5F55\u97F3\u5B8C\u6210,id:' + newId);
        callback.succeed && callback.succeed();
      }, function () {
        //失败
        recording = false;
        Xut.$warn('record', '\u5F55\u97F3\u5931\u8D25,id:' + newId);
        callback.fail && callback.fail();
      });
    }, id);
  };

  /**
   * 停止录音
   * 每次翻页都会调用一次
   * 1 清空记录
   * 2 判断如果还有录音的，强制停止
   */
  Xut.Assist.RecordStop = function (callback) {
    //翻页清空
    currentNextCallback = null;
    cuurentRepeatCallback = null;
    if (recording) {
      hasRecordPlugin(function () {
        callback && callback;
        recording = false;
        Xut.Plugin.Recorder.stopRecord();
      });
    }
  };

  /**
   * 播放录音
   * failCallback 播放录音失败回调
   * 播放成功与播放失败
   */
  Xut.Assist.RecordPlay = function (id, failCallback) {
    if (!id) {
      Xut.$warn('record', '\u64AD\u653E\u5F55\u97F3\u5931\u8D25,\u7F3A\u5C11id:' + id);
      return;
    }
    hasRecordPlugin(function (newId) {
      //如果上一个还在播，先停止，保持只播一个
      Xut.Assist.RecordPlayStop();
      playIds.push(newId);
      Xut.$warn('record', '\u64AD\u653E\u5F55\u97F3,id:' + newId);
      Xut.Plugin.Recorder.startPlay(newId, function () {
        removeArray(playIds, newId);
        Xut.$warn('record', '\u64AD\u653E\u5F55\u97F3\u6210\u529F:' + newId + ',id\u5408\u96C6\u7F16\u53F7:' + playIds.toString() + ',\u6570\u91CF:' + playIds.length);
      }, function () {
        Xut.$warn('record', '\u64AD\u653E\u5F55\u97F3\u5931\u8D25,id\u5408\u96C6\u7F16\u53F7:' + playIds.toString());
        removeArray(playIds, newId);
        failCallback && failCallback();
      });
    }, id);
  };

  /**
   * 播放停止
   * ids  一个或者数组
   * 1 播放之前停止
   * 2 翻页停止
   * 3 强制停止
   */
  Xut.Assist.RecordPlayStop = function (id) {
    //强制停止,传递是外部接口的直接id
    if (id) {
      hasRecordPlugin(function (newId) {
        if (!newId) {
          Xut.$warn('record', '\u505C\u6B62\u5F55\u97F3\u5931\u8D25,\u7F3A\u5C11id:' + id);
          return;
        }
        removeArray(playIds, newId);
        Xut.$warn('record', '\u64AD\u653E\u5F55\u97F3\u505C\u6B62,id:' + newId);
        Xut.Plugin.Recorder.stopPlay(newId);
      }, id);
    } else if (playIds.length) {
      Xut.$warn('record', '\u505C\u6B62\u64AD\u653E\u97F3\u4E50,id\u5408\u96C6\u7F16\u53F7:' + playIds.toString() + ',\u6570\u91CF:' + playIds.length);
      //翻页停止，或者播放之前停止，传递是封装后的id
      hasRecordPlugin(function () {
        playIds.forEach(function (newId) {
          Xut.$warn('record', '\u64AD\u653E\u5F55\u97F3\u505C\u6B62,id:' + newId);
          Xut.Plugin.Recorder.stopPlay(newId);
          removeArray(playIds, newId);
        });
      });
    }
  };
}

/**
 * 读库服务器网址
 * 通过iframe加载本地localhost地址的时候
 * 会有通讯跨域的问题
 * 这里统一解决问题的接口
 */
/////////////////////////
///
/// 发送外部消息
///
////////////////////////


/**
 * 发送通讯接口
 * @param  {[type]} type [description]
 * @return {[type]}      [description]
 */
function sendPostMessage(type) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return type && window.parent && window.parent.postMessage({
    type: type,
    content: data
  }, '*');
}

/**
 * 获取iframe中的配置文件
 * @return {[type]} [description]
 */


/**
 * 制作PostMessage闭包
 * @return {[type]} [description]
 */
function getPostMessageFn(type) {
  if (window.parent && type) {
    return function (data) {
      return sendPostMessage(type, data);
    };
  }
}

/**
 * 监控内部的watch，转化成外部的PostMessage
 * @return {[type]} [description]
 */
function watchPostMessage() {
  //秒秒学，完成通知
  Xut.Application.Watch('complete', function () {
    sendPostMessage('complete');
  });

  //秒秒学收集用户信息通知
  Xut.Application.Watch('trackCode', function (type, options) {
    sendPostMessage(type, options);
  });
}

function unWatchPostMessage() {
  Xut.Application.unWatch('complete');
  Xut.Application.unWatch('trackCode');
}

/////////////////////////
///
/// 接收外部消息后处理
///
////////////////////////


/**
 * 监听跨域的外部事件
 * 秒秒学使用
 * 2017.11.28
 */
function bindMessage() {
  window.addEventListener('message', handleMessage, false);
}

function unBindMessage() {
  window.removeEventListener('message', handleMessage, false);
}

function parse(data) {
  if (typeof data === 'string') {
    return JSON.parse(data);
  }
  return data;
}

/**
 * 接收外部通讯，设置
 * @param {[type]} event [description]
 */
function handleMessage(event) {

  if (event.data) {
    var type = event.data.type;

    if (type) {

      //外部设置配置文件
      if (type === 'config') {
        try {
          Xut.mixin(config.postMessage, parse(event.data.content));
        } catch (err) {
          $warn({
            type: 'config',
            content: '\u8DE8\u57DFmessage\u63A5\u53D7config\u51FA\u9519 ' + event.data.content
          });
        }
      }

      //圆点状态
      if (type === 'forumDot') {
        Xut.Application.Notify('globalForumDot', parse(event.data.content));
      }
      if (type === 'commitWorkDot') {
        Xut.Application.Notify('globalCommitWorkDot', parse(event.data.content));
      }

      //外部调用内部API处理
      if (type === 'api' && event.data.content) {
        try {
          makeJsonPack(event.data.content)();
        } catch (err) {
          $warn({
            type: 'api',
            content: '\u8DE8\u57DFmessage\u63A5\u53D7API\u51FA\u9519 ' + event.data.content
          });
        }
      }
    }
  }
}

//========================
//  秒秒学嵌套Iframe 讨论区
//========================

function extendGlobal(access, $$globalSwiper) {

  /**
   * 标记讨论区状态
   * @type {Boolean}
   */
  var forumStatus = false;

  /**
   * 设置讨论区
   * @param {Function} fn    [description]
   * @param {[type]}   state [description]
   */
  function setForum(callback, fn, state) {
    //互斥可以相互关闭
    //并且排除重复调用
    if (fn && forumStatus !== state) {
      //从1开始算
      fn({ pageIndex: Xut.Presentation.GetPageIndex() + 1 });
      //标记状态，提供关闭
      forumStatus = state;
      callback && callback();
    }
  }

  /**
   * 针对秒秒学的api
   * 打开讨论区
   */
  Xut.Assist.GlobalForumOpen = function (callback) {
    return setForum(callback, getPostMessageFn('forumOpen'), true);
  };

  /**
   * 针对秒秒学的api
   * 关闭讨论区
   */
  Xut.Assist.GlobalForumClose = function (callback) {
    return setForum(callback, getPostMessageFn('forumClose'), false);
  };

  /**
   * 发送圆点状态请求
   * type
   *   forumDot
   *   commitWorkDot
   */
  Xut.Assist.RequestDot = function (type, pageIndex) {
    var fn = getPostMessageFn(type);
    if (fn) {
      fn({ pageIndex: pageIndex });
    }
  };

  /**
   * 讨论区切换
   * @param {[type]} options.open  [description]
   * @param {[type]} options.close [description]
   */
  Xut.Assist.GlobalForumToggle = function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        open = _ref.open,
        close = _ref.close;

    if (forumStatus) {
      Xut.Assist.GlobalForumClose(close);
    } else {
      Xut.Assist.GlobalForumOpen(open);
    }
  };

  //===============================
  //  秒秒学嵌套Iframe 全局工具栏目录
  //===============================

  var globalDirStatus = false;

  function setBarDir(callback, fn, state) {
    if (fn && globalDirStatus !== state) {
      //从1开始算
      fn();
      globalDirStatus = state;
      callback && callback();
    }
  }

  /**
   * 打开全局工具栏目录
   * @return {[type]} [description]
   */
  Xut.Assist.GlobalDirOpen = function (callback) {
    return setBarDir(callback, getPostMessageFn('dirOpen'), true);
  };

  /**
   * 关闭全局工具栏目录
   * @return {[type]} [description]
   */
  Xut.Assist.GlobalDirClose = function (callback) {
    return setBarDir(callback, getPostMessageFn('dirClose'), false);
  };

  /**
   * 自动切换
   */
  Xut.Assist.GlobalDirToggle = function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        open = _ref2.open,
        close = _ref2.close;

    if (globalDirStatus) {
      Xut.Assist.GlobalDirClose(close);
    } else {
      Xut.Assist.GlobalDirOpen(open);
    }
  };

  //==========================
  //  秒秒学嵌套Iframe 继续学习
  //==========================
  Xut.Assist.GlobalKeepLearn = function () {
    var fn = getPostMessageFn('keepLearn');
    if (fn) {
      fn();
    }
  };

  //==========================
  //  秒秒学嵌套Iframe 提交作业
  //==========================
  Xut.Assist.GlobalCommitWork = function () {
    var fn = getPostMessageFn('commitWork');
    if (fn) {
      fn();
    }
  };
}

//========================
// 秒秒学嵌套Iframe  答题卡
//========================

function extendAnswer(access, $$globalSwiper) {

  /**
   * 设置答题卡的正确错误率
   */
  function setAnswer(event) {
    console.log(event);
  }

  /**
   * 秒秒学答题卡
   * 正确性
   */
  Xut.Assist.AnswerRight = function () {
    return setAnswer('right');
  };

  /**
   * 秒秒学答题卡
   * 错误性
   */
  Xut.Assist.AnswerError = function () {
    return setAnswer('error');
  };
}

//========================
// 控制content接口
//========================

function extendContent(access, $$globalSwiper) {

  /**
   * 运行独立的content动画
   */
  Xut.Assist.RunContent = function (activityId, contentId) {
    if (!activityId && !contentId) {
      Xut.$Warn('content', '缺少运行RunContent接口的数据');
      return;
    }
    //执行运行页面母版上activityId中为activityId的动画
    Xut.Assist.Run('page', activityId, null, contentId);
  };

  /**
   * 辅助对象的控制接口
   * 运行辅助动画
   * 辅助对象的activityId,或者合集activityId
   * Run
   * stop
   * Hide隐藏动画元素
   * 1 零件
   * 2 音频动画
   */
  _.each(["Run", "Stop", "Hide"], function (apiName) {
    Xut.Assist[apiName] = function (pageType, activityId, outCallBack, contentId) {
      access(function (manager, pageType, activityId, outCallBack) {
        function assistAppoint(id, callback) {
          manager.assistAppoint(Number(id), $$globalSwiper.getVisualIndex(), callback, apiName, contentId);
        }

        //数组
        if (_.isArray(activityId)) {
          var markComplete = function () {
            var completeStatistics = activityId.length; //动画完成统计
            return function () {
              if (completeStatistics === 1) {
                outCallBack && outCallBack();
                markComplete = null;
              }
              completeStatistics--;
            };
          }();
          _.each(activityId, function (id) {
            assistAppoint(id, markComplete);
          });
        } else {
          assistAppoint(activityId, outCallBack);
        }
      }, pageType, activityId, outCallBack);
    };
  });
}

/********************************************
 * 场景API
 * 辅助对象
 ********************************************/
function extendAssist(access, $$globalSwiper) {

  //录音接口相关
  extendRecord(access, $$globalSwiper);
  //继承全局接口相关
  extendGlobal(access, $$globalSwiper);
  //继承答题接口
  extendAnswer(access, $$globalSwiper);
  //content
  extendContent(access, $$globalSwiper);

  //========================
  //  其他平台接口
  //========================

  /**
   * 允许翻页
   */
  //最大的翻页索引标记
  //这个是顺序
  var maxFlipIndex = 0;
  Xut.Assist.EnableFlip = function () {
    var pageIndex = Xut.Presentation.GetPageIndex();
    if (pageIndex > maxFlipIndex) {
      maxFlipIndex = pageIndex;
      Xut.Application.Notify('enableFlip', maxFlipIndex);
    }
  };

  /**
   * 滤镜渐变动画
   * content id
   * 滤镜样式名
   * 1  ".filter-blur-a2"
   * 优先查找page层，后查找master层
   */
  Xut.Assist.FilterGradient = function (contentId, filterClassName) {
    if (contentId && filterClassName) {
      var contentObj = Xut.Contents.Get('page', contentId);
      if (!contentObj) {
        contentObj = Xut.Contents.Get('master', contentId);
        if (contentObj) return;
      }
      if (filterClassName.length) {
        filterClassName = filterClassName.join(' ');
      }
      contentObj.$contentNode.addClass(filterClassName);
    }
  };

  /**
   * 针对HOT的显示与隐藏
   * @param {[type]} activityId    [activity中的Id]
   * @param {[type]} start         [显示与隐藏]
   *     Xut.Assist.TriggerPoint(activityId, 'show')
         Xut.Assist.TriggerPoint(activityId, 'hide')
   */
  Xut.Assist.TriggerPoint = function (activityId, state) {
    var data = Xut.data.query('Activity', activityId);
    if (data) {
      var $dom = $('#' + data.actType + '_' + data._id);
      if ($dom.length) {
        if (state === 'show') {
          Xut.nextTick(function () {
            $dom.css('visibility', 'visible');
          });
        }
        if (state === 'hide') {
          $dom.css('visibility', 'hidden');
        }
      }
    }
  };

  /**
   * 文字动画
   * @param {[type]} contentId [description]
   */
  Xut.Assist.TextFx = function (contentId) {
    var pageObj = Xut.Presentation.GetPageBase();
    var fxObj = pageObj.getLetterObjs(contentId);
    if (fxObj) {
      fxObj.play();
    }
  };
}

var typeFilter = ['page', 'master'];

/********************************************
 * 场景API
 * 针对page页面的content类型操作接口
 ********************************************/
function extendContent$1(access, $$globalSwiper) {

  /**
   * 获取指定的对象
   * 传递参数
   * 单一 id
   * 数据id合集 [1,2,4,5,6]
   * @param {[type]}   contentIds  [description]
   * @param {Function} eachContext 回调遍历每一个上下文
   */
  Xut.Contents.Get = function (pageType, contentIds, eachContext) {

    return access(function (manager, pageType, contentIds, eachContext) {

      var contentObj,
          contentObjs,
          pageIndex = Xut.Presentation.GetPageIndex();

      function findContent(currIndex, contentId) {
        var pageObj;
        if (pageObj = manager.$$getPageBase(currIndex)) {
          return pageObj.baseGetContentObject(contentId);
        }
      }

      //如果传递是数组合集
      if (_.isArray(contentIds)) {
        contentObjs = [];
        _.each(contentIds, function (id) {
          contentObj = findContent(pageIndex, id);
          if (eachContext) {
            //传递每一个处理的上下文
            eachContext(id, contentObj);
          } else {
            if (contentObj) {
              contentObjs.push(contentObj);
            } else {
              // console.log('error', '找不到对应的content数据' + id)
            }
          }
        });
        return contentObjs;
      }

      //如果传递的是Content_1_3组合情况
      if (/_/.test(contentIds)) {
        var expr = contentIds.split('_');
        if (expr.length > 1) {
          return findContent(expr[1], expr[2]);
        }
      }

      //单一content id
      contentObj = findContent(pageIndex, contentIds);

      if (eachContext) {
        eachContext(contentObj);
      } else {
        return contentObj;
      }
    }, pageType, contentIds, eachContext);
  };

  /**
   * 得到指定页面零件的数据
   * 获取指定的content数据
   * @param  {[type]} contentId [description]
   * @return {[type]}           [description]
   */
  Xut.Contents.GetPageWidgetData = function (pageType, contentId, pageProportion) {

    //如果没有传递pageType取默认
    if (-1 === typeFilter.indexOf(pageType)) {
      contentId = pageType;
      pageType = 'page';
    }

    //必须有数据
    if (!contentId || !contentId.length) {
      return;
    }

    //保证是数组格式
    if (_.isString(contentId)) {
      contentId = [contentId];
    }

    var contentData,
        contents = [];

    Xut.Contents.Get(pageType, contentId, function (cid, content) {
      //是内部对象
      if (content && (contentData = content.contentData)) {
        //通过内部管理获取对象
        contents.push({
          'id': content.id,
          'idName': content.actName,
          'element': content.$contentNode,
          'theTitle': contentData.theTitle,
          'scaleHeight': contentData.scaleHeight,
          'scaleLeft': contentData.scaleLeft,
          'scaleTop': contentData.scaleTop,
          'scaleWidth': contentData.scaleWidth,
          'contentData': contentData,
          'source': 'innerObjet' //获取方式内部对象
        });
      } else {
        //如果通过内部找不到对象的content数据,则直接查找数据库
        //可能是一个事件的钩子对象
        if (contentData = seekQuery(cid, pageProportion)) {
          var actName = Xut.Presentation.GetContentName(cid);
          var element;
          //如果对象是事件钩子或者是浮动对象
          //没有具体的数据
          if (content && content.$contentNode) {
            element = content.$contentNode;
          } else {
            element = $('#' + actName);
          }
          contents.push({
            'id': cid,
            'idName': actName,
            'element': element,
            'theTitle': contentData.theTitle,
            'scaleHeight': contentData.scaleHeight,
            'scaleLeft': contentData.scaleLeft,
            'scaleTop': contentData.scaleTop,
            'scaleWidth': contentData.scaleWidth,
            'contentData': contentData,
            'source': 'dataBase'
          });
        } else {
          // console.log('error', '找不到对应的GetPageWidgetData数据' + cid)
        }
      }
    });
    return contents;
  };

  //数据库查找
  function seekQuery(id, proportion) {
    var contentData = Xut.data.query('Content', id);
    if (contentData) {
      return reviseSize({
        results: _.extend({}, contentData),
        proportion: proportion
      });
    }
  }

  /**
   * 互斥接口
   * 直接显示\隐藏\停止动画
   */

  //检测类型为字符串
  function typeCheck(objNameList) {
    return !objNameList || typeof objNameList !== 'string' ? true : false;
  }

  /**
   * 针对文本对象的直接操作
   * 显示
   * 隐藏
   * 停止动画
   */
  _.each(["Show", "Hide", "StopAnim"], function (operate) {
    Xut.Contents[operate] = function (pageType, nameList) {
      access(function (manager, pageType, nameList) {
        if (typeCheck(nameList)) return;
        var pageBaseObj;
        if (!(pageBaseObj = manager.assistPocess($$globalSwiper.getVisualIndex()))) {
          console.log('注入互斥接口数据错误！');
          return;
        }
        _.each(nameList.split(','), function (contentId) {
          pageBaseObj.baseContentMutex(contentId, operate);
        });
      }, pageType, nameList);
    };
  });
}

/********************************************
 * 场景API
 * app应用接口
 ********************************************/

function extendApplication(access, $$mediator, $$globalSwiper) {
  /**
   * 获取一个存在的实例对象
   * 区分不同层级page/master
   * 不同类型    content/widget
   */
  Xut.Application.GetExistObject = function (pageType, data) {
    return access(function (manager, pageType) {
      var pageObj;
      if (pageObj = manager.$$getPageBase(data.pageIndex)) {
        if (data.type === 'Content') {
          return pageObj.baseSpecifiedContent(data);
        } else {
          return pageObj.baseSpecifiedComponent(data);
        }
      }
    }, pageType);
  };

  /**
   * 获取全局滚动条对象
   */
  Xut.Application.GetScrollBarObject = function () {
    if ($$mediator.miniBar) {
      if ($$mediator.miniBar.length) {
        for (var i = 0; i < $$mediator.miniBar.length; i++) {
          if ($$mediator.miniBar[i].type === 'Scrollbar') {
            return $$mediator.miniBar[i];
          }
        }
      } else {
        if ($$mediator.miniBar.type === 'Scrollbar') {
          return $$mediator.miniBar;
        }
      }
    }
  };

  /**
   * 获取迷你滚动条对象数量
   */
  Xut.Application.GetMiniBars = function () {
    if ($$mediator.miniBar) {
      return $$mediator.miniBar.length;
    }
    return 0;
  };
}

/********************************************
 * 虚拟摄像机运行的接口
 ********************************************/
function extendCamera(access, $$globalSwiper) {

  /**
   * 移动页面
   * 针对当期那页面操作
     λ  position=0，代表DOM页面的最左边，
     λ  position=50，代表DOM页面的中间，
     λ  position=100，代表DOM页面的最右边
     delay 延时执行时间
   */
  Xut.Camera.MoveX = function (position, speed, delay) {
    if (config.launch.visualMode === 5) {
      $$globalSwiper.scrollToPosition(position, speed, delay);
    }
  };
}

/**
 * 合并参数设置
 * 1 pageMgr
 * 2 masterMgr
 * 3 修正pageType
 * 4 args参数
 * 5 回调每一个上下文
 */
function createaAccess(mgr) {
  return function (callback, pageType, args, eachContext) {
    //如果第一个参数不是pageType模式
    //参数移位
    if (pageType !== undefined && -1 === typeFilter.indexOf(pageType)) {
      var temp = args;
      args = pageType;
      eachContext = temp;
      pageType = 'page';
    }
    //pageIndex为pageType参数
    if (-1 !== typeFilter.indexOf(args)) {
      pageType = args;
      args = null;
    }
    pageType = pageType || 'page';
    if (mgr[pageType]) {
      return callback(mgr[pageType], pageType, args, eachContext);
    } else {
      Xut.$warn({
        type: 'api',
        content: '\u4F20\u9012\u5230access\u7684pageType\u9519\u8BEF\uFF0CpageType=' + pageType,
        color: 'red'
      });
    }
  };
}

/********************************************
 * 场景API
 * 此模块的所有方法都是动态修正上下文，自动切换场景
 * @return {[type]} [description]
 ********************************************/

function initSceneApi($$mediator) {
  var $$globalSwiper = $$mediator.$$globalSwiper;

  //页面与母版的管理器
  var access = createaAccess({
    page: $$mediator.$$scheduler.pageMgr,
    master: $$mediator.$$scheduler.masterMgr
  });

  extendCamera(access, $$globalSwiper);
  extendPresentation(access, $$globalSwiper); //数据接口
  extendView($$mediator, access, $$globalSwiper); //视图接口
  extendAssist(access, $$globalSwiper); // 辅助对象
  extendContent$1(access, $$globalSwiper); //content对象
  extendApplication(access, $$mediator, $$globalSwiper); //app应用接口

  return function () {
    $$globalSwiper = null;
    access = null;
    $$mediator = null;
  };
}

/*********************************************************************
 *              场景容器构造器
 *          1 构件页面级容器
 *          2 翻页全局事件
 *
 **********************************************************************/
/**
 * 配置多页面参数
 */
function configMultiple(options) {
  //如果是epub,强制转换为单页面
  if (Xut.IBooks.Enabled) {
    options.hasMultiPage = false;
  } else {

    ////////////////////////////////
    /// scrollMode全局定义翻页模式  ////
    /// pageMode当前页面定义模式  ////
    ////////////////////////////////
    var pageMode = Number(options.pageMode);

    //如果是禁止翻页，然后还要看是不是有pageMode的设置
    if (!config.launch.gestureSwipe) {

      //喵喵学模式比较特别
      //在数据里中设定了filpMode为1
      //那么就是锁定了不允许翻页，但是还要能支持左右跳页面
      //这里就需要按照多页面的模式处理
      //强制是多页面的方式创建，但是锁住翻页而已
      if (config.launch.pageFlip) {
        options.hasMultiPage = true;
        return;
      }

      options.hasMultiPage = false;
      //如果工具栏单独设置了页面模式，那么多页面强制改成true
      if (pageMode > 0) {
        options.hasMultiPage = true;
      }
    } else {
      if (pageMode === 0) {
        //如果工具栏强制禁止滑动
        options.hasMultiPage = false;
      } else {
        /*判断多页面情况*/
        options.hasMultiPage = true;
      }
    }
  }
}

/**
 * 判断处理那个页面层次
 * 找到pageType类型
 * 项目分4个层
 * page mater page浮动 mater浮动
 * 通过
 * 因为冒泡的元素，可能是页面层，也可能是母板上的
 * @return {Boolean} [description]
 */
function isBelong(node) {
  var pageType = 'page';
  if (node.dataset && node.dataset.belong) {
    pageType = node.dataset.belong;
  }
  return pageType;
}

////////////////////////////////////////////
///
/// 中介类
/// 全局事件Swiper与全局调度器Scheduler通讯
///
////////////////////////////////////////////

var Mediator = function (_Observer) {
  inherits(Mediator, _Observer);

  function Mediator(parameter) {
    classCallCheck(this, Mediator);

    var _this = possibleConstructorReturn(this, (Mediator.__proto__ || Object.getPrototypeOf(Mediator)).call(this));

    var $$mediator = _this;

    //配置文件
    var options = $$mediator.options = _.extend({
      //是否多场景加载
      //单页场景 false
      //多场景   true
      'hasMultiScene': false,
      //是否为连续页面
      //通过pageMode的参数定义
      'hasMultiPage': false
    }, parameter);

    //配置多页面参数
    configMultiple(options);

    //启用内部滚动模式
    var insideScroll = false;
    if (config.launch.visualMode === 5) {
      insideScroll = true;
    }

    var setOptions = {
      insideScroll: insideScroll, //内部滚动
      scope: 'child', //translate
      snap: true, //分段
      hasHook: true,
      container: options.sceneNode,
      visualIndex: options.initIndex,
      totalIndex: options.pageTotal,
      actualWidth: config.visualSize.width,
      actualHeight: config.visualSize.height,
      visualWidth: config.screenSize.width, //可视区的宽度
      hasMultiPage: options.hasMultiPage, //多页面
      sectionRang: options.sectionRang //分段值


      /*如果没有强制关闭，并且是竖版的情况下，会启动鼠标滚动模式*/
    };if (config.launch.mouseWheel !== false && config.launch.scrollMode === 'v') {
      setOptions.mouseWheel = true;
    }

    /*虚拟摄像头模式，关闭边界反弹*/
    if (config.launch.visualMode === 5) {
      setOptions.borderBounce = false;
    }

    /*快速配置了*/
    _.extend(setOptions, Swiper.getConfig());

    var $$globalSwiper = $$mediator.$$globalSwiper = new Swiper(setOptions);
    var $$scheduler = $$mediator.$$scheduler = new Scheduler($$mediator);

    //如果是主场景,才能切换系统工具栏
    if (options.hasMultiPage) {
      _this._mixTool($$mediator);
    }

    //事件句柄对象
    var handlerObj = null;

    /**
     * 过滤器.全局控制函数
     * return true 阻止页面滑动
     */
    $$globalSwiper.$$watch('onFilter', function (hookCallback, point, evtObj) {
      var node = point.target;
      swiperHook(evtObj, node);
      //页面类型
      var pageType = isBelong(node);
      //冒泡的ul根节点
      var parentNode = $$globalSwiper.findBubbleRootNode(point, pageType);
      //执行过滤处理
      handlerObj = closestProcessor.call(parentNode, point, pageType);

      //如果找到是空节点
      //并且是虚拟模式2的话
      //默认允许滑动
      if (!handlerObj) {
        if (config.launch.visualMode === 2) {
          return;
        } else if (config.launch.visualMode === 5) {
          return;
        }
      }

      //停止翻页,针对content对象可以拖动,滑动的情况处理
      if (!handlerObj || handlerObj.attribute === 'disable') {
        hookCallback();
      }
    });

    /**
     * 触屏松手点击，无滑动，判断为点击
     */
    $$globalSwiper.$$watch('onTap', function (pageIndex, hookCallback) {
      if (handlerObj) {
        if (handlerObj.handlers) {
          handlerObj.handlers(handlerObj.elem, handlerObj.attribute, handlerObj.rootNode, pageIndex);
        } else {
          if (!Xut.Contents.Canvas.getIsTap()) {
            Xut.View.ToggleToolbar();
          }
        }
        handlerObj = null;
        hookCallback();
      }
    });

    /**
     * 触屏滑动,通知pageMgr处理页面移动
     */
    $$globalSwiper.$$watch('onMove', function (data) {
      $$scheduler.movePageBases(data);
    });

    /**
     * 触屏滑动,通知ProcessMgr关闭所有激活的热点
     */
    $$globalSwiper.$$watch('onEnd', function (pointers) {
      $$scheduler.suspendPageBases(pointers);
    });

    /**
     * 翻页动画完成回调
     */
    $$globalSwiper.$$watch('onComplete', function () {
      $$scheduler.completePageBases.apply($$scheduler, arguments);
    });

    /**
     * 鼠标滚轮
     */
    var wheellook = false; //如果首页向上滑动，那么锁定马上可以向下滑动
    $$globalSwiper.$$watch('onWheel', function (e, wheelDeltaY) {

      var currPageBase = Xut.Presentation.GetPageBase($$globalSwiper.visualIndex);

      /*如果当前是流式页面*/
      if (currPageBase && currPageBase.hasColumnData) {
        var columnObj = currPageBase.columnGroup.get()[0];
        if (columnObj) {
          /*如果flow的进去是touch的方式，那么这里不需要控制了*/
          if (columnObj.getEntry() === 'touch') {
            wheellook = false;
          }
          /*等待翻页结束后才可以委托到columnObj内部的onWheel滚动
          避免在翻页的时候重复触发*/
          if (!wheellook) {
            var direction = wheelDeltaY > 0 ? 'up' : 'down';
            columnObj && columnObj.onWheel(e, wheelDeltaY, direction);
          }
        }
      } else {

        ///////////////////
        /// PPT页面滚动
        /// 1 mac上鼠标有惯性
        /// 2 win上鼠标每次滑动一点，就是100的值
        ///////////////////

        wheellook = true;

        /*向上滚动*/
        if (wheelDeltaY > 0) {
          $$globalSwiper.prev({
            speed: Xut.plat.isMacOS ? 600 : 300,
            callback: function callback() {
              wheellook = false;
            }
          });
        } else {
          $$globalSwiper.next({
            speed: Xut.plat.isMacOS ? 600 : 300,
            callback: function callback() {
              wheellook = false;
            }
          });
        }
      }
    });

    /**
     * 切换页面
     * @return {[type]}      [description]
     */
    $$globalSwiper.$$watch('onJumpPage', function (data) {
      $$scheduler.gotoPageBases(data);
    });

    /**
     * 退出应用
     * @return {[type]}      [description]
     */
    $$globalSwiper.$$watch('onDropApp', function (data) {
      window.GLOBALIFRAME && Xut.publish('magazine:dropApp');
    });

    /**
     * 母板移动反馈
     * 只有存在data-parallaxProcessed
     * 才需要重新激活对象
     * 删除parallaxProcessed
     */
    $$globalSwiper.$$watch('onMasterMove', function (hindex, target) {
      if (/Content/i.test(target.id) && target.getAttribute('data-parallaxProcessed')) {
        $$scheduler.masterMgr && $$scheduler.masterMgr.reactivation(target);
      }
    });

    /**
     * 销毁接口api
     * @type {[type]}
     */
    _this.destorySceneApi = initSceneApi(_this);
    return _this;
  }

  /**
   * 系统工具栏
   */


  createClass(Mediator, [{
    key: '_mixTool',
    value: function _mixTool($$mediator) {

      _.extend(delegateHooks, {

        /**
         * li节点,多线程创建的时候处理滑动
         */
        'data-container': function dataContainer() {
          Xut.View.ToggleToolbar();
        },


        /**
         * 是背景层
         */
        'data-multilayer': function dataMultilayer() {
          //改变工具条状态
          Xut.View.ToggleToolbar();
        },


        /**
         * 默认content元素可以翻页
         */
        'data-behavior': function dataBehavior(target, attribute, rootNode, pageIndex) {
          //没有事件的元素,即可翻页又可点击切换工具栏
          if (attribute == 'click-swipe') {
            Xut.View.ToggleToolbar();
          }
        }
      });
    }
  }]);
  return Mediator;
}(Observer);

defAccess(Mediator.prototype, '$hasMultiScene', {
  get: function get$$1() {
    return this.options.hasMultiScene;
  }
});

/**
 * 动态注入对象接口
 * 注入对象管理,注册所有widget组件对象
 *  content类型  创建时注册
 *  widget类型   执行时注册
 *  widget 包括 视频 音频 Action 子文档 弹出口 类型
 *  这种类型是冒泡处理，无法传递钩子，直接用这个接口与场景对接
 */
defAccess(Mediator.prototype, '$injectionComponent', {
  set: function set$$1(regData) {
    var injection;
    if (injection = this.$$scheduler[regData.pageType + 'Mgr']) {
      injection.assistPocess(regData.pageIndex, function (pageObj) {
        pageObj.baseAddComponent.call(pageObj, regData.widget);
      });
    } else {
      console.log('注册injection失败,regData=' + regData);
    }
  }
});

/**
 * 得到当前的视图页面
 * @return {[type]}   [description]
 */
defAccess(Mediator.prototype, '$visualPageBase', {
  get: function get$$1() {
    return this.$$scheduler.pageMgr.$$getPageBase(this.$$globalSwiper.getVisualIndex());
  }
});

/**
 *  监听viewmodel内部的状态的改变,触发后传入值
 *
 *  与状态有关的change:
 *      翻页
 *          'flipOver' : function(pageIndex) {},
 *
 *      切换工具栏
 *          'toggleToolbar' : function(state, pointer) {},
 *
 *      复位工具栏
 *          'resetToolbar'  : function() {},
 *
 *      隐藏下一页按钮
 *          'hideNext'   : function(state) {},
 *
 *      显示下一页按钮
 *          'showNext'   : function() {}
 *
 *  与创建相关
 *      创建完毕回调
 *          'createPageComplete': null,
 *      创建后中断自动运行回调
 *          'suspendAutoCallback': null
 *
 */
defProtected(Mediator.prototype, '$bind', function (key, callback) {
  var $$mediator = this;
  $$mediator.$$watch(key, function () {
    callback.apply($$mediator, arguments);
  });
});

/**
 * 创建页面
 * @return {[type]} [description]
 */
defProtected(Mediator.prototype, '$init', function () {
  //如果是主场景，并且有历史记录
  //那么就不需要创建当前页面了
  if (this.options.isMain && this.options.hasHistory) {
    this.$$scheduler.initPage('init', false);
  } else {
    this.$$scheduler.initCreate();
  }
});

/**
 * 复位对象
 * @return {[type]} [description]
 */
defProtected(Mediator.prototype, '$reset', function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      pageType = _ref.pageType,
      pageIndex = _ref.pageIndex;

  pageType = pageType || 'page';
  var mgr = pageType === 'page' ? 'pageMgr' : 'masterMgr';
  this.$$scheduler[mgr].resetOriginal(pageIndex || this.$$globalSwiper.getVisualIndex());
});

/**
 * 停止所有任务
 * @return {[type]} [description]
 */
defProtected(Mediator.prototype, '$suspend', function (pageIndex) {
  if (pageIndex) {} else {
    Xut.Application.Suspend({
      skipAudio: true //跨页面不处理
    });
  }
});

/**
 * 销毁场景内部对象
 * @return {[type]} [description]
 */
defProtected(Mediator.prototype, '$destroy', function () {
  this.$$unWatch(); //观察事件
  this.$$globalSwiper.destroy(); //全局事件
  this.$$scheduler.destroyManage(); //派发器
  this.$$scheduler = null;
  this.$$globalSwiper = null;
  this.destorySceneApi(); //动态api
});

var isIOS$2 = Xut.plat.isIOS;
var isBrowser$1 = Xut.plat.isBrowser;

/**
 * 获取翻页按钮位置
 * @return {[type]} [description]
 */
var getArrowStyle = function getArrowStyle() {
  var height = config.data.iconHeight;
  var styleText = 'height:' + height + 'px;width:' + height + 'px';
  var setTable = config.data.settings;
  if (setTable) {
    switch (setTable.NavbarPos) {
      case 0:
        styleText += ';top:0';
        break; //顶部
      case 1:
        styleText += ';margin-top:' + -height / 2 + 'px';
        break; //中间
      case 2:
        styleText += ';top:auto;bottom:0';
        break; //底部
      default:
        break;
    }
  }
  return styleText;
};

/**
 * 工具栏超类
 */

var BarSuper = function () {
  function BarSuper(options) {
    classCallCheck(this, BarSuper);


    if (options) {
      _.extend(this, options);
    }

    /**
     * 系统状态栏高度
     * 在ios浏览器中状态栏高度为0
     * @type {[type]}
     */
    this.$$barHeight = isIOS$2 && !isBrowser$1 ? 20 : 0;

    //获取高度缩放比
    //自动选择缩放比例
    var prop = config.proportion;
    this.$$propHeight = config.layoutMode == "horizontal" ? prop.width : prop.height;

    //获取图标高度
    //工具栏图标高度
    var iconHeight = config.data.iconHeight;
    this.$$iconHeight = isIOS$2 ? iconHeight : Math.round(this.$$propHeight * iconHeight);

    //应用标题
    this.$$appName = config.data.shortName;

    //应用默认配置
    this.$$setTable = config.data.settings;

    /*模板*/
    this._initState();
    this._initToolbar();
  }

  /////////////////////////////////////
  ///        超类私有方法
  /////////////////////////////////////

  createClass(BarSuper, [{
    key: '_$$getArrowOption',
    value: function _$$getArrowOption() {
      var style = getArrowStyle();
      var state = this.barStatus ? '' : 'hide';
      var height = config.data.iconHeight;
      return {
        style: style,
        state: state,
        height: height
      };
    }

    /**
     * 客户端指定：自定义翻页按钮
     * @return {[type]} [description]
     */

  }, {
    key: '_$$createIcon',
    value: function _$$createIcon() {
      var style = getArrowStyle();
      var state = this.toolBarStatus ? '' : 'hide';

      //默认图标路径
      var leftStyle = style + ';background-image:url(images/icons/pageforward_' + config.data.appId + '.svg);background-size:cover';
      var rightStyle = style + ';background-image:url(images/icons/pageback_' + config.data.appId + '.svg);background-size:cover';

      return '<div name="prevArrow"\n                 class="xut-flip-control xut-flip-control-left ' + state + '"\n                 style="' + leftStyle + '">\n           </div>\n           <div name="nextArrow"\n                class="xut-flip-control xut-flip-control-right ' + state + '"\n                style="' + rightStyle + '">\n           </div>';
    }

    /**
     * font字体版本：箭头翻页按钮
     */

  }, {
    key: '_$$createArrow',
    value: function _$$createArrow() {
      var option = this._$$getArrowOption();
      return '<div class="si-icon xut-flip-control xut-flip-control-left xut-icon-angle-left ' + option.state + '"\n                 style="' + option.style + ';text-align:center;line-height:' + option.height + 'px;font-size:4vh;">\n            </div>\n            <div class="si-icon xut-flip-control xut-flip-control-right xut-icon-angle-right ' + option.state + '"\n                 style="' + option.style + ';text-align:center;line-height:' + option.height + 'px;">\n            </div>';
    }

    /**
     * 绑定左右翻页事件响应
     */

  }, {
    key: '_$$bindArrow',
    value: function _$$bindArrow(el, callback) {
      el.on("mouseup touchend", function (e) {
        callback();
        return false;
      });
      return function () {
        el.off();
        el = null;
      };
    }

    /**
     * 显示工具栏
     */

  }, {
    key: '_$$showToolBar',
    value: function _$$showToolBar(pointer) {
      switch (pointer) {
        case 'controlBar':
          this._showTopBar();
          break;
        case 'button':
          this._$$showArrow();
          this.Lock = false;
          break;
        default:
          this._showTopBar();
          this._$$showArrow();
      }
    }

    /**
     *  隐藏工具栏
     */

  }, {
    key: '_$$hideToolBar',
    value: function _$$hideToolBar(pointer) {
      switch (pointer) {
        case 'controlBar':
          this._hideTopBar();
          break;
        case 'button':
          this._$$hideArrow();
          this.Lock = false;
          break;
        default:
          this._hideTopBar();
          this._$$hideArrow();
      }
    }

    /**
     * 针对单个按钮的显示隐藏处理
     */

  }, {
    key: '_$$toggleArrow',
    value: function _$$toggleArrow(dir, status) {
      if (!this.arrows) return;
      var arrow = this.arrows[dir];
      //如果没有创建翻页按钮,则不处理
      if (!arrow) return;
      arrow.able = status;
      //如果人为隐藏了工具栏,则不显示翻页按钮
      if (this.hasTopBar && !this.toolBarStatus && status) {
        return;
      }
      arrow.el[status ? 'show' : 'hide']();
    }

    /////////////////////////////////////
    ///       超类暴露给子类接口
    /////////////////////////////////////

    /**
     * 显示IOS系统工具栏
     *  iOS状态栏0=show,1=hide
     */

  }, {
    key: '_$$showSystemBar',
    value: function _$$showSystemBar() {
      isIOS$2 && Xut.plat.hasPlugin && Xut.Plugin.statusbarPlugin.setStatus(null, null, 0);
    }

    /**
     * 隐藏IOS系统工具栏
     */

  }, {
    key: '_$$hideSystemBar',
    value: function _$$hideSystemBar() {
      isIOS$2 && Xut.plat.hasPlugin && Xut.Plugin.statusbarPlugin.setStatus(null, null, 1);
    }

    /**
     * 创建翻页按钮
     * @return {[type]} [description]
     */

  }, {
    key: '_$$createArrows',
    value: function _$$createArrows() {

      /*存放左右翻页按钮*/
      this.arrows = hash();

      var $str = void 0;

      //动态图标，数据库定义的翻页图标
      //font字体画翻页图标
      //是否使用自定义的翻页按钮: true /false
      //图标名称是客户端指定的：pageforward_'+appId+'.svg
      if (this.$$setTable.customButton) {
        $str = $(String.styleFormat(this._$$createIcon()));
      } else {
        $str = $(String.styleFormat(this._$$createArrow()));
      }
      var $left = $str.eq(0);
      var $right = $str.eq($str.length - 1); //存在文本节点

      this.arrows = {
        prev: {
          off: this._$$bindArrow($left, function () {
            Xut.View.GotoPrevSlide();
          }),
          el: $left,
          able: true
        },
        next: {
          off: this._$$bindArrow($right, function () {
            Xut.View.GotoNextSlide();
          }),
          el: $right,
          able: true
        }
      };

      this.$sceneNode.append($str);
    }

    /**
     * 显示翻页按钮
     */

  }, {
    key: '_$$showArrow',
    value: function _$$showArrow() {
      var arrows = this.arrows;
      for (var dir in arrows) {
        var arrow = arrows[dir];
        arrow.able && arrow.el.show();
      }
    }

    /**
     * 隐藏翻页按钮
     */

  }, {
    key: '_$$hideArrow',
    value: function _$$hideArrow() {
      var arrows = this.arrows;
      for (var dir in arrows) {
        arrows[dir].el.hide();
      }
    }

    /////////////////////////////////////
    ///   对外接口，子类向上转型接口
    /////////////////////////////////////


    /**
     * 重置翻页按钮,状态以工具栏为标准
     */

  }, {
    key: 'resetArrow',
    value: function resetArrow() {
      this.toolBarStatus ? this._$$showArrow() : this._$$hideArrow();
    }

    /**
     * 隐藏导航栏
     */

  }, {
    key: 'hideNavbar',
    value: function hideNavbar() {
      this.navbarObj && this.navbarObj.hide('hide');
    }

    /**
     * 隐藏下一页按钮
     */

  }, {
    key: 'hideNext',
    value: function hideNext() {
      this._$$toggleArrow('next', false);
    }

    /**
     * 显示下一页按钮
     */

  }, {
    key: 'showNext',
    value: function showNext() {
      this._$$toggleArrow('next', true);
    }

    /**
     * 隐藏上一页按钮
     */

  }, {
    key: 'hidePrev',
    value: function hidePrev() {
      this._$$toggleArrow('prev', false);
    }

    /**
     * 显示上一页按钮
     */

  }, {
    key: 'showPrev',
    value: function showPrev() {
      this._$$toggleArrow('prev', true);
    }

    /**
     * 切换状态
     */

  }, {
    key: 'toggle',
    value: function toggle(state, pointer) {
      if (this.Lock) return;
      this.Lock = true;
      switch (state) {
        case 'show':
          this._$$showToolBar(pointer);
          break;
        case 'hide':
          this._$$hideToolBar(pointer);
          break;
        default:
          //默认：工具栏显示隐藏互斥处理
          this.toolBarStatus ? this._$$hideToolBar(pointer) : this._$$showToolBar(pointer);
          break;
      }
    }

    /**
     * 超类销毁
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      /*销毁子类*/
      this._destroy();
      /*销毁自身*/
      if (this.arrows) {
        this.arrows.prev.off();
        this.arrows.next.off();
        this.arrows = null;
      }
    }
  }]);
  return BarSuper;
}();

var round$1 = Math.round;
var ratio = 6;
var isIOS$3 = Xut.plat.isIOS;
var TOP = isIOS$3 ? 20 : 0;

var getNavOptions = function getNavOptions() {

  var iconHeight = config.data.iconHeight;
  var proportion = config.proportion;
  var visualSize = config.visualSize;

  //横版模式
  var isHorizontal = config.layoutMode == 'horizontal';

  proportion = isHorizontal ? proportion.width : proportion.height;
  iconHeight = isIOS$3 ? iconHeight : round$1(proportion * iconHeight);

  //导航菜单宽高
  var navHeight = void 0,
      navWidth = void 0;
  var sWidth = visualSize.width;
  var sHeight = visualSize.height;

  //横版模版
  if (isHorizontal) {
    navHeight = round$1(sHeight / ratio);
  } else {
    navWidth = Math.min(sWidth, sHeight) / (isIOS$3 ? 8 : 3);
    navHeight = round$1((sHeight - iconHeight - TOP) * 0.96);
  }

  return {
    sWidth: sWidth,
    sHeight: sHeight,
    navHeight: navHeight,
    navWidth: navWidth,
    proportion: proportion
  };
};

/**
 * 获得css配置数据
 * @param  {[type]} seasonlist [description]
 * @return {[type]}            [description]
 */
var getWrapper = function getWrapper(seasonlist) {

  var width = void 0,
      height = void 0,
      blank = void 0,
      scroller = void 0,
      contentstyle = void 0,
      containerstyle = void 0,
      overwidth = void 0,
      overHeigth = void 0;

  //获得css配置数据
  var options = getNavOptions();
  var font = round$1(options.proportion * 2);

  var navWidth = options.navWidth;
  var navHeight = options.navHeight;
  var sWidth = options.sWidth;
  var sHeight = options.sHeight;

  if (config.layoutMode == 'horizontal') {
    height = round$1(navHeight * 0.9);
    width = round$1(height * sWidth / sHeight); //保持缩略图的宽高比
    blank = round$1(navHeight * 0.05); //缩略图之间的间距
    scroller = 'width:' + seasonlist * (width + blank) + 'px>';
    contentstyle = 'float:left;width:' + width + 'px;height:' + height + 'px;margin-left:' + blank + 'px';
    containerstyle = 'width:96%;height:' + height + 'px;margin:' + blank + 'px auto;font-size:' + font + 'em';
    //横版左右滑动
    //溢出长度+上偏移量
    overwidth = width * seasonlist + seasonlist * blank;
  } else {
    width = round$1(navWidth * 0.9);
    height = round$1(navWidth * 1.1);
    blank = round$1(navWidth * 0.05);
    contentstyle = 'width:' + width + 'px;height:' + height + 'px;margin:' + blank + 'px auto;border-bottom:1px solid rgba(0,0,0,0.3)';
    containerstyle = 'height:' + (navHeight - 4) + 'px;overflow:hidden;margin:2px auto;font-size:' + font + 'em';
    //竖版上下滑动
    overHeigth = height * seasonlist + seasonlist * blank;
  }

  return {
    contentstyle: contentstyle,
    containerstyle: containerstyle,
    overwidth: overwidth,
    overHeigth: overHeigth,
    scroller: scroller
  };
};

/**
 * 导航菜单
 * @param  {[type]} seasonSqlRet [description]
 * @return {[type]}              [description]
 */
function navLayout(results) {

  var seasonlist = results.length;
  var options = getWrapper(seasonlist);

  var list = '';
  var seasonId = void 0;
  var chapterId = void 0;
  var data = void 0;
  var xxtlink = void 0;

  for (var i = 0; i < seasonlist; i++) {
    data = results[i];
    seasonId = data.seasonId;
    chapterId = data._id;
    xxtlink = seasonId + '-' + chapterId;
    list += '<li style="' + options.contentstyle + '">\n                <div data-xxtlink="' + xxtlink + '">\n                    ' + (i + 1) + '\n                </div>\n           </li>';
  }

  //导航
  var navHTML = '<div id="xut-nav-wrapper" style="' + options.containerstyle + '">\n            <div style="width:' + options.overwidth + 'px;\n                                           height:' + options.overHeigth + 'px;\n                                           ' + options.scroller + '">\n                <ul id="xut-nav-section-list">\n                    ' + list + '\n                </ul>\n            </div>\n        </div>';

  return String.styleFormat(navHTML);
}

/**
 * 下拉章节列表
 */

var Section = function () {
  function Section(data) {
    classCallCheck(this, Section);

    this._isHorizontal = config.layoutMode === 'horizontal';
    this._pagedata = data;
    this._$section = $('#xut-nav-section-list');
    this._$list = this._$section.find("li");
  }

  /**
   * 卷滚条
   * @param  {[type]} pageIndex [description]
   * @return {[type]}           [description]
   */


  createClass(Section, [{
    key: 'userIscroll',
    value: function userIscroll(pageIndex) {
      var _this = this;

      var isHorizontal = this._isHorizontal;

      if (this.hBox) {
        if (isHorizontal) {
          this.hBox.goToPage(pageIndex, 0, 0);
        } else {
          this.hBox.goToPage(0, pageIndex, 0);
        }
      } else {
        this.hBox = IScroll('#xut-nav-wrapper', {
          snap: 'li',
          tap: true,
          scrollX: isHorizontal,
          scrollY: !isHorizontal,
          scrollbars: 'custom',
          fadeScrollbars: true,
          stopPropagation: true
        });

        //滑动结束,动态处理缩略图
        this.hBox.on('scrollEnd', function (e) {
          _this.createThumb();
          _this._removeThumb();
        });

        this._$section.on('tap', this._toJump);
      }
    }

    /**
     * 点击元素跳转
     */

  }, {
    key: '_toJump',
    value: function _toJump(e) {
      var target = e.target;
      var xxtlink = void 0;
      if (target) {
        var _xxtlink = target.getAttribute('data-xxtlink');
        if (_xxtlink) {
          _xxtlink = _xxtlink.split('-');
          Xut.View.GotoSlide(_xxtlink[0], _xxtlink[1]);
        }
      }
    }

    /**
     * [ 创建缩略图]
     * @return {[type]} [description]
     */

  }, {
    key: 'createThumb',
    value: function createThumb() {
      var index = this._getPageIndex(),
          //最左边的索引
      count = this._getViewLen(),
          //允许显示的页数
      createBak = this.createBak || [],
          //已创建的页码索引
      createNew = [],
          //新建的页码索引
      pageData = this._pagedata,
          maxLen = pageData.length;

      //确保不会溢出
      count = count > maxLen ? maxLen : count;
      //尽可能地填满
      index = index + count > maxLen ? maxLen - count : index;

      var i = 0;
      var j = void 0;
      var page = void 0;

      for (i = 0; i < count; i++) {
        j = index + i;
        page = pageData[j];
        createNew.push(j);
        if (_.contains(createBak, j)) continue;
        createBak.push(j);

        //如果是分层母板了,此时用icon代替
        if (page.iconImage) {
          this._$list.eq(j).css({
            'background-image': 'url(' + getFileFullPath(page.iconImage, 'navbar-bg') + ')'
          });
        } else {
          this._$list.eq(j).css({
            'background-image': 'url(' + getFileFullPath(page.md5, 'navbar-bg') + ')',
            'background-color': 'white'
          });
        }
      }

      this.createNew = createNew;
      this.createBak = createBak;
    }

    /**
     * [ 清理隐藏的缩略图]
     * @return {[type]} [description]
     */

  }, {
    key: '_removeThumb',
    value: function _removeThumb() {
      var list = this._$list;
      var createNew = this.createNew;
      var createBak = this.createBak;

      _.each(createBak, function (val, i) {
        if (!_.contains(createNew, val)) {
          //标记要清理的索引
          createBak[i] = -1;
          list.eq(val).css({
            'background': ''
          });
        }
      });

      //执行清理
      this.createBak = _.without(createBak, -1);
    }

    /**
     * [ 得到滑动列表中最左侧的索引]
     * @return {[type]} [description]
     */

  }, {
    key: '_getPageIndex',
    value: function _getPageIndex() {
      if (this.hBox.options.scrollX) {
        return this.hBox.currentPage.pageX;
      } else {
        return this.hBox.currentPage.pageY;
      }
    }

    /**
     * [ 获取待创建的缩略图的个数]
     * @return {[type]} [description]
     */

  }, {
    key: '_getViewLen',
    value: function _getViewLen() {
      var hBox = this.hBox,
          eleSize = 1,
          //单个li的高度,
      count = 1,
          len = this._pagedata.length; //li的总数

      if (this._isHorizontal) {
        eleSize = hBox.scrollerWidth / len;
        count = hBox.wrapperWidth / eleSize;
      } else {
        eleSize = hBox.scrollerHeight / len;
        count = hBox.wrapperHeight / eleSize;
      }
      //多创建一个
      return Math.ceil(count) + 1;
    }

    /**
     * 滚动指定位置
     */

  }, {
    key: 'scrollTo',
    value: function scrollTo(pageIndex) {
      this.userIscroll(pageIndex);
    }

    /**
     * 刷新
     */

  }, {
    key: 'refresh',
    value: function refresh() {
      this.hBox && this.hBox.refresh();
    }

    /**
     * 销毁
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.hBox) {
        this._$section.off();
        this._$section = null;
        this._$list = null;
        this.hBox.destroy();
        this.hBox = null;
      }
      this._pagedata = null;
    }
  }]);
  return Section;
}();

/**
 * 目录列表
 * @param  {[type]} hindex    [description]
 * @param  {[type]} pageArray [description]
 * @param  {[type]} modules   [description]
 * @return {[type]}           [description]
 */
var Navbar = function () {
  createClass(Navbar, [{
    key: 'toggle',


    /**
     * 切换
     * @param  {[type]} pageIndex [description]
     * @return {[type]}           [description]
     */
    value: function toggle(pageIndex) {
      this.pageIndex = pageIndex;
      this._navControl();
    }

    /**
     * 隐藏
     * @return {[type]} [description]
     */

  }, {
    key: 'hide',
    value: function hide() {
      this.isRunning && this._navControl();
    }

    /**
     * 销毁
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.sectionObj) {
        this.sectionObj.destroy();
        this.sectionObj = null;
      }
      this.$container = null;
      this.$button = null;
    }
  }]);

  function Navbar(pageIndex) {
    classCallCheck(this, Navbar);

    this.pageIndex = pageIndex;
    this.isRunning = false; //运行状态
    this.$container = $(".xut-nav-bar"); //显示容器
    this.$button = $(".xut-control-navbar"); //触发按钮
    this._initialize();
  }

  createClass(Navbar, [{
    key: '_initialize',
    value: function _initialize() {
      var _this = this;

      var data = [];
      Xut.data.query('Chapter', Xut.data.novelId, 'seasonId', function (item) {
        return data.push(item);
      });
      Xut.nextTick({
        'container': this.$container,
        'content': navLayout(data)
      }, function () {
        _this.sectionObj = new Section(data); //目录对象
        _this.sectionObj.userIscroll(_this.pageIndex); //初始化滑动
        _this.sectionObj.createThumb(); //初始缩略图
        _this._navControl(); //初始化样式
      });
    }

    /**
     * 控制导航条
     * @return {[type]} [description]
     */

  }, {
    key: '_navControl',
    value: function _navControl() {

      var action = this.$button.attr('fly') || 'in'; //判断点击的动作
      var isIn = action === 'in';

      //初始化目录栏的样式
      //能够显示出来
      if (isIn) {
        this.$container.css({
          'z-index': 0,
          'opacity': 0,
          'display': 'block'
        });
      }

      //触发控制条
      this.$button.css('opacity', isIn ? 0.5 : 1);

      //执行动画
      //出现
      if (isIn) {
        //导航需要重置
        //不同的页面定位不一定
        this.sectionObj.refresh();
        this.sectionObj.scrollTo(this.pageIndex);

        //动画出现
        this.$container.css({
          'z-index': Xut.zIndexlevel(),
          'opacity': 1
        });
        this.$button.attr('fly', 'out');
        this.isRunning = true;
      } else {
        //隐藏
        this.$button.attr('fly', 'in');
        this.$container.hide();
        this.isRunning = false;
      }
    }
  }]);
  return Navbar;
}();

/**
 * 创建主页按钮
 * @param  {[type]} bar [description]
 * @return {[type]}     [description]
 */
function createHomeIcon(height) {
  return "<div class=\"xut-control-backhome\"\n                 style=\"float:left;text-indent:0.25em;height:" + height + "px;line-height:" + height + "px;color:#007aff\">\n                \u4E3B\u9875\n            </div>";
}

/**
 * 创建目录按钮
 * @param  {[type]} bar [description]
 * @return {[type]}     [description]
 */
function createDirIcon(height) {
  return "<div class=\"xut-control-navbar\"\n                 style=\"float:left;margin-left:4px;width:" + height + "px;height:" + height + "px;background-size:cover\">\n            </div>";
}

/**
 * 应用标题
 * @param  {[type]} bar [description]
 * @return {[type]}     [description]
 */
function createTitle(height, appName) {
  return "<div class=\"xut-control-title\"\n                 style=\"z-index:-99;width:100%;position:absolute;line-height:" + height + "px;pointer-events:none\">\n                " + appName + "\n            </div>";
}

/**
 * 创建页码数
 * @param  {[type]} bar [description]
 * @return {[type]}     [description]
 */
function createPageNumber(height, currentPage, pageTotal) {
  var marginTop = height * 0.25;
  var iconH = height * 0.5;
  return "<div class=\"xut-control-pageIndex\"\n                 style=\"float:right;\n                        margin:" + marginTop + "px 4px;\n                        padding:0 0.25em;\n                        height:" + iconH + "px;\n                        line-height:" + iconH + "px;\n                        border-radius:0.5em\">\n                  <span class=\"control-current-page\">" + currentPage + "</span>/<span>" + pageTotal + "</span>\n            </div>";
}

/**
 * 工具栏隐藏按钮
 * @param  {[type]} bar [description]
 * @return {[type]}     [description]
 */
function createHideToolbar(height) {
  return "<div class=\"xut-control-hidebar\"\n                 style=\"float:right;width:" + height + "px;height:" + height + "px;background-size:cover\">\n            </div>";
}

/**
 * 关闭子文档按钮(font字体版本)
 * @param  {[type]} height [description]
 * @return {[type]}        [description]
 */
function createCloseIcon$1(height) {
  return "<div class=\"si-icon xut-icon-close2\"\n                 style=\"float:right;margin-right:4px;width:" + height + "px;height:" + height + "px\">\n            </div>";
}

/**
 * 系统工具栏
 * 主场景工具栏
 */
/**
 * 系统工具栏
 * 模拟ios风格
 */

var IosBar = function (_BarSuper) {
  inherits(IosBar, _BarSuper);

  /**
      $sceneNode,
      arrowButton,
      pageTotal,
      currentPage,
      toolType
   */
  function IosBar(options) {
    classCallCheck(this, IosBar);
    return possibleConstructorReturn(this, (IosBar.__proto__ || Object.getPrototypeOf(IosBar)).call(this, options));
  }

  ////////////////////////
  ///  私有方法
  ///////////////////////

  createClass(IosBar, [{
    key: '_initState',
    value: function _initState() {
      this.Lock = false; //操作锁
      this.delay = 50; //动画延时
      this.hasTopBar = true; //有顶部工具条
      this.currPageNode = null; //当前页码对象
      this.$controlNode = this.$sceneNode.find('.xut-control-bar');
      this.eventElement = this.$controlNode[0]; //绑定事件
    }

    /**
     * 初始化工具栏
     */

  }, {
    key: '_initToolbar',
    value: function _initToolbar() {
      //顶部工具栏可配置
      //0 禁止工具栏
      //1 系统工具栏 - 显示IOS系统工具栏
      if (_.some(this.toolType)) {
        this._initTopBar();
      }

      /*翻页按钮*/
      if (this.arrowButton) {
        this._$$createArrows();
      }
    }

    /**
     * 系统工具条的位置
     * position
     *     0 顶部
     *     1 底部
     */

  }, {
    key: '_barPostion',
    value: function _barPostion(element, position) {
      if (position == 1) {
        //在底部
        element.css({
          bottom: 0,
          height: this.$$iconHeight + 'px'
        });
      } else {
        element.css({ //在顶部
          top: 0,
          height: this.$$iconHeight + 'px',
          paddingTop: '' + this.$$barHeight
        });
      }
    }

    /**
     * 初始化顶部工具栏
     */

  }, {
    key: '_initTopBar',
    value: function _initTopBar() {

      var $controlNode = this.$controlNode;

      //工具栏的显示状态
      this.toolBarStatus = $controlNode.css('display') === 'none' ? false : true;

      //工具栏摆放位置
      this._barPostion($controlNode, this.$$setTable.ToolbarPos);

      var html = '';

      //首页按钮
      if (this.$$setTable.HomeBut) {
        html += createHomeIcon(this.$$iconHeight);
      }
      //目录按钮
      if (this.$$setTable.ContentBut) {
        html += createDirIcon(this.$$iconHeight);
      }
      //添加标题
      html += createTitle(this.$$iconHeight, this.$$appName);
      //工具栏隐藏按钮
      html += createHideToolbar(this.$$iconHeight);
      //关闭子文档
      if (this.$$setTable.CloseBut) {
        html += createCloseIcon$1(this.$$iconHeight);
      }
      //页码数
      if (this.$$setTable.PageBut) {
        html += createPageNumber(this.$$iconHeight, this.currentPage, this.pageTotal);
      }

      //显示
      Xut.nextTick($controlNode.append(String.styleFormat(html)));

      //当前页码标识
      this.currPageNode = $controlNode.find('.control-current-page');

      //事件
      $on(this.eventElement, { start: this });
    }

    /**
     * 跳转到主页
     */

  }, {
    key: '_toggleNavBar',


    /**
     * 切换目录导航
     */
    value: function _toggleNavBar() {
      var pageIndex = Xut.Presentation.GetPageIndex();
      if (this.navbarObj) {
        this.navbarObj.toggle(pageIndex);
      } else {
        this.navbarObj = new Navbar(pageIndex);
      }
    }

    /**
     * 相应事件
     */

  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      $handle({
        start: function start(e) {
          switch ($target(e).className) {
            //跳主页
            case "xut-control-backhome":
              IosBar.goHomePage();
              break;
            //切换目录
            case "xut-control-navbar":
              this._toggleNavBar();
              break;
            //隐藏工具栏
            case 'xut-control-hidebar':
              this._hideTopBar();
              break;
          }
        }
      }, this, e);
    }

    ////////////////////////
    ///  提供super接口
    ///////////////////////

    /**
     * 显示顶部工具栏
     */

  }, {
    key: '_showTopBar',
    value: function _showTopBar() {
      var self = this;

      if (this.toolBarStatus) {
        this.Lock = false;
        return;
      }
      this.$controlNode.css({
        'display': 'block',
        'opacity': 0
      });

      self.$controlNode && self.$controlNode.transition({
        'opacity': 1
      }, self.delay, 'in', function () {
        self.hideNavbar();
        self._$$showSystemBar();
        self.toolBarStatus = true;
        self.Lock = false;
      });
    }

    /**
     * 隐藏顶部工具栏
     */

  }, {
    key: '_hideTopBar',
    value: function _hideTopBar() {
      var self = this;
      if (!this.toolBarStatus) {
        this.Lock = false;
        return;
      }
      this.$controlNode && this.$controlNode.transition({
        'opacity': 0
      }, self.delay, 'in', function () {
        self.hideNavbar();
        self.$controlNode.hide();
        self._$$hideSystemBar();
        self.toolBarStatus = false;
        self.Lock = false;
      });
    }

    /**
     * 销毁
     * @return {[type]} [description]
     */

  }, {
    key: '_destroy',
    value: function _destroy() {
      //目录导航
      this.navbarObj && this.navbarObj.destroy();
      //解除事件
      $off(this.eventElement);
      this.currPageNode = null;
      this.toolBarStatus = false;
      this.$controlNode = null;
      this.eventElement = null;
    }

    ////////////////////////
    ///  外部接口
    ///////////////////////

    /**
     * 更新页码指示
     */

  }, {
    key: 'updatePointer',
    value: function updatePointer(_ref) {
      var parentIndex = _ref.parentIndex;

      this.currPageNode && this.currPageNode.html(parentIndex + 1);
    }
  }], [{
    key: 'goHomePage',
    value: function goHomePage() {
      if (window.DUKUCONFIG) {
        Xut.Application.Suspend({
          processed: function processed() {
            Xut.Application.DropApp(); //退出应用
          }
        });
        return;
      }
      //动作处理
      //如果有动作则关闭，否则直接跳转
      Xut.Application.Suspend({
        processed: function processed() {
          Xut.View.GotoSlide(1);
        }
      });
    }
  }]);
  return IosBar;
}(BarSuper);

/**
 * 函数工具栏
 */

var isIOS$4 = Xut.plat.isIOS;

var closeScenario = function closeScenario() {
  Xut.View.CloseScenario();
};

var fnBar = function (_BarSuper) {
  inherits(fnBar, _BarSuper);

  /*
      arrowButton = false,
      sceneNode,
      toolType,
      pageTotal,
      currentPage
   */
  function fnBar(options) {
    classCallCheck(this, fnBar);
    return possibleConstructorReturn(this, (fnBar.__proto__ || Object.getPrototypeOf(fnBar)).call(this, options));
  }

  /**
   * 初始化
   * @return {[type]} [description]
   */


  createClass(fnBar, [{
    key: '_initState',
    value: function _initState() {
      this.pageTips = null;
      this.currTip = null;
      this.tipsMode = 0;
      this.top = this.$$barHeight;
      this.Lock = false;
      this.delay = 50;
      this.hasTopBar = false;
      this.barStatus = true;
    }

    /**
     * 创建工具栏
     * toolType:
     *      0   禁止工具栏
     *      1   系统工具栏   - 显示IOS系统工具栏
     *      2   场景工具栏   - 显示关闭按钮
     *      3   场景工具栏   - 显示返回按钮
     *      4   场景工具栏   - 显示顶部小圆点式标示
      */

  }, {
    key: '_initToolbar',
    value: function _initToolbar() {
      var type = void 0;
      this.$sceneNode.hide();
      this.controlBar = [];
      //配置工具栏
      while (type = this.toolType.shift()) {
        switch (type) {
          case 1:
            this._createSystemBar();
            break;
          case 2:
            this._createCloseIcon();
            break;
          case 3:
            this._createBackIcon();
            break;
          case 4:
            this._createPageTips();
            break;
          default:
            this.barStatus = false;
            this.hasTopBar = false;
            break;
        }
      }
      //创建翻页按钮
      if (this.arrowButton) {
        this._$$createArrows();
      }
      this.$sceneNode.show();
    }

    /**
     * 系统工具栏
     */

  }, {
    key: '_createSystemBar',
    value: function _createSystemBar() {
      var html = '<div class="xut-control-bar"\n                         style="top:0;height:' + this.$$iconHeight + 'px;padding-top:' + this.top + 'px">\n                    </div>';
      html = $(String.styleFormat(html));
      this._$$showSystemBar();
      this._createBackIcon(html);
      this._createTitle(html);
      this._createPageNum(html);
      this.controlBar = html;
      this.$sceneNode.append(html);
      this.hasTopBar = true;
    }

    /**
     * 页码小圆点
     */

  }, {
    key: '_createPageTips',
    value: function _createPageTips() {
      var _this2 = this;

      var chapters = this.pageTotal;
      var height = this.$$iconHeight;
      var html = '';

      //li内容
      var content = '';

      //如果只有一页则不显示小圆
      if (chapters < 2) {
        return html;
      }

      //圆点尺寸
      var size = isIOS$4 ? 7 : Math.max(8, Math.round(this.$$propHeight * 8));
      var width = 2.5 * size; //圆点间距
      var tipsWidth = chapters * width; //圆点总宽度
      var top = (height - size) / 2; //保持圆点垂直居中
      var left = (config.visualSize.width - tipsWidth) / 2; //保持圆点水平居中


      for (var i = 1; i <= chapters; i++) {
        content += '<li class="xut-scenario-dark"\n                      style="float:left;width:' + width + 'px;height:' + height + 'px;"\n                      data-index="' + i + '">\n                    <div class="xut-scenario-radius"\n                          style="width:' + size + 'px;height:' + size + 'px;margin:' + top + 'px auto">\n                    </div>\n                </li>';
      }

      html = '<ul class="xut-scenario-tips"\n                    style="top:' + this.top + 'px;left:' + left + 'px;width:' + tipsWidth + 'px;opacity:0.6">\n                    ' + content + '\n                </ul>';

      html = $(String.styleFormat(html));

      //点击跳转页面
      this.$tipsNode = html;
      this.$tipsNode.on('click', function (e) {
        var target = e.target;
        switch (target.className) {
          case 'xut-control-nav-hide':
            _this2.hideTopBar();
            break;
          case 'xut-scenario-dark':
            if (_this2.arrowButton) {
              var index = target.getAttribute('data-index') || 1;
              Xut.View.GotoSlide(Number(index));
            }
            break;
          default:
            break;
        }
      });
      this.pageTips = html.children();
      this.tipsMode = 1;
      this.controlBar.push(html);
      this.$sceneNode.append(html);
    }
  }, {
    key: '_onBackClose',
    value: function _onBackClose(el) {
      el.on("mouseup touchend", function (e) {
        closeScenario();
        return false;
      });
      return function () {
        el.off();
        el = null;
      };
    }

    /**
     * font字体版本：关闭按钮
     * @return {[type]} [description]
     */

  }, {
    key: '_createCloseIcon',
    value: function _createCloseIcon() {
      var height = this.$$iconHeight;
      var html = $('<div class="si-icon xut-scenario-close xut-icon-close2"\n                style="top:' + this.top + 'px;width:' + height + 'px;height:' + height + 'px;line-height:' + height + 'px;text-align:center;font-size:3vh;">\n            </div>');

      this.$closeIcon = html;
      this._onBackClose(this.$closeIcon);
      this.controlBar.push(html);
      this.$sceneNode.append(html);
    }

    /**
     * font字体版本：返回按钮
     * @return {[type]} [description]
     */

  }, {
    key: '_createBackIcon',
    value: function _createBackIcon() {
      var height = this.$$iconHeight;
      var html = $('<div class="si-icon xut-scenario-back xut-icon-arrow-left"\n                  style="top:' + this.top + 'px;width:' + height + 'px;height:' + height + 'px;line-height:' + height + 'px;">\n            </div>');

      this.$backIcon = html;
      this._onBackClose(this.$backIcon);
      this.controlBar.push(html);
      this.$sceneNode.append(html);
    }

    /**
     * 创建页码数
     * @param  {[type]} $sceneNode [description]
     * @return {[type]}            [description]
     */

  }, {
    key: '_createPageNum',
    value: function _createPageNum($sceneNode) {
      var pageTotal = this.pageTotal,
          TOP = this.top,
          height = this.$$iconHeight,
          currentPage = this.currentPage,
          style,
          html;

      html = '<div class="xut-control-pageindex"\n                  style="position:absolute;\n                         right:4px;\n                         top:' + (height * 0.25 + TOP) + 'px;\n                         padding:0 0.25em;\n                         height:' + height * 0.5 + 'px;\n                         line-height:' + height * 0.5 + 'px;\n                         border-radius:0.5em">\n                <span class="currentPage">' + currentPage + '</span>/<span>' + pageTotal + '</span>\n            </div>';
      html = $(String.styleFormat(html));
      this.tipsMode = 2;
      this.currTip = html.children().first();
      $sceneNode.append(html);
    }

    /**
     * 应用标题
     * @param  {[type]} $sceneNode [description]
     * @return {[type]}            [description]
     */

  }, {
    key: '_createTitle',
    value: function _createTitle($sceneNode) {
      var html = '<div class="xut-control-title"\n                  style="line-height:' + this.$$iconHeight + 'px">\n                ' + this.$$appName + '\n            </div>';
      $sceneNode.append(String.styleFormat(html));
    }

    ////////////////////////
    ///  提供super接口
    ///////////////////////

    /**
     * 显示顶部工具栏
     */

  }, {
    key: '_showTopBar',
    value: function _showTopBar() {
      var that = this,
          delay = this.delay,
          controlBar = this.controlBar;
      if (this.barStatus) {
        this.Lock = false;
        return;
      }
      if (this.hasTopBar) {
        controlBar.css({
          'display': 'block',
          'opacity': 0
        });
        setTimeout(function () {
          controlBar.transition({
            'opacity': 1
          }, delay, 'linear', function () {
            that.__showSystemBar();
            that.barStatus = true;
            that.Lock = false;
          });
        });
      } else {
        controlBar.forEach(function (el) {
          el.show();
          that.Lock = false;
          that.barStatus = true;
        });
      }
    }

    /**
     * 隐藏顶部工具栏
     */

  }, {
    key: '_hideTopBar',
    value: function _hideTopBar() {
      var that = this,
          delay = this.delay,
          controlBar = this.controlBar;

      if (!this.barStatus) {
        this.Lock = false;
        return;
      }
      if (this.hasTopBar) {
        controlBar.transition({
          'opacity': 0
        }, delay, 'linear', function () {
          that.controlBar.hide();
          that.__hideSystemBar();
          that.barStatus = false;
          that.Lock = false;
        });
      } else {
        controlBar.forEach(function (el) {
          el.hide(delay, function () {
            that.Lock = false;
            that.barStatus = false;
          });
        });
      }
    }

    /**
     * 销毁
     */

  }, {
    key: '_destroy',
    value: function _destroy() {
      this.$sceneNode = null;
      this.controlBar = null;
      this.pageTips = null;
      this.currTip = null;
      this.prevTip = null;

      //小图标点击事件
      if (this.$tipsNode) {
        this.$tipsNode.off();
        this.$tipsNode = null;
      }

      //关闭按钮
      if (this.$closeIcon) {
        this.$closeIcon.off();
        this.$closeIcon = null;
      }

      //返回按钮
      if (this.$backIcon) {
        this.$backIcon.off();
        this.$backIcon = null;
      }
    }

    ////////////////////////
    ///  外部接口
    ///////////////////////

    /**
     * 更新页码指示
     */

  }, {
    key: 'updatePointer',
    value: function updatePointer(_ref) {
      var parentIndex = _ref.parentIndex;

      switch (this.tipsMode) {
        case 1:
          if (this.prevTip) {
            this.prevTip.className = 'xut-scenario-dark';
          }
          this.currTip = this.pageTips[parentIndex];
          this.currTip.className = 'xut-scenario-light';
          this.prevTip = this.currTip;
          break;
        case 2:
          this.currTip.html(parentIndex + 1);
          break;
        default:
          break;
      }
    }
  }]);
  return fnBar;
}(BarSuper);

/**
 * 书签栏
 * 加入这个书签功能后，可以让用户自由选择哪页是需要保存记录的
 * @param options object
 * @example {parent:页面容器,pageId:chapterId,seasonId:seasionId}
 */
/**
 * 行高
 * @type {[type]}
 */
var sLineHeiht$1 = parseInt($('body').css('font-size')) || 16; //行高

/**
 * 书签缓存
 */
var BOOKCACHE$1 = void 0;

var Mark = function () {
  function Mark() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        parent = _ref.parent,
        pageId = _ref.pageId,
        seasonId = _ref.seasonId;

    classCallCheck(this, Mark);

    this.parent = parent;
    this.pageId = pageId;
    this.seasonId = seasonId;

    var visualSize = config.visualSize;
    this.sHeight = visualSize.height;
    this.sWidth = visualSize.width;

    //是否已存储
    this.isStored = false;
    this.init();
  }

  /**
   * 初始化
   * @return {[type]} [description]
   */


  createClass(Mark, [{
    key: 'init',
    value: function init() {
      var $bookMark = this.createBookMarkFont(),
          dom = this.parent[0],
          that = this;

      this.parent.append($bookMark);
      this.bookMarkMenu = $bookMark.eq(0);
      //显示书签
      setTimeout(function () {
        that.restore();
      }, 20);
      //获取历史记录
      BOOKCACHE$1 = this.getHistory();

      //邦定用户事件
      $on(dom, {
        end: this
      });
    }

    /**
     * 创建书签(font版本)
     * @return {[object]} [jquery生成的dom对象]
     */

  }, {
    key: 'createBookMarkFont',
    value: function createBookMarkFont() {
      var height = sLineHeiht$1 * 3; // menu的高为3em
      var sHeight = this.sHeight;
      var box = '<div class="xut-bookmark-menu"\n               style="width:100%;height:' + height + 'px;left:0;top:' + sHeight + 'px;">\n              <div class="xut-bookmark-wrap">\n                <div class="xut-bookmark-add">\u52A0\u5165\u4E66\u7B7E</div>\n                <div class="xut-bookmark-off xut-icon-chevron-down" style="vertical-align:bottom;"></div>\n                <div class="xut-bookmark-view">\u4E66\u7B7E\u8BB0\u5F55</div>\n              </div>\n            </div>\n            <div class="xut-bookmark-list" style="display:none;width:100%;height:' + sHeight + 'px;">\n              <ul class="xut-bookmark-head">\n                <li class="xut-bookmark-back">\u8FD4\u56DE</li>\n                <li>\u4E66\u7B7E</li>\n              </ul>\n              <ul class="xut-bookmark-body"></ul>\n            </div>';
      this.markHeight = height;
      return $(box);
    }

    /**
     * 生成书签列表
     * @return {[type]} [description]
     */

  }, {
    key: 'createMarkList',
    value: function createMarkList() {
      var tmp,
          seasonId,
          pageId,
          list = '',
          box = '',
          self = this;

      //取历史记录
      _.each(BOOKCACHE$1, function (mark) {
        tmp = mark.split('-');
        seasonId = tmp[0];
        pageId = tmp[1];
        mark = self.getMarkId(seasonId, pageId);
        list += '<li>\n               <a data-mark="' + mark + '" class="xut-bookmark-id" href="javascript:0">\u7B2C' + pageId + '\u9875</a>\n               <a class="xut-bookmark-del" data-mark="' + mark + '" href="javascript:0">X</a>\n             </li>';
      });

      return list;
    }

    /**
     * 创建存储标签
     * 存储格式 seasonId-pageId
     * @return {string} [description]
     */

  }, {
    key: 'getMarkId',
    value: function getMarkId(seasonId, pageId) {
      return seasonId + '-' + pageId;
    }

    /**
     * 获取历史记录
     * @return {[type]} [description]
     */

  }, {
    key: 'getHistory',
    value: function getHistory() {
      var mark = $getStorage('bookMark');
      if (mark) {
        return mark.split(',');
      }
      return [];
    }

    /**
     * 添加书签
     * @return {[type]} [description]
     */

  }, {
    key: 'addBookMark',
    value: function addBookMark() {
      var key;

      this.updatePageInfo();
      key = this.getMarkId(this.seasonId, this.pageId);

      //避免重复缓存
      if (BOOKCACHE$1.indexOf(key) > -1) {
        return;
      }
      BOOKCACHE$1.push(key);
      $setStorage('bookMark', BOOKCACHE$1);
    }

    /**
     * 更新页信息
     *  针对母板层上的书签
     */

  }, {
    key: 'updatePageInfo',
    value: function updatePageInfo() {
      var pageData = Xut.Presentation.GetPageData();
      this.pageId = pageData._id;
      this.seasonId = pageData.seasonId;
    }

    /**
     * 删除书签
     * @param {object} [key] [事件目标对象]
     * @return {[type]} [description]
     */

  }, {
    key: 'delBookMark',
    value: function delBookMark(target) {
      if (!target || !target.dataset) return;

      var key = target.dataset.mark,
          index = BOOKCACHE$1.indexOf(key);

      BOOKCACHE$1.splice(index, 1);
      $setStorage('bookMark', BOOKCACHE$1);

      if (BOOKCACHE$1.length == 0) {
        $removeStorage('bookMark');
      }

      //移除该行
      $(target).parent().remove();
    }

    /**
     * 显示书签
     * @param {object} [target] [事件目标对象]
     * @return {[type]} [description]
     */

  }, {
    key: 'viewBookMark',
    value: function viewBookMark(target) {
      var $bookMarkList,
          list = this.createMarkList();

      if (this.bookMarkList) {
        $bookMarkList = this.bookMarkList;
      } else {
        $bookMarkList = $(target).parent().parent().next();
      }
      //更新书签内容
      $bookMarkList.find('.xut-bookmark-body').html(list);
      this.bookMarkList = $bookMarkList;
      $bookMarkList.fadeIn();
    }

    /**
     * 点击放大效果
     * @param  {[object]} target [事件目标对象]
     * @return {[type]}      [description]
     */

  }, {
    key: 'iconManager',
    value: function iconManager(target) {
      var $icon = this.bookMarkIcon = $(target),
          restore = this.iconRestore;
      $icon.css({
        'transform': 'scale(1.2)',
        'transition-duration': '500ms'
      })[0].addEventListener(Xut.style.transitionEnd, restore.bind(this), false);
    }

    /**
     * 复原按钮
     * @return {[type]} [description]
     */

  }, {
    key: 'iconRestore',
    value: function iconRestore() {
      this.bookMarkIcon.css('transform', '');
    }

    /**
     * 跳转到书签页
     * @param  {[type]} target [description]
     * @return {[type]}        [description]
     */

  }, {
    key: 'goBookMark',
    value: function goBookMark(target) {
      if (!target || !target.dataset) return;

      var key = target.dataset.mark.split('-');
      var seasonId = Number(key[0]);
      var pageId = Number(key[1]);

      this.updatePageInfo();
      //关闭书签列表
      this.backBookMark();

      //忽略当前页的跳转
      if (this.pageId == pageId && this.seasonId == seasonId) {
        return;
      }

      Xut.View.LoadScenario({
        'seasonId': seasonId,
        'chapterId': pageId
      });
    }

    /**
     * 书签回退键
     * @return {[type]} [description]
     */

  }, {
    key: 'backBookMark',
    value: function backBookMark() {
      this.bookMarkList.fadeOut();
    }

    /**
     * 邦定事件
     * @param  {[type]} evt [事件]
     * @return {[type]}     [description]
     */

  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      var target = e.target;
      $handle({
        end: function end(e) {
          switch ($target(e).className) {
            //加入书签
            case 'xut-bookmark-add':
              this.addBookMark();
              this.iconManager(target);
              break;
            //显示书签记录
            case 'xut-bookmark-view':
              this.viewBookMark(target);
              this.iconManager(target);
              break;
            //关闭书签
            case 'xut-bookmark-off':
            case 'xut-bookmark-off xut-icon-chevron-down':
              this.closeBookMark(target);
              break;
            //返回书签主菜单
            case 'xut-bookmark-back':
              this.backBookMark();
              break;
            //删除书签记录
            case 'xut-bookmark-del':
              this.delBookMark(target);
              break;
            //跳转到书签页
            case 'xut-bookmark-id':
              this.goBookMark(target);
              break;
            default:
              //console.log(target.className)
              break;
          }
        }
      }, this, e);
    }

    /**
     * 关闭书签菜单
     * @return {[type]} [description]
     */

  }, {
    key: 'closeBookMark',
    value: function closeBookMark(target) {
      Xut.style.setTranslate({
        speed: 1000,
        node: this.bookMarkMenu
      });
    }

    /**
     * 恢复书签菜单
     */

  }, {
    key: 'restore',
    value: function restore() {
      Xut.style.setTranslate({
        y: -this.markHeight,
        speed: 1000,
        node: this.bookMarkMenu
      });
    }

    /**
     * 销毁书签
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {

      $off(this.parent);

      //菜单部分
      if (this.bookMarkMenu) {
        this.bookMarkMenu.remove();
        this.bookMarkMenu = null;
      }

      //列表部分
      if (this.bookMarkList) {
        this.bookMarkList.remove();
        this.bookMarkList = null;
      }

      //按钮效果
      if (this.bookMarkIcon) {
        this.bookMarkIcon[0].removeEventListener(Xut.style.transitionEnd, this.iconRestore, false);
        this.bookMarkIcon = null;
      }

      this.parent = null;
    }
  }]);
  return Mark;
}();

/**
 * 阅读模式工具栏
 * @param options object
 * @demo {$sceneNode:页面容器,$controlNode:工具栏容器,...}
 * @desc 继承自Toolbar.js
 */

var BookBar = function (_BarSuper) {
  inherits(BookBar, _BarSuper);

  /*
      arrowButton = false,
      sceneNode,
      toolType,
      pageTotal
   */
  function BookBar(options) {
    classCallCheck(this, BookBar);
    return possibleConstructorReturn(this, (BookBar.__proto__ || Object.getPrototypeOf(BookBar)).call(this, options));
  }

  ////////////////////////
  ///  私有方法
  ///////////////////////


  createClass(BookBar, [{
    key: '_initState',
    value: function _initState() {
      //工具栏容器
      this.$controlNode = this.$sceneNode.find('.xut-control-bar');
      //是否有顶部工具栏
      this.hasTopBar = true;
      this.Lock = false;
      this.delay = 50;

      //图书工具栏高度
      this.topBarHeight = this.$$iconHeight * 1.25;
    }

    /**
     * 初始化
     */

  }, {
    key: '_initToolbar',
    value: function _initToolbar() {

      //工具栏的显示状态
      var display = this.$controlNode.css('display');
      this.barStatus = display == 'none' ? false : true;
      this._setToolbarStyle();

      this._createBackIcon();
      this._createDirIcon();
      this._createMarkIcon();

      // this._createStarIcon();

      //翻页按钮
      if (this.arrowButton) {
        this._$$createArrows();
      }

      //监听事件
      $on(this.$sceneNode, {
        end: this,
        cancel: this
      });
    }

    /**
     * 工具条的样式
     */

  }, {
    key: '_setToolbarStyle',
    value: function _setToolbarStyle() {
      var height = this.topBarHeight;

      //在顶部
      this.$controlNode.css({
        top: 0,
        height: height + 'px',
        paddingTop: this.$$barHeight + 'px', //系统工具栏占用的高度
        backgroundColor: 'rgba(0, 0, 0, 0.2)', //transparent
        fontSize: '0.625em',
        color: 'white'
      });
    }

    /**
     *  font版本：创建目录图标
     * @return {[type]} [description]
     */

  }, {
    key: '_createDirIcon',
    value: function _createDirIcon() {
      var parent = document.createElement('div');
      var icon = document.createElement('div');
      var iconText = document.createElement('div');

      parent.style.width = '48px';
      parent.style.height = "100%";
      parent.style.float = "left";
      parent.style.marginLeft = "3vw";
      parent.style.cursor = "pointer";
      parent.style.position = "relative";

      icon.style.fontSize = "2.5vh";
      icon.style.color = "#fff";
      icon.className = 'xut-icon-th-list2';
      icon.style.position = "absolute";
      icon.style.bottom = this.$$iconHeight * 0.5 + 'px';

      iconText.innerHTML = '目录';
      iconText.className = "xut-book-dirFont";
      // iconText.style.height = "40%";
      // iconText.style.width = "100%";
      iconText.style.position = "absolute";
      iconText.style.bottom = "0";

      parent.appendChild(icon);
      parent.appendChild(iconText);
      this.$controlNode.append(parent);
    }

    /**
     * font版本：创建书签图标
     * @return {[type]} [description]
     */

  }, {
    key: '_createMarkIcon',
    value: function _createMarkIcon() {
      var parent = document.createElement('div');
      var icon = document.createElement('div');
      var iconText = document.createElement('div');

      parent.style.width = '48px';
      parent.style.height = "100%";
      parent.style.float = "left";
      parent.style.marginLeft = "1vw";
      parent.style.cursor = "pointer";
      parent.style.position = "relative";

      icon.style.fontSize = "2.5vh";
      icon.style.color = "#fff";
      icon.style.position = "absolute";
      icon.style.bottom = this.$$iconHeight * 0.5 + 'px';
      icon.className = 'xut-icon-bookmark2';

      iconText.innerHTML = '书签';
      iconText.className = "xut-book-markFont";
      //iconText.style.height = "40%";
      iconText.style.position = "absolute";
      iconText.style.bottom = "0";

      parent.appendChild(icon);
      parent.appendChild(iconText);
      this.$controlNode.append(parent);
    }

    /**
     * 创建评分图标
     */

  }, {
    key: '_createStarIcon',
    value: function _createStarIcon(bar) {
      var icon = document.createElement('div');
      icon.innerHTML = '评分';
      icon.style.width = this.$$iconHeight + 'px';
      icon.style.lineHeight = 1.5 * this.topBarHeight + 'px';
      icon.className = 'xut-book-bar-star';
      this.$controlNode.append(icon);
    }

    /**
     * font字体版本：后退按钮
     * @return {[type]} [description]
     */

  }, {
    key: '_createBackIcon',
    value: function _createBackIcon() {
      var icon = document.createElement('div');
      icon.style.width = this.topBarHeight + 'px';
      icon.style.lineHeight = this.topBarHeight + 'px';
      icon.style.color = "#fff";

      icon.className = 'xut-icon-angle-left xut-icon-book-bar';
      icon.style.fontSize = "6vh";
      this.$controlNode.append(icon);
    }

    /**
     * 创建目录菜单
     */

  }, {
    key: '_createDirMenu',
    value: function _createDirMenu() {
      var self = this;
      var wrap = document.createElement('div');
      var mask = document.createElement('div');
      //添加遮层
      mask.className = 'xut-book-menu-mask';
      //获取内容
      this._getDirContent();
      wrap.className = 'xut-book-menu';
      wrap.innerHTML = '<ul>' + this.contentText + '</ul>';
      this.$sceneNode.append(wrap);
      //是否滚动
      this.isScrolled = false;

      //添加滚动条
      //url : http://iscrolljs.com/
      this.iscroll = IScroll(wrap, {
        scrollbars: 'custom',
        fadeScrollbars: true,
        scrollX: false
      });

      this.menu = wrap;

      this._setColor();

      this.iscroll.on('scrollStart', function (e) {
        self.isScrolled = true;
      });

      this.iscroll.on('scrollEnd', function (e) {
        self.isScrolled = false;
      });

      wrap.appendChild(mask);
    }

    /**
     *  显示目录菜单
     */

  }, {
    key: '_showDirMenu',
    value: function _showDirMenu() {
      //获取当前页面
      var page = Xut.Presentation.GetPageRootNode('page');

      if (this.menu) {
        this.menu.style.display = 'block';
      } else {
        this._createDirMenu();
      }

      //添加模糊效果
      page.addClass('filter');
      this.page = page;

      //隐藏顶部工具栏
      this.$controlNode.hide();
      var iscroll = this.iscroll;
      //自动定位到上一位置
      if (iscroll.y > iscroll.wrapperHeight) {
        iscroll.scrollToElement(this.selectedChild);
      }
    }

    /**
     *  隐藏目录菜单
     */

  }, {
    key: '_hideDirMenu',
    value: function _hideDirMenu() {
      this.menu.style.display = 'none';
      //恢复顶部工具栏
      this.$controlNode.show();
      //移除模糊效果
      this.page.removeClass('filter');
    }

    /**
     *  创建目录内容
     */

  }, {
    key: '_getDirContent',
    value: function _getDirContent() {

      var Api = Xut.Presentation;
      var data = Api.GetAppSectionData();
      var sns = data[0];
      var seaonId = sns._id;
      var cids = Xut.data.Chapter;

      ////////////////////////////
      //针对book模式，合并了Season的参数 //
      //1 SeasonTitle
      //2 ChapterList列表的范围区间
      ////////////////////////////
      data = parseJSON(sns.parameter);

      if (!data) {
        console.log('book模式parameter数据出错');
        return;
      }

      //二级目录
      function secondaryDirectory(startCid, endCid) {
        var cid,
            str = '';
        for (startCid; startCid <= endCid; startCid++) {
          cid = cids.item(startCid - 1);
          if (cid && cid.chapterTitle) {
            str += '<section><a class="xut-book-menu-item" data-mark=' + seaonId + '-' + startCid + ' href="javascript:0">' + cid.chapterTitle + '</a></section>';
          }
        }
        return str;
      }

      var i = 0;
      var len = data.length;
      var li = '<li class="title"><center class="select">目录</center></li>';
      var seasonInfo, mark, seasonTitle, seaonId, startCid, endCid;

      for (i; i < len; i++) {
        seasonInfo = data[i];
        startCid = seasonInfo.ChapterList[0];
        endCid = seasonInfo.ChapterList[1];
        mark = seaonId + '-' + startCid;
        if (seasonInfo.SeasonTitle.length <= 0) continue;
        seasonTitle = seasonInfo.SeasonTitle || '第' + (i + 1) + '章';
        //第一级目录
        li += '<li>' + '<a class="xut-book-menu-item" data-mark="' + mark + '" href="javascript:0">' + seasonTitle + '</a>' +
        //第二级目录
        secondaryDirectory(startCid, endCid) + '</li>';
      }

      this.contentText = li;
    }

    /**
     * 突出显示点击颜色
     */

  }, {
    key: '_setColor',
    value: function _setColor(element) {
      if (this.selectedChild) {
        this.selectedChild.className = 'xut-book-menu-item';
      }
      if (!element || !this.menu) {
        return;
      }
      element = element || this.menu.querySelectorAll('li')[0].children[0];
      element.className = 'select';
      this.selectedChild = element;
    }

    /**
     * 跳转到指定书页
     */

  }, {
    key: '_turnToPage',
    value: function _turnToPage(target) {
      //忽略滚动点击
      if (this.isScrolled) return;
      this._setColor(target);
      this._hideDirMenu();
      var data = target.dataset.mark || '';
      if (data) {
        data = data.split('-');
        Xut.View.LoadScenario({
          'seasonId': data[0],
          'chapterId': data[1]
        });
      }
    }

    /**
     * 显示书签
     */

  }, {
    key: '_showBookMark',
    value: function _showBookMark() {
      if (this.bookMark) {
        this.bookMark.restore();
      } else {
        var pageData = Xut.Presentation.GetPageData();
        this.bookMark = new Mark({
          parent: this.$sceneNode,
          seasonId: pageData.seasonId,
          pageId: pageData._id
        });
      }
    }

    /**
     * 返回首页
     */

  }, {
    key: '_goBack',
    value: function _goBack() {
      var self = this;
      Xut.Application.Suspend({
        processed: function processed() {
          Xut.View.GotoSlide(1); //调整到首页
          self._setColor();
        }
      });
    }

    /**
     * 相应事件
     * @param  {[type]} e [description]
     * @return {[type]}   [description]
     */

  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      var target = e.target || e.srcElement;
      $handle({
        end: function end(e) {
          switch ($target(e).className) {
            case 'xut-icon-angle-left xut-icon-book-bar':
              this._goBack();
              //返回
              break;
            case 'xut-icon-th-list2':
            case 'xut-book-dirFont':
              //目录
              this._showDirMenu();
              break;
            case 'xut-icon-bookmark2':
            case 'xut-book-markFont':
              //书签
              this._showBookMark();
              break;
            case 'xut-book-bar-star':
              //评分
              break;
            case 'xut-book-menu-item':
              //跳转
              this._turnToPage(target);
              break;
            case 'xut-book-menu-mask':
            case 'select':
              this._hideDirMenu();
              break;
            default:
              // console.log(name+':undefined')
              break;
          }
        }
      }, this, e);
    }

    ////////////////////////
    ///  提供super接口
    ///////////////////////

    /**
     * 显示顶部工具栏
     * @return {[type]} [description]
     */

  }, {
    key: '_showTopBar',
    value: function _showTopBar() {
      var that = this;

      if (this.barStatus) {
        this.Lock = false;
        return;
      }

      this.$controlNode.css({
        'display': 'block',
        'opacity': 0
      });

      setTimeout(function () {
        that.$controlNode.transition({
          'opacity': 1
        }, that.delay, 'linear', function () {
          that._$$showSystemBar();
          that.barStatus = true;
          that.Lock = false;
        });
      }, 50);
    }

    /**
     * 隐藏顶部工具栏
     * @return {[type]} [description]
     */

  }, {
    key: '_hideTopBar',
    value: function _hideTopBar() {
      var that = this;

      if (!this.barStatus) {
        this.Lock = false;
        return;
      }

      this.$controlNode.transition({
        'opacity': 0
      }, that.delay, 'linear', function () {
        that.$controlNode.hide();
        that._$$hideSystemBar();
        that.barStatus = false;
        that.Lock = false;
      });
    }

    /**
     * 销毁
     */

  }, {
    key: '_destroy',
    value: function _destroy() {
      this.iscroll && this.iscroll.destroy();
      this.bookMark && this.bookMark.destroy();
      $off(this.$sceneNode);
      this.iscroll = null;
      this.menu = null;
      this.page = null;
    }

    ////////////////////////
    ///  对外接口
    ///////////////////////

    /**
     * 更新页码
     */

  }, {
    key: 'updatePointer',
    value: function updatePointer() {
      //预留
    }
  }]);
  return BookBar;
}(BarSuper);

/**
 * 迷你工具栏超类
 *$sceneNode: $sceneNode,
  visualIndex: pageIndex,
  pageTotal: getPageTotal()
 */

var MiniSuper = function () {
  function MiniSuper(pageBar, options) {
    classCallCheck(this, MiniSuper);

    this.pageBar = pageBar;
    for (var key in options) {
      this[key] = options[key];
    }
    this._$$template();
  }

  /**
   * 模板初始化
   * @return {[type]} [description]
   */


  createClass(MiniSuper, [{
    key: '_$$template',
    value: function _$$template() {
      var _this = this;

      this._init && this._init();
      this._parseBar && this._parseBar();
      var html = this._createHTML();
      if (html) {
        this.$container = $(String.styleFormat(html));
        this._getContextNode();
        this.status = true;
        Xut.nextTick(function () {
          _this._render();
        });
      }
    }
  }, {
    key: '_$$showlBar',
    value: function _$$showlBar() {
      this.status = true;
      this.$container.show();
    }
  }, {
    key: '_$$hideBar',
    value: function _$$hideBar() {
      this.status = false;
      this.$container.hide();
    }
  }, {
    key: '_$$update',
    value: function _$$update(action, index, time) {
      /*避免滚动页面重复更新*/
      if (this._visualIndex != index) {
        this._updateSingle(action, index, time);
      }
      this._visualIndex = index;
    }

    //==========================
    //        对外接口
    //==========================


  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._destroy) {
        this._destroy();
      }
      this.$sceneNode = null;
      this.$container = null;
    }
  }, {
    key: 'toggle',
    value: function toggle(state, pointer) {
      if (pointer !== 'pageNumber') return;
      switch (state) {
        case 'show':
          this._$$showlBar();
          break;
        case 'hide':
          this._$$hideBar();
          break;
        default:
          //默认：工具栏显示隐藏互斥处理
          this.status ? this._$$showlBar() : this._$$hideBar();
          break;
      }
    }

    /**
     * 更新页码
     */

  }, {
    key: 'updatePointer',
    value: function updatePointer(_ref) {
      var _ref$time = _ref.time,
          time = _ref$time === undefined ? 600 : _ref$time,
          action = _ref.action,
          direction = _ref.direction,
          parentIndex = _ref.parentIndex,
          _ref$hasSon = _ref.hasSon,
          hasSon = _ref$hasSon === undefined ? false : _ref$hasSon,
          _ref$sonIndex = _ref.sonIndex,
          sonIndex = _ref$sonIndex === undefined ? 0 : _ref$sonIndex;


      var chapterData = Xut.Presentation.GetPageData('page', parentIndex);

      //从正索引开始
      ++parentIndex;

      //没有column
      if (!hasColumn()) {
        this._$$update(action, parentIndex, time);
        return;
      }

      //默认，需要拿到前置的总和(出去当前)
      var beforeCount = getBeforeCount(chapterData.seasonId, chapterData._id);
      var updateIndex = parentIndex + beforeCount + sonIndex;

      //前翻页，需要叠加flow的总和
      if (direction === 'prev') {
        //前翻页：内部翻页
        if (hasSon) {
          updateIndex = parentIndex + beforeCount + sonIndex - 2;
        }
        //前翻页：外部往内部翻页，正好前一页是内部页，所以需要获取内部页总和
        else {
            //前翻页，需要拿到当期那到前置的总和
            updateIndex = parentIndex + getCurrentBeforeCount(chapterData.seasonId, chapterData._id);
          }
      }

      this._$$update(action, updateIndex, time);
    }
  }]);
  return MiniSuper;
}();

/**
 * 迷你杂志页面工具栏扩展
 * 数字类型
 */

var Digital = function (_MiniSuper) {
  inherits(Digital, _MiniSuper);

  function Digital(pageBar, options) {
    classCallCheck(this, Digital);
    return possibleConstructorReturn(this, (Digital.__proto__ || Object.getPrototypeOf(Digital)).call(this, pageBar, options));
  }

  createClass(Digital, [{
    key: '_createHTML',
    value: function _createHTML() {
      //存在模式3的情况，所以页码要处理溢出的情况。left值
      var right = 0;
      if (config.visualSize.overflowWidth) {
        right = Math.abs(config.visualSize.left * 2) + 'px';
      }
      return '<div class="xut-page-number" style="right:' + right + ';bottom:0;">\n                  <div>1</div>\n                  <strong>/</strong>\n                  <div>' + this.pageTotal + '</div>\n            </div>';
    }
  }, {
    key: '_getContextNode',
    value: function _getContextNode() {
      this.$currtNode = this.$container.find('div:first');
      this.$allNode = this.$container.find('div:last');
    }
  }, {
    key: '_render',
    value: function _render() {
      this.$sceneNode.append(this.$container);
    }

    /**
     * 更新单页
     */

  }, {
    key: '_updateSingle',
    value: function _updateSingle(action, updateIndex) {
      var _this2 = this;

      Xut.nextTick(function () {
        _this2.$currtNode.text(updateIndex);
        if (action === 'init') {
          _this2.$container.show();
        }
      });
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this.$currtNode = null;
      this.$allNode = null;
    }

    //==========================
    //        对外接口
    //==========================


    /**
     * 更新总页数
     */

  }, {
    key: 'updateTotal',
    value: function updateTotal(newTotalIndex) {
      /*更新数必须大于当前数*/
      if (newTotalIndex > this.pageTotal) {
        this.pageTotal = newTotalIndex;
        this.$allNode.text(newTotalIndex);
      }
    }
  }]);
  return Digital;
}(MiniSuper);

//样式类型
var dotStyleClass = ["xut-dotIcon-brightness_1", "xut-dotIcon-circle-full", "xut-dotIcon-cd", "xut-dotIcon-adjust", "xut-dotIcon-stop", "xut-dotIcon-record"];

/**
 * 迷你杂志页面工具栏扩展
 * 圆形类型
 */

var Circular = function (_MiniSuper) {
  inherits(Circular, _MiniSuper);

  function Circular(pageBar, options) {
    classCallCheck(this, Circular);
    return possibleConstructorReturn(this, (Circular.__proto__ || Object.getPrototypeOf(Circular)).call(this, pageBar, options));
  }

  /**
   * 解析参数
   * @return {[type]} [description]
   */


  createClass(Circular, [{
    key: "_parseBar",
    value: function _parseBar() {
      var pageBar = this.pageBar;
      //圆点模式样式
      this.dotStyle = Number(pageBar.mode) || 1;
      //样式
      this.dotStyleClass = dotStyleClass[this.dotStyle - 1];
      //位置
      if (pageBar.position) {
        var left = pageBar.position.left;
        var top = pageBar.position.top;
        var width = 'width:100%;';
        if (_.isUndefined(left)) {
          left = 'width:100%;text-align:center;';
        } else {
          width = "width:" + (100 - parseInt(left)) + "%;";
          left = "left:" + left + ";";
        }
        if (_.isUndefined(top)) {
          top = 'bottom:0;';
        } else {
          top = "top:" + top + ";";
        }
        this.position = "" + width + left + top;
      } else {
        this.position = "width:100%;text-align:center;bottom:0;margin-bottom:0.3rem";
      }
    }
  }, {
    key: "_createHTML",
    value: function _createHTML() {
      var dotString = '';
      var countPage = this.pageTotal;
      while (countPage--) {
        dotString += "<span class=\"slider-pager-page\"><i class= " + this.dotStyleClass + "></i></span>";
      }
      return "<div class=\"xut-page-number\" style=\"" + this.position + ";\">" + dotString + "</div>";
    }
  }, {
    key: "_getContextNode",
    value: function _getContextNode() {
      this.$currtNode = this.$container.find('span:first');
    }
  }, {
    key: "_render",
    value: function _render() {
      this.$sceneNode.append(this.$container);
    }

    /**
     * 更新单页
     */

  }, {
    key: "_updateSingle",
    value: function _updateSingle(action, updateIndex) {
      var _this2 = this;

      Xut.nextTick(function () {
        _this2.$container.find('span.slider-pager-page.active').removeClass('active');
        $(_this2.$container.find('span.slider-pager-page')[updateIndex - 1]).addClass("active");
        if (action === 'init') {
          _this2.$container.show();
        }
      });
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$currtNode = null;
    }

    //==========================
    //        对外接口
    //==========================

    /**
     * 更新总页数
     */

  }, {
    key: "updateTotal",
    value: function updateTotal(newTotalIndex) {
      if (newTotalIndex > this.pageTotal) {
        var visualIndex = 0;
        var span, iconi;
        _.each(this.$container.find('span.slider-pager-page'), function (value, index) {
          if (value.className != "slider-pager-page") {
            visualIndex = index;
          }
        });
        this.$container.empty();
        for (var i = 0; i < newTotalIndex; i++) {
          span = document.createElement('span');
          if (i == visualIndex) {
            span.className = "slider-pager-page active";
          } else {
            span.className = "slider-pager-page";
          }
          iconi = document.createElement('i');
          iconi.className = this.dotStyleClass;
          span.appendChild(iconi);
          this.$container.append(span);
        }
      }
    }
  }]);
  return Circular;
}(MiniSuper);

/**
 * 迷你杂志页面工具栏扩展
 * 卷滚类型
 */

var Scrollbar = function (_MiniSuper) {
  inherits(Scrollbar, _MiniSuper);

  function Scrollbar(pageBar, options) {
    classCallCheck(this, Scrollbar);
    return possibleConstructorReturn(this, (Scrollbar.__proto__ || Object.getPrototypeOf(Scrollbar)).call(this, pageBar, options));
  }

  createClass(Scrollbar, [{
    key: '_init',
    value: function _init() {
      this.visualHeight = config.visualSize.height;
      this.visualWidth = config.visualSize.width;
    }
  }, {
    key: '_parseBar',
    value: function _parseBar() {
      this.direction = this.pageBar.direction || config.launch.scrollMode;
    }
  }, {
    key: '_createHTML',
    value: function _createHTML() {
      //横向翻页
      if (this.direction == "h") {
        this.ratio = this.visualWidth / this.pageTotal;
        return '<div class="xut-iscroll-bar"\n                   style="height:.3rem;left: 2px; right: 2px; bottom: 1px; overflow: hidden;">\n                <div class="xut-iscroll-indicator" style="height: 100%;width: ' + this.ratio + 'px; "></div>\n             </div>';
      } else {
        this.ratio = this.visualHeight / this.pageTotal;
        return '<div class="xut-iscroll-bar"\n                   style="width:.3rem;bottom: 2px; top: 2px; right: 1px; overflow: hidden;">\n                <div class="xut-iscroll-indicator" style="width: 100%;height: ' + this.ratio + 'px;"></div>\n             </div>';
      }
    }

    /**
     * 获取卷滚条对象
     */

  }, {
    key: '_getContextNode',
    value: function _getContextNode() {
      this.$indicatorNode = this.$container.find('div:first');
      this.indicatorNode = this.$indicatorNode[0];
    }
  }, {
    key: '_render',
    value: function _render() {
      this.$sceneNode.append(this.$container);
    }
  }, {
    key: '_setTranslate',
    value: function _setTranslate() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      Xut.style.setTranslate({ x: x, y: y, speed: speed, node: this.indicatorNode });
    }
  }, {
    key: '_updateTranslate',
    value: function _updateTranslate(updateIndex, speed) {
      if (this.indicatorNode) {
        var distance = void 0;
        if (this.direction == "h") {
          distance = this.visualWidth * (updateIndex - 1) / this.pageTotal;
          this._setTranslate(distance, 0, speed);
        } else {
          distance = this.visualHeight * (updateIndex - 1) / this.pageTotal;
          this._setTranslate(0, distance, speed);
        }
        this.baesTranslateY = this.initTranslateY = distance;
      }
    }
  }, {
    key: '_clearTimer',
    value: function _clearTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }

    /**
     * 更新单页
     * PPT页面更新
     */

  }, {
    key: '_updateSingle',
    value: function _updateSingle(action, updateIndex, speed) {
      var _this2 = this;

      if (this.barState === 'hide') {
        this.showBar();
      }

      if (!this.timer) {
        this.timer = setTimeout(function () {
          _this2.hideBar();
        }, 1500);
      }

      /*初始化处理*/
      if (action === 'init') {
        this._updateTranslate(updateIndex, 0);
        this.$container.show();
      } else {
        /*边界处翻页处理*/
        this._updateTranslate(updateIndex, speed);
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._clearTimer();
      this.$indicatorNode = null;
      this.indicatorNode = null;
    }

    //==========================
    //        对外接口
    //==========================


    /**
     * Flow内部滚动
     * 内部滑动页面操作
     * 更新坐标
     */

  }, {
    key: 'updatePosition',
    value: function updatePosition(scrollY) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var action = arguments[2];

      var distance = void 0;
      /*向下*/
      if (action === 'down') {
        distance = scrollY + this.initTranslateY;
        this.preTranslateY = distance;
        /*清楚上滑动的参考基础值*/
        this.baesTranslateY = null;
      }
      /*向上*/
      if (action === 'up') {
        /*preTranslateY的值是一直在变化的，但是每次改变其实只要拿到最后一次值，当做基础值设置*/
        if (!this.baesTranslateY) {
          this.baesTranslateY = this.preTranslateY;
        }
        distance = this.baesTranslateY - scrollY;
        this.preTranslateY = distance;
      }
      this._setTranslate(0, distance, time);
    }

    /*显示滚动条*/

  }, {
    key: 'showBar',
    value: function showBar() {
      if (this.barState === 'hide') {
        this.$indicatorNode.css('opacity', 1);
        this.barState = 'show';
      }
    }

    /*隐藏滚动条*/

  }, {
    key: 'hideBar',
    value: function hideBar() {
      this.barState = 'hide';
      this.$indicatorNode.transition({
        opacity: 0,
        duration: 1500,
        easing: 'in'
      });
      this._clearTimer();
    }

    /**
     * 更新总页数
     * flow数据开始不完全，动态补全后重新处理
     */

  }, {
    key: 'updateTotal',
    value: function updateTotal(newTotalIndex) {
      /*更新数必须大于当前数*/
      if (newTotalIndex > this.pageTotal) {
        this.pageTotal = newTotalIndex;
        /*更新基数*/
        if (this.direction == "h") {
          this.ratio = this.visualWidth / this.pageTotal;
          this.$indicatorNode.css('width', this.ratio);
        } else {
          this.ratio = this.visualHeight / this.pageTotal;
          this.$indicatorNode.css('height', this.ratio);
        }
      }
    }
  }]);
  return Scrollbar;
}(MiniSuper);

var matchBar = {
  Digital: Digital,
  Circular: Circular,
  Scrollbar: Scrollbar
};

var create$1 = function create(type, pageBar, options) {
  type = titleCase(type);
  options.type = type;
  //digital
  //circular
  //scrollbar
  if (matchBar[type]) {
    return new matchBar[type](pageBar, options);
  } else {
    /*默认发送数字显示类型*/
    return new Digital(pageBar, options);
  }
};

/**
 * 迷你杂志页面工具栏
 */
function MiniBar() {
  var pageBar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments[1];

  var arr = [];
  /*多个*/
  if (_.isArray(pageBar.type)) {
    for (var i = 0; i < pageBar.type.length; i++) {
      arr.push(create$1(pageBar.type[i], pageBar, options));
    }
  } else {
    /**单个 */
    arr.push(create$1(pageBar.type, pageBar, options));
  }
  return arr;
}

/**
 * 秒秒学定制工具栏
 */
/**
 * 全局工具栏
 */

var GlobalBar = function () {
  function GlobalBar() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        $sceneNode = _ref.$sceneNode,
        pageTotal = _ref.pageTotal,
        currentPage = _ref.currentPage;

    classCallCheck(this, GlobalBar);

    this.$sceneNode = $sceneNode;
    this.pageTotal = pageTotal;
    this.currentPage = currentPage;
    this._init();
  }

  createClass(GlobalBar, [{
    key: '_init',
    value: function _init() {
      //标记最大的索引号
      this._maxIndex = 0;
      this._initData();
      this._initContainer();
      this._leftView();
      this._centerView();
      this._rightView();
      this._bindEvent();
      this._bindWatch();
      this.pageElement = this.container.find('.g-page .g-page-current');
      this.$sceneNode.append(this.container);
      config.launch.pageBar.height = config.visualSize.height - this.container.offset().top;
    }

    /**
     * 绑定监听
     * @return {[type]} [description]
     */

  }, {
    key: '_bindWatch',
    value: function _bindWatch() {

      var self = this;

      /**
       * 设置小圆点的变化
       */
      function setDot(className) {
        //通过接收外部的状态
        //修改本身的圆点
        //data.dot /show /hide
        var dotStatus = 'hide'; //默认隐藏
        var element = self.container.find(className);
        return function (pageIndex, newState, className) {
          //只处理当前页面
          if (pageIndex && pageIndex == self.currentPage) {
            if (newState && newState !== dotStatus) {
              if (newState === 'show') {
                element.removeClass(className + '-defalut');
                element.addClass(className + '-message');
              }
              if (newState === 'hide') {
                element.removeClass(className + '-message');
                element.addClass(className + '-defalut');
              }
              dotStatus = newState; //更新状态
            }
          }
        };
      }

      if (this.bottomConfig) {
        //如果配置了答题讨论
        //才提供可更新
        if (this.bottomConfig.forum) {
          var updateDot = setDot('.g-forum-click');
          Xut.Application.Watch('globalForumDot', function (data) {
            updateDot(data.pageIndex, data.dot, 'forum');
          });
        }

        //提交作业
        if (this.bottomConfig.commitWork) {
          var _updateDot = setDot('.g-work-click');
          Xut.Application.Watch('globalCommitWorkDot', function (data) {
            _updateDot(data.pageIndex, data.dot, 'commitWork');
          });
        }
      }

      //停止关闭下一个翻页箭头控制
      Xut.Application.Watch('enableFlip', function (pageIndex) {
        self._directionArrows && self._directionArrows.resetNext(pageIndex);
      });
    }

    /**
     * 绑定事件
     * @return {[type]} [description]
     */

  }, {
    key: '_bindEvent',
    value: function _bindEvent() {
      var self = this;
      $on(this.container, {
        end: function end(event) {
          event.stopPropagation();
          //有3个按钮样式有多个样式
          //只取第一个
          var classNames = event.target.className.split(' ');
          switch (classNames[0]) {
            case "g-cover":
              //回主页
              Xut.View.GotoSlide(1);
              break;
            case "g-dir":
              //打开目录
              Xut.Assist.GlobalDirToggle();
              break;
            case "g-prev":
              Xut.View.GotoPrevSlide();
              break;
            case "g-next":
              //如果不允许跳转
              if (~event.target.parentNode.className.indexOf('g-direction-end')) {
                return;
              }
              Xut.View.GotoNextSlide();
              break;
            case "g-learn-click":
              //继续学习
              if (classNames[1] === 'on-click') {
                //必须要可点击
                Xut.Assist.GlobalKeepLearn();
              }
              break;
            case "g-work-click":
              //提交作业
              Xut.Assist.GlobalCommitWork();
              break;
            case "g-forum-click":
              //答题讨论
              Xut.Assist.GlobalForumToggle();
              break;
          }
        }
      });
    }
  }, {
    key: '_initData',
    value: function _initData() {
      this.learnButtonClassName = ''; //学习按钮的样式
      //工具栏的高度
      this.barHeight = config.launch.pageBar.bottom || Math.round(config.visualSize.height / 17);
    }

    /**
     * 容器
     * @return {[type]} [description]
     */

  }, {
    key: '_initContainer',
    value: function _initContainer() {
      this.container = $('<ul class="xut-global-bar"></ul>');
    }

    /**
     * 左边区域
     * @return {[type]} [description]
     */

  }, {
    key: '_leftView',
    value: function _leftView() {
      var html = '<li class="g-left">\n          <div><a class="g-dir"></a></div>\n          <div><a class="g-cover"></a></div>\n       </li>';
      this.container.append(String.styleFormat(html));
    }

    /**
     * 中间区域，拼接问题
     * 所以合并到一个li中
     * @return {[type]} [description]
     */

  }, {
    key: '_centerView',
    value: function _centerView() {

      var html = '<li class="g-center g-direction-first">\n         <div class="g-prev g-prev-noclick"></div>\n         <div class="g-title"><a>' + (config.launch.pageBar.title || config.data.shortName) + '</a></div>\n         <div class="g-next g-next-noclick"></div>\n       </li>';

      this.container.append(String.styleFormat(html));

      var self = this;

      /**
       * 根据页面的类型
       * 设置是否显示下一页箭头可点击
       * 必须要练习题页面
       */
      function setNextArrows(rootElement, pageIndex) {
        var pb = Xut.Presentation.GetPageBase(self.currentPage - 1);
        //如果已经游览过的页面
        //跳过设置
        if (self._maxIndex >= pageIndex) {
          return false;
        }
        if (pb && pb.pageAttr === 'practicepage') {
          rootElement.addClass('g-direction-end');
          return true;
        }
      }

      //控制按钮状态
      function setIcon() {
        var rootElement = self.container.find('.g-center');
        var isFirst = true;
        var isEnd = true;
        var addClass = function addClass(className) {
          return rootElement.addClass(className);
        };
        var removeClass = function removeClass(className) {
          return rootElement.removeClass(className);
        };
        return {
          /**
           * 设置默认状态
           */
          default: function _default(pageIndex) {
            //每次都复位练习，重新设置题状态
            //默认下一页箭头显示
            var nextArrowsShow = true;
            //首页
            if (self.currentPage === 1) {
              if (isEnd) {
                //直接重尾页跳到首页
                isEnd = false;
                removeClass('g-direction-end');
              }
              isFirst = true;
              addClass('g-direction-first');
            }
            //尾页
            else if (self.currentPage === self.pageTotal) {
                if (isFirst) {
                  //直接重首页跳到尾页
                  isFirst = false;
                  removeClass('g-direction-first');
                }
                isEnd = true;
                addClass('g-direction-end');
              } else {

                //如果是练习题就标记
                //否则就还清状态
                if (setNextArrows(rootElement, pageIndex)) {
                  nextArrowsShow = false;
                }

                //中间页面
                if (isFirst) {
                  isFirst = false;
                  removeClass('g-direction-first');
                }

                if (isEnd) {
                  isEnd = false;
                  removeClass('g-direction-end');
                }

                if (nextArrowsShow) {
                  //如果显示下一页箭头
                  removeClass('g-direction-end');
                } else {
                  //隐藏下一页箭头
                  addClass('g-direction-end');
                }
              }
          },
          /**
           * 重设下一页状态
           */
          resetNext: function resetNext(pageIndex) {
            self._maxIndex = ++pageIndex;
            //如果不是尾页设置
            if (self.currentPage !== self.pageTotal) {
              removeClass('g-direction-end');
            }
          }
        };
      }

      //控制方向图片
      //前进或者后退
      this._directionArrows = setIcon();
    }

    /**
     * 获取学习按钮的状态
     */

  }, {
    key: '_getLearnButtonClassName',
    value: function _getLearnButtonClassName() {
      //如果是最后一页或倒数第二页，允许点击
      if (this.currentPage >= this.pageTotal - 1) {
        return 'on-click';
      }
      return 'no-click';
    }

    /**
     * 设置学习按钮
     */

  }, {
    key: '_setLearnButton',
    value: function _setLearnButton() {
      //如果状态不对，就需要重新设置
      var className = this._getLearnButtonClassName();
      if (className !== this.learnButtonClassName) {
        var element = this.container.find('.g-learn-click');
        //移除旧样式 增加新的
        element.removeClass(this.learnButtonClassName);
        element.addClass(className);
        this.learnButtonClassName = className;
      }
    }

    /**
     * 右边区域
     * @return {[type]} [description]
     */

  }, {
    key: '_rightView',
    value: function _rightView() {
      //根据iframe的配置，确定是否显示继续学习
      //如果没有则占空位
      var button = this.bottomConfig = config.launch.pageBar && config.launch.pageBar.button;

      var goLearnHtml = '';
      var commitWorkHtml = '';
      var forumHTML = '';

      if (button) {
        //下一节，继续学习
        if (button.keepLearn) {
          var getLearn = function getLearn(clickClass) {
            return '<div class="g-learn"><a class="g-learn-click ' + clickClass + '"></a></div>';
          };
          //如果是最后一页或倒数第二页，允许点击


          if (this._getLearnButtonClassName() === 'on-click') {
            this.learnButtonClassName = 'on-click';
            goLearnHtml = getLearn('on-click');
          } else {
            this.learnButtonClassName = 'no-click';
            goLearnHtml = getLearn('no-click');
          }
        }

        //提交作业
        if (button.commitWork) {
          //commitWork-defalut commitWork-message
          commitWorkHtml = '<div class="g-work"><a class="g-work-click commitWork-defalut"></a></div>';
        }

        //答题讨论
        if (button.forum) {
          forumHTML = '<div class="g-forum"><a class="g-forum-click forum-defalut"></a></div>';
        }
      }

      var html = '<li class="g-right">\n          <div class="g-page">\n            <div>\n              <a class="g-page-current">' + this.currentPage + '</a>\n              <a>' + this.pageTotal + '</a>\n            </div>\n          </div>\n          ' + forumHTML + '\n          ' + commitWorkHtml + '\n          ' + goLearnHtml + '\n       </li>';
      this.container.append(String.styleFormat(html));
    }

    /**
     * 更新页码
     * @return {[type]} [description]
     */

  }, {
    key: 'updatePointer',
    value: function updatePointer(_ref2) {
      var parentIndex = _ref2.parentIndex;

      ++parentIndex; //从1开始索引，parentIndex默认从0开始
      if (parentIndex !== undefined && parentIndex !== this.currentPage) {
        this.currentPage = parentIndex;
        this.pageElement.html(parentIndex);
        this._setLearnButton();
      }

      //首尾，控制方向图片
      this._directionArrows.default(parentIndex);

      //每次翻页需要圆点状态请求
      if (this.bottomConfig) {
        if (this.bottomConfig.forum) {
          Xut.Assist.RequestDot('forumDot', this.currentPage);
        }
        if (this.bottomConfig.commitWork) {
          Xut.Assist.RequestDot('commitWorkDot', this.currentPage);
        }
      }
    }

    /**
     * 销毁
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      Xut.Application.unWatch('globalForumDot');
      Xut.Application.unWatch('globalCommitWorkDot');
      Xut.Application.unWatch('enableFlip');
      this._directionArrows = null;
      $off(this.container);
      this.$sceneNode = null;
      this.container = null;
      this.pageElement = null;
    }
  }]);
  return GlobalBar;
}();

/**
 *
 * 配置工具栏行为
 *  1.  工具栏类型
 *  tbType：(如果用户没有选择任何工具栏信息处理，tbType字段就为空)
 *   0  禁止工具栏
 *   1  系统工具栏   - 显示IOS系统工具栏
 *   2  场景工具栏   - 显示关闭按钮
 *   3  场景工具栏   - 显示返回按钮
 *   4  场景工具栏   - 显示顶部小圆点式标示
 *
 *  2.  翻页模式
 *  pageMode：(如果用户没有选择任何处理，pageMode字段就为空)
 *   0 禁止滑动
 *   1 允许滑动无翻页按钮
 *   2 允许滑动带翻页按钮
 *
 * @return {[type]} [description]
 */

/**
 * 分解工具栏配置文件
 */
function parseTooBar(toolbar, toolType, pageMode) {
  if (toolbar = parseJSON(toolbar)) {
    //兼容数据库中未指定的情况
    var n = Number(toolbar.pageMode);
    pageMode = _.isFinite(n) ? n : pageMode;
    if (_.isString(toolbar.tbType)) {
      toolType = _.map(toolbar.tbType.split(','), function (num) {
        return Number(num);
      });
    }
  }
  return {
    'toolType': toolType,
    'pageMode': pageMode
  };
}

/**
 * 主场景工具栏配置
 * pageMode:默认2 允许滑动,带翻页按钮
 */
function getMainBar(seasonId) {
  var related = Xut.data.query('sectionRelated', seasonId);

  //默认显示系统工具栏
  var toolType = [1];

  /*如果有多页面，就允许滑动，带翻页按钮
    如果没有多页面，0禁止滑动*/
  var pageMode = related.length > 1 ? 2 : 0;
  return parseTooBar(related.toolbar, toolType, pageMode);
}

/**
 * 副场景工具栏配置
 * pageMode 是否支持滑动翻页  0禁止滑动 1允许滑动
 * toolType   工具栏显示的类型 [0-5]
 */
function getDeputyBar(toolbar, totalCount) {
  var toolType = [0];

  /*如果有多页面，就允许滑动，但是不带翻页按钮
    如果没有多页面，0禁止滑动*/
  var pageMode = totalCount > 1 ? 1 : 0;
  return parseTooBar(toolbar, toolType, pageMode);
}

/**
 * 布局文件
 * 1 控制条
 * 2 导航栏
 * @param  {[type]} config [description]
 * @return {[type]}        [description]
 */
var round$2 = Math.round;
var ratio$1 = 6;
var isIOS$5 = Xut.plat.isIOS;
var TOP$1 = isIOS$5 ? 20 : 0;

/**
 * 主场景
 * @return {[type]} [description]
 */
function mainScene() {
  var layoutMode = config.layoutMode,
      iconHeight = config.iconHeight,
      proportion = config.proportion,
      screenSize = config.screenSize,
      visualSize = config.visualSize,
      originalVisualSize = config.originalVisualSize;
  var sWidth = visualSize.sWidth,
      sHeight = visualSize.sHeight;

  var isHorizontal = layoutMode == 'horizontal';

  proportion = isHorizontal ? proportion.width : proportion.height;
  iconHeight = isIOS$5 ? iconHeight : round$2(proportion * iconHeight);

  var navBarWidth = void 0;
  var navBarHeight = void 0;
  if (isHorizontal) {
    navBarWidth = '100%';
    navBarHeight = round$2(sHeight / ratio$1);
  } else {
    if (sHeight) {
      navBarWidth = Math.min(sWidth, sHeight) / (isIOS$5 ? 8 : 3) + 'px';
      navBarHeight = round$2((sHeight - iconHeight - TOP$1) * 0.96);
    }
  }

  var navBarTop = isHorizontal ? '' : 'top:' + (iconHeight + TOP$1 + 2) + 'px;';
  var navBarLeft = isHorizontal ? '' : 'left:' + iconHeight + 'px;';
  var navBarBottom = isHorizontal ? 'bottom:4px;' : '';
  var navBaroOverflow = isHorizontal ? 'hidden' : 'visible';

  //导航
  var navBarHTML = void 0;
  if (navBarWidth || navBarHeight) {
    navBarHTML = '<div class="xut-nav-bar"\n          style="width:' + navBarWidth + ';\n                 height:' + (navBarHeight || 0) + 'px;\n                 ' + navBarTop + '\n                 ' + navBarLeft + '\n                 ' + navBarBottom + '\n                 background-color:white;\n                 border-top:1px solid rgba(0,0,0,0.1);\n                 overflow:' + navBaroOverflow + ';">\n    </div>';
  } else {
    navBarHTML = '<div class="xut-nav-bar"></div>';
  }

  //如果启动了双页模式
  //那么可视区的宽度是就是全屏的宽度了，因为有2个页面拼接
  var width = config.launch.doublePageMode ? screenSize.width : visualSize.width;

  //如果有拼接的页面高度
  //这边是为秒秒学处理的
  var style = '';
  if (config.launch.pageBar && config.launch.pageBar.bottom) {
    style = 'style="height:' + visualSize.height + 'px;"';
  }

  //2017.12.4
  //新增全局工具栏容器
  return String.styleFormat('<div id="xut-main-scene"\n          style="width:' + width + 'px;\n                 height:' + screenSize.height + 'px;\n                 top:0;\n                 left:' + originalVisualSize.left + 'px;\n                 position:absolute;\n                 z-index:' + sceneController.createIndex() + ';\n                 overflow:hidden;">\n\n        <ul id="xut-page-container" class="xut-flip" ' + style + '></ul>\n        <ul id="xut-master-container" class="xut-master xut-flip" ' + style + '></ul>\n        <div class="xut-control-bar"></div>\n        <div class="xut-tool-tip"></div>\n        ' + navBarHTML + '\n    </div>');
}

/**
 * 副场景
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
function deputyScene(id) {
  var visualSize = config.visualSize,
      originalVisualSize = config.originalVisualSize;


  return String.styleFormat('<div id="' + ('scenario-' + id) + '"\n          style="width:' + visualSize.width + 'px;\n                 height:100%;\n                 top:0;\n                 left:' + originalVisualSize.left + 'px;\n                 z-index:' + sceneController.createIndex() + ';\n                 position:absolute;\n                 overflow:hidden;">\n        <ul id="' + ('scenarioPage-' + id) + '" class="xut-flip" style="z-index:2"></ul>\n        <ul id="' + ('scenarioMaster-' + id) + '" class="xut-flip" style="z-index:1"></ul>\n    </div>');
}

/**
 * 找到对应容器
 */
function findContainer($context, id, isMain) {
  return function (pane, parallax) {
    var node;
    if (isMain) {
      node = '#' + pane;
    } else {
      node = '#' + parallax + id;
    }
    return $context.find(node)[0];
  };
}

/**
 * 如果启动了缓存记录
 * 加载新的场景
 */
function checkHistory(history, callback) {

  //直接启用快捷调试模式
  if (config.debug.locationPage) {
    console.log('启动了debug.locationPage,如果进不去，需要检测定位的坐标');
    Xut.View.LoadScenario(config.debug.locationPage, callback);
    return;
  }

  //如果有历史记录
  if (history) {
    var scenarioInfo = sceneController.seqReverse(history);
    if (scenarioInfo) {
      scenarioInfo = scenarioInfo.split('-');
      Xut.View.LoadScenario({
        'seasonId': scenarioInfo[0],
        'chapterId': scenarioInfo[1],
        'pageIndex': scenarioInfo[2]
      }, callback);
      return;
    }
  }

  //正常模式
  callback();
}

/**
 * 场景创建类
 */
var SceneFactory = function () {
  function SceneFactory(data) {
    var _this = this;

    classCallCheck(this, SceneFactory);

    var options = _.extend(this, data);
    //创建主场景
    this._createHTML(options, function () {
      if (!Xut.IBooks.Enabled) {
        _this._initToolBar();
      }
      _this._createMediator();

      //主场景有历史记录，并且没有chapterId的时候
      //主动赋值，因为没有读取数据
      if (data.isMain && data.history && !data.chapterId) {
        data.chapterId = 1;
      }

      sceneController.add(data.seasonId, data.chapterId, _this);
    });
  }

  /**
   * 创建场景
   * @return {[type]} [description]
   */


  createClass(SceneFactory, [{
    key: '_createHTML',
    value: function _createHTML(options, callback) {
      //如果是静态文件执行期
      //支持Xut.IBooks模式
      //都不需要创建节点
      if (Xut.IBooks.runMode()) {
        this.$sceneNode = $('#xut-main-scene');
        callback();
        return;
      }
      this.$sceneNode = $(options.isMain ? mainScene() : deputyScene(this.seasonId));
      Xut.nextTick({
        'container': $('.xut-scene-container'),
        'content': this.$sceneNode
      }, callback);
    }

    /**
     * 初始化工具栏
     * @return {[type]} [description]
     */

  }, {
    key: '_initToolBar',
    value: function _initToolBar() {
      var seasonId = this.seasonId,
          pageTotal = this.pageTotal,
          pageIndex = this.pageIndex,
          $sceneNode = this.$sceneNode;


      _.extend(this, this._initDefaultBar(pageIndex, pageTotal, $sceneNode, seasonId));

      this._initMiniBar(pageIndex, pageTotal, $sceneNode);
      this._initGlobalbar(pageIndex, pageTotal, $sceneNode);
    }

    /**
     * 初始化传统工具栏
     * 1 主场景，系统工具栏
     * 2 副场景，函数工具栏
     */

  }, {
    key: '_initDefaultBar',
    value: function _initDefaultBar(pageIndex, pageTotal, $sceneNode, seasonId) {

      //配置文件
      var barConfig = {};

      ///////////////////
      /// 主场景工具栏设置
      //////////////////
      if (this.isMain) {

        barConfig = getMainBar(seasonId, pageTotal);

        //word模式，自动启动工具条
        //秒秒学中会使用
        // if (config.launch.visualMode === 1) {
        //   this.mainToolbar = new BookBar({
        //     $sceneNode: $sceneNode,
        //     arrowButton: barConfig.pageMode === 2
        //   })
        // }
        //如果工具栏提供可配置选项
        //或者pageMode带有翻页按钮
        if (_.some(barConfig.toolType)) {
          this.mainToolbar = new IosBar({
            $sceneNode: $sceneNode,
            pageTotal: pageTotal,
            currentPage: pageIndex + 1,
            toolType: barConfig.toolType,
            arrowButton: barConfig.pageMode === 2
          });
        }
      } else {
        ///////////////////
        /// 副场工具栏配置
        //////////////////
        barConfig = getDeputyBar(this.barInfo, pageTotal);
        if (_.some(barConfig.toolType)) {
          this.deputyToolbar = new fnBar({
            $sceneNode: $sceneNode,
            toolType: barConfig.toolType,
            pageTotal: pageTotal,
            currentPage: pageIndex,
            arrowButton: barConfig.pageMode === 2
          });
        }
      }

      return barConfig;
    }

    /**
     * 初始化全局工具栏，秒秒学
     * 2017.12.4
     * @return {[type]} [description]
     */

  }, {
    key: '_initGlobalbar',
    value: function _initGlobalbar(pageIndex, pageTotal, $sceneNode) {
      if (config.launch.pageBar && config.launch.pageBar.type === 'globalBar') {
        this.globalToolbar = new GlobalBar({
          $sceneNode: $sceneNode,
          pageTotal: pageTotal,
          currentPage: pageIndex + 1
        });
      }
    }

    /**
     * 初始化迷你工具栏
     * 1 全场景，页码显示（右下角）
     * 2 星星显示
     * 3 滚动条
     * @return {[type]} [description]
     */

  }, {
    key: '_initMiniBar',
    value: function _initMiniBar(pageIndex, pageTotal, $sceneNode) {
      var _this2 = this;

      //2016.9.29
      //新增页码显示
      //如果有分栏
      var columnCounts = getColumnCount$1(this.seasonId);

      //如果是min平台强制启动
      if (config.launch.platform === 'mini' || config.debug.toolType.number !== false && columnCounts) {

        //获取页面总数
        var getPageTotal = function getPageTotal(again) {
          if (again) {
            //高度变化后，重新获取
            columnCounts = getColumnCount$1(_this2.seasonId);
          }
          var columnChapterCount = 0;
          if (columnCounts) {
            columnChapterCount = getColumnChapterCount(_this2.seasonId);
          }
          return columnCounts ? pageTotal + columnCounts - columnChapterCount : pageTotal;
        };

        this.miniBar = MiniBar(config.launch.pageBar, {
          $sceneNode: $sceneNode,
          visualIndex: pageIndex,
          pageTotal: getPageTotal()
        });

        //页面总数改变
        if (config.launch.columnCheck) {
          Xut.Application.Watch('change:number:total', function () {
            _this2._eachMiniBar(function () {
              this.updateTotal(getPageTotal(true));
            });
          });
        }
      }
    }

    /**
     * minibar可能是一个合集对象
     * 可以同时存在的可能
     */

  }, {
    key: '_eachMiniBar',
    value: function _eachMiniBar(callback) {
      if (this.miniBar) {
        this.miniBar.forEach(function (bar) {
          callback.call(bar);
        });
      }
    }

    /**
     * 构建创建对象
     * @return {[type]} [description]
     */

  }, {
    key: '_createMediator',
    value: function _createMediator() {
      var _this3 = this;

      var isMain = this.isMain,
          $sceneNode = this.$sceneNode,
          seasonId = this.seasonId,
          pageTotal = this.pageTotal,
          pageIndex = this.pageIndex;


      var tempfind = findContainer($sceneNode, seasonId, isMain);
      var scenePageNode = tempfind('xut-page-container', 'scenarioPage-');
      var sceneMasterNode = tempfind('xut-master-container', 'scenarioMaster-');

      Xut.$warn({
        type: 'create',
        content: '\u521B\u5EFA\u65B0\u573A\u666F,\n      seasonId:' + seasonId + ',\n      chapterId:' + this.chapterId + ',\n      pageIndex:' + pageIndex + ',\n      pageTotal:' + pageTotal
      });

      //场景容器对象
      var $$mediator = this.$$mediator = new Mediator({
        scenePageNode: scenePageNode,
        sceneMasterNode: sceneMasterNode,
        isMain: isMain, //是否为主场景
        'hasHistory': this.history, //有历史记录
        'pageMode': this.pageMode,
        'sceneNode': this.$sceneNode[0],
        'hasMultiScene': !isMain,
        'initIndex': pageIndex, //保存索引从0开始
        'pageTotal': pageTotal,
        'sectionRang': this.sectionRang,
        'seasonId': seasonId,
        'chapterId': this.chapterId,
        'isInApp': this.isInApp //提示页面
      });

      $$mediator.miniBar = this.miniBar;

      /**
       * 配置选项
       */
      var pptBar = this.pptBar = this.deputyToolbar ? this.deputyToolbar : this.mainToolbar;

      /**
       * 监听翻页
       * 用于更新页码
       *   parentIndex  父索引
       *   subIndex     子索引
       * @return {[type]} [description]
       */
      $$mediator.$bind('updatePage', function () {
        var _globalToolbar;

        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
          arg[_key] = arguments[_key];
        }

        pptBar && pptBar.updatePointer.apply(pptBar, arg);
        _this3.globalToolbar && (_globalToolbar = _this3.globalToolbar).updatePointer.apply(_globalToolbar, arg);
        _this3._eachMiniBar(function () {
          this.updatePointer.apply(this, arg);
        });
      });

      /**
       * 显示下一页按钮
       */
      $$mediator.$bind('showNext', function () {
        pptBar && pptBar.showNext();
      });

      /**
       * 隐藏下一页按钮
       */
      $$mediator.$bind('hideNext', function () {
        pptBar && pptBar.hideNext();
      });

      /**
       * 显示上一页按钮
       */
      $$mediator.$bind('showPrev', function () {
        pptBar && pptBar.showPrev();
      });

      /**
       * 隐藏上一页按钮
       */
      $$mediator.$bind('hidePrev', function () {
        pptBar && pptBar.hidePrev();
      });

      /**
       * 切换工具栏
       * state, pointer
       */
      $$mediator.$bind('toggleToolbar', function () {
        for (var _len2 = arguments.length, arg = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          arg[_key2] = arguments[_key2];
        }

        pptBar && pptBar.toggle.apply(pptBar, arg);
        _this3._eachMiniBar(function () {
          this.toggle.apply(this, arg);
        });
      });

      /**
       * 复位工具栏
       */
      $$mediator.$bind('resetToolbar', function () {
        if (_this3.mainToolbar) {
          _this3.mainToolbar.resetArrow(); //左右翻页按钮
          _this3.mainToolbar.hideNavbar(); //导航栏
        }
      });

      /**
       * 获取滚动条对象
       */
      $$mediator.$bind('getMiniBar', function () {
        return _this3.miniBar;
      });

      /**
       * 监听内部管理页面创建完成
       */
      $$mediator.$bind('createPageComplete', function (nextAction) {

        Xut.$warn({
          type: 'create',
          content: '\u521B\u5EFA\u65B0\u573A\u666F\u5B8C\u6210,seasonId:' + seasonId
        });

        //主场景
        if (isMain) {
          //1 回到SceneFactory处理完成，历史记录
          //2 回调View接口处理销毁
          //3 回调main入口处理回调
          _this3.complete(function () {
            Xut.View.HideBusy();
            //检测是不是有缓存加载
            checkHistory(_this3.history, function () {
              //第一次加载应用
              if (window.GLOBALIFRAME) {
                removeCover(nextAction);
                return;
              }
              //获取应用的状态
              if (Xut.Application.getAppState()) {
                //保留启动方法
                var pre = Xut.Application.LaunchApp;
                Xut.Application.LaunchApp = function () {
                  pre();
                  removeCover(nextAction);
                };
              } else {
                removeCover(nextAction);
              }
            });
          });
          return;
        }
        //副场景切换
        _this3.complete(nextAction);
      });

      /**
       * 必须要延时下，让this加入对象管理器
       */
      setTimeout(function () {
        //如果是读酷端加载
        if (window.DUKUCONFIG && isMain && window.DUKUCONFIG.success) {
          window.DUKUCONFIG.success();
          $$mediator.$init();
          //如果是客户端加载
        } else if (window.CLIENTCONFIGT && isMain && window.CLIENTCONFIGT.success) {
          window.CLIENTCONFIGT.success();
          $$mediator.$init();
        } else {
          //正常加载
          $$mediator.$init();
        }
      }, 100);
    }

    /**
     * 获取场景根节点
     * @return {[type]} [description]
     */

  }, {
    key: 'getSceneNode',
    value: function getSceneNode() {
      return this.$sceneNode;
    }

    /**
     * 销毁场景对象
     * @return {[type]} [description]
     */

  }, {
    key: 'destroy',
    value: function destroy() {

      if (config.launch.columnCheck) {
        Xut.Application.unWatch('change:number:total');
      }

      //销毁工具栏
      if (this.pptBar) {
        this.pptBar.destroy();
        this.pptBar = null;
      }
      this._eachMiniBar(function () {
        this.destroy();
      });
      if (this.globalToolbar) {
        this.globalToolbar.destroy();
        this.globalToolbar = null;
      }

      this.$$mediator.miniBar = null;

      //销毁当前场景
      this.$$mediator.$destroy();

      //销毁节点
      this.$sceneNode.off();
      this.$sceneNode.remove();
      this.$sceneNode = null;

      //销毁引用
      sceneController.remove(this.seasonId);
    }
  }]);
  return SceneFactory;
}();

function initView() {

  //重复点击
  var repeatClick = false;

  /**
   * 忙碌光标
   * */
  $extend(Xut.View, {
    'ShowBusy': showBusy,
    'HideBusy': hideBusy,
    'ShowTextBusy': showTextBusy
  });

  /**
   * 关闭场景
   */
  Xut.View.CloseScenario = function () {
    if (repeatClick) return;
    repeatClick = true;
    var serial = sceneController.takeOutPrevChainId();
    Xut.View.LoadScenario({
      'seasonId': serial.seasonId,
      'chapterId': serial.chapterId,
      'createMode': 'sysClose'
    }, function () {
      repeatClick = false;
    });
  };

  /**
   * 'main': true, //主场景入口
   * 'seasonId': seasonId,
   * 'pageIndex': options.pageIndex,
   * 'chapterId'
   * 'history': options.history
   */
  Xut.View.LoadScenario = function (options, callback) {

    /**
     * 如果启动了预加载模式
     * 需要处理跳转的页面预加载逻辑
     */
    var chapterId = toNumber(options.chapterId);
    if (!options.main && chapterId && config.launch.preload) {
      var status = requestInterrupt({
        chapterId: chapterId,
        type: 'nolinear',
        processed: function processed() {
          loadScenario(options, callback);
          Xut.View.HideBusy();
        }
      });

      //如果还在预加载，禁止新进场的处理
      if (status) {
        Xut.View.ShowBusy();
        return;
      }
    }

    //正常加载
    loadScenario(options, callback);
  };

  /**
   * 页面跳转拦截
   */
  Xut.View.Intercept = function (chapterId) {
    //有map链接表
    //用于动态插入页面
    if (chapterId) {
      var linkMap = Xut.View.linkMap[chapterId];
      if (linkMap) {
        linkMap();
        return true;
      }
    }
  };

  /**
   * 加载一个新的场景
   * 1 节与节跳
   *    单场景情况
   *    多场景情况
   * 2 章与章跳
   * useUnlockCallBack 用来解锁回调,重复判断
   * isInApp 是否跳转到提示页面
   */
  function loadScenario(options, callback) {

    var seasonId = toNumber(options.seasonId);
    var chapterId = toNumber(options.chapterId);
    var pageIndex = toNumber(options.pageIndex);
    var createMode = options.createMode;

    //ibooks模式下的跳转
    //全部转化成超链接
    if (!options.main && Xut.IBooks.Enabled && Xut.IBooks.runMode()) {
      location.href = chapterId + ".xhtml";
      return;
    }

    //当前活动场景容器对象
    var current = sceneController.containerObj('current');

    //获取到当前的页面对象,用于跳转去重复
    var visualPageBase = current && current.$$mediator && current.$$mediator.$visualPageBase;

    //如果下一页被拦截了
    if (visualPageBase && Xut.View.Intercept(visualPageBase.chapterId)) {
      return;
    }

    if (visualPageBase && visualPageBase.seasonId == seasonId && visualPageBase.chapterId == chapterId) {
      $warn({
        type: 'api',
        content: '\u62E6\u622A:\u91CD\u590D\u89E6\u53D1Xut.View.LoadScenario,seasonId:' + seasonId + ',chapterId:' + chapterId,
        color: 'red'
      });
      return;
    }

    //用户指定的跳转入口，而不是通过内部关闭按钮处理的
    var userAssign = createMode === 'sysClose' ? false : true;

    /**
     * 场景内部跳转
     * 节相同，章与章的跳转
     * 用户指定跳转模式,如果目标对象是当前应用页面，按内部跳转处理
     */
    if (userAssign && current && current.seasonId === seasonId) {
      Xut.View.GotoSlide(seasonId, chapterId, pageIndex, callback);
      return;
    }

    //////////////////////////////////////
    ///
    ///  以下代码是加载一个新场景处理
    ///
    /////////////////////////////////////

    /*读酷启动时不需要忙碌光标*/
    if (options.main && window.DUKUCONFIG) {
      Xut.View.HideBusy();
    } else {
      Xut.View.ShowBusy();
    }

    if (current) {

      //清理热点动作,场景外部跳转,需要对场景的处理
      current.$$mediator.$suspend();

      //通过内部关闭按钮加载新场景处理，检测是不是往回跳转,重复处理
      if (userAssign) {
        sceneController.checkToRepeat(seasonId);
      }

      /**
       * 跳出去
       * $hasMultiScene
       * 场景模式
       * $hasMultiScene
       *      true  多场景
       *      false 单场景模式
       * 如果当前是从主场景加载副场景
       * 关闭系统工具栏
       */
      if (!current.$$mediator.$hasMultiScene) {
        Xut.View.HideToolBar();
      }

      //重写场景的顺序编号,用于记录场景最后记录
      var pageId = Xut.Presentation.GetPageId();
      if (pageId) {
        sceneController.rewrite(current.seasonId, pageId);
      }
    }

    /*场景信息*/
    var sectionRang = Xut.data.query('sectionRelated', seasonId);

    /**
     * 通过chapterId转化为实际页码指标
     * season 2 {
     *     chapterId : 1  => 0
     *     chpaterId : 2  => 1
     *  }
     * [description]
     * @return {[type]} [description]
     */
    var getInitIndex = function getInitIndex() {
      return chapterId ? function () {
        //如果节点内部跳转方式加载,无需转化页码
        if (createMode === 'GotoSlide') {
          return chapterId;
        }
        //初始页从0开始，减去下标1
        return chapterId - sectionRang.start - 1;
      }() : 0;
    };

    /*传递的参数*/
    var data = {
      seasonId: seasonId, //节ID
      chapterId: chapterId, //页面ID
      sectionRang: sectionRang, //节信息
      isInApp: options.isInApp, //是否跳到收费提示页
      history: options.history, // 历史记录
      barInfo: sectionRang.toolbar, //工具栏配置文件
      pageIndex: pageIndex || getInitIndex(), //指定页码
      pageTotal: sectionRang.length, //页面总数
      complete: function complete(nextBack) {
        //构件完毕回调
        //第一次加载的外部回调
        callback && callback();
        //销毁旧场景
        current && current.destroy();
        //下一个任务存在,执行切换回调后,在执行页面任务
        nextBack && nextBack();
        //去掉忙碌
        Xut.View.HideBusy();
      }
    };

    //主场景判断（第一个节,因为工具栏的配置不同）
    if (options.main || sceneController.mianId === seasonId) {
      //清理缓存
      $removeStorage("history");
      //确定主场景
      sceneController.mianId = seasonId;
      //是否主场景
      data.isMain = true;
    }

    new SceneFactory(data);
  }

  /**
   * 通过插件打开一个新view窗口
   */
  Xut.View.Open = function (pageUrl, width, height, left, top) {
    Xut.Plugin.WebView.open(pageUrl, left, top, height, width, 1);
  };

  /**
   * 关闭view窗口
   */
  Xut.View.Close = function () {
    Xut.Plugin.WebView.close();
  };
}

function initAsset() {

  //ppt动画需要扩展音频api，所以挂到辅助中
  Xut.Assist.ContentAudioCreate = createContentAudio;

  /**
   * 跳转接口
   * @param {[type]} seasonId  [description]
   * @param {[type]} chapterId [description]
   */
  Xut.U3d.View = function (seasonId, chapterId) {
    Xut.View.LoadScenario({
      'seasonId': seasonId,
      'chapterId': chapterId
    });
  };

  /**
   *读取系统中保存的变量的值。
   *如果变量不存在，则新建这个全局变量
   *如果系统中没有保存的值，用默认值进行赋值
   *这个函数，将是创建全局变量的默认函数。
   */
  window.XXTAPI.ReadVar = function (variable, defaultValue) {
    var temp;
    if (temp = $getStorage(variable)) {
      return temp;
    } else {
      $setStorage(variable, defaultValue);
      return defaultValue;
    }
  };

  /**
   * 将变量的值保存起来
   */
  window.XXTAPI.SaveVar = function (variable, value) {
    $setStorage(variable, value);
  };

  /*
   *对变量赋值，然后保存变量的值
   *对于全局变量，这个函数将是主要使用的，替代简单的“=”赋值
   */
  window.XXTAPI.SetVar = function (variable, value) {
    $setStorage(variable, value);
  };
}

function initContents() {

  //存在文档碎片
  //针对音频字幕增加的快捷查找
  Xut.Contents.contentsFragment = {};

  /**
   * 是否为canvas元素
   * 用来判断事件冒泡
   * 判断当前元素是否支持滑动
   * 默认任何元素都支持滑动
   * @type {Boolean}
   */
  Xut.Contents.Canvas = {

    /**
     * 是否允许滑动
     * @type {Boolean}
     */
    SupportSwipe: true,

    /**
     * 对象是否滑动
     * @type {Boolean}
     */
    isSwipe: false,

    /**
     * 对象是否点击
     */
    isTap: false,

    /**
     * 复位标记
     */
    Reset: function Reset() {
      Xut.Contents.Canvas.SupportSwipe = true;
      Xut.Contents.Canvas.isSwipe = false;
    },


    /**
     * 判断是否可以滑动
     * @return {[type]} [description]
     */
    getSupportState: function getSupportState() {
      var state;
      if (Xut.Contents.Canvas.SupportSwipe) {
        state = true;
      } else {
        state = false;
      }
      //清空状态
      Xut.Contents.Canvas.Reset();
      return state;
    },


    /**
     * 判断是否绑定了滑动事件
     * @return {Boolean} [description]
     */
    getIsSwipe: function getIsSwipe() {
      var state;
      if (Xut.Contents.Canvas.isSwipe) {
        state = true;
      } else {
        state = false;
      }
      //清空状态
      Xut.Contents.Canvas.Reset();
      return state;
    },


    /**
     * 是否绑定了点击事件
     */
    getIsTap: function getIsTap() {
      Xut.Contents.Canvas.isTap = false;
      return Xut.Contents.Canvas.isTap;
    }
  };

  /**
   * 恢复节点的默认控制
   * 默认是系统接管
   * 如果'drag', 'dragTag', 'swipeleft', 'swiperight', 'swipeup', 'swipedown'等事件会重写
   * 还需要考虑第三方调用，所以需要给一个重写的接口
   * @return {[type]} [description]
   * Content_1_3
   * [Content_1_3,Content_1_4,Content_1_5]
   */
  Xut.Contents.ResetDefaultControl = function (pageType, id, value) {
    if (!id) return;
    var elements;
    var handle = function handle(ele) {
      if (value) {
        ele.attr('data-behavior', value);
      } else {
        ele.attr('data-behavior', 'disable');
      }
    };
    if ((elements = Xut.Contents.Get(pageType, id)) && elements.$contentNode) {
      handle(elements.$contentNode);
    } else {
      elements = $("#" + id);
      elements.length && handle(elements);
    }
  };

  /**
   * 针对SVG无节点操作
   * 关闭控制
   */
  Xut.Contents.DisableControl = function (callback) {
    return {
      behavior: 'data-behavior',
      value: 'disable'
    };
  };

  /**
   * 针对SVG无节点操作
   * 启动控制
   */
  Xut.Contents.EnableControl = function (Value) {
    return {
      behavior: 'data-behavior',
      value: Value || 'click-swipe'
    };
  };
}

/////////////////////////////
/// 初始化页面默认行为
/////////////////////////////

/**
 * 特殊的一个方法，用来修正图片资源错误的
 * dom中的事件onerror触发，所以直接
 * @return {[type]} [description]
 */
window.fixNodeError = function (type, node, chapterIndex, src) {
  if (type === 'image') {
    repairImage(node, chapterIndex, src);
  }
};

//只初始一次
//横竖切换要判断
var onceBind = false;

/**
 * 全局事件
 * 只有完全退出整个应用
 * 或者退出iframe的情况下才使用
 *
 * 只是动态切换应用
 * 或者横竖切换不销毁
 * @return {[type]} [description]
 */
function initGlobalEvent() {
  if (!onceBind) {

    onceBind = true;

    watchPostMessage();
    bindMessage();

    //禁止全局的缩放处理
    $('body').on('touchmove', function (event) {
      event.preventDefault && event.preventDefault();
    });

    /*防止快速刷新，会触发Original时间*/
    setTimeout(function () {
      /*Home键音频动作处理*/
      $(document).on('visibilitychange', function (event) {
        /*home 后台*/
        if (document.visibilityState === 'hidden') {
          Xut.Application.Original();
        } else {
          /*如果不是嵌套iframe，激活*/
          if (!window.GLOBALIFRAME) {
            Xut.Application.Activate();
          }
        }
      });
    }, 1500);

    if (Xut.plat.isBrowser) {

      //桌面鼠标控制翻页
      $(document).keyup(function (event) {
        switch (event.keyCode) {
          case 37:
            Xut.View.GotoPrevSlide();
            break;
          case 39:
            Xut.View.GotoNextSlide();
            break;
        }
      });

      /*
      启动代码用户操作跟踪
      1、先不判断，一律按关闭提交（要有延迟）。
      2、如果是刷新，取消之前的延迟，提交刷新提示。
      */
      $(window).on('beforeunload', function () {
        config.sendTrackCode('exit', { time: +new Date() - config.launch.launchTime });
      });
    }
  }
}

/*
移除全局绑定
 */
function clearGlobalEvent() {
  if (onceBind) {
    unBindMessage();
    unWatchPostMessage();
    $('body').off(); //touchmove 禁止全局的缩放处理
    $(document).off(); //keyup 左右按钮
    $(window).off(); //beforeunload,orientationchange
    onceBind = false;
  }
}

/**
 * 销毁缓存
 */
function clearCache(isRefresh) {
  removeCache(); //userCache
}

/**
 * 销毁结果集
 * @param  {Boolean} isRefresh [description]
 * @return {[type]}            [description]
 */
function clearResult(isRefresh) {
  removeResults(); //json database
}

/**
 * 销毁接口
 * action 可能是
 * 1 exit 默认，单页面切换，只做销毁。但是代码还是同一份
 * 2 refresh 刷新，旋转切换（需要做一些数据保留，比如外联json数据）
 * 3 destory 销毁整个上下文，退出iframe的时候
 * @param {[type]} action [description]
 */
function Destroy() {
  var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'exit';


  //销毁所有场景
  sceneController.destroyAllScene();

  //销毁只创建一次的对象
  //修复的音频对象
  //数据的结果集
  if (action === 'destory') {
    //销毁修复的音频对象
    clearFixAudio();
    //销毁默认全局事件
    clearGlobalEvent();
  }

  // refresh状态不删除结果集
  // 只处理destory与exit状态
  if (action === 'destory' || action === 'exit') {
    //删除结果集
    clearResult();

    //删除流式布局的数据
    var $flowNode = $("#xut-stream-flow");
    if ($flowNode.length) {
      $flowNode.remove();
      $flowNode = null;
    }
  }

  //config路径缓存
  clearConfig();

  //删除数据匹配缓存
  clearCache();

  //音视频
  clearAudio$1();

  //音频
  clearVideo();

  //销毁独立APK的键盘事件
  clearAndroid();

  /**
   * 重设缓存的UUID
   * 为了只计算一次
   * @return {[type]} [description]
   */
  clearId();

  Xut.TransformFilter.empty();
  Xut.CreateFilter.empty();

  //销毁节点
  clearRootNode();

  /*清理预加载*/
  clearPreload();

  //清理自动运行
  $stopAutoWatch();

  //删除动态加载的两个css文件
  $('link[data-type]').each(function (index, link) {
    var type = link.getAttribute('data-type');
    if (type === 'svgsheet' || type === 'xxtflow') {
      link.parentNode.removeChild(link);
    }
  });

  //停止分栏探测
  clearColumnDetection();

  //启动配置文件去掉
  config.launch = null;

  Xut.Application.Notify('appDestory');
}

/****************************************************
 *  杂志全局API
 *  Xut.Application
 *  整个应用程序的接口，执行应用级别的操作，例如退出应用之类
 * **************************************************/

function initApplication() {

  /**
   * 后台运行
   * @type {Number}
   */
  var backstage = 0;

  /**
   * 应用加载状态
   * false未加载
   * true 已加载
   * @type {Boolean}
   */
  var appState = false;

  /**
   * 应用事件监听
   * 1.Xut.Application.Watch('complete',fn)
   * 2.initComplete
   */
  var __app__ = new Observer();

  /**
   * 监听应用事件
   * @param {[type]}   event    [description]
   * @param {Function} callback [description]
   */
  Xut.Application.Watch = function (event, callback) {
    var fn = function fn() {
      callback.apply(__app__, arguments);
    };
    __app__.$$watch(event, fn);
    return fn;
  };

  /**
   * 只监听一次
   * 触发后就销毁
   */
  Xut.Application.onceWatch = function (event, callback) {
    var fn = function fn() {
      callback.apply(__app__, arguments);
    };
    __app__.$$once(event, fn);
    return fn;
  };

  /**
   * 触发通知
   * @param {...[type]} arg [description]
   */
  Xut.Application.Notify = function () {
    __app__.$$emit.apply(__app__, arguments);
  };

  /**
   * 销毁
   */
  Xut.Application.unWatch = function (event, fn) {
    __app__.$$unWatch(event, fn);
  };

  /**
   * 后台运行
   * @type {Number}
   */
  Xut.Application.IsBackStage = function () {
    return backstage;
  };

  /**
   * home隐藏
   * 后台运行的时候,恢复到初始化状态
   * 用于进来的时候激活Activate
   */
  Xut.Application.Original = function () {
    backstage = 1;
    //传递一个完全关闭的参数
    $suspend('', '', true);
    $original();
  };

  /**
   * home显示
   * 后台弹回来
   * 激活应用行为
   */
  Xut.Application.Activate = function () {
    backstage = 0;
    $autoRun();
  };

  /**
   * 退出应用
   */
  Xut.Application.Exit = function () {
    //判断重复调用
    if (config.launch) {
      /*启动代码用户操作跟踪*/
      config.sendTrackCode('exit', { time: +new Date() - config.launch.launchTime });
      Destroy('exit');
    }
  };

  /**
   * 2016.10.11
   * 刷新程序
   * 这个与销毁有点区别
   * 比如外联的数据，不需要删除
   */
  Xut.Application.Refresh = function () {
    Destroy('refresh');
  };

  /**
   * 销毁应用
   */
  Xut.Application.Destroy = function () {
    Xut.Application.DropApp();
  };

  /**
   * 销毁
   * 退出app
   * 提供给iframe方式加载后退出app处理接口
   */
  Xut.Application.DropApp = function () {

    /**
     * iframe模式,退出处理
     * @return {[type]} [description]
     */
    var destroy = function destroy() {
      __app__.$$unWatch();
      Destroy('destory');
      window.GLOBALCONTEXT = null;
    };

    /**
     * 通过launch启动动态配置
     */
    if (config.launch.lauchMode === 1) {
      destroy();
      return;
    }

    //如果读酷
    if (window.DUKUCONFIG) {
      //外部回调通知
      if (window.DUKUCONFIG.iframeDrop) {
        var appId = $getStorage('appId');
        window.DUKUCONFIG.iframeDrop(['appId-' + appId, 'novelId-' + appId, 'pageIndex-' + appId]);
      }
      window.DUKUCONFIG = null;
      destroy();
      return;
    }

    //客户端模式
    if (window.CLIENTCONFIGT) {
      //外部回调通知
      if (window.CLIENTCONFIGT.iframeDrop) {
        window.CLIENTCONFIGT.iframeDrop();
      }
      window.CLIENTCONFIGT = null;
      destroy();
      return;
    }

    //妙妙学客户端
    if (window.MMXCONFIG) {
      //外部回调通知
      if (window.MMXCONFIG.iframeDrop) {
        window.MMXCONFIG.iframeDrop();
      }
      window.MMXCONFIG = null;
      destroy();
      return;
    }
  };

  /**
   * 停止应用
   * skipMedia 跳过音频你处理(跨页面)
   * dispose   成功处理回调
   * processed 处理完毕回调
   */
  Xut.Application.Suspend = function (_ref) {
    var skipAudio = _ref.skipAudio,
        dispose = _ref.dispose,
        processed = _ref.processed;

    $stop(skipAudio);
    processed && processed();
  };

  /**
   * 启动应用
   */
  Xut.Application.Launch = function () {};

  /**
   * 设置应用状态
   */
  Xut.Application.setAppState = function () {
    appState = true;
  };

  /**
   * 删除应用状态
   * @return {[type]} [description]
   */
  Xut.Application.delAppState = function () {
    appState = false;
  };

  /**
   * 获取应用加载状态
   * @return {[type]} [description]
   */
  Xut.Application.getAppState = function () {
    return appState;
  };

  /**
   * 延时APP运用
   * 一般是在等待视频先加载完毕
   * @return {[type]} [description]
   */
  Xut.Application.delayAppRun = function () {
    Xut.Application.setAppState();
  };

  /**
   * 启动app
   * 重载启动方法
   * 如果调用在重载之前，就删除，
   * 否则被启动方法重载
   * @type {[type]}
   */
  Xut.Application.LaunchApp = function () {
    Xut.Application.delAppState();
  };
}

/**
 * 通过全局方法 Xut.extend() 使用插件:
 */
function initExtend() {
  Xut.extend = function (plugin) {
    //   if (plugin.installed) {
    //     return
    //   }
    //   const args = _.toArray(arguments, 1)
    //   args.unshift(this)
    //   if (typeof plugin.install === 'function') {
    //     plugin.install.apply(plugin, args)
    //   } else {
    //     plugin.apply(null, args)
    //   }
    //   plugin.installed = true
    //   return this
  };
}

/**
 *
 * 杂志全局API
 *
 *  *** 有方法体的是全局接口，不会被重载***
 *  *** 无方法体的是场景接口，总会切换到当前可视区域场景***
 *
 * 1.   Xut.Application
 *          a)  整个应用程序的接口，执行应用级别的操作，例如退出应用之类。
 * 2.   Xut.DocumentWindow
 *          a)  窗口的接口。窗口就是电子杂志的展示区域，可以操作诸如宽度、高度、长宽比之类。
 * 3.   Xut.View
 *          a)  视图接口。视图是窗口的展示方式，和页面相关的接口，都在这里。
 * 4.   Xut.Presentation
 *          a)  数据接口。和电子杂志的数据相关的接口，都在这里。
 * 5.   Xut.Slides
 *          a)  所有页面的集合
 * 6.   Xut.Slide
 *          a)  单个页面
 * 7.   Xut.Master
 *          a)  页面的母版
 */
var assignInit = function assignInit(interName) {
  if (!Xut[interName]) {
    Xut[interName] = {};
  }
};

function initGlobalAPI() {

  //初始化接口
  assignInit('U3d');
  assignInit('View');
  assignInit('Assist');
  assignInit('Contents');
  assignInit('Application');
  assignInit('Presentation');

  /*新增虚拟摄像机运行的接口
  2017.6.2*/
  assignInit('Camera');

  //脚本接口
  window.XXTAPI = {};

  initExtend();
  initAsset();
  initView();
  initContents();
  initApplication();
}

/**
 * app初始化功能
 * @return {[type]} [description]
 */
/**
 * 代码初始化
 */
initAudio();
initVideo();
initGlobalAPI();

initGlobalEvent();

function initApp$1(callback) {
  /*针对异步的代码以前检测出来*/
  initAsyn(function () {
    if (window.parent) {
      //读库上iframe跨域报错处理
      //一个服务器域，一个是本地域，所以parent无法访问了
      //通过一个定时器延迟，等待第一次config.postMessage的配置
      return setTimeout(callback, 0);
    }
    callback();
  });
}

function initMain(novelData) {

  $warn('logic', '初始化base-config完成');

  /**
   * IBOOS模式
   */
  if (Xut.IBooks.Enabled) {
    //删除背景图
    $(".xut-cover").remove();
    initMainScene({
      "pageIndex": Xut.IBooks.CONFIG.pageIndex
    });
    return;
  }

  /**
   * 缓存加载
   * 如果启动recordHistory记录
   */
  var pageIndex = Number($getStorage('pageIndex'));
  if (config.launch.historyMode && pageIndex !== undefined) {
    var novelId = parseInt($getStorage("novelId"));
    if (novelId) {
      return initMainScene({
        "novelId": novelId,
        "pageIndex": pageIndex,
        'history': $getStorage('history')
      });
    }
  }

  //第一次加载
  //没有缓存
  initMainScene({ "novelId": novelData._id, "pageIndex": 0 });
}

/**
 * 加载app应用
 */
var initApp = function initApp() {
  return baseConfig(initMain);
};

/**
 * 如果是安卓桌面端
 * 绑定事件
 * @return {[type]} [description]
 */
function bindPlatEvent() {
  //安卓上并且不是浏览器打开的情况
  if (Xut.plat.isAndroid && !Xut.plat.isBrowser) {
    //预加载处理视频
    //妙妙学不加载视频
    //读库不加载视频
    if (window.MMXCONFIG && !window.DUKUCONFIG) {
      plugVideo();
    }
    //不是子文档指定绑定按键
    if (!window.SUbCONFIGT) {
      /*app初始化完毕*/
      Xut.Application.Watch('initComplete', function () {
        bindAndroid();
      });
    }
  }
  if (window.DUKUCONFIG) {
    PMS.bind("MagazineExit", function () {
      PMS.unbind();
      Xut.Application.DropApp();
    }, "*");
  }
  initApp();
}

/*
  如果不是读库模式
  播放HTML5视频
  在IOS
  if (!window.DUKUCONFIG && !window.GLOBALIFRAME && Xut.plat.isIOS) {
      html5Video()
  }
  Ifarme嵌套处理
  1 新阅读
  2 子文档
  3 pc
  4 ios/android
 */
function entrance(options) {
  //初始化全局一些配置
  initApp$1(function () {
    if (window.GLOBALIFRAME) {
      bindPlatEvent();
    } else {
      //brower
      if (Xut.plat.isBrowser) {
        initApp();
      } else {
        //mobile(apk or ipa)
        window.openDatabase(config.data.dbName, "1.0", "Xxtebook Database", config.data.dbSize);
        document.addEventListener("deviceready", function () {
          Xut.plat.hasPlugin = true; //支持插件
          Xut.Plugin.XXTEbookInit.startup(config.data.dbName, bindPlatEvent, function () {});
        }, false);
      }
    }
  });
}

/////////////////
////  版本号  ////
/////////////////
Xut.Version = 894.2;

//接口接在参数,用户横竖切换刷新
var cacheOptions = void 0;
var delayTimer = null;

/**
 * 横竖切换
 */
var bindOrientateMode = Xut.plat.isBrowser && config.orientateMode ? function () {
  $(window).on('orientationchange', function (e) {

    /**
     * 2017.5.23
     * 安卓手机播放视频，全屏的情况下，会强制横版
     * 导致了触发横竖切换关闭应用
     */
    if (Xut.Application.PlayHTML5Video) {
      return;
    }

    //安卓设备上,对横竖切换的处理反映很慢
    //所以这里需要延时加载获取设备新的分辨率
    //2016.11.8
    function delay(fn) {
      if (!delayTimer) {
        delayTimer = setTimeout(function () {
          Xut.Application.Refresh();
          clearTimeout(delayTimer);
          delayTimer = null;
          fn();
        }, 1000);
      }
    }

    var temp = cacheOptions;
    if (temp && temp.length) {
      delay(function () {
        Xut.Application.Launch(temp.pop());
        temp = null;
      });
    } else {
      delay(function () {
        entrance();
      });
    }
  });
} : function () {};

/**
 * 新版本加载
 */
Xut.Application.Launch = function (option) {
  if (config.launch) {
    return;
  }
  var setConfig = Xut.Application.setConfig;
  if (setConfig && setConfig.lauchMode === 1) {
    mixGlobalConfig(setConfig);
    /*当前的launch配置文件，用于横竖切换处理*/
    cacheOptions = [option];
    config.launch = $.extend(true, { launchTime: +new Date() }, option);
    if (option.path) {
      _.each(option.path, function (value, key) {
        config.launch[key] = key === 'resource' ? removeSlash(value) : value;
      });
      delete config.launch.path;
    }
    bindOrientateMode();
    entrance();
  }
};

/**
 * 判断是否script有data-plat或者data-mode属性
 */
function hasLaunch() {
  var scripts = document.querySelectorAll('script');
  for (var i = 0; i < scripts.length; i++) {
    var node = scripts[i];
    if (node.getAttribute('data-lauchMode') == 1) {
      return true;
    }
    if (node.getAttribute('data-plat') === 'mini') {
      return true;
    }
  }
}

/**
 * 老版本加载
 */
setTimeout(function () {
  var setConfig = Xut.Application.setConfig;
  if (!setConfig || setConfig && setConfig.lauchMode !== 1) {
    if (hasLaunch()) {
      return;
    }
    mixGlobalConfig(setConfig);
    /*保证兼容，不需要判断launch存在，初始空对象*/
    config.launch = {};
    entrance();
  }
}, 100);

})));
